/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.40
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGOCTAVE
#define SWIG_name_d      "cv"
#define SWIG_name        cv
#define OCTAVE_API_VERSION_OPTION 0


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



#include <octave/oct.h>
#include <octave/parse.h>
#include <octave/ov-fcn-handle.h>
#include <octave/Cell.h>
#include <octave/oct-map.h>

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return and integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13




#if OCTAVE_API_VERSION_OPTION>0
#define USE_OCTAVE_API_VERSION OCTAVE_API_VERSION_OPTION
#else

#include <octave/version.h>
#ifdef OCTAVE_API_VERSION_N
#define USE_OCTAVE_API_VERSION OCTAVE_API_VERSION_N

#else // Interim hack to distinguish between Octave 3.2 and earlier versions.

#define ComplexLU __ignore
#include <octave/CmplxLU.h>
#undef ComplexLU
#ifdef octave_Complex_LU_h
#define USE_OCTAVE_API_VERSION 36
#else
#define USE_OCTAVE_API_VERSION 37
#endif

#endif

#endif

SWIGRUNTIME bool SWIG_check_num_args(const char *func_name, int num_args, int max_args, int min_args, int varargs) {
  if (num_args > max_args && !varargs)
    error("function %s takes at most %i arguments", func_name, max_args);
  else if (num_args < min_args)
    error("function %s requires at least %i arguments", func_name, min_args);
  else
    return true;
  return false;
}

SWIGRUNTIME octave_value_list *SWIG_Octave_AppendOutput(octave_value_list *ovl, const octave_value &ov) {
  ovl->append(ov);
  return ovl;
}

SWIGRUNTIME octave_value SWIG_ErrorType(int code) {
  switch (code) {
  case SWIG_MemoryError:
    return "SWIG_MemoryError";
  case SWIG_IOError:
    return "SWIG_IOError";
  case SWIG_RuntimeError:
    return "SWIG_RuntimeError";
  case SWIG_IndexError:
    return "SWIG_IndexError";
  case SWIG_TypeError:
    return "SWIG_TypeError";
  case SWIG_DivisionByZero:
    return "SWIG_DivisionByZero";
  case SWIG_OverflowError:
    return "SWIG_OverflowError";
  case SWIG_SyntaxError:
    return "SWIG_SyntaxError";
  case SWIG_ValueError:
    return "SWIG_ValueError";
  case SWIG_SystemError:
    return "SWIG_SystemError";
  case SWIG_AttributeError:
    return "SWIG_AttributeError";
  }
  return "SWIG unknown error";
}

SWIGRUNTIME octave_value SWIG_Error(int code, const char *msg) {
  octave_value type(SWIG_ErrorType(code));
  std::string r = msg;
  r += " (" + type.string_value() + ")";
  error(r.c_str());
  return octave_value(r);
}

#define SWIG_fail                                       goto fail

#define SWIG_Octave_ConvertPtr(obj, pptr, type, flags)  SWIG_Octave_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Octave_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Octave_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Octave_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Octave_NewPointerObj(ptr, type, flags)
#define swig_owntype                                    int

#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Octave_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Octave_NewPackedObj(ptr, sz, type)

#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)

#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Octave_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Octave_NewPackedObj(ptr, sz, type)

#define SWIG_GetModule(clientdata) SWIG_Octave_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer) SWIG_Octave_SetModule(clientdata,pointer);
#define SWIG_MODULE_CLIENTDATA_TYPE void*

#define Octave_Error_Occurred() 0
#define SWIG_Octave_AddErrorMsg(msg) {;}

SWIGRUNTIME swig_module_info *SWIG_Octave_GetModule(void *clientdata);
SWIGRUNTIME void SWIG_Octave_SetModule(void *clientdata, swig_module_info *pointer);

// For backward compatibility only
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      0

// Runtime API implementation

#include <map>
#include <vector>
#include <string>

typedef octave_value_list(*octave_func) (const octave_value_list &, int);
class octave_swig_type;

namespace Swig {
  class Director;

  SWIGRUNTIME void swig_register_director(octave_swig_type *self, void *ptr, Director *d);
  SWIGRUNTIME void swig_director_destroyed(octave_swig_type *self, Director *d);
  SWIGRUNTIME void swig_director_set_self(Director *d, octave_swig_type *self);

  SWIGRUNTIME octave_base_value *swig_value_ref(octave_swig_type *ost);
  SWIGRUNTIME octave_swig_type *swig_value_deref(octave_value ov);
  SWIGRUNTIME octave_swig_type *swig_value_deref(const octave_base_value &ov);

  typedef std::map < void *, Director * > rtdir_map;

  SWIGINTERN rtdir_map* get_rtdir_map() {
    static swig_module_info *module = 0;
    if (!module)
      module = SWIG_GetModule(0);
    if (!module)
      return 0;
    if (!module->clientdata)
      module->clientdata = new rtdir_map;
    return (rtdir_map *) module->clientdata;
  }

  SWIGINTERNINLINE void set_rtdir(void *vptr, Director *d) {
    rtdir_map* rm = get_rtdir_map();
    if (rm)
      (*rm)[vptr] = d;
  }

  SWIGINTERNINLINE void erase_rtdir(void *vptr) {
    rtdir_map* rm = get_rtdir_map();
    if (rm)
      (*rm).erase(vptr);
  }

  SWIGINTERNINLINE Director *get_rtdir(void *vptr) {
    rtdir_map* rm = get_rtdir_map();
    if (!rm)
      return 0;
    rtdir_map::const_iterator pos = rm->find(vptr);
    Director *rtdir = (pos != rm->end())? pos->second : 0;
    return rtdir;
  }
}

  struct swig_octave_member {
    const char *name;
    octave_func method;
    octave_func get_method;
    octave_func set_method;
    int flags;			// 1 static, 2 global
    const char *doc;
    bool is_static() const {
      return flags &1;
    } bool is_global() const {
      return flags &2;
    }
  };

  struct swig_octave_class {
    const char *name;
    swig_type_info **type;
    int director;
    octave_func constructor;
    const char *constructor_doc;
    octave_func destructor;
    const swig_octave_member *members;
    const char **base_names;
    const swig_type_info **base;
  };

  // octave_swig_type plays the role of both the shadow class and the class 
  // representation within Octave, since there is no support for classes.
  //
  // These should really be decoupled, with the class support added to Octave
  // and the shadow class given by an m-file script. That would dramatically 
  // reduce the runtime complexity, and be more in line w/ other modules.

  class octave_swig_type:public octave_base_value {
    struct cpp_ptr {
      void *ptr;
      bool destroyed;
      cpp_ptr(void *_ptr):ptr(_ptr), destroyed(false) {
      }};
    typedef std::pair < const swig_type_info *, cpp_ptr > type_ptr_pair;

    mutable swig_module_info *module;

    const swig_type_info *construct_type;	// type of special type object
    std::vector < type_ptr_pair > types;	// our c++ base classes
    int own;			// whether we call c++ destructors when we die

    typedef std::pair < const swig_octave_member *, octave_value > member_value_pair;
    typedef std::map < std::string, member_value_pair > member_map;
    member_map members;
    bool always_static;

    const swig_octave_member *find_member(const swig_type_info *type, const std::string &name) {
      if (!type->clientdata)
	return 0;
      swig_octave_class *c = (swig_octave_class *) type->clientdata;
      const swig_octave_member *m;
      for (m = c->members; m->name; ++m)
	if (m->name == name)
	  return m;
      for (int j = 0; c->base_names[j]; ++j) {
	if (!c->base[j]) {
	  if (!module)
	    module = SWIG_GetModule(0);
	  assert(module);
	  c->base[j] = SWIG_MangledTypeQueryModule(module, module, c->base_names[j]);
	}
	if (!c->base[j])
	  return 0;
	if ((m = find_member(c->base[j], name)))
	  return m;
      }
      return 0;
    }

    member_value_pair *find_member(const std::string &name, bool insert_if_not_found) {
      member_map::iterator it = members.find(name);
      if (it != members.end())
	return &it->second;
      const swig_octave_member *m;
      for (unsigned int j = 0; j < types.size(); ++j)
	if ((m = find_member(types[j].first, name)))
	  return &members.insert(std::make_pair(name, std::make_pair(m, octave_value()))).first->second;
      if (!insert_if_not_found)
	return 0;
      return &members[name];
    }

    const swig_type_info *find_base(const std::string &name, const swig_type_info *base) {
      if (!base) {
	for (unsigned int j = 0; j < types.size(); ++j) {
	  assert(types[j].first->clientdata);
	  swig_octave_class *cj = (swig_octave_class *) types[j].first->clientdata;
	  if (cj->name == name)
	    return types[j].first;
	}
	return 0;
      }
      assert(base->clientdata);
      swig_octave_class *c = (swig_octave_class *) base->clientdata;
      for (int j = 0; c->base_names[j]; ++j) {
	if (!c->base[j]) {
	  if (!module)
	    module = SWIG_GetModule(0);
	  assert(module);
	  c->base[j] = SWIG_MangledTypeQueryModule(module, module, c->base_names[j]);
	}
	if (!c->base[j])
	  return 0;
	assert(c->base[j]->clientdata);
	swig_octave_class *cj = (swig_octave_class *) c->base[j]->clientdata;
	if (cj->name == name)
	  return c->base[j];
      }
      return 0;
    }

    void load_members(const swig_octave_class* c,member_map& out) const {
      for (const swig_octave_member *m = c->members; m->name; ++m) {
	if (out.find(m->name) == out.end())
	  out.insert(std::make_pair(m->name, std::make_pair(m, octave_value())));
      }
      for (int j = 0; c->base_names[j]; ++j) {
	if (!c->base[j]) {
	  if (!module)
	    module = SWIG_GetModule(0);
	  assert(module);
	  c->base[j] = SWIG_MangledTypeQueryModule(module, module, c->base_names[j]);
	}
	if (!c->base[j])
	  continue;
	assert(c->base[j]->clientdata);
	const swig_octave_class *cj =
	  (const swig_octave_class *) c->base[j]->clientdata;
	load_members(cj,out);
      }
    }

    void load_members(member_map& out) const {
      out=members;
      for (unsigned int j = 0; j < types.size(); ++j)
	if (types[j].first->clientdata)
	  load_members((const swig_octave_class *) types[j].first->clientdata, out);
    }

    octave_value_list member_invoke(member_value_pair *m, const octave_value_list &args, int nargout) {
      if (m->second.is_defined())
	return m->second.subsref("(", std::list < octave_value_list > (1, args), nargout);
      else if (m->first && m->first->method)
	return m->first->method(args, nargout);
      error("member not defined or not invocable");
      return octave_value_list();
    }

    bool dispatch_unary_op(const std::string &symbol, octave_value &ret) {
      member_value_pair *m = find_member(symbol, false);
      if (!m || m->first->is_static() || m->first->is_global())
	return false;
      octave_value_list args;
      args.append(as_value());
      octave_value_list argout(member_invoke(m, args, 1));
      if (argout.length() < 1)
	return false;
      ret = argout(0);
      return true;
    }

    bool dispatch_binary_op(const std::string &symbol, const octave_base_value &rhs, octave_value &ret) {
      member_value_pair *m = find_member(symbol, false);
      if (!m || m->first->is_static() || m->first->is_global())
	return false;
      octave_value_list args;
      args.append(as_value());
      args.append(make_value_hack(rhs));
      octave_value_list argout(member_invoke(m, args, 1));
      if (argout.length() < 1)
	return false;
      ret = argout(0);
      return true;
    }

    bool dispatch_index_op(const std::string &symbol, const octave_value_list &rhs, octave_value_list &ret) {
      member_value_pair *m = find_member(symbol, false);
      if (!m || m->first->is_static() || m->first->is_global())
	return false;
      octave_value_list args;
      args.append(as_value());
      args.append(rhs);
      octave_value_list argout(member_invoke(m, args, 1));
      if (argout.length() >= 1)
	ret = argout(0);
      return true;
    }

    octave_value_list member_deref(member_value_pair *m, const octave_value_list &args) {
      if (m->second.is_defined())
	return m->second;
      else if (m->first) {
	if (m->first->get_method)
	  return m->first->get_method(args, 1);
	else if (m->first->method)
	  return octave_value(new octave_builtin(m->first->method));
      }
      error("undefined member");
      return octave_value_list();
    }

    static octave_value make_value_hack(const octave_base_value &x) {
      ((octave_swig_type &) x).count++;
      return octave_value((octave_base_value *) &x);
    }

    octave_swig_type(const octave_swig_type &x);
    octave_swig_type &operator=(const octave_swig_type &rhs);
  public:

    octave_swig_type(void *_ptr = 0, const swig_type_info *_type = 0, int _own = 0,
		     bool _always_static = false)
      :	module(0), construct_type(_ptr ? 0 : _type), own(_own), 
      always_static(_always_static) {
      if (_type || _ptr)
	types.push_back(std::make_pair(_type, _ptr));
      if (_ptr) {
	Swig::Director *d = Swig::get_rtdir(_ptr);
	if (d)
	  Swig::swig_director_set_self(d, this);
      }
    }

    ~octave_swig_type() {
      if (own) {
	++count;
	for (unsigned int j = 0; j < types.size(); ++j) {
	  if (!types[j].first || !types[j].first->clientdata)
	    continue;
	  swig_octave_class *c = (swig_octave_class *) types[j].first->clientdata;
	  if (c->destructor && !types[j].second.destroyed && types[j].second.ptr) {
	    c->destructor(as_value(), 0);
	  }
	}
      }
      for (unsigned int j = 0; j < types.size(); ++j)
	Swig::erase_rtdir(types[j].second.ptr);
    }

    octave_value as_value() {
      ++count;
      return Swig::swig_value_ref(this);
    }

    void incref() {
      ++count;
    }

    void decref() {
      if (!--count)
	delete this;
    }

    long swig_this() const {
      if (!types.size())
	return (long) this;
      return (long) types[0].second.ptr;
    }
    const char* help_text() const {
      if (!types.size())
	return 0;
      if (!types[0].first->clientdata)
	return 0;
      swig_octave_class *c = (swig_octave_class *) types[0].first->clientdata;
      return c->constructor_doc;
    }

    std::string swig_type_name() const {
      // * need some way to manually name subclasses.
      // * eg optional first arg to subclass(), or named_subclass()
      std::string ret;
      for (unsigned int j = 0; j < types.size(); ++j) {
	if (j)
	  ret += "_";
	if (types[j].first->clientdata) {
	  swig_octave_class *c = (swig_octave_class *) types[j].first->clientdata;
	  ret += c->name;
	} else
	  ret += types[j].first->name;
      }
      return ret;
    }

    void merge(octave_swig_type &rhs) {
      rhs.own = 0;
      for (unsigned int j = 0; j < rhs.types.size(); ++j) {
	assert(!rhs.types[j].second.destroyed);
	Swig::Director *d = Swig::get_rtdir(rhs.types[j].second.ptr);
	if (d)
	  Swig::swig_director_set_self(d, this);
      }
      types.insert(types.end(), rhs.types.begin(), rhs.types.end());
      members.insert(rhs.members.begin(), rhs.members.end());
      rhs.types.clear();
      rhs.members.clear();
    }

    void install_global() {
      for (member_map::const_iterator it = members.begin(); it != members.end(); ++it) {
	if (it->second.first && it->second.first->method)
	  install_builtin_function(it->second.first->method, it->first,
				   it->second.first->doc?it->second.first->doc:std::string());
	else if (it->second.second.is_defined()) {
#if USE_OCTAVE_API_VERSION<37
	  link_to_global_variable(curr_sym_tab->lookup(it->first, true));
#else 
	  symbol_table::varref(it->first);
	  symbol_table::mark_global(it->first);
#endif
	  set_global_value(it->first, it->second.second);
	  
#if USE_OCTAVE_API_VERSION<37
	  octave_swig_type *ost = Swig::swig_value_deref(it->second.second);
	  if (ost) {
	    const char* h = ost->help_text();
	    if (h) {
	      symbol_record *sr = global_sym_tab->lookup (it->first, true);
	      sr->document(h);
	    }
	  }
#endif
	}
      }
    }

    void *cast(swig_type_info *type, int *_own, int flags) {
      if (_own)
	*_own = own;
      if (flags &SWIG_POINTER_DISOWN)
	own = 0;
      if (!type && types.size())
	return types[0].second.ptr;
      for (unsigned int j = 0; j < types.size(); ++j)
	if (type == types[j].first)
	  return types[j].second.ptr;
      for (unsigned int j = 0; j < types.size(); ++j) {
	swig_cast_info *tc = SWIG_TypeCheck(types[j].first->name, type);
	if (!tc)
	  continue;
	int newmemory = 0;
	void *vptr = SWIG_TypeCast(tc, types[j].second.ptr, &newmemory);
	assert(!newmemory);	// newmemory handling not yet implemented
	return vptr;
      }
      return 0;
    }

    bool is_owned() const {
      return own;
    }

    void director_destroyed(Swig::Director *d) {
      bool found = false;
      for (unsigned int j = 0; j < types.size(); ++j) {
	Swig::Director *dj = Swig::get_rtdir(types[j].second.ptr);
	if (dj == d) {
	  types[j].second.destroyed = true;
	  found = true;
	}
      }
      assert(found);
    }

    void assign(const std::string &name, const octave_value &ov) {
      members[name] = std::make_pair((const swig_octave_member *) 0, ov);
    }

    void assign(const std::string &name, const swig_octave_member *m) {
      members[name] = std::make_pair(m, octave_value());
    }

    octave_base_value *clone() const {
      // pass-by-value is probably not desired, and is harder;
      // requires calling copy constructors of contained types etc.
      assert(0);
      *(int *) 0 = 0;
      return 0;
    }

    octave_base_value *empty_clone() const {
      return new octave_swig_type();
    }

    bool is_defined() const {
      return true;
    }

    virtual bool is_map() const {
      return true;
    }

    virtual octave_value subsref(const std::string &ops, const std::list < octave_value_list > &idx) {
      octave_value_list ovl = subsref(ops, idx, 1);
      return ovl.length()? ovl(0) : octave_value();
    }

    virtual octave_value_list subsref(const std::string &ops, const std::list < octave_value_list > &idx, int nargout) {
      assert(ops.size() > 0);
      assert(ops.size() == idx.size());

      std::list < octave_value_list >::const_iterator idx_it = idx.begin();
      int skip = 0;
      octave_value_list sub_ovl;

      // constructor invocation
      if (ops[skip] == '(' && construct_type) {
	assert(construct_type->clientdata);
	swig_octave_class *c = (swig_octave_class *) construct_type->clientdata;
	if (!c->constructor) {
	  error("cannot create instance");
	  return octave_value_list();
	}
	octave_value_list args;
	if (c->director)
	  args.append(Swig::swig_value_ref(new octave_swig_type(this, 0, 0)));
	args.append(*idx_it++);
	++skip;
	sub_ovl = c->constructor(args, nargout);
      }
      // member dereference or invocation
      else if (ops[skip] == '.') {
	std::string subname;
	const swig_type_info *base = 0;	// eg, a.base.base_cpp_mem
	for (;;) {
	  octave_value_list subname_ovl(*idx_it++);
	  ++skip;
	  assert(subname_ovl.length() == 1 && subname_ovl(0).is_string());
	  subname = subname_ovl(0).string_value();

	  const swig_type_info *next_base = find_base(subname, base);
	  if (!next_base || skip >= (int) ops.size() || ops[skip] != '.')
	    break;
	  base = next_base;
	}

	member_value_pair tmp, *m = &tmp;
	if (!base || !(m->first = find_member(base, subname)))
	  m = find_member(subname, false);
	if (!m) {
	  error("member not found");
	  return octave_value_list();
	}

	octave_value_list args;
	if (!always_static &&
	    (!m->first || (!m->first->is_static() && !m->first->is_global())))
	  args.append(as_value());
	if (skip < (int) ops.size() && ops[skip] == '(' && 
	    ((m->first && m->first->method) || m->second.is_function() || 
	     m->second.is_function_handle())) {
	  args.append(*idx_it++);
	  ++skip;
	  sub_ovl = member_invoke(m, args, nargout);
	} else {
	  sub_ovl = member_deref(m, args);
	}
      }
      // index operator
      else {
	if (ops[skip] == '(' || ops[skip] == '{') {
	  const char *op_name = ops[skip] == '(' ? "__paren__" : "__brace__";
	  octave_value_list args;
	  args.append(*idx_it++);
	  ++skip;
	  if (!dispatch_index_op(op_name, args, sub_ovl)) {
	    error("error evaluating index operator");
	    return octave_value_list();
	  }
	} else {
	  error("unsupported subsref");
	  return octave_value_list();
	}
      }

      if (skip >= (int) ops.size())
	return sub_ovl;
      if (sub_ovl.length() < 1) {
	error("bad subs ref");
	return octave_value_list();
      }
      return sub_ovl(0).next_subsref(nargout, ops, idx, skip);
    }

    octave_value subsasgn(const std::string &ops, const std::list < octave_value_list > &idx, const octave_value &rhs) {
      assert(ops.size() > 0);
      assert(ops.size() == idx.size());

      std::list < octave_value_list >::const_iterator idx_it = idx.begin();
      int skip = 0;

      if (ops.size() > 1) {
	std::list < octave_value_list >::const_iterator last = idx.end();
	--last;
	std::list < octave_value_list > next_idx(idx.begin(), last);
	octave_value next_ov = subsref(ops.substr(0, ops.size() - 1), next_idx);
	next_ov.subsasgn(ops.substr(ops.size() - 1), std::list < octave_value_list > (1, *last), rhs);
      }

      else if (ops[skip] == '(' || ops[skip] == '{') {
	const char *op_name = ops[skip] == '(' ? "__paren_asgn__" : "__brace_asgn__";
	member_value_pair *m = find_member(op_name, false);
	if (m) {
	  octave_value_list args;
	  args.append(as_value());
	  args.append(*idx_it);
	  args.append(rhs);
	  member_invoke(m, args, 1);
	} else
	  error("%s member not found", op_name);
      }

      else if (ops[skip] == '.') {
	octave_value_list subname_ovl(*idx_it++);
	++skip;
	assert(subname_ovl.length() == 1 &&subname_ovl(0).is_string());
	std::string subname = subname_ovl(0).string_value();

	member_value_pair *m = find_member(subname, true);
	if (!m->first || !m->first->set_method) {
	  m->first = 0;
	  m->second = rhs;
	} else if (m->first->set_method) {
	  octave_value_list args;
	  if (!m->first->is_static() && !m->first->is_global())
	    args.append(as_value());
	  args.append(rhs);
	  m->first->set_method(args, 1);
	} else
	  error("member not assignable");
      } else
	error("unsupported subsasgn");

      return as_value();
    }

    virtual bool is_string() const {
      octave_swig_type *nc_this = const_cast < octave_swig_type *>(this);
      return !!nc_this->find_member("__str__", false);
    }

    virtual std::string string_value(bool force = false) const {
      octave_swig_type *nc_this = const_cast < octave_swig_type *>(this);
      member_value_pair *m = nc_this->find_member("__str__", false);
      if (!m) {
	error("__str__ method not defined");
	return std::string();
      }
      octave_value_list outarg = nc_this->member_invoke(m, octave_value_list(nc_this->as_value()), 1);
      if (outarg.length() < 1 || !outarg(0).is_string()) {
	error("__str__ method did not return a string");
	return std::string();
      }
      return outarg(0).string_value();
    }

    virtual Octave_map map_value() const {
      return Octave_map();
    }

    virtual string_vector map_keys() const {
      member_map tmp;
      load_members(tmp);

      string_vector keys(tmp.size());
      int k = 0;
      for (member_map::iterator it = tmp.begin(); it != tmp.end(); ++it)
	keys(k++) = it->first;

      return keys;
    }

    virtual bool save_ascii (std::ostream& os) {
      return true;
    }

    virtual bool load_ascii (std::istream& is) {
      return true;
    }

    virtual bool save_binary (std::ostream& os, bool& save_as_floats) {
      return true;
    }

    virtual bool load_binary (std::istream& is, bool swap, 
			      oct_mach_info::float_format fmt) {
      return true;
    }

#if defined (HAVE_HDF5)
    virtual bool
      save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats) {
      return true;
    }

    virtual bool
      load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug) {
      return true;
    }
#endif

    virtual octave_value convert_to_str(bool pad = false, bool force = false, char type = '"') const {
      return string_value();
    }

    virtual octave_value convert_to_str_internal(bool pad, bool force, char type) const {
      return string_value();
    }

    static bool dispatch_global_op(const std::string &symbol, const octave_value_list &args, octave_value &ret) {
      // we assume that "op_"-prefixed functions are installed in global namespace
      // (rather than any module namespace).

      octave_value fcn = get_global_value(symbol, true);
      if (!fcn.is_function() && !fcn.is_function_handle())
	return false;
      ret = fcn.subsref("(", std::list < octave_value_list > (1, args));
      return true;
    }

    static octave_value dispatch_unary_op(const octave_base_value &x, const char *op_name) {
      octave_swig_type *ost = Swig::swig_value_deref(x);
      assert(ost);

      octave_value ret;
      if (ost->dispatch_unary_op(std::string("__") + op_name + std::string("__"), ret))
	return ret;
      std::string symbol = "op_" + ost->swig_type_name() + "_" + op_name;
      octave_value_list args;
      args.append(make_value_hack(x));
      if (dispatch_global_op(symbol, args, ret))
	return ret;

      error("could not dispatch unary operator");
      return octave_value();
    }

    static octave_value dispatch_binary_op(const octave_base_value &lhs, const octave_base_value &rhs, const char *op_name) {
      octave_swig_type *lhs_ost = Swig::swig_value_deref(lhs);
      octave_swig_type *rhs_ost = Swig::swig_value_deref(rhs);

      octave_value ret;
      if (lhs_ost && lhs_ost->dispatch_binary_op(std::string("__") + op_name + std::string("__"), rhs, ret))
	return ret;

      std::string symbol;
      octave_value_list args;
      args.append(make_value_hack(lhs));
      args.append(make_value_hack(rhs));

      symbol = "op_";
      symbol += lhs_ost ? lhs_ost->swig_type_name() : lhs.type_name();
      symbol += "_";
      symbol += op_name;
      symbol += "_";
      symbol += rhs_ost ? rhs_ost->swig_type_name() : rhs.type_name();
      if (dispatch_global_op(symbol, args, ret))
	return ret;

      symbol = "op_";
      symbol += lhs_ost ? lhs_ost->swig_type_name() : lhs.type_name();
      symbol += "_";
      symbol += op_name;
      symbol += "_";
      symbol += "any";
      if (dispatch_global_op(symbol, args, ret))
	return ret;

      symbol = "op_";
      symbol += "any";
      symbol += "_";
      symbol += op_name;
      symbol += "_";
      symbol += rhs_ost ? rhs_ost->swig_type_name() : rhs.type_name();
      if (dispatch_global_op(symbol, args, ret))
	return ret;

      error("could not dispatch binary operator");
      return octave_value();
    }

    void print(std::ostream &os, bool pr_as_read_syntax = false) const {
      if (is_string()) {
	os << string_value();
	return;
      }

      member_map tmp;
      load_members(tmp);

      os << "{" << std::endl;
      for (unsigned int j = 0; j < types.size(); ++j) {
	if (types[j].first->clientdata) {
	  const swig_octave_class *c = (const swig_octave_class *) types[j].first->clientdata;
	  os << "  " << c->name << ", ptr = " << types[j].second.ptr << std::endl;
	} else {
	  os << "  " << types[j].first->name << ", ptr = " << types[j].second.ptr << std::endl;
	}
      }
      for (member_map::const_iterator it = tmp.begin(); it != tmp.end(); ++it) {
	if (it->second.first) {
	  const char *objtype = it->second.first->method ? "method" : "variable";
	  const char *modifier = (it->second.first->flags &1) ? "static " : (it->second.first->flags &2) ? "global " : "";
	  os << "  " << it->second.first->name << " (" << modifier << objtype << ")" << std::endl;
	  assert(it->second.first->name == it->first);
	} else {
	  os << "  " << it->first << std::endl;
	}
      }
      os << "}" << std::endl;
    }
  };

  // Octave tries hard to preserve pass-by-value semantics. Eg, assignments
  // will call clone() via make_unique() if there is more than one outstanding 
  // reference to the lhs, and forces the clone's reference count to 1 
  // (so you can't just increment your own count and return this).
  //
  // One way to fix this (without modifying Octave) is to add a level of
  // indirection such that clone copies ref-counted pointer and we keep 
  // pass-by-ref semantics (which are more natural/expected for C++ bindings).
  //
  // Supporting both pass-by-{ref,value} and toggling via %feature/option 
  // might be nice.

  class octave_swig_ref:public octave_base_value {
    octave_swig_type *ptr;
  public:
    octave_swig_ref(octave_swig_type *_ptr = 0)
      :ptr(_ptr) { }

    ~octave_swig_ref()
      { if (ptr) ptr->decref(); }

    octave_swig_type *get_ptr() const
      { return ptr; }

    octave_base_value *clone() const
      { if (ptr) ptr->incref(); return new octave_swig_ref(ptr); }

    octave_base_value *empty_clone() const
      { return new octave_swig_ref(0); }

    bool is_defined() const
      { return ptr->is_defined(); }

    virtual bool is_map() const 
      { return ptr->is_map(); }

    virtual octave_value subsref(const std::string &ops, const std::list < octave_value_list > &idx) 
      { return ptr->subsref(ops, idx); }

    virtual octave_value_list subsref(const std::string &ops, const std::list < octave_value_list > &idx, int nargout)
      { return ptr->subsref(ops, idx, nargout); }

    octave_value subsasgn(const std::string &ops, const std::list < octave_value_list > &idx, const octave_value &rhs)
      { return ptr->subsasgn(ops, idx, rhs); }

    virtual bool is_string() const 
      { return ptr->is_string(); }

    virtual std::string string_value(bool force = false) const 
      { return ptr->string_value(force); }

    virtual Octave_map map_value() const
      { return ptr->map_value(); }

    virtual string_vector map_keys() const
      { return ptr->map_keys(); }

    virtual bool save_ascii (std::ostream& os)
      { return ptr->save_ascii(os); }

    virtual bool load_ascii (std::istream& is)
      { return ptr->load_ascii(is); }

    virtual bool save_binary (std::ostream& os, bool& save_as_floats)
      { return ptr->save_binary(os, save_as_floats); }

    virtual bool load_binary (std::istream& is, bool swap, 
			      oct_mach_info::float_format fmt)
      { return ptr->load_binary(is, swap, fmt); }

#if defined (HAVE_HDF5)
    virtual bool
      save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
      { return ptr->save_hdf5(loc_id, name, save_as_floats); }

    virtual bool
      load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug)
      { return ptr->load_hdf5(loc_id, name, have_h5giterate_bug); }
#endif

    virtual octave_value convert_to_str(bool pad = false, bool force = false, char type = '"') const
      { return ptr->convert_to_str(pad, force, type); }

    virtual octave_value convert_to_str_internal(bool pad, bool force, char type) const
      { return ptr->convert_to_str_internal(pad, force, type); }

    void print(std::ostream &os, bool pr_as_read_syntax = false) const
      { return ptr->print(os, pr_as_read_syntax); }

  private:
    DECLARE_OCTAVE_ALLOCATOR;
    DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA;
  };
  DEFINE_OCTAVE_ALLOCATOR(octave_swig_ref);
  DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_swig_ref, "swig_ref", "swig_ref");

  class octave_swig_packed:public octave_base_value {
    swig_type_info *type;
    std::vector < char > buf;
  public:

    octave_swig_packed(swig_type_info *_type = 0, const void *_buf = 0, size_t _buf_len = 0)
      :	type(_type), buf((const char*)_buf, (const char*)_buf + _buf_len) {
    }

    bool copy(swig_type_info *outtype, void *ptr, size_t sz) const {
      if (outtype && outtype != type)
	return false;
      assert(sz <= buf.size());
      std::copy(buf.begin(), buf.begin()+sz, (char*)ptr);
      return true;
    }

    octave_base_value *clone() const {
      return new octave_swig_packed(*this);
    }

    octave_base_value *empty_clone() const {
      return new octave_swig_packed();
    }

    bool is_defined() const {
      return true;
    }

    void print(std::ostream &os, bool pr_as_read_syntax = false) const {
      os << "swig packed type: name = " << (type ? type->name : std::string()) << ", len = " << buf.size() << std::endl;
    }


    virtual bool save_ascii (std::ostream& os) {
      return true;
    }

    virtual bool load_ascii (std::istream& is) {
      return true;
    }

    virtual bool save_binary (std::ostream& os, bool& save_as_floats) {
      return true;
    }

    virtual bool load_binary (std::istream& is, bool swap, 
			      oct_mach_info::float_format fmt) {
      return true;
    }

#if defined (HAVE_HDF5)
    virtual bool
      save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats) {
      return true;
    }

    virtual bool
      load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug) {
      return true;
    }
#endif

  private:
    DECLARE_OCTAVE_ALLOCATOR;
    DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA;
  };
  DEFINE_OCTAVE_ALLOCATOR(octave_swig_packed);
  DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_swig_packed, "swig_packed", "swig_packed");

  static octave_value_list octave_set_immutable(const octave_value_list &args, int nargout) {
    error("attempt to set immutable member variable");
    return octave_value_list();
  }

  struct octave_value_ref {
    const octave_value_list &ovl;
    int j;

    octave_value_ref(const octave_value_list &_ovl, int _j)
      :ovl(_ovl), j(_j) { }

    operator  octave_value() const {
      return ovl(j);
    }

    octave_value operator*() const {
      return ovl(j);
    }
  };

  octave_value_list swig_subclass(const octave_value_list &args, int nargout) {
    octave_swig_type *top = new octave_swig_type;
    for (int j = 0; j < args.length(); ++j) {
      if (args(j).type_id() == octave_swig_ref::static_type_id()) {
	octave_swig_ref *osr = static_cast < octave_swig_ref *>(args(j).internal_rep());
	octave_swig_type *ost = osr->get_ptr();
	if (!ost->is_owned()) {
	  error("cannot subclass object not constructed on octave side");
	  return octave_value_list();
	}
	top->merge(*ost);
      } else if (args(j).is_function_handle()) {
	top->assign(args(j).fcn_handle_value()->fcn_name(), args(j));
      } else if (args(j).is_string()) {
	if (j + 1 >= args.length()) {
	  error("member assignments must be of string,value form");
	  return octave_value_list();
	}
	top->assign(args(j).string_value(), args(j + 1));
	++j;
      } else {
	error("invalid arguments to subclass");
	return octave_value_list();
      }
    }
    return octave_value(Swig::swig_value_ref(top));
  }

  octave_value_list swig_type(const octave_value_list &args, int nargout) {
    if (args.length() != 1) {
      error("swig_typeinfo must be called with only a single object");
      return octave_value_list();
    }
    octave_swig_type *ost = Swig::swig_value_deref(args(0));
    if (!ost) {
      error("object is not a swig_ref");
      return octave_value_list();
    }
    return octave_value(ost->swig_type_name());
  }

  octave_value_list swig_typequery(const octave_value_list &args, int nargout) {
    if (args.length() != 1 || !args(0).is_string()) {
      error("swig_typeinfo must be called with single string argument");
      return octave_value_list();
    }
    swig_module_info *module = SWIG_GetModule(0);
    swig_type_info *type = SWIG_TypeQueryModule(module, module, args(0).string_value().c_str());
    if (!type)
      return octave_value("<unknown>");
    return octave_value(type->name);
  }

  octave_value_list swig_this(const octave_value_list &args, int nargout) {
    if (args.length() != 1) {
      error("swig_typeinfo must be called with only a single object");
      return octave_value_list();
    }
    if (args(0).is_matrix_type() && args(0).rows() == 0 && args(0).columns() == 0)
      return octave_value(octave_uint64(0));
    octave_swig_type *ost = Swig::swig_value_deref(args(0));
    if (!ost) {
      error("object is not a swig_ref");
      return octave_value_list();
    }
    return octave_value(octave_uint64((unsigned long long) ost->swig_this()));
  }

#define SWIG_DIRECTORS

namespace Swig {
  class Director {
    octave_swig_type *self;
    bool disowned;

    Director(const Director &x);
    Director &operator=(const Director &rhs);
  public:

    Director(void *vptr):self(0), disowned(false) {
      set_rtdir(vptr, this);
    }

    ~Director() {
      swig_director_destroyed(self, this);
      if (disowned)
	self->decref();
    }

    void swig_set_self(octave_swig_type *new_self) {
      assert(!disowned);
      self = new_self;
    }

    octave_swig_type *swig_get_self() const {
      return self;
    }

    void swig_disown() {
      if (disowned)
	return;
      disowned = true;
      self->incref();
    }
  };

  struct DirectorTypeMismatchException {
    static void raise(const char *msg) {
      // ... todo
      throw(DirectorTypeMismatchException());
    }

    static void raise(const octave_value &ov, const char *msg) {
      // ... todo
      raise(msg);
    }
  };
  struct DirectorPureVirtualException {
    static void raise(const char *msg) {
      // ... todo
      throw(DirectorPureVirtualException());
    }

    static void raise(const octave_value &ov, const char *msg) {
      // ... todo
      raise(msg);
    }
  };

}

  SWIGRUNTIME void swig_acquire_ownership(void *vptr) {
    //  assert(0);
    // ... todo
  }

  SWIGRUNTIME void swig_acquire_ownership_array(void *vptr) {
    //  assert(0);
    // ... todo
  }

  SWIGRUNTIME void swig_acquire_ownership_obj(void *vptr, int own) {
    //  assert(0);
    // ... todo
  }

  namespace Swig {
    SWIGRUNTIME void swig_director_destroyed(octave_swig_type *self, Director *d) {
      self->director_destroyed(d);
    }

    SWIGRUNTIME void swig_director_set_self(Director *d, octave_swig_type *self) {
      d->swig_set_self(self);
    }

    SWIGRUNTIME octave_base_value *swig_value_ref(octave_swig_type *ost) {
      return new octave_swig_ref(ost);
    }

    SWIGRUNTIME octave_swig_type *swig_value_deref(octave_value ov) {
      if (ov.is_cell() && ov.rows() == 1 && ov.columns() == 1)
	ov = ov.cell_value()(0);
      return swig_value_deref(*ov.internal_rep());
    }

    SWIGRUNTIME octave_swig_type *swig_value_deref(const octave_base_value &ov) {
      if (ov.type_id() != octave_swig_ref::static_type_id())
	return 0;
      const octave_swig_ref *osr = static_cast < const octave_swig_ref *>(&ov);
      return osr->get_ptr();
    }

  }

#define swig_unary_op(name) \
SWIGRUNTIME octave_value swig_unary_op_##name(const octave_base_value &x) { \
  return octave_swig_type::dispatch_unary_op(x,#name); \
}
#define swig_binary_op(name) \
SWIGRUNTIME octave_value swig_binary_op_##name(const octave_base_value&lhs,const octave_base_value &rhs) { \
  return octave_swig_type::dispatch_binary_op(lhs,rhs,#name); \
}
#define swigreg_unary_op(name) \
if (!octave_value_typeinfo::lookup_unary_op(octave_value::op_##name,tid)) \
octave_value_typeinfo::register_unary_op(octave_value::op_##name,tid,swig_unary_op_##name);
#define swigreg_binary_op(name) \
if (!octave_value_typeinfo::lookup_binary_op(octave_value::op_##name,tid1,tid2)) \
octave_value_typeinfo::register_binary_op(octave_value::op_##name,tid1,tid2,swig_binary_op_##name);

  swig_unary_op(not);
  swig_unary_op(uplus);
  swig_unary_op(uminus);
  swig_unary_op(transpose);
  swig_unary_op(hermitian);
  swig_unary_op(incr);
  swig_unary_op(decr);

  swig_binary_op(add);
  swig_binary_op(sub);
  swig_binary_op(mul);
  swig_binary_op(div);
  swig_binary_op(pow);
  swig_binary_op(ldiv);
  swig_binary_op(lshift);
  swig_binary_op(rshift);
  swig_binary_op(lt);
  swig_binary_op(le);
  swig_binary_op(eq);
  swig_binary_op(ge);
  swig_binary_op(gt);
  swig_binary_op(ne);
  swig_binary_op(el_mul);
  swig_binary_op(el_div);
  swig_binary_op(el_pow);
  swig_binary_op(el_ldiv);
  swig_binary_op(el_and);
  swig_binary_op(el_or);

  SWIGRUNTIME void SWIG_InstallUnaryOps(int tid) {
    swigreg_unary_op(not);
    swigreg_unary_op(uplus);
    swigreg_unary_op(uminus);
    swigreg_unary_op(transpose);
    swigreg_unary_op(hermitian);
    swigreg_unary_op(incr);
    swigreg_unary_op(decr);
  }
  SWIGRUNTIME void SWIG_InstallBinaryOps(int tid1, int tid2) {
    swigreg_binary_op(add);
    swigreg_binary_op(sub);
    swigreg_binary_op(mul);
    swigreg_binary_op(div);
    swigreg_binary_op(pow);
    swigreg_binary_op(ldiv);
    swigreg_binary_op(lshift);
    swigreg_binary_op(rshift);
    swigreg_binary_op(lt);
    swigreg_binary_op(le);
    swigreg_binary_op(eq);
    swigreg_binary_op(ge);
    swigreg_binary_op(gt);
    swigreg_binary_op(ne);
    swigreg_binary_op(el_mul);
    swigreg_binary_op(el_div);
    swigreg_binary_op(el_pow);
    swigreg_binary_op(el_ldiv);
    swigreg_binary_op(el_and);
    swigreg_binary_op(el_or);
  }
  SWIGRUNTIME void SWIG_InstallOps(int tid) {
    // here we assume that tid are conseq integers increasing from zero, and 
    // that our tid is the last one. might be better to have explicit string 
    // list of types we should bind to, and use lookup_type to resolve their tid.

    SWIG_InstallUnaryOps(tid);
    SWIG_InstallBinaryOps(tid, tid);
    for (int j = 0; j < tid; ++j) {
      SWIG_InstallBinaryOps(j, tid);
      SWIG_InstallBinaryOps(tid, j);
    }
  }

SWIGRUNTIME octave_value SWIG_Octave_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  int own = (flags &SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;

  Swig::Director *d = Swig::get_rtdir(ptr);
  if (d && d->swig_get_self())
    return d->swig_get_self()->as_value();
  return Swig::swig_value_ref(new octave_swig_type(ptr, type, own));
}

SWIGRUNTIME int SWIG_Octave_ConvertPtrAndOwn(octave_value ov, void **ptr, swig_type_info *type, int flags, int *own) {
  if (ov.is_cell() && ov.rows() == 1 && ov.columns() == 1)
    ov = ov.cell_value()(0);
  if (!ov.is_defined() ||
      (ov.is_matrix_type() && ov.rows() == 0 && ov.columns() == 0) ) {
    if (ptr)
      *ptr = 0;
    return SWIG_OK;
  }
  if (ov.type_id() != octave_swig_ref::static_type_id())
    return SWIG_ERROR;
  octave_swig_ref *osr = static_cast < octave_swig_ref *>(ov.internal_rep());
  octave_swig_type *ost = osr->get_ptr();
  void *vptr = ost->cast(type, own, flags);
  if (!vptr)
    return SWIG_ERROR;
  if (ptr)
    *ptr = vptr;
  return SWIG_OK;
}

SWIGRUNTIME octave_value SWIG_Octave_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return new octave_swig_packed(type, (char *) ptr, sz);
}

SWIGRUNTIME int SWIG_Octave_ConvertPacked(const octave_value &ov, void *ptr, size_t sz, swig_type_info *type) {
  if (!ov.is_defined())
    return SWIG_ERROR;
  if (ov.type_id() != octave_swig_packed::static_type_id())
    return SWIG_ERROR;
  octave_swig_packed *ost = static_cast < octave_swig_packed *>(ov.internal_rep());
  return ost->copy(type, (char *) ptr, sz) ? SWIG_OK : SWIG_ERROR;
}

void SWIG_Octave_SetConstant(octave_swig_type *module_ns, const std::string &name, const octave_value &ov) {
  module_ns->assign(name, ov);
}

SWIGRUNTIME swig_module_info *SWIG_Octave_GetModule(void *clientdata) {
  octave_value ov = get_global_value("__SWIG_MODULE__" SWIG_TYPE_TABLE_NAME SWIG_RUNTIME_VERSION, true);
  if (!ov.is_defined() ||
      ov.type_id() != octave_swig_packed::static_type_id())
    return 0;
  const octave_swig_packed* osp = 
    static_cast < const octave_swig_packed *> (ov.internal_rep());
  swig_module_info *pointer = 0;
  osp->copy(0, &pointer, sizeof(swig_module_info *));
  return pointer;
}

SWIGRUNTIME void SWIG_Octave_SetModule(void *clientdata, swig_module_info *pointer) {
  octave_value ov = new octave_swig_packed(0, &pointer, sizeof(swig_module_info *));
  const char *module_var = "__SWIG_MODULE__" SWIG_TYPE_TABLE_NAME SWIG_RUNTIME_VERSION;
#if USE_OCTAVE_API_VERSION<37
  link_to_global_variable(curr_sym_tab->lookup(module_var, true));
#else
  symbol_table::varref(module_var);
  symbol_table::mark_global(module_var);
#endif
  set_global_value(module_var, ov);
}



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Cv32suf swig_types[0]
#define SWIGTYPE_p_Cv64suf swig_types[1]
#define SWIGTYPE_p_CvAttrList swig_types[2]
#define SWIGTYPE_p_CvAvgComp swig_types[3]
#define SWIGTYPE_p_CvBox2D swig_types[4]
#define SWIGTYPE_p_CvChain swig_types[5]
#define SWIGTYPE_p_CvChainPtReader swig_types[6]
#define SWIGTYPE_p_CvConDensation swig_types[7]
#define SWIGTYPE_p_CvConnectedComp swig_types[8]
#define SWIGTYPE_p_CvContour swig_types[9]
#define SWIGTYPE_p_CvContourTree swig_types[10]
#define SWIGTYPE_p_CvConvexityDefect swig_types[11]
#define SWIGTYPE_p_CvFeatureTree swig_types[12]
#define SWIGTYPE_p_CvFileNode swig_types[13]
#define SWIGTYPE_p_CvFileNode_data swig_types[14]
#define SWIGTYPE_p_CvFileStorage swig_types[15]
#define SWIGTYPE_p_CvFilter swig_types[16]
#define SWIGTYPE_p_CvFont swig_types[17]
#define SWIGTYPE_p_CvGenericHash swig_types[18]
#define SWIGTYPE_p_CvGraph swig_types[19]
#define SWIGTYPE_p_CvGraphEdge swig_types[20]
#define SWIGTYPE_p_CvGraphScanner swig_types[21]
#define SWIGTYPE_p_CvGraphVtx swig_types[22]
#define SWIGTYPE_p_CvGraphVtx2D swig_types[23]
#define SWIGTYPE_p_CvHaarClassifier swig_types[24]
#define SWIGTYPE_p_CvHaarClassifierCascade swig_types[25]
#define SWIGTYPE_p_CvHaarFeature swig_types[26]
#define SWIGTYPE_p_CvHaarFeature_rect swig_types[27]
#define SWIGTYPE_p_CvHaarStageClassifier swig_types[28]
#define SWIGTYPE_p_CvHidHaarClassifierCascade swig_types[29]
#define SWIGTYPE_p_CvHistogram swig_types[30]
#define SWIGTYPE_p_CvHuMoments swig_types[31]
#define SWIGTYPE_p_CvImage swig_types[32]
#define SWIGTYPE_p_CvKalman swig_types[33]
#define SWIGTYPE_p_CvLSH swig_types[34]
#define SWIGTYPE_p_CvLSHOperations swig_types[35]
#define SWIGTYPE_p_CvLineIterator swig_types[36]
#define SWIGTYPE_p_CvMSERParams swig_types[37]
#define SWIGTYPE_p_CvMat swig_types[38]
#define SWIGTYPE_p_CvMatND swig_types[39]
#define SWIGTYPE_p_CvMatND_data swig_types[40]
#define SWIGTYPE_p_CvMatND_dim swig_types[41]
#define SWIGTYPE_p_CvMat_data swig_types[42]
#define SWIGTYPE_p_CvMatrix swig_types[43]
#define SWIGTYPE_p_CvMatrix3 swig_types[44]
#define SWIGTYPE_p_CvMemBlock swig_types[45]
#define SWIGTYPE_p_CvMemStorage swig_types[46]
#define SWIGTYPE_p_CvMemStoragePos swig_types[47]
#define SWIGTYPE_p_CvModule swig_types[48]
#define SWIGTYPE_p_CvModuleInfo swig_types[49]
#define SWIGTYPE_p_CvMoments swig_types[50]
#define SWIGTYPE_p_CvNArrayIterator swig_types[51]
#define SWIGTYPE_p_CvNextEdgeType swig_types[52]
#define SWIGTYPE_p_CvPOSITObject swig_types[53]
#define SWIGTYPE_p_CvPluginFuncInfo swig_types[54]
#define SWIGTYPE_p_CvPoint swig_types[55]
#define SWIGTYPE_p_CvPoint2D32f swig_types[56]
#define SWIGTYPE_p_CvPoint2D64f swig_types[57]
#define SWIGTYPE_p_CvPoint3D32f swig_types[58]
#define SWIGTYPE_p_CvPoint3D64f swig_types[59]
#define SWIGTYPE_p_CvQuadEdge2D swig_types[60]
#define SWIGTYPE_p_CvRNG_Wrapper swig_types[61]
#define SWIGTYPE_p_CvRandState swig_types[62]
#define SWIGTYPE_p_CvRect swig_types[63]
#define SWIGTYPE_p_CvSURFParams swig_types[64]
#define SWIGTYPE_p_CvSURFPoint swig_types[65]
#define SWIGTYPE_p_CvScalar swig_types[66]
#define SWIGTYPE_p_CvSeq swig_types[67]
#define SWIGTYPE_p_CvSeqBlock swig_types[68]
#define SWIGTYPE_p_CvSeqReader swig_types[69]
#define SWIGTYPE_p_CvSeqWriter swig_types[70]
#define SWIGTYPE_p_CvSet swig_types[71]
#define SWIGTYPE_p_CvSetElem swig_types[72]
#define SWIGTYPE_p_CvSize swig_types[73]
#define SWIGTYPE_p_CvSize2D32f swig_types[74]
#define SWIGTYPE_p_CvSlice swig_types[75]
#define SWIGTYPE_p_CvSparseMat swig_types[76]
#define SWIGTYPE_p_CvSparseMatIterator swig_types[77]
#define SWIGTYPE_p_CvSparseNode swig_types[78]
#define SWIGTYPE_p_CvStarDetectorParams swig_types[79]
#define SWIGTYPE_p_CvStarKeypoint swig_types[80]
#define SWIGTYPE_p_CvStereoBMState swig_types[81]
#define SWIGTYPE_p_CvStereoGCState swig_types[82]
#define SWIGTYPE_p_CvString swig_types[83]
#define SWIGTYPE_p_CvStringHashNode swig_types[84]
#define SWIGTYPE_p_CvSubdiv2D swig_types[85]
#define SWIGTYPE_p_CvSubdiv2DEdge_Wrapper swig_types[86]
#define SWIGTYPE_p_CvSubdiv2DPoint swig_types[87]
#define SWIGTYPE_p_CvSubdiv2DPointLocation swig_types[88]
#define SWIGTYPE_p_CvTermCriteria swig_types[89]
#define SWIGTYPE_p_CvTreeNodeIterator swig_types[90]
#define SWIGTYPE_p_CvTupleT_CvPoint_2_t swig_types[91]
#define SWIGTYPE_p_CvTupleT_float_2_t swig_types[92]
#define SWIGTYPE_p_CvTupleT_float_3_t swig_types[93]
#define SWIGTYPE_p_CvType swig_types[94]
#define SWIGTYPE_p_CvTypeInfo swig_types[95]
#define SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t swig_types[96]
#define SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t swig_types[97]
#define SWIGTYPE_p_CvTypedSeqT_CvPoint_t swig_types[98]
#define SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t swig_types[99]
#define SWIGTYPE_p_CvTypedSeqT_CvRect_t swig_types[100]
#define SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t swig_types[101]
#define SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t swig_types[102]
#define SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t swig_types[103]
#define SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t swig_types[104]
#define SWIGTYPE_p__CvContourScanner swig_types[105]
#define SWIGTYPE_p__IplConvKernel swig_types[106]
#define SWIGTYPE_p__IplConvKernelFP swig_types[107]
#define SWIGTYPE_p__IplImage swig_types[108]
#define SWIGTYPE_p__IplROI swig_types[109]
#define SWIGTYPE_p__IplTileInfo swig_types[110]
#define SWIGTYPE_p_a_2__float swig_types[111]
#define SWIGTYPE_p_a_2__signed_char swig_types[112]
#define SWIGTYPE_p_a_3__float swig_types[113]
#define SWIGTYPE_p_allocator_type swig_types[114]
#define SWIGTYPE_p_char swig_types[115]
#define SWIGTYPE_p_difference_type swig_types[116]
#define SWIGTYPE_p_double swig_types[117]
#define SWIGTYPE_p_f_int_int_int_int_int__p__IplROI swig_types[118]
#define SWIGTYPE_p_f_int_int_int_p_char_p_char_int_int_int_int_int_p_IplROI_p_IplImage_p_void_p_IplTileInfo__p__IplImage swig_types[119]
#define SWIGTYPE_p_f_int_p_q_const__char_p_q_const__char_p_q_const__char_int_p_void__int swig_types[120]
#define SWIGTYPE_p_f_p_CvFileStorage_p_CvFileNode__p_void swig_types[121]
#define SWIGTYPE_p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void swig_types[122]
#define SWIGTYPE_p_f_p__IplImage_int__void swig_types[123]
#define SWIGTYPE_p_f_p__IplImage_int_int__void swig_types[124]
#define SWIGTYPE_p_f_p_p_void__void swig_types[125]
#define SWIGTYPE_p_f_p_q_const__IplImage__p__IplImage swig_types[126]
#define SWIGTYPE_p_f_p_q_const__char_int__p_CvMat swig_types[127]
#define SWIGTYPE_p_f_p_q_const__char_int__p__IplImage swig_types[128]
#define SWIGTYPE_p_f_p_q_const__char_p_q_const__void__void swig_types[129]
#define SWIGTYPE_p_f_p_q_const__char_p_q_const__void_p_q_const__int__int swig_types[130]
#define SWIGTYPE_p_f_p_q_const__float_p_q_const__float_p_void__float swig_types[131]
#define SWIGTYPE_p_f_p_q_const__void__int swig_types[132]
#define SWIGTYPE_p_f_p_q_const__void__p_void swig_types[133]
#define SWIGTYPE_p_f_p_q_const__void_p_q_const__void_p_void__int swig_types[134]
#define SWIGTYPE_p_f_p_void_p_void__int swig_types[135]
#define SWIGTYPE_p_f_size_t_p_void__p_void swig_types[136]
#define SWIGTYPE_p_float swig_types[137]
#define SWIGTYPE_p_int swig_types[138]
#define SWIGTYPE_p_int64_t swig_types[139]
#define SWIGTYPE_p_p_CvConDensation swig_types[140]
#define SWIGTYPE_p_p_CvFileStorage swig_types[141]
#define SWIGTYPE_p_p_CvGraphEdge swig_types[142]
#define SWIGTYPE_p_p_CvGraphScanner swig_types[143]
#define SWIGTYPE_p_p_CvGraphVtx swig_types[144]
#define SWIGTYPE_p_p_CvHaarClassifierCascade swig_types[145]
#define SWIGTYPE_p_p_CvHistogram swig_types[146]
#define SWIGTYPE_p_p_CvKalman swig_types[147]
#define SWIGTYPE_p_p_CvLSH swig_types[148]
#define SWIGTYPE_p_p_CvMat swig_types[149]
#define SWIGTYPE_p_p_CvMatND swig_types[150]
#define SWIGTYPE_p_p_CvMemStorage swig_types[151]
#define SWIGTYPE_p_p_CvPOSITObject swig_types[152]
#define SWIGTYPE_p_p_CvPoint swig_types[153]
#define SWIGTYPE_p_p_CvSeq swig_types[154]
#define SWIGTYPE_p_p_CvSeqBlock swig_types[155]
#define SWIGTYPE_p_p_CvSetElem swig_types[156]
#define SWIGTYPE_p_p_CvSparseMat swig_types[157]
#define SWIGTYPE_p_p_CvStereoBMState swig_types[158]
#define SWIGTYPE_p_p_CvStereoGCState swig_types[159]
#define SWIGTYPE_p_p_CvSubdiv2DPoint swig_types[160]
#define SWIGTYPE_p_p_CvTypedSeqT_CvConnectedComp_t swig_types[161]
#define SWIGTYPE_p_p_CvTypedSeqT_CvPoint2D32f_t swig_types[162]
#define SWIGTYPE_p_p_CvTypedSeqT_CvPoint_t swig_types[163]
#define SWIGTYPE_p_p_CvTypedSeqT_CvQuadEdge2D_t swig_types[164]
#define SWIGTYPE_p_p_CvTypedSeqT_CvRect_t swig_types[165]
#define SWIGTYPE_p_p_CvTypedSeqT_CvSeq_p_t swig_types[166]
#define SWIGTYPE_p_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t swig_types[167]
#define SWIGTYPE_p_p_CvTypedSeqT_CvTupleT_float_2_t_t swig_types[168]
#define SWIGTYPE_p_p_CvTypedSeqT_CvTupleT_float_3_t_t swig_types[169]
#define SWIGTYPE_p_p__CvContourScanner swig_types[170]
#define SWIGTYPE_p_p__IplConvKernel swig_types[171]
#define SWIGTYPE_p_p__IplImage swig_types[172]
#define SWIGTYPE_p_p_char swig_types[173]
#define SWIGTYPE_p_p_float swig_types[174]
#define SWIGTYPE_p_p_p_CvMat swig_types[175]
#define SWIGTYPE_p_p_unsigned_char swig_types[176]
#define SWIGTYPE_p_p_void swig_types[177]
#define SWIGTYPE_p_short swig_types[178]
#define SWIGTYPE_p_signed_char swig_types[179]
#define SWIGTYPE_p_size_t swig_types[180]
#define SWIGTYPE_p_size_type swig_types[181]
#define SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t swig_types[182]
#define SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__allocator_type swig_types[183]
#define SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type swig_types[184]
#define SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t swig_types[185]
#define SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t__allocator_type swig_types[186]
#define SWIGTYPE_p_swig__OctSwigIterator swig_types[187]
#define SWIGTYPE_p_uint64_t swig_types[188]
#define SWIGTYPE_p_unsigned_char swig_types[189]
#define SWIGTYPE_p_unsigned_int swig_types[190]
#define SWIGTYPE_p_unsigned_short swig_types[191]
#define SWIGTYPE_p_value_type swig_types[192]
#define SWIGTYPE_p_void swig_types[193]
static swig_type_info *swig_types[195];
static swig_module_info swig_module = {swig_types, 194, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */


#define SWIGVERSION 0x010340 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) (void *)((const void *)(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),(void**)(a)) 


#include <stdexcept>


#include "octhelpers.h"
#include "octcvseq.hpp"
#include "octerror.h"




  static inline bool OctSwigObject_Check(const octave_value& ov) {
    return ov.type_id()==octave_swig_ref::static_type_id();
  }

  static CvArr * OctObject_to_CvArr(octave_value obj, bool * freearg);
  static CvArr * OctSequence_to_CvArr( octave_value obj );

  // convert a octave sequence/array/list object into a c-array
#define OctObject_AsArrayImpl(func, ctype, ptype)                              \
 int func(octave_value obj, ctype * array, int len){                         \
   void * mat_vptr=NULL;                                                     \
   void * im_vptr=NULL;                                                      \
   if(OctNumber_Check(obj)){                                                  \
     memset( array, 0, sizeof(ctype)*len );                                \
     array[0] = OctObject_As##ptype( obj );                                 \
   }                                                                         \
   else if(OctList_Check(obj) || OctTuple_Check(obj)){                         \
     int seqsize = OctSequence_Size(obj);                                   \
     for(int i=0; i<len && i<seqsize; i++){                                \
       if(i<seqsize){                                                    \
	 array[i] =  OctObject_As##ptype( OctSequence_GetItem(obj, i) ); \
       }                                                                 \
       else{                                                             \
	 array[i] = 0;                                                 \
       }                                                                 \
     }                                                                     \
   }                                                                         \
   else if( SWIG_ConvertPtr(obj, &mat_vptr, SWIGTYPE_p_CvMat, 0)!=-1 ||      \
	    SWIG_ConvertPtr(obj, &im_vptr, SWIGTYPE_p__IplImage, 0)!=-1)     \
     {                                                                         \
       CvMat * mat = (CvMat *) mat_vptr;                                     \
       CvMat stub;                                                           \
       if(im_vptr) mat = cvGetMat(im_vptr, &stub);                           \
       if( mat->rows!=1 && mat->cols!=1 ){                                   \
	 error("OctObject_As*Array: CvArr must be row or column vector" );   \
	 return -1;                                                        \
       }                                                                     \
       if( mat->rows==1 && mat->cols==1 ){                                   \
	 CvScalar val;                                                     \
	 if( len!=CV_MAT_CN(mat->type) ){                                  \
	   error("OctObject_As*Array: CvArr channels != length" );              \
	   return -1;                                                    \
	 }                                                                 \
	 val = cvGet1D(mat, 0);                                            \
	 for(int i=0; i<len; i++){                                         \
	   array[i] = (ctype) val.val[i];                                \
	 }                                                                 \
       }                                                                     \
       else{                                                                 \
	 mat = cvReshape(mat, &stub, -1, mat->rows*mat->cols);             \
	 if( mat->rows != len ){                                           \
	   error("OctObject_As*Array: CvArr rows or cols must equal length" ); \
	   return -1;                                                   \
	 }                                                                 \
	 for(int i=0; i<len; i++){                                         \
	   CvScalar val = cvGet1D(mat, i);                               \
	   array[i] = (ctype) val.val[0];                                \
	 }                                                                 \
       }                                                                     \
     }                                                                         \
   else{                                                                     \
     error("OctObject_As*Array: Expected a number, sequence or CvArr" );  \
     return -1;                                                            \
   }                                                                         \
   return 0;                                                                 \
 }

  OctObject_AsArrayImpl( OctObject_AsFloatArray, float, Double );
  OctObject_AsArrayImpl( OctObject_AsDoubleArray, double, Double );
  OctObject_AsArrayImpl( OctObject_AsLongArray, int, Long );

  static CvPoint OctObject_to_CvPoint(octave_value obj){
    CvPoint val;
    CvPoint *ptr;
    CvPoint2D32f * ptr2D32f;
    CvScalar * scalar;

    if( SWIG_ConvertPtr(obj, (void**)&ptr, SWIGTYPE_p_CvPoint, 0) != -1) {
      return *ptr;
    }
    if( SWIG_ConvertPtr(obj, (void**)&ptr2D32f, SWIGTYPE_p_CvPoint2D32f, 0) != -1) {
      return cvPointFrom32f( *ptr2D32f );
    }
    if( SWIG_ConvertPtr(obj, (void**)&scalar, SWIGTYPE_p_CvScalar, 0) != -1) {
      return cvPointFrom32f(cvPoint2D32f( scalar->val[0], scalar->val[1] ));
    }
    if(OctObject_AsLongArray(obj, (int *) &val, 2) != -1){
      return val;
    }

    error("could not convert to CvPoint");
    return cvPoint(0,0);
  }

  static CvPoint2D32f OctObject_to_CvPoint2D32f(octave_value obj){
    CvPoint2D32f val;
    CvPoint2D32f *ptr2D32f;
    CvPoint *ptr;
    CvScalar * scalar;
    if( SWIG_ConvertPtr(obj, (void**)&ptr2D32f, SWIGTYPE_p_CvPoint2D32f, 0) != -1) {
      return *ptr2D32f;
    }
    if( SWIG_ConvertPtr(obj, (void**)&ptr, SWIGTYPE_p_CvPoint, 0) != -1) {
      return cvPointTo32f(*ptr);
    }
    if( SWIG_ConvertPtr(obj, (void**)&scalar, SWIGTYPE_p_CvScalar, 0) != -1) {
      return cvPoint2D32f( scalar->val[0], scalar->val[1] );
    }
    if(OctObject_AsFloatArray(obj, (float *) &val, 2) != -1){
      return val;
    }
    error("could not convert to CvPoint2D32f");
    return cvPoint2D32f(0,0);
  }

  static CvScalar OctObject_to_CvScalar(octave_value obj){
    CvScalar val;
    CvScalar * ptr;
    CvPoint2D32f *ptr2D32f;
    CvPoint *pt_ptr;
    void * vptr;
    if( SWIG_ConvertPtr(obj, &vptr, SWIGTYPE_p_CvScalar, 0 ) != -1)
      {
	ptr = (CvScalar *) vptr;
	return *ptr;
      }
    if( SWIG_ConvertPtr(obj, (void**)&ptr2D32f, SWIGTYPE_p_CvPoint2D32f, 0) != -1) {
      return cvScalar(ptr2D32f->x, ptr2D32f->y);
    }
    if( SWIG_ConvertPtr(obj, (void**)&pt_ptr, SWIGTYPE_p_CvPoint, 0) != -1) {
      return cvScalar(pt_ptr->x, pt_ptr->y);
    }
    if(OctObject_AsDoubleArray(obj, val.val, 4)!=-1){
      return val;
    }
    return cvScalar(-1,-1,-1,-1); 
  }

  // if octave sequence type, convert to CvMat or CvMatND
  static CvArr * OctObject_to_CvArr(octave_value obj, bool * freearg){
    CvArr * cvarr;
    *freearg = false;

    // check if OpenCV type
    if ( OctSwigObject_Check(obj) ){
      SWIG_ConvertPtr(obj, &cvarr, 0, SWIG_POINTER_EXCEPTION);
    }
    else if (OctList_Check(obj) || OctTuple_Check(obj)){
      cvarr = OctSequence_to_CvArr( obj );
      *freearg = (cvarr != NULL);
    }
    else if (OctLong_Check(obj) && OctLong_AsLong(obj)==0){
      return NULL;
    }
    else {
      SWIG_ConvertPtr(obj, (void**)&cvarr, 0, SWIG_POINTER_EXCEPTION);
    }
    return cvarr;
  }

  static int OctObject_GetElemType(octave_value obj){
    void *vptr;
    if(SWIG_ConvertPtr(obj, &vptr, SWIGTYPE_p_CvPoint, 0) != -1) return CV_32SC2;	
    if(SWIG_ConvertPtr(obj, &vptr, SWIGTYPE_p_CvSize, 0) != -1) return CV_32SC2;	
    if(SWIG_ConvertPtr(obj, &vptr, SWIGTYPE_p_CvRect, 0) != -1) return CV_32SC4;	
    if(SWIG_ConvertPtr(obj, &vptr, SWIGTYPE_p_CvSize2D32f, 0) != -1) return CV_32FC2;	
    if(SWIG_ConvertPtr(obj, &vptr, SWIGTYPE_p_CvPoint2D32f, 0) != -1) return CV_32FC2;	
    if(SWIG_ConvertPtr(obj, &vptr, SWIGTYPE_p_CvPoint3D32f, 0) != -1) return CV_32FC3;	
    if(SWIG_ConvertPtr(obj, &vptr, SWIGTYPE_p_CvPoint2D64f, 0) != -1) return CV_64FC2;	
    if(SWIG_ConvertPtr(obj, &vptr, SWIGTYPE_p_CvPoint3D64f, 0) != -1) return CV_64FC3;	
    if(SWIG_ConvertPtr(obj, &vptr, SWIGTYPE_p_CvScalar, 0) != -1) return CV_64FC4;	
    if(OctTuple_Check(obj) || OctList_Check(obj)) return CV_MAKE_TYPE(CV_32F, OctSequence_Size( obj ));
    if(OctLong_Check(obj)) return CV_32S;
    return CV_32F;
  }

  // Would like this to convert Octave lists to CvMat
  // Also lists of CvPoints, CvScalars, CvMats? etc
  static CvArr * OctSequence_to_CvArr( octave_value obj ){
    int dims[CV_MAX_DIM] = {1,1,1};
    int ndim=0;
    int cvtype;
    octave_value item;

    // figure out dimensions
    for(item = obj; 
	(OctTuple_Check(item) || OctList_Check(item));
	item = OctSequence_GetItem(item, 0))
      {
	dims[ndim] = OctSequence_Size( item ); 
	ndim++;
      }

    if(ndim==0){
      error("Cannot convert an empty octave object to a CvArr");
      return NULL;
    }

    cvtype = OctObject_GetElemType(item);
    // collapse last dim into NCH if we found a single channel, but the last dim is <=3
    if(CV_MAT_CN(cvtype)==1 && dims[ndim-1]>1 && dims[ndim-1]<4){
      cvtype=CV_MAKE_TYPE(cvtype, dims[ndim-1]);
      dims[ndim-1]=1;	
      ndim--;
    }

    if(cvtype==-1){
      error("Could not determine OpenCV element type of Octave sequence");
      return NULL;
    }

    // CvMat
    if(ndim<=2){
      CvMat *m = cvCreateMat(dims[0], dims[1], cvtype);
      for(int i=0; i<dims[0]; i++){
	octave_value rowobj = OctSequence_GetItem(obj, i);
	if( dims[1] > 1 ){
	  // double check size
	  assert((OctTuple_Check(rowobj) || OctList_Check(rowobj)) && 
		 OctSequence_Size(rowobj) == dims[1]);

	  for(int j=0; j<dims[1]; j++){
	    octave_value colobj = OctSequence_GetItem(rowobj, j);
	    cvSet2D( m, i, j, OctObject_to_CvScalar( colobj ) );
	  }
	}
	else{
	  cvSet1D(m, i, OctObject_to_CvScalar( rowobj ) );
	}
      }
      return (CvArr *) m;
    }

    // CvMatND
    error("Cannot convert Octave Object to CvArr -- ndim > 3");
    return NULL;
  }


  // Wrapper class
  class CvRNG_Wrapper {
  private:
    CvRNG m_val;
  public:
    CvRNG_Wrapper( const CvRNG & val ) :
      m_val(val)
      {
      }
    CvRNG * ptr() { return &m_val; }
    CvRNG & ref() { return m_val; }
    bool operator==(const CvRNG_Wrapper & x){
      return m_val==x.m_val;
    }
    bool operator!=(const CvRNG_Wrapper & x){
      return m_val!=x.m_val;
    }
  };
  

SWIGINTERNINLINE octave_value
  SWIG_From_bool  (bool value)
{
  return octave_value(value);
}


  // Wrapper class
  class CvSubdiv2DEdge_Wrapper {
  private:
    CvSubdiv2DEdge m_val;
  public:
    CvSubdiv2DEdge_Wrapper( const CvSubdiv2DEdge & val ) :
      m_val(val)
      {
      }
    CvSubdiv2DEdge * ptr() { return &m_val; }
    CvSubdiv2DEdge & ref() { return m_val; }
    bool operator==(const CvSubdiv2DEdge_Wrapper & x){
      return m_val==x.m_val;
    }
    bool operator!=(const CvSubdiv2DEdge_Wrapper & x){
      return m_val!=x.m_val;
    }
  };
  

  SWIGINTERN int SWIG_AsVal_unsigned_SS_long (const octave_value& ov, unsigned long* val)
    {
      if (!ov.is_scalar_type())
	return SWIG_TypeError;
      if (ov.is_complex_scalar())
	return SWIG_TypeError;
      if (ov.is_double_type()||ov.is_single_type()) {
	double v=ov.double_value();
	if (v<0)
	  return SWIG_OverflowError;  
	if (v!=floor(v))
	  return SWIG_TypeError;
      }
      if (ov.is_int8_type()||ov.is_int16_type()||
	  ov.is_int32_type()) {
	long v=ov.long_value();
	if (v<0)
	  return SWIG_OverflowError;  
      }
      if (ov.is_int64_type()) {
	long long v=ov.int64_scalar_value().value();
	if (v<0)
	  return SWIG_OverflowError;  
      }
      if (val)
	*val = ov.ulong_value();
      return SWIG_OK;
    }


SWIGINTERNINLINE int
SWIG_AsVal_size_t (octave_value obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = (size_t)(v);
  return res;
}


#include "cvshadow.h"


#include <stdexcept>


#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <string>
#include <stdexcept>


#include <string>


#include <iostream>

  
namespace swig {
  struct stop_iteration {
  };

  struct OctSwigIterator {
  private:
    octave_value _seq;

  protected:
    OctSwigIterator(octave_value seq) : _seq(seq)
    {
    }
      
  public:
    virtual ~OctSwigIterator() {}

    virtual octave_value value() const = 0;

    virtual OctSwigIterator *incr(size_t n = 1) = 0;

    virtual OctSwigIterator *decr(size_t n = 1)
    {
      throw stop_iteration();
    }

    virtual ptrdiff_t distance(const OctSwigIterator &x) const
    {
      throw std::invalid_argument("operation not supported");
    }

    virtual bool equal (const OctSwigIterator &x) const
    {
      throw std::invalid_argument("operation not supported");
    }
    
    virtual OctSwigIterator *copy() const = 0;

    octave_value next()
    {
      octave_value obj = value();
      incr();
      return obj;
    }

    octave_value previous()
    {
      decr();
      return value();
    }

    OctSwigIterator *advance(ptrdiff_t n)
    {
      return  (n > 0) ?  incr(n) : decr(-n);
    }
      
    bool operator == (const OctSwigIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const OctSwigIterator& x) const
    {
      return ! operator==(x);
    }

    OctSwigIterator* operator ++ () {
      incr();
      return this;
    }

    OctSwigIterator* operator -- () {
      decr();
      return this;
    }
      
    OctSwigIterator* operator + (ptrdiff_t n) const
    {
      return copy()->advance(n);
    }

    OctSwigIterator* operator - (ptrdiff_t n) const
    {
      return copy()->advance(-n);
    }
      
    ptrdiff_t operator - (const OctSwigIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::OctSwigIterator *");
	init = 1;
      }	
      return desc;
    }    
  };
}


  SWIGINTERNINLINE octave_value SWIG_From_long    (long value)
    {    
      return octave_value(value);
    }


SWIGINTERNINLINE octave_value
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
  return SWIG_From_long  ((long)(value));
}


  SWIGINTERN int SWIG_AsVal_long (const octave_value& ov, long* val)
    {
      if (!ov.is_scalar_type())
	return SWIG_TypeError;
      if (ov.is_complex_scalar())
	return SWIG_TypeError;
      if (ov.is_double_type()||ov.is_single_type()) {
	double v=ov.double_value();
	if (v!=floor(v))
	  return SWIG_TypeError;
      }
      if (val)
	*val = ov.long_value();
      return SWIG_OK;
    }


SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (octave_value obj, ptrdiff_t *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = (ptrdiff_t)(v);
  return res;
}


#include <stdexcept>


#include <algorithm>


#include <vector>


#include <utility>


#include <map>
#include <algorithm>
#include <stdexcept>


namespace swig {  
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };  
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> 
  struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }    
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }    
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category> 
  struct traits_as { };
 
  template <class Type, class Category> 
  struct traits_check { };

}


namespace swig {  
// Traits that provides the from method
  template <class Type> struct traits_from_ptr {
    static octave_value from(Type *val, int owner = 0) {
      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static octave_value from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static octave_value from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static octave_value from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline octave_value from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline octave_value from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

    // Traits that provides the asval/as/check method
  template <class Type>
  struct traits_asptr {   
    static int asptr(const octave_value& obj, Type **val) {
      Type *p;
      int res = SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0);
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(const octave_value& obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(const octave_value& obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(const octave_value& obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(const octave_value& obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(const octave_value& obj, bool throw_error) {
      Type v;
      int res = asval(obj, &v);
      if (!obj.is_defined() || !SWIG_IsOK(res)) {
	if (!Octave_Error_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(const octave_value& obj, bool throw_error) {
      Type *v = 0;      
      int res = traits_asptr<Type>::asptr(obj, &v);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	// Uninitialized return value, no Type() constructor required.
	static Type *v_def = (Type*) malloc(sizeof(Type));
	if (!Octave_Error_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	memset(v_def,0,sizeof(Type));
	return *v_def;
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(const octave_value& obj, bool throw_error) {
      Type *v = 0;      
      int res = traits_asptr<Type>::asptr(obj, &v);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (!Octave_Error_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	return 0;
      }
    }
  };
    
  template <class Type>
  inline Type as(const octave_value& obj, bool te = false) {
    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(const octave_value& obj) {
      int res = asval(obj, (Type *)(0));
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(const octave_value& obj) {
      int res = asptr(obj, (Type **)(0));
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(const octave_value& obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


#include <functional>

namespace std {
  template <>
  struct less <octave_value>: public binary_function<octave_value, octave_value, bool>
  {
    bool
    operator()(const octave_value& v, const octave_value& w) const
    { 
      octave_value res = do_binary_op(octave_value::op_le,v,w);
      return res.is_true();
    }
  };
}

namespace swig {
  inline size_t
  check_index(ptrdiff_t i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    
    throw std::out_of_range("index out of range");
  }

  inline size_t
  slice_index(ptrdiff_t i, size_t size) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) {
	return (size_t) (i + size);
      } else {
	throw std::out_of_range("index out of range");
      }
    } else {
      return ( (size_t) i < size ) ? ((size_t) i) : size;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size);
    typename Sequence::size_type jj = swig::slice_index(j, size);

    if (jj > ii) {
      typename Sequence::const_iterator vb = self->begin();
      typename Sequence::const_iterator ve = self->begin();
      std::advance(vb,ii);
      std::advance(ve,jj);
      return new Sequence(vb, ve);
    } else {
      return new Sequence();
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj < ii) jj = ii;
    size_t ssize = jj - ii;
    if (ssize <= v.size()) {
      typename Sequence::iterator sb = self->begin();
      typename InputSeq::const_iterator vmid = v.begin();
      std::advance(sb,ii);
      std::advance(vmid, jj - ii);
      self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
    } else {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
      self->insert(sb, v.begin(), v.end());
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj > ii) {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
    }
  }
}


#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif


namespace swig {
  template<typename OutIterator>
  class OctSwigIterator_T :  public OctSwigIterator
  {
  public:
    typedef OutIterator out_iterator;
    typedef typename std::iterator_traits<out_iterator>::value_type value_type;    
    typedef OctSwigIterator_T<out_iterator> self_type;

    OctSwigIterator_T(out_iterator curr, octave_value seq)
      : OctSwigIterator(seq), current(curr)
    {
    }

    const out_iterator& get_current() const
    {
      return current;
    }

    
    bool equal (const OctSwigIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    ptrdiff_t distance(const OctSwigIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }    
    
  protected:
    out_iterator current;
  };
  
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef octave_value result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class OctSwigIteratorOpen_T :  public OctSwigIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef OctSwigIterator_T<out_iterator>  base;
    typedef OctSwigIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
    
    OctSwigIteratorOpen_T(out_iterator curr, octave_value seq)
      : OctSwigIterator_T<OutIterator>(curr, seq)
    {
    }
    
    octave_value value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    OctSwigIterator *copy() const
    {
      return new self_type(*this);
    }

    OctSwigIterator *incr(size_t n = 1)
    {
      while (n--) {
	++base::current;
      }
      return this;
    }

    OctSwigIterator *decr(size_t n = 1)
    {
      while (n--) {
	--base::current;
      }
      return this;
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class OctSwigIteratorClosed_T :  public OctSwigIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef OctSwigIterator_T<out_iterator>  base;    
    typedef OctSwigIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
    
    OctSwigIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, octave_value seq)
      : OctSwigIterator_T<OutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    octave_value value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    OctSwigIterator *copy() const
    {
      return new self_type(*this);
    }

    OctSwigIterator *incr(size_t n = 1)
    {
      while (n--) {
	if (base::current == end) {
	  throw stop_iteration();
	} else {
	  ++base::current;
	}
      }
      return this;
    }

    OctSwigIterator *decr(size_t n = 1)
    {
      while (n--) {
	if (base::current == begin) {
	  throw stop_iteration();
	} else {
	  --base::current;
	}
      }
      return this;
    }

  private:
    out_iterator begin;
    out_iterator end;
  };

  template<typename OutIter>
  inline OctSwigIterator*
  make_output_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, octave_value seq = octave_value())
  {
    return new OctSwigIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  template<typename OutIter>
  inline OctSwigIterator*
  make_output_iterator(const OutIter& current, octave_value seq = octave_value())
  {
    return new OctSwigIteratorOpen_T<OutIter>(current, seq);
  }
}


namespace swig
{
  template <class T>
    struct OctSequence_Ref // * octave can't support these, because of how assignment works
  {
    OctSequence_Ref(const octave_value& seq, int index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      //      swig::SwigVar_PyObject item = OctSequence_GetItem(_seq, _index);
      octave_value item; // * todo
      try {
	return swig::as<T>(item, true);
      } catch (std::exception& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", _index);
	if (!Octave_Error_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
	}
	SWIG_Octave_AddErrorMsg(msg);
	SWIG_Octave_AddErrorMsg(e.what());
	throw;
      }
    }

    OctSequence_Ref& operator=(const T& v)
    {
      //      OctSequence_SetItem(_seq, _index, swig::from<T>(v));
      // * todo
      return *this;
    }

  private:
    octave_value _seq;
    int _index;
  };

  template <class T>
  struct OctSequence_ArrowProxy
  {
    OctSequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };

  template <class T, class Reference >
  struct OctSequence_InputIterator
  {
    typedef OctSequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;

    OctSequence_InputIterator()
    {
    }

    OctSequence_InputIterator(const octave_value& seq, int index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    OctSequence_ArrowProxy<T>
    operator->() const {
      return OctSequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    octave_value _seq;
    difference_type _index;
  };

  template <class T>
  struct OctSequence_Cont
  {
    typedef OctSequence_Ref<T> reference;
    typedef const OctSequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;
    typedef int size_type;
    typedef const pointer const_pointer;
    typedef OctSequence_InputIterator<T, reference> iterator;
    typedef OctSequence_InputIterator<T, const_reference> const_iterator;

    OctSequence_Cont(const octave_value& seq) : _seq(seq)
    {
      // * assert that we have map type etc.
      /*
      if (!OctSequence_Check(seq)) {
	throw std::invalid_argument("a sequence is expected");
      }
      _seq = seq;
      Py_INCREF(_seq);
      */
    }

    ~OctSequence_Cont()
    {
    }

    size_type size() const
    {
      //      return static_cast<size_type>(OctSequence_Size(_seq));
      return 0; // * todo
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check(bool set_err = true) const
    {
      int s = size();
      for (int i = 0; i < s; ++i) {
	//	swig::SwigVar_PyObject item = OctSequence_GetItem(_seq, i);
	octave_value item; // * todo
	if (!swig::check<value_type>(item)) {
	  if (set_err) {
	    char msg[1024];
	    sprintf(msg, "in sequence element %d", i);
	    SWIG_Error(SWIG_RuntimeError, msg);
	  }
	  return false;
	}
      }
      return true;
    }

  private:
    octave_value _seq;
  };

}


#include <float.h>


  SWIGINTERN int SWIG_AsVal_double (const octave_value& ov, double* val)
    {
      if (!ov.is_scalar_type())
	return SWIG_TypeError;
      if (ov.is_complex_scalar())
	return SWIG_TypeError;
      if (val)
	*val = ov.double_value();
      return SWIG_OK;
    }


SWIGINTERN int
SWIG_AsVal_float (octave_value obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < -FLT_MAX || v > FLT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (float)(v);
    }
  }  
  return res;
}


  SWIGINTERNINLINE octave_value SWIG_From_double    (double value)
    {    
      return octave_value(value);
    }


SWIGINTERNINLINE octave_value
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}


namespace swig {
  template <> struct traits<float > {
    typedef value_category category;
    static const char* type_name() { return"float"; }
  };  
  template <>  struct traits_asval<float > {   
    typedef float value_type;
    static int asval(octave_value obj, value_type *val) { 
      return SWIG_AsVal_float (obj, val);
    }
  };
  template <>  struct traits_from<float > {
    typedef float value_type;
    static octave_value from(const value_type& val) {
      return SWIG_From_float  (val);
    }
  };
}


namespace swig {
  template <class OctSeq, class Seq>
  inline void
  assign(const OctSeq& octseq, Seq* seq) {
#ifdef SWIG_STD_NOASSIGN_STL
    typedef typename OctSeq::value_type value_type;
    typename OctSeq::const_iterator it = octseq.begin();
    for (;it != octseq.end(); ++it) {
      seq->insert(seq->end(),(value_type)(*it));
    }
#else
    seq->assign(octseq.begin(), octseq.end());
#endif
  }

  template <class Seq, class T = typename Seq::value_type >
  struct traits_asptr_stdseq {
    typedef Seq sequence;
    typedef T value_type;

    static int asptr(const octave_value& obj, sequence **seq) {
      if (!obj.is_defined() || Swig::swig_value_deref(obj)) {
	sequence *p;
	if (SWIG_ConvertPtr(obj,(void**)&p,
			    swig::type_info<sequence>(),0) == SWIG_OK) {
	  if (seq) *seq = p;
	  return SWIG_OLDOBJ;
	}
      } else if (obj.is_cell()) {
	try {
	  OctSequence_Cont<value_type> octseq(obj);
	  if (seq) {
	    sequence *pseq = new sequence();
	    assign(octseq, pseq);
	    *seq = pseq;
	    return SWIG_NEWOBJ;
	  } else {
	    return octseq.check() ? SWIG_OK : SWIG_ERROR;
	  }
	} catch (std::exception& e) {
	  if (seq&&!error_state)
	    error("swig type error: %s",e.what());
	  return SWIG_ERROR;
	}
      }
      return SWIG_ERROR;
    }
  };

  template <class Seq, class T = typename Seq::value_type >
  struct traits_from_stdseq {
    typedef Seq sequence;
    typedef T value_type;
    typedef typename Seq::size_type size_type;
    typedef typename sequence::const_iterator const_iterator;

    static octave_value from(const sequence& seq) {






      size_type size = seq.size();
      if (size <= (size_type)INT_MAX) {
	Cell c(size,1);
	int i = 0;
	for (const_iterator it = seq.begin();
	     it != seq.end(); ++it, ++i) {
	  c(i) = swig::from<value_type>(*it);
	}
	return c;
      } else {
	error("swig overflow error: sequence size not valid in octave");
	return octave_value();
      }
      return octave_value();
    }
  };
}


  namespace swig {
    template <class T>
    struct traits_asptr<std::vector<T> >  {
      static int asptr(const octave_value& obj, std::vector<T> **vec) {
	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
      }
    };
    
    template <class T>
    struct traits_from<std::vector<T> > {
      static octave_value from(const std::vector<T>& vec) {
	return traits_from_stdseq<std::vector<T> >::from(vec);
      }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<float, std::allocator< float > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "float" "," "std::allocator< float >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< float >::value_type std_vector_Sl_float_Sg__pop(std::vector< float > *self){
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      std::vector<float,std::allocator< float > >::value_type x = self->back();
      self->pop_back();
      return x;
    }
SWIGINTERN std::vector< float >::value_type std_vector_Sl_float_Sg____paren__(std::vector< float > *self,std::vector< float >::difference_type i){
      return *(swig::cgetpos(self, i));
    }
SWIGINTERN void std_vector_Sl_float_Sg____paren_asgn__(std::vector< float > *self,std::vector< float >::difference_type i,std::vector< float >::value_type x){
      *(swig::getpos(self,i)) = x;
    }
SWIGINTERN void std_vector_Sl_float_Sg__append(std::vector< float > *self,std::vector< float >::value_type x){
      self->push_back(x);
    }

  SWIGINTERNINLINE octave_value SWIG_From_unsigned_SS_long    (unsigned long value)
    {    
      return octave_value(value);
    }


SWIGINTERNINLINE octave_value
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  ((unsigned long)(value));
}


  namespace swig {
    template <>  struct traits<CvPoint > {
      typedef pointer_category category;
      static const char* type_name() { return"CvPoint"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<CvPoint, std::allocator< CvPoint > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "CvPoint" "," "std::allocator< CvPoint >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< CvPoint >::value_type std_vector_Sl_CvPoint_Sg__pop(std::vector< CvPoint > *self){
      if (self->size() == 0)
	throw std::out_of_range("pop from empty container");
      std::vector<CvPoint,std::allocator< CvPoint > >::value_type x = self->back();
      self->pop_back();
      return x;
    }
SWIGINTERN std::vector< CvPoint >::value_type std_vector_Sl_CvPoint_Sg____paren__(std::vector< CvPoint > *self,std::vector< CvPoint >::difference_type i){
      return *(swig::cgetpos(self, i));
    }
SWIGINTERN void std_vector_Sl_CvPoint_Sg____paren_asgn__(std::vector< CvPoint > *self,std::vector< CvPoint >::difference_type i,std::vector< CvPoint >::value_type x){
      *(swig::getpos(self,i)) = x;
    }
SWIGINTERN void std_vector_Sl_CvPoint_Sg__append(std::vector< CvPoint > *self,std::vector< CvPoint >::value_type x){
      self->push_back(x);
    }

#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERN int
SWIG_AsVal_int (octave_value obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (int)(v);
    }
  }  
  return res;
}


#include "cxtypes.h"
#include "cxcore.h"
#include "cvtypes.h"
#include "cv.h"


SWIGINTERNINLINE octave_value
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


#include <stdlib.h>


CvMat * cvCreateImageMat( CvSize size, int depth, int channels ){
    static const signed char icvDepthToType[]=
    {
        -1, -1, CV_8U, CV_8S, CV_16U, CV_16S, -1, -1,
        CV_32F, CV_32S, -1, -1, -1, -1, -1, -1, CV_64F, -1
    };

	depth = icvDepthToType[((depth & 255) >> 2) + (depth < 0)];
	return cvCreateMat( size.height, size.width, CV_MAKE_TYPE(depth, channels));
}
#define cvCloneImageMat( mat ) cvCloneMat( mat )

#ifdef WIN32

CvModuleInfo *CvModule::first=0;
CvModuleInfo *CvModule::last=0;
CvTypeInfo *CvType::first=0;
CvTypeInfo *CvType::last=0;

#endif



SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERNINLINE octave_value
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  return std::string(carray,carray+size);
}


SWIGINTERNINLINE octave_value 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (octave_value obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = (unsigned int)(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE octave_value
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}

SWIGINTERN void delete_IplImage(IplImage *self){ IplImage       * dummy = self; cvReleaseImage              (& dummy); }
SWIGINTERN IplImage *IplImage_operator_Sa___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
		cvAdd(self, src, res);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sm___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
		cvMul(self, src, res);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Ss___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
		cvSub(self, src, res);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sd___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
		cvDiv(self, src, res);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sx___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
		cvXor(self, src, res);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sa___SWIG_1(IplImage *self,CvScalar val){
		IplImage * res = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
		cvAddS(self, val, res);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sx___SWIG_1(IplImage *self,CvScalar val){
		IplImage * res = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
		cvXorS(self, val, res);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Ss___SWIG_1(IplImage *self,CvScalar val){
		IplImage * res = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
		cvSubS(self, val, res);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sg__Se___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmp(self, src, res, 2);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sg__Se___SWIG_1(IplImage *self,double val){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmpS(self, val, res, 2);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Se__Se___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmp(self, src, res, 0);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Se__Se___SWIG_1(IplImage *self,double val){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmpS(self, val, res, 0);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sl__Se___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmp(self, src, res, 4);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sl__Se___SWIG_1(IplImage *self,double val){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmpS(self, val, res, 4);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_SN__Se___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmp(self, src, res, 5);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_SN__Se___SWIG_1(IplImage *self,double val){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmpS(self, val, res, 5);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sl___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmp(self, src, res, 3);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sl___SWIG_1(IplImage *self,double val){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmpS(self, val, res, 3);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sg___SWIG_0(IplImage *self,CvArr *src){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmp(self, src, res, 1);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sg___SWIG_1(IplImage *self,double val){
		IplImage * res = cvCreateImage(cvGetSize(self), 8, 1);
		cvCmpS(self, val, res, 1);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sm___SWIG_1(IplImage *self,double val){
		IplImage * res = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
		cvConvertScale(self, res, val);
		return res;
	}
SWIGINTERN IplImage *IplImage_operator_Sd___SWIG_1(IplImage *self,double val){
		IplImage * res = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
		cvConvertScale(self, res, 1.0/val);
		return res;
	}
SWIGINTERN IplImage *IplImage___radd____SWIG_0(IplImage *self,CvArr *arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvAdd(self, arg, retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___rsub____SWIG_0(IplImage *self,CvArr *arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvSub(arg, self, retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___rdiv____SWIG_0(IplImage *self,CvArr *arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvDiv(arg, self, retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___rmul____SWIG_0(IplImage *self,CvArr *arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvMatMul(arg, self, retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___radd____SWIG_1(IplImage *self,CvScalar arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvAddS(self, arg, retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___radd____SWIG_2(IplImage *self,double arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvAddS(self, cvScalar(arg), retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___rsub____SWIG_1(IplImage *self,CvScalar arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvSubRS(self, arg, retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___rsub____SWIG_2(IplImage *self,double arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvSubRS(self, cvScalar(arg), retarg);
    return retarg;
  }
SWIGINTERN CvArr *IplImage___rmul____SWIG_1(IplImage *self,double arg){
    CvArr * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvConvertScale(self, retarg, arg);
    return retarg;
  }
SWIGINTERN CvArr *IplImage___rdiv____SWIG_1(IplImage *self,double arg){
    CvArr * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvConvertScale(self, retarg, 1.0/arg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___ror____SWIG_0(IplImage *self,CvScalar arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvOrS(self, arg, retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___ror____SWIG_1(IplImage *self,double arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvOrS(self, cvScalar(arg), retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___rand____SWIG_0(IplImage *self,CvScalar arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvAndS(self, arg, retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___rand____SWIG_1(IplImage *self,double arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvAndS(self, cvScalar(arg), retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___rxor____SWIG_0(IplImage *self,CvScalar arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvXorS(self, arg, retarg);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___rxor____SWIG_1(IplImage *self,double arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvXorS(self, cvScalar(arg), retarg);
    return retarg;
  }
SWIGINTERN CvArr *IplImage___req__(IplImage *self,double arg){
    CvArr * retarg = cvCreateImage(cvGetSize(self), 8, 1);
    cvCmpS(self, arg, retarg, 0);
    return retarg;
  }
SWIGINTERN CvArr *IplImage___rgt__(IplImage *self,double arg){
    CvArr * retarg = cvCreateImage(cvGetSize(self), 8, 1);
    cvCmpS(self, arg, retarg, 1);
    return retarg;
  }
SWIGINTERN CvArr *IplImage___rge__(IplImage *self,double arg){
    CvArr * retarg = cvCreateImage(cvGetSize(self), 8, 1);
    cvCmpS(self, arg, retarg, 2);
    return retarg;
  }
SWIGINTERN CvArr *IplImage___rlt__(IplImage *self,double arg){
    CvArr * retarg = cvCreateImage(cvGetSize(self), 8, 1);
    cvCmpS(self, arg, retarg, 3);
    return retarg;
  }
SWIGINTERN CvArr *IplImage___rle__(IplImage *self,double arg){
    CvArr * retarg = cvCreateImage(cvGetSize(self), 8, 1);
    cvCmpS(self, arg, retarg, 4);
    return retarg;
  }
SWIGINTERN CvArr *IplImage___rne__(IplImage *self,double arg){
    CvArr * retarg = cvCreateImage(cvGetSize(self), 8, 1);
    cvCmpS(self, arg, retarg, 5);
    return retarg;
  }
SWIGINTERN IplImage *IplImage___pow__(IplImage *self,double arg){
    IplImage * retarg = cvCreateImage(cvGetSize(self), self->depth, self->nChannels);
    cvPow(self, retarg, arg);
    return retarg;
  }
SWIGINTERN char *IplImage___str(IplImage *self){
    static char str[8];
    cvArrPrint( self );
    str[0]=0;
    return str;
    return "";
  }
SWIGINTERN void IplImage___paren_asgn__SWIG_0(IplImage *self,octave_value object,double val){
    CvMat tmp;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    cvGetSubRect(self, &tmp, subrect);
    cvSet(&tmp, cvScalarAll(val));
  }
SWIGINTERN void IplImage___paren_asgn__SWIG_1(IplImage *self,octave_value object,CvPoint val){
    CvMat tmp;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    cvGetSubRect(self, &tmp, subrect);
    cvSet(&tmp, cvScalar(val.x, val.y));
  }
SWIGINTERN void IplImage___paren_asgn__SWIG_2(IplImage *self,octave_value object,CvPoint2D32f val){
    CvMat tmp;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    cvGetSubRect(self, &tmp, subrect);
    cvSet(&tmp, cvScalar(val.x, val.y));
  }
SWIGINTERN void IplImage___paren_asgn__SWIG_3(IplImage *self,octave_value object,CvScalar val){
    CvMat tmp;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    cvGetSubRect(self, &tmp, subrect);
    cvSet(&tmp, val);
  }
SWIGINTERN void IplImage___paren_asgn__SWIG_4(IplImage *self,octave_value object,CvArr *arr){
    CvMat tmp;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    cvGetSubRect(self, &tmp, subrect);
    cvConvert(arr, &tmp);
  }
SWIGINTERN octave_value IplImage___paren(IplImage *self,octave_value object){
    CvMat mat;
    IplImage * im;
    CvRect subrect = OctSlice_to_CvRect( self, object );

    // return scalar if single element
    if(subrect.width==1 && subrect.height==1){
      CvScalar * s;
      int type = cvGetElemType( self );
      if(CV_MAT_CN(type) > 1){
	s = new CvScalar;
	*s = cvGet2D( self, subrect.y, subrect.x );
	return SWIG_NewPointerObj( s, SWIGTYPE_p_CvScalar, 1 );
      }
      switch(((type) & ((1 << 3) - 1))){
      case 0:
	return OctLong_FromUnsignedLong( CV_IMAGE_ELEM(self, uchar, subrect.y, subrect.x ) );
      case 1:
	return OctLong_FromLong( CV_IMAGE_ELEM(self, char, subrect.y, subrect.x ) );
      case 2:
	return OctLong_FromUnsignedLong( CV_IMAGE_ELEM(self, ushort, subrect.y, subrect.x ) );
      case 3:
	return OctLong_FromLong( CV_IMAGE_ELEM(self, short, subrect.y, subrect.x ) );
      case 4:
	return OctLong_FromLong( CV_IMAGE_ELEM(self, int, subrect.y, subrect.x ) );
      case 5:
	return OctFloat_FromDouble( CV_IMAGE_ELEM(self, float, subrect.y, subrect.x) );
      case 6:
	return OctFloat_FromDouble( CV_IMAGE_ELEM(self, double, subrect.y, subrect.x) );
      }
    }

    // otherwise return array
    im = (IplImage *) cvAlloc(sizeof(IplImage));
    cvGetSubRect(self, &mat, subrect);
    im = cvGetImage(&mat, im);
    return SWIG_NewPointerObj( im, SWIGTYPE_p__IplImage, 1 );
  }
SWIGINTERN void delete_IplConvKernel(IplConvKernel *self){ IplConvKernel  * dummy = self; cvReleaseStructuringElement (& dummy); }

typedef union {
        uchar* ptr;
        short* s;
        int* i;
        float* fl;
        double* db;
    } CvMat_data;


SWIGINTERN void delete_CvMat(CvMat *self){ CvMat          * dummy = self; cvReleaseMat                (& dummy); }
SWIGINTERN CvMat *CvMat_operator_Sa___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, self->type);
		cvAdd(self, src, res);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sm___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, self->type);
		cvMul(self, src, res);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Ss___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, self->type);
		cvSub(self, src, res);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sd___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, self->type);
		cvDiv(self, src, res);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sx___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, self->type);
		cvXor(self, src, res);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sa___SWIG_1(CvMat *self,CvScalar val){
		CvMat * res = cvCreateMat(self->rows, self->cols, self->type);
		cvAddS(self, val, res);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sx___SWIG_1(CvMat *self,CvScalar val){
		CvMat * res = cvCreateMat(self->rows, self->cols, self->type);
		cvXorS(self, val, res);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Ss___SWIG_1(CvMat *self,CvScalar val){
		CvMat * res = cvCreateMat(self->rows, self->cols, self->type);
		cvSubS(self, val, res);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sg__Se___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmp(self, src, res, 2);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sg__Se___SWIG_1(CvMat *self,double val){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmpS(self, val, res, 2);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Se__Se___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmp(self, src, res, 0);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Se__Se___SWIG_1(CvMat *self,double val){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmpS(self, val, res, 0);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sl__Se___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmp(self, src, res, 4);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sl__Se___SWIG_1(CvMat *self,double val){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmpS(self, val, res, 4);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_SN__Se___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmp(self, src, res, 5);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_SN__Se___SWIG_1(CvMat *self,double val){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmpS(self, val, res, 5);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sl___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmp(self, src, res, 3);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sl___SWIG_1(CvMat *self,double val){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmpS(self, val, res, 3);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sg___SWIG_0(CvMat *self,CvArr *src){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmp(self, src, res, 1);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sg___SWIG_1(CvMat *self,double val){
		CvMat * res = cvCreateMat(self->rows, self->cols, 0);
		cvCmpS(self, val, res, 1);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sm___SWIG_1(CvMat *self,double val){
		CvMat * res = cvCreateMat(self->rows, self->cols, self->type);
		cvConvertScale(self, res, val);
		return res;
	}
SWIGINTERN CvMat *CvMat_operator_Sd___SWIG_1(CvMat *self,double val){
		CvMat * res = cvCreateMat(self->rows, self->cols, self->type);
		cvConvertScale(self, res, 1.0/val);
		return res;
	}
SWIGINTERN CvMat *CvMat___radd____SWIG_0(CvMat *self,CvArr *arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvAdd(self, arg, retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___rsub____SWIG_0(CvMat *self,CvArr *arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvSub(arg, self, retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___rdiv____SWIG_0(CvMat *self,CvArr *arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvDiv(arg, self, retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___rmul____SWIG_0(CvMat *self,CvArr *arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvMatMul(arg, self, retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___radd____SWIG_1(CvMat *self,CvScalar arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvAddS(self, arg, retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___radd____SWIG_2(CvMat *self,double arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvAddS(self, cvScalar(arg), retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___rsub____SWIG_1(CvMat *self,CvScalar arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvSubRS(self, arg, retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___rsub____SWIG_2(CvMat *self,double arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvSubRS(self, cvScalar(arg), retarg);
    return retarg;
  }
SWIGINTERN CvArr *CvMat___rmul____SWIG_1(CvMat *self,double arg){
    CvArr * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvConvertScale(self, retarg, arg);
    return retarg;
  }
SWIGINTERN CvArr *CvMat___rdiv____SWIG_1(CvMat *self,double arg){
    CvArr * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvConvertScale(self, retarg, 1.0/arg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___ror____SWIG_0(CvMat *self,CvScalar arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvOrS(self, arg, retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___ror____SWIG_1(CvMat *self,double arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvOrS(self, cvScalar(arg), retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___rand____SWIG_0(CvMat *self,CvScalar arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvAndS(self, arg, retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___rand____SWIG_1(CvMat *self,double arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvAndS(self, cvScalar(arg), retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___rxor____SWIG_0(CvMat *self,CvScalar arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvXorS(self, arg, retarg);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___rxor____SWIG_1(CvMat *self,double arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvXorS(self, cvScalar(arg), retarg);
    return retarg;
  }
SWIGINTERN CvArr *CvMat___req__(CvMat *self,double arg){
    CvArr * retarg = cvCreateMat(self->rows, self->cols, 0);
    cvCmpS(self, arg, retarg, 0);
    return retarg;
  }
SWIGINTERN CvArr *CvMat___rgt__(CvMat *self,double arg){
    CvArr * retarg = cvCreateMat(self->rows, self->cols, 0);
    cvCmpS(self, arg, retarg, 1);
    return retarg;
  }
SWIGINTERN CvArr *CvMat___rge__(CvMat *self,double arg){
    CvArr * retarg = cvCreateMat(self->rows, self->cols, 0);
    cvCmpS(self, arg, retarg, 2);
    return retarg;
  }
SWIGINTERN CvArr *CvMat___rlt__(CvMat *self,double arg){
    CvArr * retarg = cvCreateMat(self->rows, self->cols, 0);
    cvCmpS(self, arg, retarg, 3);
    return retarg;
  }
SWIGINTERN CvArr *CvMat___rle__(CvMat *self,double arg){
    CvArr * retarg = cvCreateMat(self->rows, self->cols, 0);
    cvCmpS(self, arg, retarg, 4);
    return retarg;
  }
SWIGINTERN CvArr *CvMat___rne__(CvMat *self,double arg){
    CvArr * retarg = cvCreateMat(self->rows, self->cols, 0);
    cvCmpS(self, arg, retarg, 5);
    return retarg;
  }
SWIGINTERN CvMat *CvMat___pow__(CvMat *self,double arg){
    CvMat * retarg = cvCreateMat(self->rows, self->cols, self->type);
    cvPow(self, retarg, arg);
    return retarg;
  }
SWIGINTERN char *CvMat___str(CvMat *self){
    static char str[8];
    cvArrPrint( self );
    str[0]=0;
    return str;
    return "";
  }
SWIGINTERN void CvMat___paren_asgn__SWIG_0(CvMat *self,octave_value object,double val){
    CvMat tmp;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    /*@SWIG:./cvarr.i,206,CHECK_SLICE_BOUNDS@*/
     //printf("__setitem__ slice(%d:%d, %d:%d) array(%d,%d)", subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
     if(subrect.width<=0 || subrect.height<=0 ||
	subrect.width>self->cols || subrect.height>self->rows ||
	subrect.x<0 || subrect.y<0 ||
	subrect.x>= self->cols || subrect.y >=self->rows){
       char errstr[256];
       // previous function already set error string
       if(subrect.width==0 && subrect.height==0 && subrect.x==0 && subrect.y==0) return ;
       sprintf(errstr, "Requested slice [ %d:%d %d:%d ] oversteps array sized [ %d %d ]", 
	       subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
       error(errstr);
       return ;
     }
else{}
/*@SWIG@*/;
    cvGetSubRect(self, &tmp, subrect);
    cvSet(&tmp, cvScalarAll(val));
  }
SWIGINTERN void CvMat___paren_asgn__SWIG_1(CvMat *self,octave_value object,CvPoint val){
    CvMat tmp;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    /*@SWIG:./cvarr.i,206,CHECK_SLICE_BOUNDS@*/
     //printf("__setitem__ slice(%d:%d, %d:%d) array(%d,%d)", subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
     if(subrect.width<=0 || subrect.height<=0 ||
	subrect.width>self->cols || subrect.height>self->rows ||
	subrect.x<0 || subrect.y<0 ||
	subrect.x>= self->cols || subrect.y >=self->rows){
       char errstr[256];
       // previous function already set error string
       if(subrect.width==0 && subrect.height==0 && subrect.x==0 && subrect.y==0) return ;
       sprintf(errstr, "Requested slice [ %d:%d %d:%d ] oversteps array sized [ %d %d ]", 
	       subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
       error(errstr);
       return ;
     }
else{}
/*@SWIG@*/;
    cvGetSubRect(self, &tmp, subrect);
    cvSet(&tmp, cvScalar(val.x, val.y));
  }
SWIGINTERN void CvMat___paren_asgn__SWIG_2(CvMat *self,octave_value object,CvPoint2D32f val){
    CvMat tmp;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    cvGetSubRect(self, &tmp, subrect);
    /*@SWIG:./cvarr.i,206,CHECK_SLICE_BOUNDS@*/
     //printf("__setitem__ slice(%d:%d, %d:%d) array(%d,%d)", subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
     if(subrect.width<=0 || subrect.height<=0 ||
	subrect.width>self->cols || subrect.height>self->rows ||
	subrect.x<0 || subrect.y<0 ||
	subrect.x>= self->cols || subrect.y >=self->rows){
       char errstr[256];
       // previous function already set error string
       if(subrect.width==0 && subrect.height==0 && subrect.x==0 && subrect.y==0) return ;
       sprintf(errstr, "Requested slice [ %d:%d %d:%d ] oversteps array sized [ %d %d ]", 
	       subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
       error(errstr);
       return ;
     }
else{}
/*@SWIG@*/;
    cvSet(&tmp, cvScalar(val.x, val.y));
  }
SWIGINTERN void CvMat___paren_asgn__SWIG_3(CvMat *self,octave_value object,CvScalar val){
    CvMat tmp;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    cvGetSubRect(self, &tmp, subrect);
    /*@SWIG:./cvarr.i,206,CHECK_SLICE_BOUNDS@*/
     //printf("__setitem__ slice(%d:%d, %d:%d) array(%d,%d)", subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
     if(subrect.width<=0 || subrect.height<=0 ||
	subrect.width>self->cols || subrect.height>self->rows ||
	subrect.x<0 || subrect.y<0 ||
	subrect.x>= self->cols || subrect.y >=self->rows){
       char errstr[256];
       // previous function already set error string
       if(subrect.width==0 && subrect.height==0 && subrect.x==0 && subrect.y==0) return ;
       sprintf(errstr, "Requested slice [ %d:%d %d:%d ] oversteps array sized [ %d %d ]", 
	       subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
       error(errstr);
       return ;
     }
else{}
/*@SWIG@*/;
    cvSet(&tmp, val);
  }
SWIGINTERN void CvMat___paren_asgn__SWIG_4(CvMat *self,octave_value object,CvArr *arr){
    CvMat tmp, src_stub, *src;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    /*@SWIG:./cvarr.i,206,CHECK_SLICE_BOUNDS@*/
     //printf("__setitem__ slice(%d:%d, %d:%d) array(%d,%d)", subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
     if(subrect.width<=0 || subrect.height<=0 ||
	subrect.width>self->cols || subrect.height>self->rows ||
	subrect.x<0 || subrect.y<0 ||
	subrect.x>= self->cols || subrect.y >=self->rows){
       char errstr[256];
       // previous function already set error string
       if(subrect.width==0 && subrect.height==0 && subrect.x==0 && subrect.y==0) return ;
       sprintf(errstr, "Requested slice [ %d:%d %d:%d ] oversteps array sized [ %d %d ]", 
	       subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
       error(errstr);
       return ;
     }
else{}
/*@SWIG@*/;
    cvGetSubRect(self, &tmp, subrect);

    // Reshape source array to fit destination
    // This will be used a lot for small arrays b/c
    // OctObject_to_CvArr tries to compress a 2-D octave
    // array with 1-4 columns into a multichannel vector
    src=cvReshape(arr, &src_stub, CV_MAT_CN(tmp.type), tmp.rows);

    cvConvert(src, &tmp);
  }
SWIGINTERN octave_value CvMat___paren(CvMat *self,octave_value object){
    CvMat * mat;
    CvRect subrect = OctSlice_to_CvRect( self, object );
    /*@SWIG:./cvarr.i,206,CHECK_SLICE_BOUNDS@*/
     //printf("__setitem__ slice(%d:%d, %d:%d) array(%d,%d)", subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
     if(subrect.width<=0 || subrect.height<=0 ||
	subrect.width>self->cols || subrect.height>self->rows ||
	subrect.x<0 || subrect.y<0 ||
	subrect.x>= self->cols || subrect.y >=self->rows){
       char errstr[256];
       // previous function already set error string
       if(subrect.width==0 && subrect.height==0 && subrect.x==0 && subrect.y==0) return octave_value();
       sprintf(errstr, "Requested slice [ %d:%d %d:%d ] oversteps array sized [ %d %d ]", 
	       subrect.x, subrect.y, subrect.x+subrect.width, subrect.y+subrect.height, self->cols, self->rows);
       error(errstr);
       return octave_value();
     }
else{}
/*@SWIG@*/;
    if(subrect.width==1 && subrect.height==1){
      CvScalar * s; 
      int type = cvGetElemType( self );
      if(CV_MAT_CN(type) > 1){
	s = new CvScalar; 
	*s = cvGet2D( self, subrect.y, subrect.x );
	return SWIG_NewPointerObj( s, SWIGTYPE_p_CvScalar, 1 );
      }
      switch(((type) & ((1 << 3) - 1))){
      case 0:
	return OctLong_FromUnsignedLong( CV_MAT_ELEM(*self, uchar, subrect.y, subrect.x ) );
      case 1:
	return OctLong_FromLong( CV_MAT_ELEM(*self, char, subrect.y, subrect.x ) );
      case 2:
	return OctLong_FromUnsignedLong( CV_MAT_ELEM(*self, ushort, subrect.y, subrect.x ) );
      case 3:
	return OctLong_FromLong( CV_MAT_ELEM(*self, short, subrect.y, subrect.x ) );
      case 4:
	return OctLong_FromLong( CV_MAT_ELEM(*self, int, subrect.y, subrect.x ) );
      case 5:
	return OctFloat_FromDouble( CV_MAT_ELEM(*self, float, subrect.y, subrect.x) );
      case 6:
	return OctFloat_FromDouble( CV_MAT_ELEM(*self, double, subrect.y, subrect.x) );
      }
    }
    mat = (CvMat *) cvAlloc(sizeof(CvMat));
    cvGetSubRect(self, mat, subrect);
		
    // cvGetSubRect doesn't do this since it assumes mat lives on the stack
    mat->hdr_refcount = self->hdr_refcount;
    mat->refcount = self->refcount;
    cvIncRefData(mat);

    return SWIG_NewPointerObj( mat, SWIGTYPE_p_CvMat, 1 );
  }

typedef struct {
        int size;
        int step;
    } CvMatND_dim;



typedef union {
        uchar* ptr;
        float* fl;
        double* db;
        int* i;
        short* s;
    } CvMatND_data;


SWIGINTERN void delete_CvMatND(CvMatND *self){ CvMatND        * dummy = self; cvReleaseMatND              (& dummy); }
SWIGINTERN void delete_CvSparseMat(CvSparseMat *self){ CvSparseMat    * dummy = self; cvReleaseSparseMat          (& dummy); }
SWIGINTERN void delete_CvHistogram(CvHistogram *self){ CvHistogram    * dummy = self; cvReleaseHist               (& dummy); }
SWIGINTERN char const *CvPoint___str__(CvPoint *self){
		static char str[64];
		snprintf(str, 64, "[%d %d]", self->x, self->y);
		return str;
	}
SWIGINTERN char const *CvPoint___repr__(CvPoint *self){
		static char str[64];
		snprintf(str, 64, "cvPoint(%d,%d)", self->x, self->y);
		return str;
	}
SWIGINTERN char const *CvPoint2D32f___str__(CvPoint2D32f *self){
		static char str[64];
		snprintf(str, 64, "[%f %f]", self->x, self->y);
		return str;
	}
SWIGINTERN char const *CvPoint2D32f___repr__(CvPoint2D32f *self){
		static char str[64];
		snprintf(str, 64, "cvPoint2D32f(%f,%f)", self->x, self->y);
		return str;
	}
SWIGINTERN char const *CvScalar___str__(CvScalar *self){
		static char str[256];
		snprintf(str, 256, "[%f, %f, %f, %f]", self->val[0], self->val[1], self->val[2], self->val[3]);
		return str;
	}
SWIGINTERN char const *CvScalar___repr__(CvScalar *self){
		static char str[256];
		snprintf(str, 256, "cvScalar(%f, %f, %f, %f)", self->val[0], self->val[1], self->val[2], self->val[3]);
		return str;
	}
SWIGINTERN double const CvScalar___getitem__(CvScalar *self,int index){
        if (index >= 4) {



            error("indice must be lower than 4");

            return 0;
        }
        if (index < -4) {



	    error("indice must be bigger or egal to -4");

            return 0;
        }
        if (index < 0) {
            /* negative index means from the end in python */
            index = 4 - index;
        }
        return self->val [index];
    }
SWIGINTERN void CvScalar___setitem__(CvScalar *self,int index,double value){
        if (index >= 4) {



	    error("indice must be lower than 4");

            return;
        }
        if (index < -4) {



	    error("indice must be bigger or egal to -4");

            return;
        }
        if (index < 0) {
            /* negative index means from the end in python */
            index = 4 - index;
        }
        self->val [index] = value;
    }
SWIGINTERN void delete_CvMemStorage(CvMemStorage *self){ CvMemStorage   * dummy = self; cvReleaseMemStorage         (& dummy); }

SWIGINTERN int
SWIG_AsCharPtrAndSize(octave_value ov, char** cptr, size_t* psize, int *alloc)
{
  if (ov.is_cell() && ov.rows() == 1 && ov.columns() == 1)
    ov = ov.cell_value()(0);
  if (!ov.is_string())
    return SWIG_TypeError;
  
  std::string str=ov.string_value();
  size_t len=str.size();
  char* cstr=(char*)str.c_str();
  if (alloc) {
    *cptr = (char*)(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
    *alloc = SWIG_NEWOBJ;
  } else if (cptr)
    *cptr = cstr;
  if (psize)
    *psize = len + 1;
  return SWIG_OK;
}





typedef union {
        double f;
        int i;
        CvString str;
        CvSeq* seq;
        CvFileNodeHash* map;
    } CvFileNode_data;


SWIGINTERN void delete_CvGraphScanner(CvGraphScanner *self){ CvGraphScanner * dummy = self; cvReleaseGraphScanner       (& dummy); }

SWIGINTERN int
SWIG_AsVal_bool (const octave_value& ov, bool *val)
{
  if (!ov.is_bool_type())
    return SWIG_ERROR;
  if (val)
    *val = ov.bool_value();
  return SWIG_OK;
}


SWIGINTERN int
SWIG_AsCharArray(octave_value obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (octave_value obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = (char)(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE octave_value
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}

SWIGINTERN CvTypedSeq< CvQuadEdge2D > *CvSubdiv2D_typed_edges_get(CvSubdiv2D *self){
    return (CvTypedSeq<CvQuadEdge2D> *) self->edges;
  }
SWIGINTERN void CvSubdiv2D_typed_edges_set(CvSubdiv2D *self,CvTypedSeq< CvQuadEdge2D > *){
  }
SWIGINTERN void delete_CvConDensation(CvConDensation *self){ CvConDensation * dummy = self; cvReleaseConDensation       (& dummy); }
SWIGINTERN void delete_CvKalman(CvKalman *self){ CvKalman       * dummy = self; cvReleaseKalman             (& dummy); }

typedef struct {
        CvRect r;
        float weight;
    } CvHaarFeature_rect;


SWIGINTERN void delete_CvHaarClassifierCascade(CvHaarClassifierCascade *self){ CvHaarClassifierCascade * dummy = self; cvReleaseHaarClassifierCascade  (& dummy); }
SWIGINTERN void delete_CvLSH(CvLSH *self){ CvLSH          * dummy = self; cvReleaseLSH                (& dummy); }

int CvMat_cols_get(CvMat * m){
	return m->cols;
}
void CvMat_cols_set(CvMat * m, int cols){
    m->cols = cols;
}
int CvMat_rows_get(CvMat *m){
	return m->rows;
}
void CvMat_rows_set(CvMat *m, int rows){
    m->rows = rows;
}
int CvMat_width_get(CvMat * m){
	return m->cols;
}
void CvMat_width_set(CvMat * m, int width){
    m->cols = width;
}
int CvMat_height_get(CvMat *m){
	return m->rows;
}
void CvMat_height_set(CvMat * m, int height){
    m->rows = height;
}
int CvMat_depth_get(CvMat * m){
	return cvIplDepth(m->type);
}
void CvMat_depth_set(CvMat *m, int depth){
    cvError(CV_StsNotImplemented, "CvMat_depth_set", "Not Implemented", __FILE__, __LINE__);
}
int CvMat_nChannels_get(CvMat * m){
	return CV_MAT_CN(m->type);
}
void CvMat_nChannels_set(CvMat *m, int nChannels){
    int depth = CV_MAT_DEPTH(m->type);
    m->type = CV_MAKETYPE(depth, nChannels);
}
int CvMat_origin_get(CvMat * m){
    /* Always 0 - top-left origin */
    return 0;
}
void CvMat_origin_set(CvMat * m, int origin){
    cvError(CV_StsNotImplemented, "CvMat_origin_get", "IplImage is replaced by CvMat in Python, so its fields are read-only", __FILE__, __LINE__);
}
int CvMat_dataOrder_get(CvMat * m){
    cvError(CV_StsNotImplemented, "CvMat_dataOrder_get", "Not Implemented", __FILE__, __LINE__);
    return 0;
}
void CvMat_dataOrder_set(CvMat * m, int dataOrder){
    cvError(CV_StsNotImplemented, "CvMat_dataOrder_get", "IplImage is replaced by CvMat in Python, so its fields are read-only", __FILE__, __LINE__);
}
int CvMat_imageSize_get(CvMat * m){
	int step = m->step ? m->step : CV_ELEM_SIZE(m->type) * m->cols;
	return step*m->rows;
}
void CvMat_imageSize_set(CvMat * m, int imageSize){
    cvError(CV_StsNotImplemented, "CvMat_imageSize_set", "IplImage is not implemented in Python, so origin is read-only", __FILE__, __LINE__);
}
int CvMat_widthStep_get(CvMat * m){
	return m->step;
}
void CvMat_widthStep_set(CvMat *m, int widthStep){
    m->step = widthStep;
}



/// Accessor to convert a Octave string into the imageData.
void CvMat_imageData_set(CvMat * self, octave_value object)
{
  /*
  char* oct_string = OctString_AsString(object);
	int depth = CV_MAT_DEPTH(self->type);
	int cn = CV_MAT_CN(self->type);

	if (depth == CV_8U && cn==3){
		// RGB case
		// The data is reordered beause OpenCV uses BGR instead of RGB

		for (long line = 0; line < self->rows; ++line)
			for (long pixel = 0; pixel < self->cols; ++pixel)
			{
				// In OpenCV the beginning of the lines are aligned
				// to 4 Bytes. So use step instead of cols.
				long position = line*self->step + pixel*3;
				long sourcepos = line*self->cols*3 + pixel*3;
				self->data.ptr[position  ] = oct_string[sourcepos+2];
				self->data.ptr[position+1] = oct_string[sourcepos+1];
				self->data.ptr[position+2] = oct_string[sourcepos  ];
			}
	}
	else if (depth == CV_8U && cn==1)
	{
		// Grayscale 8bit case

		for (long line = 0; line < self->rows; ++line)
		{
			// In OpenCV the beginning of the lines are aligned
			// to 4 Bytes. So use step instead of cols.
			memcpy
				(
				 self->data.ptr + line*self->step,
				 oct_string + line*self->cols,
				 self->step
				);
		}
	}
	else if ( depth == CV_32F )
	{
		// float (32bit) case
		for (long line = 0; line < self->rows; ++line)
		{
			// here we don not have to care about alignment as the Floats are
			// as long as the alignment
			memcpy
				(
				 self->data.ptr + line*self->step,
				 oct_string + line*self->cols*sizeof(float),
				 self->step
				);
		}
	}
	else if ( depth == CV_64F )
	{
		// double (64bit) case
		for (long line = 0; line < self->rows; ++line)
		{
			// here we don not have to care about alignment as the Floats are
			// as long as the alignment
			memcpy
				(
				 self->data.ptr + line*self->step,
				 oct_string + line*self->cols*sizeof(double),
				 self->step
				);
		}
	}
	else
	{
	  // make some noise
	  SendErrorToOctave (SWIG_TypeError, 
                       "CvMat_imageData_set", 
                       "cannot convert string data to this image format",
                       __FILE__, __LINE__, NULL);
	}
  */
}

/// Accessor to convert the imageData into a Octave string.
octave_value CvMat_imageData_get(CvMat * self) 
{
  /*
	if (!self->data.ptr)
	{
		OctErr_SetString(OctExc_TypeError, "Data pointer of CvMat is NULL");
		return NULL;
	}		 
	return OctString_FromStringAndSize((const char *)self->data.ptr, self->rows*self->step);
  */
  return octave_value();
}


const char* _wrap_cvGetDimSize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetDimSize (@var{arr}, @var{index})\n\
@var{arr} is of type CvArr. @var{index} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCalcImageHist_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcHist (@var{image}, @var{hist}, @var{accumulate} = 0, @var{mask} = nil)\n\
@var{image} is of type . @var{hist} is of type CvHistogram. @var{accumulate} is of type int. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMatrix_create_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} create (@var{self}, @var{rows}, @var{cols}, @var{type})\n\
@var{self} is of type CvMatrix. @var{rows} is of type int. @var{cols} is of type int. @var{type} is of type int. \n\
@end deftypefn";
const char* _wrap_CvImage_create_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} create (@var{self}, @var{size}, @var{depth}, @var{channels})\n\
@var{self} is of type CvImage. @var{size} is of type CvSize. @var{depth} is of type int. @var{channels} is of type int. \n\
@end deftypefn";
const char* _wrap_cvROIToRect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvROIToRect (@var{roi})\n\
@var{roi} is of type . @var{retval} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_CvImage_height_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = height (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_SEQ_KIND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_SEQ_KIND (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSolve_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSolve (@var{src1}, @var{src2}, @var{dst}, @var{method} = 0)\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. @var{method} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvBoundingRect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvBoundingRect (@var{points}, @var{update} = 0)\n\
@var{points} is of type CvArr. @var{update} is of type int. @var{retval} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_CV_MAT_ELEM_PTR_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_MAT_ELEM_PTR (@var{mat}, @var{row}, @var{col})\n\
@var{mat} is of type CvMat. @var{row} is of type int. @var{col} is of type int. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_CvPointVector_front_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = front (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type value_type. \n\
@end deftypefn";
const char* _wrap_FloatVector_front_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = front (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type value_type. \n\
@end deftypefn";
const char* _wrap_CvMatrix_depth_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = depth (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvReleaseImageHeader_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseImageHeader (@var{image})\n\
@var{image} is of type . \n\
@end deftypefn";
const char* _wrap_cvClearND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvClearND (@var{arr}, @var{idx})\n\
@var{arr} is of type CvArr. @var{idx} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSetHistBinRanges_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetHistBinRanges (@var{hist}, @var{ranges}, @var{uniform} = 1)\n\
@var{hist} is of type CvHistogram. @var{ranges} is of type float. @var{uniform} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSubS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSubS (@var{src}, @var{value}, @var{dst}, @var{mask} = nil)\n\
@var{src} is of type CvArr. @var{value} is of type CvScalar. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvMorphologyEx_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMorphologyEx (@var{src}, @var{dst}, @var{temp}, @var{element}, @var{operation}, @var{iterations} = 1)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{temp} is of type CvArr. @var{element} is of type . @var{operation} is of type int. @var{iterations} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvHaarFeature_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvHaarFeature::CvHaarFeature ()\n\
@var{retval} is of type CvHaarFeature. \n\
@end deftypefn";
const char* _wrap_delete_CvHaarFeature_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvHaarFeature::~CvHaarFeature (@var{self})\n\
@var{self} is of type CvHaarFeature. \n\
@end deftypefn";
const char* _wrap_cvReshape_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvReshape (@var{arr}, @var{header}, @var{new_cn}, @var{new_rows} = 0)\n\
@var{arr} is of type CvArr. @var{header} is of type CvMat. @var{new_cn} is of type int. @var{new_rows} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvConvertScale_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvConvertScale (@var{src}, @var{dst}, @var{scale} = 1, @var{shift} = 0)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{scale} is of type double. @var{shift} is of type double. \n\
@end deftypefn";
const char* _wrap_cvSquareAcc_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSquareAcc (@var{image}, @var{sqsum}, @var{mask} = nil)\n\
@var{image} is of type CvArr. @var{sqsum} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvMaxS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMaxS (@var{src}, @var{value}, @var{dst})\n\
@var{src} is of type CvArr. @var{value} is of type double. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvMatchContourTrees_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMatchContourTrees (@var{tree1}, @var{tree2}, @var{method}, @var{threshold})\n\
@var{tree1} is of type CvContourTree. @var{tree2} is of type CvContourTree. @var{method} is of type int. @var{threshold} is of type double. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_CV_MAT_ELEM_PTR_FAST_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_MAT_ELEM_PTR_FAST (@var{mat}, @var{row}, @var{col}, @var{pix_size})\n\
@var{mat} is of type CvMat. @var{row} is of type int. @var{col} is of type int. @var{pix_size} is of type int. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_cvLUT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvLUT (@var{src}, @var{dst}, @var{lut})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{lut} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvSeqPopFront_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSeqPopFront (@var{seq}, @var{element} = nil)\n\
@var{seq} is of type CvSeq. @var{element} is of type void. \n\
@end deftypefn";
const char* _wrap_cvReshapeMatND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvReshapeMatND (@var{arr}, @var{sizeof_header}, @var{header}, @var{new_cn}, @var{new_dims}, @var{new_sizes})\n\
@var{arr} is of type CvArr. @var{sizeof_header} is of type int. @var{header} is of type CvArr. @var{new_cn} is of type int. @var{new_dims} is of type int. @var{new_sizes} is of type int. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvCloneMatND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCloneMatND (@var{mat})\n\
@var{mat} is of type CvMatND. @var{retval} is of type CvMatND. \n\
@end deftypefn";
const char* _wrap_cvCreateMatND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateMatND (@var{dims}, @var{type})\n\
@var{dims} is of type int. @var{type} is of type int. @var{retval} is of type CvMatND. \n\
@end deftypefn";
const char* _wrap_cvMatMul_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMatMul (@var{src1}, @var{src2}, @var{dst})\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvRQDecomp3x3_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRQDecomp3x3 (@var{matrixM}, @var{matrixR}, @var{matrixQ}, @var{matrixQx} = nil, @var{matrixQy} = nil, @var{matrixQz} = nil, @var{eulerAngles} = nil)\n\
@var{matrixM} is of type CvMat. @var{matrixR} is of type CvMat. @var{matrixQ} is of type CvMat. @var{matrixQx} is of type CvMat. @var{matrixQy} is of type CvMat. @var{matrixQz} is of type CvMat. @var{eulerAngles} is of type CvPoint3D64f. \n\
@end deftypefn";
const char* _wrap_cvGetErrInfo_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetErrInfo (@var{errcode_desc}, @var{description}, @var{filename}, @var{line})\n\
@var{errcode_desc} is of type char. @var{description} is of type char. @var{filename} is of type char. @var{line} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetRectSubPix_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGetRectSubPix (@var{src}, @var{dst}, @var{center})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{center} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_cvFindCornerSubPix_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFindCornerSubPix (@var{image}, @var{corners}, @var{win}, @var{zero_zone}, @var{criteria})\n\
@var{image} is of type CvArr. @var{corners} is of type CvPoint2D32f. @var{win} is of type CvSize. @var{zero_zone} is of type CvSize. @var{criteria} is of type CvTermCriteria. \n\
@end deftypefn";
const char* _wrap_cvSeqPushFront_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSeqPushFront (@var{seq}, @var{element} = nil)\n\
@var{seq} is of type CvSeq. @var{element} is of type void. @var{retval} is of type schar. \n\
@end deftypefn";
const char* _wrap_cvSmooth_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSmooth (@var{src}, @var{dst}, @var{smoothtype} = 2, @var{size1} = 3, @var{size2} = 0, @var{sigma1} = 0, @var{sigma2} = 0)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{smoothtype} is of type int. @var{size1} is of type int. @var{size2} is of type int. @var{sigma1} is of type double. @var{sigma2} is of type double. \n\
@end deftypefn";
const char* _wrap_new_CvSubdiv2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSubdiv2D::CvSubdiv2D ()\n\
@var{retval} is of type CvSubdiv2D. \n\
@end deftypefn";
const char* _wrap_delete_CvSubdiv2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSubdiv2D::~CvSubdiv2D (@var{self})\n\
@var{self} is of type CvSubdiv2D. \n\
@end deftypefn";
const char* _wrap_cvCreateSubdiv2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateSubdiv2D (@var{subdiv_type}, @var{header_size}, @var{vtx_size}, @var{quadedge_size}, @var{storage})\n\
@var{subdiv_type} is of type int. @var{header_size} is of type int. @var{vtx_size} is of type int. @var{quadedge_size} is of type int. @var{storage} is of type CvMemStorage. @var{retval} is of type CvSubdiv2D. \n\
@end deftypefn";
const char* _wrap_cvSetErrMode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSetErrMode (@var{mode})\n\
@var{mode} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetErrMode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetErrMode ()\n\
@var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGraphVtxDegree_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphVtxDegree (@var{graph}, @var{vtx_idx})\n\
@var{graph} is of type CvGraph. @var{vtx_idx} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_IplImage___rle___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rle__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMat___rle___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rle__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvPrevTreeNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPrevTreeNode (@var{tree_iterator})\n\
@var{tree_iterator} is of type CvTreeNodeIterator. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_cvNextTreeNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvNextTreeNode (@var{tree_iterator})\n\
@var{tree_iterator} is of type CvTreeNodeIterator. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_cvKMeans2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvKMeans2 (@var{samples}, @var{cluster_count}, @var{labels}, @var{termcrit}, @var{attempts} = 1, @var{rng} = 0, @var{flags} = 0, @var{_centers} = 0, @var{compactness} = 0)\n\
@var{samples} is of type CvArr. @var{cluster_count} is of type int. @var{labels} is of type CvArr. @var{termcrit} is of type CvTermCriteria. @var{attempts} is of type int. @var{rng} is of type CvRNG. @var{flags} is of type int. @var{_centers} is of type CvArr. @var{compactness} is of type double. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvImage_step_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = step (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_LSHSize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = LSHSize (@var{lsh})\n\
@var{lsh} is of type CvLSH. @var{retval} is of type unsigned int. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_INDEX_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_INDEX (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvRemap_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRemap (@var{src}, @var{dst}, @var{mapx}, @var{mapy}, @var{flags} = 1+8, @var{fillval} = cvScalarAll(0))\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{mapx} is of type CvArr. @var{mapy} is of type CvArr. @var{flags} is of type int. @var{fillval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_CvImage_depth_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = depth (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSub_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSub (@var{src1}, @var{src2}, @var{dst}, @var{mask} = nil)\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvInitMatNDHeader_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvInitMatNDHeader (@var{mat}, @var{dims}, @var{type}, @var{data} = nil)\n\
@var{mat} is of type CvMatND. @var{dims} is of type int. @var{type} is of type int. @var{data} is of type void. @var{retval} is of type CvMatND. \n\
@end deftypefn";
const char* _wrap_cvCreateMatNDHeader_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateMatNDHeader (@var{dims}, @var{type})\n\
@var{dims} is of type int. @var{type} is of type int. @var{retval} is of type CvMatND. \n\
@end deftypefn";
const char* _wrap_cvInitMatHeader_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvInitMatHeader (@var{mat}, @var{rows}, @var{cols}, @var{type}, @var{data} = nil, @var{step} = 0x7fffffff)\n\
@var{mat} is of type CvMat. @var{rows} is of type int. @var{cols} is of type int. @var{type} is of type int. @var{data} is of type void. @var{step} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvCreateMatHeader_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateMatHeader (@var{rows}, @var{cols}, @var{type})\n\
@var{rows} is of type int. @var{cols} is of type int. @var{type} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_IplImage___ror___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __ror__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___ror___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __ror__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvFindFeatures_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFindFeatures (@var{tr}, @var{query_points}, @var{indices}, @var{dist}, @var{k}, @var{emax} = 20)\n\
@var{tr} is of type CvFeatureTree. @var{query_points} is of type CvMat. @var{indices} is of type CvMat. @var{dist} is of type CvMat. @var{k} is of type int. @var{emax} is of type int. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint2D32f_cast_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvPoint2D32f)>::cast (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type CvSeq_CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator_next_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = next (@var{self})\n\
@var{self} is of type OctSwigIterator. @var{retval} is of type octave_value. \n\
@end deftypefn";
const char* _wrap_CvPoint___repr___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __repr__ (@var{self})\n\
@var{self} is of type CvPoint. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_CvPoint2D32f___repr___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __repr__ (@var{self})\n\
@var{self} is of type CvPoint2D32f. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_CvScalar___repr___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __repr__ (@var{self})\n\
@var{self} is of type CvScalar. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_cvSum_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSum (@var{arr})\n\
@var{arr} is of type CvArr. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_new_CvSlice_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSlice::CvSlice ()\n\
@var{retval} is of type CvSlice. \n\
@end deftypefn";
const char* _wrap_delete_CvSlice_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSlice::~CvSlice (@var{self})\n\
@var{self} is of type CvSlice. \n\
@end deftypefn";
const char* _wrap_cvSlice_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSlice (@var{start}, @var{end})\n\
@var{start} is of type int. @var{end} is of type int. @var{retval} is of type CvSlice. \n\
@end deftypefn";
const char* _wrap_cvSetIPLAllocators_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetIPLAllocators (@var{create_header}, @var{allocate_data}, @var{deallocate}, @var{create_roi}, @var{clone_image})\n\
@var{create_header} is of type Cv_iplCreateImageHeader. @var{allocate_data} is of type Cv_iplAllocateImageData. @var{deallocate} is of type Cv_iplDeallocate. @var{create_roi} is of type Cv_iplCreateROI. @var{clone_image} is of type Cv_iplCloneImage. \n\
@end deftypefn";
const char* _wrap_CV_WRITE_SEQ_ELEM_VAR_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_WRITE_SEQ_ELEM_VAR (@var{elem_ptr}, @var{writer})\n\
@var{elem_ptr} is of type void. @var{writer} is of type CvSeqWriter. \n\
@end deftypefn";
const char* _wrap_cvSeqRemove_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSeqRemove (@var{seq}, @var{index})\n\
@var{seq} is of type CvSeq. @var{index} is of type int. \n\
@end deftypefn";
const char* _wrap_cvReleaseFeatureTree_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseFeatureTree (@var{tr})\n\
@var{tr} is of type CvFeatureTree. \n\
@end deftypefn";
const char* _wrap_CV_NODE_SEQ_IS_SIMPLE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_SEQ_IS_SIMPLE (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_SIMPLE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_SIMPLE (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPointVector_empty_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = empty (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_FloatVector_empty_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = empty (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_cvSubRS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSubRS (@var{src}, @var{value}, @var{dst}, @var{mask} = nil)\n\
@var{src} is of type CvArr. @var{value} is of type CvScalar. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CV_16SC_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_16SC (@var{n})\n\
@var{n} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_MATND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_MATND (@var{mat})\n\
@var{mat} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvPyrSegmentationUntyped_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPyrSegmentation (@var{src}, @var{dst}, @var{storage}, @var{comp}, @var{level}, @var{threshold1}, @var{threshold2})\n\
@var{src} is of type . @var{dst} is of type . @var{storage} is of type CvMemStorage. @var{comp} is of type CvSeq. @var{level} is of type int. @var{threshold1} is of type double. @var{threshold2} is of type double. \n\
@end deftypefn";
const char* _wrap_cvFindContoursUntyped_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindContours (@var{image}, @var{storage}, @var{first_contour}, @var{header_size} = sizeof(CvContour), @var{mode} = 1, @var{method} = 2, @var{offset} = cvPoint(0,0))\n\
@var{image} is of type CvArr. @var{storage} is of type CvMemStorage. @var{first_contour} is of type CvSeq. @var{header_size} is of type int. @var{mode} is of type int. @var{method} is of type int. @var{offset} is of type CvPoint. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvApproxChainsUntyped_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvApproxChains (@var{src_seq}, @var{storage}, @var{method} = 2, @var{parameter} = 0, @var{minimal_perimeter} = 0, @var{recursive} = 0)\n\
@var{src_seq} is of type CvSeq. @var{storage} is of type CvMemStorage. @var{method} is of type int. @var{parameter} is of type double. @var{minimal_perimeter} is of type int. @var{recursive} is of type int. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvContourFromContourTreeUntyped_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvContourFromContourTree (@var{tree}, @var{storage}, @var{criteria})\n\
@var{tree} is of type CvContourTree. @var{storage} is of type CvMemStorage. @var{criteria} is of type CvTermCriteria. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvConvexityDefectsUntyped_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvConvexityDefects (@var{contour}, @var{convexhull}, @var{storage} = nil)\n\
@var{contour} is of type CvArr. @var{convexhull} is of type CvArr. @var{storage} is of type CvMemStorage. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvHoughLinesUntyped_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvHoughLines2 (@var{image}, @var{line_storage}, @var{method}, @var{rho}, @var{theta}, @var{threshold}, @var{param1} = 0, @var{param2} = 0)\n\
@var{image} is of type CvArr. @var{line_storage} is of type void. @var{method} is of type int. @var{rho} is of type double. @var{theta} is of type double. @var{threshold} is of type int. @var{param1} is of type double. @var{param2} is of type double. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvHoughCirclesUntyped_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvHoughCircles (@var{image}, @var{circle_storage}, @var{method}, @var{dp}, @var{min_dist}, @var{param1} = 100, @var{param2} = 100, @var{min_radius} = 0, @var{max_radius} = 0)\n\
@var{image} is of type CvArr. @var{circle_storage} is of type void. @var{method} is of type int. @var{dp} is of type double. @var{min_dist} is of type double. @var{param1} is of type double. @var{param2} is of type double. @var{min_radius} is of type int. @var{max_radius} is of type int. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvAbs_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAbs (@var{src}, @var{dst})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvSobel_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSobel (@var{src}, @var{dst}, @var{xorder}, @var{yorder}, @var{aperture_size} = 3)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{xorder} is of type int. @var{yorder} is of type int. @var{aperture_size} is of type int. \n\
@end deftypefn";
const char* _wrap_IplImage___eq___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator == (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvSubdiv2DEdge_Wrapper___eq___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator == (@var{self}, @var{x})\n\
@var{self} is of type CvSubdiv2DEdge_Wrapper. @var{x} is of type CvSubdiv2DEdge_Wrapper. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_CvRNG_Wrapper___eq___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator == (@var{self}, @var{x})\n\
@var{self} is of type CvRNG_Wrapper. @var{x} is of type CvRNG_Wrapper. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator___eq___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator == (@var{self}, @var{x})\n\
@var{self} is of type OctSwigIterator. @var{x} is of type OctSwigIterator. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_CvMat___eq___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator == (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvFloor_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFloor (@var{value})\n\
@var{value} is of type double. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMat (@var{rows}, @var{cols}, @var{type})\n\
@var{rows} is of type int. @var{cols} is of type int. @var{type} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CV_SWAP_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_SWAP (@var{a}, @var{b}, @var{t})\n\
@var{a} is of type int. @var{b} is of type int. @var{t} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPointVector_begin_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = begin (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type const_iterator. \n\
@end deftypefn";
const char* _wrap_FloatVector_begin_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = begin (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type const_iterator. \n\
@end deftypefn";
const char* _wrap_cvMax_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMax (@var{src1}, @var{src2}, @var{dst})\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvReleaseMatND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseMatND (@var{mat})\n\
@var{mat} is of type CvMatND. \n\
@end deftypefn";
const char* _wrap_cvAcc_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAcc (@var{image}, @var{sum}, @var{mask} = nil)\n\
@var{image} is of type CvArr. @var{sum} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator_previous_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = previous (@var{self})\n\
@var{self} is of type OctSwigIterator. @var{retval} is of type octave_value. \n\
@end deftypefn";
const char* _wrap_IplImage___rdiv___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rdiv__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMat___rdiv___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rdiv__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint2D32f_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type CvSeq_CvPoint2D32f. @var{retval} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint_2_cast_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvTuple<(CvPoint,2)>)>::cast (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type CvSeq_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_2_cast_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvTuple<(float,2)>)>::cast (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type CvSeq_float_2. \n\
@end deftypefn";
const char* _wrap_cvCmpS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCmpS (@var{src}, @var{value}, @var{dst}, @var{cmp_op})\n\
@var{src} is of type CvArr. @var{value} is of type double. @var{dst} is of type CvArr. @var{cmp_op} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvConvexityDefect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvConvexityDefect::CvConvexityDefect ()\n\
@var{retval} is of type CvConvexityDefect. \n\
@end deftypefn";
const char* _wrap_delete_CvConvexityDefect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvConvexityDefect::~CvConvexityDefect (@var{self})\n\
@var{self} is of type CvConvexityDefect. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator_advance_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = advance (@var{self}, @var{n})\n\
@var{self} is of type OctSwigIterator. @var{n} is of type ptrdiff_t. @var{retval} is of type OctSwigIterator. \n\
@end deftypefn";
const char* _wrap_cvUnregisterType_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvUnregisterType (@var{type_name})\n\
@var{type_name} is of type char. \n\
@end deftypefn";
const char* _wrap_cvRegisterType_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRegisterType (@var{info})\n\
@var{info} is of type CvTypeInfo. \n\
@end deftypefn";
const char* _wrap_cvCheckArr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCheckArr (@var{arr}, @var{flags} = 0, @var{min_val} = 0, @var{max_val} = 0)\n\
@var{arr} is of type CvArr. @var{flags} is of type int. @var{min_val} is of type double. @var{max_val} is of type double. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvFindExtrinsicCameraParams2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFindExtrinsicCameraParams2 (@var{object_points}, @var{image_points}, @var{camera_matrix}, @var{distortion_coeffs}, @var{rotation_vector}, @var{translation_vector}, @var{use_extrinsic_guess} = 0)\n\
@var{object_points} is of type CvMat. @var{image_points} is of type CvMat. @var{camera_matrix} is of type CvMat. @var{distortion_coeffs} is of type CvMat. @var{rotation_vector} is of type CvMat. @var{translation_vector} is of type CvMat. @var{use_extrinsic_guess} is of type int. \n\
@end deftypefn";
const char* _wrap_cvWarpAffine_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvWarpAffine (@var{src}, @var{dst}, @var{map_matrix}, @var{flags} = 1+8, @var{fillval} = cvScalarAll(0))\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{map_matrix} is of type CvMat. @var{flags} is of type int. @var{fillval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_IplImage___add___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator + (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type CvScalar. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_OctSwigIterator___add___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator + (@var{self}, @var{n})\n\
@var{self} is of type OctSwigIterator. @var{n} is of type ptrdiff_t. @var{retval} is of type OctSwigIterator. \n\
@end deftypefn";
const char* _wrap_CvMat___add___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator + (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type CvScalar. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CV_IS_HAAR_CLASSIFIER_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_HAAR_CLASSIFIER (@var{haar})\n\
@var{haar} is of type void. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvAdd_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAdd (@var{src1}, @var{src2}, @var{dst}, @var{mask} = nil)\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvPutText_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPutText (@var{img}, @var{text}, @var{org}, @var{font}, @var{color})\n\
@var{img} is of type CvArr. @var{text} is of type char. @var{org} is of type CvPoint. @var{font} is of type CvFont. @var{color} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_delete_IplConvKernelFP_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} IplConvKernelFP::~IplConvKernelFP (@var{self})\n\
@var{self} is of type . \n\
@end deftypefn";
const char* _wrap_new_IplConvKernelFP_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = IplConvKernelFP::IplConvKernelFP ()\n\
@var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CV_16UC_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_16UC (@var{n})\n\
@var{n} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPointVector_rend_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = rend (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type const_reverse_iterator. \n\
@end deftypefn";
const char* _wrap_FloatVector_rend_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = rend (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type const_reverse_iterator. \n\
@end deftypefn";
const char* _wrap_cvMatchTemplate_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMatchTemplate (@var{image}, @var{templ}, @var{result}, @var{method})\n\
@var{image} is of type CvArr. @var{templ} is of type CvArr. @var{result} is of type CvArr. @var{method} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSetRemove_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetRemove (@var{set_header}, @var{index})\n\
@var{set_header} is of type CvSet. @var{index} is of type int. \n\
@end deftypefn";
const char* _wrap_cvLSHRemove_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvLSHRemove (@var{lsh}, @var{indices})\n\
@var{lsh} is of type CvLSH. @var{indices} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CvPointVector_get_allocator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = get_allocator (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type allocator_type. \n\
@end deftypefn";
const char* _wrap_FloatVector_get_allocator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = get_allocator (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type allocator_type. \n\
@end deftypefn";
const char* _wrap_cvTriangleArea_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvTriangleArea (@var{a}, @var{b}, @var{c})\n\
@var{a} is of type CvPoint2D32f. @var{b} is of type CvPoint2D32f. @var{c} is of type CvPoint2D32f. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvEllipse_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvEllipse (@var{img}, @var{center}, @var{axes}, @var{angle}, @var{start_angle}, @var{end_angle}, @var{color}, @var{thickness} = 1, @var{line_type} = 8, @var{shift} = 0)\n\
@var{img} is of type CvArr. @var{center} is of type CvPoint. @var{axes} is of type CvSize. @var{angle} is of type double. @var{start_angle} is of type double. @var{end_angle} is of type double. @var{color} is of type CvScalar. @var{thickness} is of type int. @var{line_type} is of type int. @var{shift} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPointVector_erase_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = erase (@var{self}, @var{first}, @var{last})\n\
@var{self} is of type CvPointVector. @var{first} is of type iterator. @var{last} is of type iterator. @var{retval} is of type iterator. \n\
@end deftypefn";
const char* _wrap_FloatVector_erase_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = erase (@var{self}, @var{first}, @var{last})\n\
@var{self} is of type FloatVector. @var{first} is of type iterator. @var{last} is of type iterator. @var{retval} is of type iterator. \n\
@end deftypefn";
const char* _wrap_cvCopyHist_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCopyHist (@var{src}, @var{dst})\n\
@var{src} is of type CvHistogram. @var{dst} is of type CvHistogram. \n\
@end deftypefn";
const char* _wrap_cvInitUndistortRectifyMap_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInitUndistortRectifyMap (@var{camera_matrix}, @var{dist_coeffs}, @var{R}, @var{new_camera_matrix}, @var{mapx}, @var{mapy})\n\
@var{camera_matrix} is of type CvMat. @var{dist_coeffs} is of type CvMat. @var{R} is of type CvMat. @var{new_camera_matrix} is of type CvMat. @var{mapx} is of type CvArr. @var{mapy} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvImage_coi_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = coi (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_NODE_IS_STRING_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_IS_STRING (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_ARE_TYPES_EQ_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_ARE_TYPES_EQ (@var{mat1}, @var{mat2})\n\
@var{mat1} is of type CvMat. @var{mat2} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvInvSqrt_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInvSqrt (@var{value})\n\
@var{value} is of type double. \n\
@end deftypefn";
const char* _wrap_cvRound_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRound (@var{value})\n\
@var{value} is of type double. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvWriteInt_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvWriteInt (@var{fs}, @var{name}, @var{value})\n\
@var{fs} is of type CvFileStorage. @var{name} is of type char. @var{value} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCanny_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCanny (@var{image}, @var{edges}, @var{threshold1}, @var{threshold2}, @var{aperture_size} = 3)\n\
@var{image} is of type CvArr. @var{edges} is of type CvArr. @var{threshold1} is of type double. @var{threshold2} is of type double. @var{aperture_size} is of type int. \n\
@end deftypefn";
const char* _wrap_CvImage_attach_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} attach (@var{self}, @var{img})\n\
@var{self} is of type CvImage. @var{img} is of type . \n\
@end deftypefn";
const char* _wrap_CvPointVector_pop_back_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} pop_back (@var{self})\n\
@var{self} is of type CvPointVector. \n\
@end deftypefn";
const char* _wrap_FloatVector_pop_back_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} pop_back (@var{self})\n\
@var{self} is of type FloatVector. \n\
@end deftypefn";
const char* _wrap_cvGetCols_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetCols (@var{arr}, @var{submat}, @var{start_col}, @var{end_col})\n\
@var{arr} is of type CvArr. @var{submat} is of type CvMat. @var{start_col} is of type int. @var{end_col} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CvImage_roi_row_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = roi_row (@var{self}, @var{y})\n\
@var{self} is of type CvImage. @var{y} is of type int. @var{retval} is of type uchar. \n\
@end deftypefn";
const char* _wrap_cvReadRawData_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReadRawData (@var{fs}, @var{src}, @var{dst}, @var{dt})\n\
@var{fs} is of type CvFileStorage. @var{src} is of type CvFileNode. @var{dst} is of type void. @var{dt} is of type char. \n\
@end deftypefn";
const char* _wrap_cvStartReadRawData_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvStartReadRawData (@var{fs}, @var{src}, @var{reader})\n\
@var{fs} is of type CvFileStorage. @var{src} is of type CvFileNode. @var{reader} is of type CvSeqReader. \n\
@end deftypefn";
const char* _wrap_cvWriteRawData_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvWriteRawData (@var{fs}, @var{src}, @var{len}, @var{dt})\n\
@var{fs} is of type CvFileStorage. @var{src} is of type void. @var{len} is of type int. @var{dt} is of type char. \n\
@end deftypefn";
const char* _wrap_cvGetRawData_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGetRawData (@var{arr}, @var{data}, @var{step} = nil, @var{roi_size} = nil)\n\
@var{arr} is of type CvArr. @var{data} is of type uchar. @var{step} is of type int. @var{roi_size} is of type CvSize. \n\
@end deftypefn";
const char* _wrap_cvScalarToRawData_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvScalarToRawData (@var{scalar}, @var{data}, @var{type}, @var{extend_to_12} = 0)\n\
@var{scalar} is of type CvScalar. @var{data} is of type void. @var{type} is of type int. @var{extend_to_12} is of type int. \n\
@end deftypefn";
const char* _wrap_CvImage_save_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} save (@var{self}, @var{filename}, @var{imgname})\n\
@var{self} is of type CvImage. @var{filename} is of type char. @var{imgname} is of type char. \n\
@end deftypefn";
const char* _wrap_cvContourArea_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvContourArea (@var{contour}, @var{slice} = cvSlice(0, 0x3fffffff))\n\
@var{contour} is of type CvArr. @var{slice} is of type CvSlice. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_CvPointVector_push_back_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} push_back (@var{self}, @var{x})\n\
@var{self} is of type CvPointVector. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_FloatVector_push_back_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} push_back (@var{self}, @var{x})\n\
@var{self} is of type FloatVector. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_cvMatchShapes_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMatchShapes (@var{object1}, @var{object2}, @var{method}, @var{parameter} = 0)\n\
@var{object1} is of type void. @var{object2} is of type void. @var{method} is of type int. @var{parameter} is of type double. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvComposeRT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvComposeRT (@var{_rvec1}, @var{_tvec1}, @var{_rvec2}, @var{_tvec2}, @var{_rvec3}, @var{_tvec3}, @var{dr3dr1} = 0, @var{dr3dt1} = 0, @var{dr3dr2} = 0, @var{dr3dt2} = 0, @var{dt3dr1} = 0, @var{dt3dt1} = 0, @var{dt3dr2} = 0, @var{dt3dt2} = 0)\n\
@var{_rvec1} is of type CvMat. @var{_tvec1} is of type CvMat. @var{_rvec2} is of type CvMat. @var{_tvec2} is of type CvMat. @var{_rvec3} is of type CvMat. @var{_tvec3} is of type CvMat. @var{dr3dr1} is of type CvMat. @var{dr3dt1} is of type CvMat. @var{dr3dr2} is of type CvMat. @var{dr3dt2} is of type CvMat. @var{dt3dr1} is of type CvMat. @var{dt3dt1} is of type CvMat. @var{dt3dr2} is of type CvMat. @var{dt3dt2} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvFindType_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindType (@var{type_name})\n\
@var{type_name} is of type char. @var{retval} is of type CvTypeInfo. \n\
@end deftypefn";
const char* _wrap_cvContourPerimeter_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvContourPerimeter_Shadow (@var{arr})\n\
@var{arr} is of type CvArr. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvAbsDiffS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAbsDiffS (@var{src}, @var{dst}, @var{value})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{value} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvCorrectMatches_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCorrectMatches (@var{F}, @var{points1}, @var{points2}, @var{new_points1}, @var{new_points2})\n\
@var{F} is of type CvMat. @var{points1} is of type CvMat. @var{points2} is of type CvMat. @var{new_points1} is of type CvMat. @var{new_points2} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_POLYLINE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_POLYLINE (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPointVector_resize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} resize (@var{self}, @var{new_size}, @var{x})\n\
@var{self} is of type CvPointVector. @var{new_size} is of type size_type. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_FloatVector_resize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} resize (@var{self}, @var{new_size}, @var{x})\n\
@var{self} is of type FloatVector. @var{new_size} is of type size_type. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_cvResize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvResize (@var{src}, @var{dst}, @var{interpolation} = 1)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{interpolation} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGoodFeaturesToTrack_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGoodFeaturesToTrack (@var{image}, @var{eig_image}, @var{temp_image}, @var{corners}, @var{quality_level}, @var{min_distance}, @var{mask} = nil, @var{block_size} = 3, @var{use_harris} = 0, @var{k} = 0.04)\n\
@var{image} is of type CvArr. @var{eig_image} is of type CvArr. @var{temp_image} is of type CvArr. @var{corners} is of type CvPoint2D32f. @var{quality_level} is of type double. @var{min_distance} is of type double. @var{mask} is of type CvArr. @var{block_size} is of type int. @var{use_harris} is of type int. @var{k} is of type double. \n\
@end deftypefn";
const char* _wrap_cvFitEllipse2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFitEllipse2 (@var{points})\n\
@var{points} is of type CvArr. @var{retval} is of type CvBox2D. \n\
@end deftypefn";
const char* _wrap_CV_PREV_POINT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_PREV_POINT (@var{reader})\n\
@var{reader} is of type CvSeqReader. @var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CV_CURRENT_POINT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_CURRENT_POINT (@var{reader})\n\
@var{reader} is of type CvSeqReader. @var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CV_READ_CHAIN_POINT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_READ_CHAIN_POINT (@var{_pt}, @var{reader})\n\
@var{_pt} is of type CvPoint. @var{reader} is of type CvChainPtReader. \n\
@end deftypefn";
const char* _wrap_cvFlushSeqWriter_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFlushSeqWriter (@var{writer})\n\
@var{writer} is of type CvSeqWriter. \n\
@end deftypefn";
const char* _wrap_delete_CvSeqWriter_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSeqWriter::~CvSeqWriter (@var{self})\n\
@var{self} is of type CvSeqWriter. \n\
@end deftypefn";
const char* _wrap_new_CvSeqWriter_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSeqWriter::CvSeqWriter ()\n\
@var{retval} is of type CvSeqWriter. \n\
@end deftypefn";
const char* _wrap_cvNot_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvNot (@var{src}, @var{dst})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvGetOptimalDFTSize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetOptimalDFTSize (@var{size0})\n\
@var{size0} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetSize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetSize (@var{arr})\n\
@var{arr} is of type CvArr. @var{retval} is of type CvSize. \n\
@end deftypefn";
const char* _wrap_cvSeqSort_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSeqSort (@var{seq}, @var{func}, @var{userdata} = nil)\n\
@var{seq} is of type CvSeq. @var{func} is of type CvCmpFunc. @var{userdata} is of type void. \n\
@end deftypefn";
const char* _wrap_cvCvtColor_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCvtColor (@var{src}, @var{dst}, @var{code})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{code} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCornerMinEigenVal_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCornerMinEigenVal (@var{image}, @var{eigenval}, @var{block_size}, @var{aperture_size} = 3)\n\
@var{image} is of type CvArr. @var{eigenval} is of type CvArr. @var{block_size} is of type int. @var{aperture_size} is of type int. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint_2_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type CvSeq_CvPoint_2. @var{retval} is of type CvTuple_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_2_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type CvSeq_float_2. @var{retval} is of type CvTuple_float_2. \n\
@end deftypefn";
const char* _wrap_cvPyrUp_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPyrUp (@var{src}, @var{dst}, @var{filter} = CV_GAUSSIAN_5x5)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{filter} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCalcOpticalFlowPyrLK_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcOpticalFlowPyrLK (@var{prev}, @var{curr}, @var{prev_pyr}, @var{curr_pyr}, @var{prev_features}, @var{curr_features}, @var{win_size}, @var{level}, @var{status}, @var{track_error}, @var{criteria}, @var{flags})\n\
@var{prev} is of type CvArr. @var{curr} is of type CvArr. @var{prev_pyr} is of type CvArr. @var{curr_pyr} is of type CvArr. @var{prev_features} is of type CvPoint2D32f. @var{curr_features} is of type CvPoint2D32f. @var{win_size} is of type CvSize. @var{level} is of type int. @var{status} is of type char. @var{track_error} is of type float. @var{criteria} is of type CvTermCriteria. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCalcAffineFlowPyrLK_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcAffineFlowPyrLK (@var{prev}, @var{curr}, @var{prev_pyr}, @var{curr_pyr}, @var{prev_features}, @var{curr_features}, @var{matrices}, @var{count}, @var{win_size}, @var{level}, @var{status}, @var{track_error}, @var{criteria}, @var{flags})\n\
@var{prev} is of type CvArr. @var{curr} is of type CvArr. @var{prev_pyr} is of type CvArr. @var{curr_pyr} is of type CvArr. @var{prev_features} is of type CvPoint2D32f. @var{curr_features} is of type CvPoint2D32f. @var{matrices} is of type float. @var{count} is of type int. @var{win_size} is of type CvSize. @var{level} is of type int. @var{status} is of type char. @var{track_error} is of type float. @var{criteria} is of type CvTermCriteria. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_CvMatrix_channels_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = channels (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvImage_channels_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = channels (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvMixChannels_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMixChannels (@var{src}, @var{src_count}, @var{dst}, @var{dst_count}, @var{from_to}, @var{pair_count})\n\
@var{src} is of type CvArr. @var{src_count} is of type int. @var{dst} is of type CvArr. @var{dst_count} is of type int. @var{from_to} is of type int. @var{pair_count} is of type int. \n\
@end deftypefn";
const char* _wrap_cvLinearPolar_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvLinearPolar (@var{src}, @var{dst}, @var{center}, @var{maxRadius}, @var{flags} = 1+8)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{center} is of type CvPoint2D32f. @var{maxRadius} is of type double. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_CvMatrix_write_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} write (@var{self}, @var{fs}, @var{matname})\n\
@var{self} is of type CvMatrix. @var{fs} is of type CvFileStorage. @var{matname} is of type char. \n\
@end deftypefn";
const char* _wrap_cvCalcOpticalFlowBM_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcOpticalFlowBM (@var{prev}, @var{curr}, @var{block_size}, @var{shift_size}, @var{max_range}, @var{use_previous}, @var{velx}, @var{vely})\n\
@var{prev} is of type CvArr. @var{curr} is of type CvArr. @var{block_size} is of type CvSize. @var{shift_size} is of type CvSize. @var{max_range} is of type CvSize. @var{use_previous} is of type int. @var{velx} is of type CvArr. @var{vely} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvCloneGraph_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCloneGraph (@var{graph}, @var{storage})\n\
@var{graph} is of type CvGraph. @var{storage} is of type CvMemStorage. @var{retval} is of type CvGraph. \n\
@end deftypefn";
const char* _wrap_cvCreateGraph_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateGraph (@var{graph_flags}, @var{header_size}, @var{vtx_size}, @var{edge_size}, @var{storage})\n\
@var{graph_flags} is of type int. @var{header_size} is of type int. @var{vtx_size} is of type int. @var{edge_size} is of type int. @var{storage} is of type CvMemStorage. @var{retval} is of type CvGraph. \n\
@end deftypefn";
const char* _wrap_cvAttrValue_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvAttrValue (@var{attr}, @var{attr_name})\n\
@var{attr} is of type CvAttrList. @var{attr_name} is of type char. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_CvMatrix_clone_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = clone (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type CvMatrix. \n\
@end deftypefn";
const char* _wrap_cvSeqPop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSeqPop (@var{seq}, @var{element} = nil)\n\
@var{seq} is of type CvSeq. @var{element} is of type void. \n\
@end deftypefn";
const char* _wrap_cvSegmentMotion_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSegmentMotion_Shadow (@var{mhi}, @var{seg_mask}, @var{storage}, @var{timestamp}, @var{seg_thresh})\n\
@var{mhi} is of type CvArr. @var{seg_mask} is of type CvArr. @var{storage} is of type CvMemStorage. @var{timestamp} is of type double. @var{seg_thresh} is of type double. @var{retval} is of type CvSeq_CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_cvFastArctan_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFastArctan (@var{y}, @var{x})\n\
@var{y} is of type float. @var{x} is of type float. @var{retval} is of type float. \n\
@end deftypefn";
const char* _wrap_IplImage___rne___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rne__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMat___rne___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rne__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CV_NODE_VAL_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_VAL (@var{mat}, @var{node})\n\
@var{mat} is of type CvSparseMat. @var{node} is of type CvSparseNode. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_CV_IS_MASK_ARR_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_MASK_ARR (@var{mat})\n\
@var{mat} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCornerHarris_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCornerHarris (@var{image}, @var{harris_responce}, @var{block_size}, @var{aperture_size} = 3, @var{k} = 0.04)\n\
@var{image} is of type CvArr. @var{harris_responce} is of type CvArr. @var{block_size} is of type int. @var{aperture_size} is of type int. @var{k} is of type double. \n\
@end deftypefn";
const char* _wrap_CvImage_detach_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} detach (@var{self})\n\
@var{self} is of type CvImage. \n\
@end deftypefn";
const char* _wrap_cvGetTickFrequency_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetTickFrequency ()\n\
@var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_IplImage___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{object}, @var{arr})\n\
@var{self} is of type . @var{object} is of type octave_value. @var{arr} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMat___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{object}, @var{arr})\n\
@var{self} is of type CvMat. @var{object} is of type octave_value. @var{arr} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvTuple_CvPoint_2___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvTuple_CvPoint_2. @var{i} is of type int. @var{obj} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CvTuple_float_2___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvTuple_float_2. @var{i} is of type int. @var{obj} is of type float. \n\
@end deftypefn";
const char* _wrap_CvTuple_float_3___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvTuple_float_3. @var{i} is of type int. @var{obj} is of type float. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvPoint. @var{i} is of type int. @var{obj} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint2D32f___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvPoint2D32f. @var{i} is of type int. @var{obj} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvRect___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvRect. @var{i} is of type int. @var{obj} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvSeq___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvSeq. @var{i} is of type int. @var{obj} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvQuadEdge2D___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvQuadEdge2D. @var{i} is of type int. @var{obj} is of type CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvConnectedComp___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvConnectedComp. @var{i} is of type int. @var{obj} is of type CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint_2___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvPoint_2. @var{i} is of type int. @var{obj} is of type CvTuple_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_2___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_float_2. @var{i} is of type int. @var{obj} is of type CvTuple_float_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_3___paren_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_float_3. @var{i} is of type int. @var{obj} is of type CvTuple_float_3. \n\
@end deftypefn";
const char* _wrap_IplImage___ge___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator >= (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___ge___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator >= (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_POINT_SET_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_POINT_SET (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_NODE_IS_INT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_IS_INT (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvFloodFill_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFloodFill (@var{image}, @var{seed_point}, @var{new_val}, @var{lo_diff} = cvScalarAll(0), @var{up_diff} = cvScalarAll(0), @var{comp} = nil, @var{flags} = 4, @var{mask} = nil)\n\
@var{image} is of type CvArr. @var{seed_point} is of type CvPoint. @var{new_val} is of type CvScalar. @var{lo_diff} is of type CvScalar. @var{up_diff} is of type CvScalar. @var{comp} is of type CvConnectedComp. @var{flags} is of type int. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_CONVEX_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_CONVEX (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSeqPartition_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSeqPartition (@var{seq}, @var{storage}, @var{labels}, @var{is_equal}, @var{userdata})\n\
@var{seq} is of type CvSeq. @var{storage} is of type CvMemStorage. @var{labels} is of type CvSeq. @var{is_equal} is of type CvCmpFunc. @var{userdata} is of type void. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_SPARSE_MAT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SPARSE_MAT (@var{mat})\n\
@var{mat} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSeqSearch_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSeqSearch (@var{seq}, @var{elem}, @var{func}, @var{is_sorted}, @var{elem_idx}, @var{userdata} = nil)\n\
@var{seq} is of type CvSeq. @var{elem} is of type void. @var{func} is of type CvCmpFunc. @var{is_sorted} is of type int. @var{elem_idx} is of type int. @var{userdata} is of type void. @var{retval} is of type schar. \n\
@end deftypefn";
const char* _wrap_CV_32SC_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_32SC (@var{n})\n\
@var{n} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_NEXT_LINE_POINT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_NEXT_LINE_POINT (@var{line_iterator})\n\
@var{line_iterator} is of type CvLineIterator. \n\
@end deftypefn";
const char* _wrap_cvCreateHist_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateHist (@var{dims}, @var{type}, @var{ranges} = nil, @var{uniform} = 1)\n\
@var{dims} is of type int. @var{type} is of type int. @var{ranges} is of type float. @var{uniform} is of type int. @var{retval} is of type CvHistogram. \n\
@end deftypefn";
const char* _wrap_CV_IS_SUBDIV2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SUBDIV2D (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvStarKeypoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvStarKeypoint::CvStarKeypoint ()\n\
@var{retval} is of type CvStarKeypoint. \n\
@end deftypefn";
const char* _wrap_delete_CvStarKeypoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvStarKeypoint::~CvStarKeypoint (@var{self})\n\
@var{self} is of type CvStarKeypoint. \n\
@end deftypefn";
const char* _wrap_cvStarKeypoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvStarKeypoint (@var{pt}, @var{size}, @var{response})\n\
@var{pt} is of type CvPoint. @var{size} is of type int. @var{response} is of type float. @var{retval} is of type CvStarKeypoint. \n\
@end deftypefn";
const char* _wrap_cvPreCornerDetect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPreCornerDetect (@var{image}, @var{corners}, @var{aperture_size} = 3)\n\
@var{image} is of type CvArr. @var{corners} is of type CvArr. @var{aperture_size} is of type int. \n\
@end deftypefn";
const char* _wrap_cvRandShuffle_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRandShuffle (@var{mat}, @var{rng}, @var{iter_factor} = 1.)\n\
@var{mat} is of type CvArr. @var{rng} is of type CvRNG. @var{iter_factor} is of type double. \n\
@end deftypefn";
const char* _wrap_cvSolveCubic_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSolveCubic (@var{coeffs}, @var{roots})\n\
@var{coeffs} is of type CvMat. @var{roots} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvImage_asIplImage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator IplImage* (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_delete_IplImage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} IplImage (@var{self})\n\
@var{self} is of type . \n\
@end deftypefn";
const char* _wrap_new_CvPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvPoint::CvPoint ()\n\
@var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_delete_CvPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvPoint::~CvPoint (@var{self})\n\
@var{self} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_cvPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPoint (@var{x}, @var{y})\n\
@var{x} is of type int. @var{y} is of type int. @var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_new_CvSeq_CvPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvPoint)>::CvTypedSeq<(CvPoint)> ()\n\
@var{retval} is of type CvSeq_CvPoint. \n\
@end deftypefn";
const char* _wrap_delete_CvSeq_CvPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTypedSeq<(CvPoint)>::~CvTypedSeq<(CvPoint)> (@var{self})\n\
@var{self} is of type CvSeq_CvPoint. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_HOLE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_HOLE (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvWriteComment_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvWriteComment (@var{fs}, @var{comment}, @var{eol_comment})\n\
@var{fs} is of type CvFileStorage. @var{comment} is of type char. @var{eol_comment} is of type int. \n\
@end deftypefn";
const char* _wrap_CvImage_write_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} write (@var{self}, @var{fs}, @var{imgname})\n\
@var{self} is of type CvImage. @var{fs} is of type CvFileStorage. @var{imgname} is of type char. \n\
@end deftypefn";
const char* _wrap_cvEllipseBox_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvEllipseBox (@var{img}, @var{box}, @var{color}, @var{thickness} = 1, @var{line_type} = 8, @var{shift} = 0)\n\
@var{img} is of type CvArr. @var{box} is of type CvBox2D. @var{color} is of type CvScalar. @var{thickness} is of type int. @var{line_type} is of type int. @var{shift} is of type int. \n\
@end deftypefn";
const char* _wrap_cvReadChainPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvReadChainPoint (@var{reader})\n\
@var{reader} is of type CvChainPtReader. @var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_cvMinEnclosingCircle_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMinEnclosingCircle (@var{points}, @var{center})\n\
@var{points} is of type CvArr. @var{center} is of type CvPoint2D32f. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGraphGetEdgeCount_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphGetEdgeCount (@var{graph})\n\
@var{graph} is of type CvGraph. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvPolarToCart_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPolarToCart (@var{magnitude}, @var{angle}, @var{x}, @var{y}, @var{angle_in_degrees} = 0)\n\
@var{magnitude} is of type CvArr. @var{angle} is of type CvArr. @var{x} is of type CvArr. @var{y} is of type CvArr. @var{angle_in_degrees} is of type int. \n\
@end deftypefn";
const char* _wrap_cvPyrMeanShiftFiltering_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPyrMeanShiftFiltering (@var{src}, @var{dst}, @var{sp}, @var{sr}, @var{max_level} = 1, @var{termcrit} = cvTermCriteria(1 +2,5,1))\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{sp} is of type double. @var{sr} is of type double. @var{max_level} is of type int. @var{termcrit} is of type CvTermCriteria. \n\
@end deftypefn";
const char* _wrap_CvImage_clone_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = clone (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type CvImage. \n\
@end deftypefn";
const char* _wrap_CV_INIT_3X3_DELTAS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_INIT_3X3_DELTAS (@var{deltas}, @var{step}, @var{nch})\n\
@var{deltas} is of type double. @var{step} is of type int. @var{nch} is of type int. \n\
@end deftypefn";
const char* _wrap_IplImage___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{object})\n\
@var{self} is of type . @var{object} is of type octave_value. @var{retval} is of type octave_value. \n\
@end deftypefn";
const char* _wrap_CvMat___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{object})\n\
@var{self} is of type CvMat. @var{object} is of type octave_value. @var{retval} is of type octave_value. \n\
@end deftypefn";
const char* _wrap_CvTuple_CvPoint_2___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvTuple_CvPoint_2. @var{i} is of type int. @var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CvTuple_float_2___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvTuple_float_2. @var{i} is of type int. @var{retval} is of type float. \n\
@end deftypefn";
const char* _wrap_CvTuple_float_3___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvTuple_float_3. @var{i} is of type int. @var{retval} is of type float. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvPoint. @var{i} is of type int. @var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint2D32f___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvPoint2D32f. @var{i} is of type int. @var{retval} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvRect___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvRect. @var{i} is of type int. @var{retval} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvSeq___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvSeq. @var{i} is of type int. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvQuadEdge2D___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvQuadEdge2D. @var{i} is of type int. @var{retval} is of type CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvConnectedComp___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvConnectedComp. @var{i} is of type int. @var{retval} is of type CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint_2___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvPoint_2. @var{i} is of type int. @var{retval} is of type CvTuple_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_2___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_float_2. @var{i} is of type int. @var{retval} is of type CvTuple_float_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_3___paren_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_float_3. @var{i} is of type int. @var{retval} is of type CvTuple_float_3. \n\
@end deftypefn";
const char* _wrap_cvSeqPopMulti_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSeqPopMulti (@var{seq}, @var{elements}, @var{count}, @var{in_front} = 0)\n\
@var{seq} is of type CvSeq. @var{elements} is of type void. @var{count} is of type int. @var{in_front} is of type int. \n\
@end deftypefn";
const char* _wrap_cvMakeSeqHeaderForArray_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMakeSeqHeaderForArray (@var{seq_type}, @var{header_size}, @var{elem_size}, @var{elements}, @var{total}, @var{seq}, @var{block})\n\
@var{seq_type} is of type int. @var{header_size} is of type int. @var{elem_size} is of type int. @var{elements} is of type void. @var{total} is of type int. @var{seq} is of type CvSeq. @var{block} is of type CvSeqBlock. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvMakeHistHeaderForArray_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMakeHistHeaderForArray (@var{dims}, @var{hist}, @var{data}, @var{ranges} = nil, @var{uniform} = 1)\n\
@var{dims} is of type int. @var{hist} is of type CvHistogram. @var{data} is of type float. @var{ranges} is of type float. @var{uniform} is of type int. @var{retval} is of type CvHistogram. \n\
@end deftypefn";
const char* _wrap_new_CvSURFPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSURFPoint::CvSURFPoint ()\n\
@var{retval} is of type CvSURFPoint. \n\
@end deftypefn";
const char* _wrap_delete_CvSURFPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSURFPoint::~CvSURFPoint (@var{self})\n\
@var{self} is of type CvSURFPoint. \n\
@end deftypefn";
const char* _wrap_cvSURFPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSURFPoint (@var{pt}, @var{laplacian}, @var{size}, @var{dir} = 0, @var{hessian} = 0)\n\
@var{pt} is of type CvPoint2D32f. @var{laplacian} is of type int. @var{size} is of type int. @var{dir} is of type float. @var{hessian} is of type float. @var{retval} is of type CvSURFPoint. \n\
@end deftypefn";
const char* _wrap_CvImage_roi_size_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = roi_size (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type CvSize. \n\
@end deftypefn";
const char* _wrap_cvXorS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvXorS (@var{src}, @var{value}, @var{dst}, @var{mask} = nil)\n\
@var{src} is of type CvArr. @var{value} is of type CvScalar. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CV_IS_MAT_CONST_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_MAT_CONST (@var{mat})\n\
@var{mat} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvSize2D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSize2D32f::CvSize2D32f ()\n\
@var{retval} is of type CvSize2D32f. \n\
@end deftypefn";
const char* _wrap_delete_CvSize2D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSize2D32f::~CvSize2D32f (@var{self})\n\
@var{self} is of type CvSize2D32f. \n\
@end deftypefn";
const char* _wrap_cvSize2D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSize2D32f (@var{width}, @var{height})\n\
@var{width} is of type double. @var{height} is of type double. @var{retval} is of type CvSize2D32f. \n\
@end deftypefn";
const char* _wrap_cvAttrList_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvAttrList ()\n\
@var{retval} is of type CvAttrList. \n\
@end deftypefn";
const char* _wrap_delete_CvAttrList_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvAttrList::~CvAttrList (@var{self})\n\
@var{self} is of type CvAttrList. \n\
@end deftypefn";
const char* _wrap_new_CvAttrList_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvAttrList::CvAttrList ()\n\
@var{retval} is of type CvAttrList. \n\
@end deftypefn";
const char* _wrap_CvImage_size_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = size (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type CvSize. \n\
@end deftypefn";
const char* _wrap_cvGet1D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGet1D (@var{arr}, @var{idx0})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_CvImage_show_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} show (@var{self}, @var{window_name})\n\
@var{self} is of type CvImage. @var{window_name} is of type char. \n\
@end deftypefn";
const char* _wrap_cvCloneSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCloneSeq (@var{seq}, @var{storage} = nil)\n\
@var{seq} is of type CvSeq. @var{storage} is of type CvMemStorage. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvSeqPushMulti_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSeqPushMulti (@var{seq}, @var{elements}, @var{count}, @var{in_front} = 0)\n\
@var{seq} is of type CvSeq. @var{elements} is of type void. @var{count} is of type int. @var{in_front} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCopyMakeBorder_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCopyMakeBorder (@var{src}, @var{dst}, @var{offset}, @var{bordertype}, @var{value} = cvScalarAll(0))\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{offset} is of type CvPoint. @var{bordertype} is of type int. @var{value} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvMin_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMin (@var{src1}, @var{src2}, @var{dst})\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvGuiBoxReport_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGuiBoxReport (@var{status}, @var{func_name}, @var{err_msg}, @var{file_name}, @var{line}, @var{userdata})\n\
@var{status} is of type int. @var{func_name} is of type char. @var{err_msg} is of type char. @var{file_name} is of type char. @var{line} is of type int. @var{userdata} is of type void. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvStdErrReport_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvStdErrReport (@var{status}, @var{func_name}, @var{err_msg}, @var{file_name}, @var{line}, @var{userdata})\n\
@var{status} is of type int. @var{func_name} is of type char. @var{err_msg} is of type char. @var{file_name} is of type char. @var{line} is of type int. @var{userdata} is of type void. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvNulDevReport_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvNulDevReport (@var{status}, @var{func_name}, @var{err_msg}, @var{file_name}, @var{line}, @var{userdata})\n\
@var{status} is of type int. @var{func_name} is of type char. @var{err_msg} is of type char. @var{file_name} is of type char. @var{line} is of type int. @var{userdata} is of type void. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCountNonZero_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCountNonZero (@var{arr})\n\
@var{arr} is of type CvArr. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvSubdiv2DEdge_Wrapper_ptr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = ptr (@var{self})\n\
@var{self} is of type CvSubdiv2DEdge_Wrapper. @var{retval} is of type CvSubdiv2DEdge. \n\
@end deftypefn";
const char* _wrap_CvRNG_Wrapper_ptr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = ptr (@var{self})\n\
@var{self} is of type CvRNG_Wrapper. @var{retval} is of type CvRNG. \n\
@end deftypefn";
const char* _wrap_cvFindGraphEdge_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindGraphEdge (@var{graph}, @var{start_idx}, @var{end_idx})\n\
@var{graph} is of type CvGraph. @var{start_idx} is of type int. @var{end_idx} is of type int. @var{retval} is of type CvGraphEdge. \n\
@end deftypefn";
const char* _wrap_delete_CvGraphEdge_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvGraphEdge::~CvGraphEdge (@var{self})\n\
@var{self} is of type CvGraphEdge. \n\
@end deftypefn";
const char* _wrap_new_CvGraphEdge_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvGraphEdge::CvGraphEdge ()\n\
@var{retval} is of type CvGraphEdge. \n\
@end deftypefn";
const char* _wrap_cvConvertPointsHomogeneous_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvConvertPointsHomogeneous (@var{src}, @var{dst})\n\
@var{src} is of type CvMat. @var{dst} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_new_CvStereoGCState_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvStereoGCState::CvStereoGCState ()\n\
@var{retval} is of type CvStereoGCState. \n\
@end deftypefn";
const char* _wrap_delete_CvStereoGCState_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvStereoGCState::~CvStereoGCState (@var{self})\n\
@var{self} is of type CvStereoGCState. \n\
@end deftypefn";
const char* _wrap_cvCreateStereoGCState_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateStereoGCState (@var{numberOfDisparities}, @var{maxIters})\n\
@var{numberOfDisparities} is of type int. @var{maxIters} is of type int. @var{retval} is of type CvStereoGCState. \n\
@end deftypefn";
const char* _wrap_cvReleaseStereoGCState_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseStereoGCState (@var{state})\n\
@var{state} is of type CvStereoGCState. \n\
@end deftypefn";
const char* _wrap_cvGet2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGet2D (@var{arr}, @var{idx0}, @var{idx1})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{idx1} is of type int. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvSetND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetND (@var{arr}, @var{idx}, @var{value})\n\
@var{arr} is of type CvArr. @var{idx} is of type int. @var{value} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_new_CvPoint2D64f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvPoint2D64f::CvPoint2D64f ()\n\
@var{retval} is of type CvPoint2D64f. \n\
@end deftypefn";
const char* _wrap_delete_CvPoint2D64f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvPoint2D64f::~CvPoint2D64f (@var{self})\n\
@var{self} is of type CvPoint2D64f. \n\
@end deftypefn";
const char* _wrap_cvPoint2D64f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPoint2D64f (@var{x}, @var{y})\n\
@var{x} is of type double. @var{y} is of type double. @var{retval} is of type CvPoint2D64f. \n\
@end deftypefn";
const char* _wrap_cvClearHist_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvClearHist (@var{hist})\n\
@var{hist} is of type CvHistogram. \n\
@end deftypefn";
const char* _wrap_cvFitLine_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFitLine (@var{points}, @var{dist_type}, @var{param}, @var{reps}, @var{aeps}, @var{line})\n\
@var{points} is of type CvArr. @var{dist_type} is of type int. @var{param} is of type double. @var{reps} is of type double. @var{aeps} is of type double. @var{line} is of type float. \n\
@end deftypefn";
const char* _wrap_cvCalcMatMulDeriv_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcMatMulDeriv (@var{A}, @var{B}, @var{dABdA}, @var{dABdB})\n\
@var{A} is of type CvMat. @var{B} is of type CvMat. @var{dABdA} is of type CvMat. @var{dABdB} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvCircle_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCircle (@var{img}, @var{center}, @var{radius}, @var{color}, @var{thickness} = 1, @var{line_type} = 8, @var{shift} = 0)\n\
@var{img} is of type CvArr. @var{center} is of type CvPoint. @var{radius} is of type int. @var{color} is of type CvScalar. @var{thickness} is of type int. @var{line_type} is of type int. @var{shift} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvTuple_float_2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTuple<(float,2)>::CvTuple<(float,2)> ()\n\
@var{retval} is of type CvTuple_float_2. \n\
@end deftypefn";
const char* _wrap_delete_CvTuple_float_2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTuple<(float,2)>::~CvTuple<(float,2)> (@var{self})\n\
@var{self} is of type CvTuple_float_2. \n\
@end deftypefn";
const char* _wrap_new_CvSeq_float_2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvTuple<(float,2)>)>::CvTypedSeq<(CvTuple<(float,2)>)> ()\n\
@var{retval} is of type CvSeq_float_2. \n\
@end deftypefn";
const char* _wrap_delete_CvSeq_float_2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTypedSeq<(CvTuple<(float,2)>)>::~CvTypedSeq<(CvTuple<(float,2)>)> (@var{self})\n\
@var{self} is of type CvSeq_float_2. \n\
@end deftypefn";
const char* _wrap_new_CvTuple_float_3_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTuple<(float,3)>::CvTuple<(float,3)> ()\n\
@var{retval} is of type CvTuple_float_3. \n\
@end deftypefn";
const char* _wrap_delete_CvTuple_float_3_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTuple<(float,3)>::~CvTuple<(float,3)> (@var{self})\n\
@var{self} is of type CvTuple_float_3. \n\
@end deftypefn";
const char* _wrap_new_CvSeq_float_3_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvTuple<(float,3)>)>::CvTypedSeq<(CvTuple<(float,3)>)> ()\n\
@var{retval} is of type CvSeq_float_3. \n\
@end deftypefn";
const char* _wrap_delete_CvSeq_float_3_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTypedSeq<(CvTuple<(float,3)>)>::~CvTypedSeq<(CvTuple<(float,3)>)> (@var{self})\n\
@var{self} is of type CvSeq_float_3. \n\
@end deftypefn";
const char* _wrap_cvStereoCalibrate_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvStereoCalibrate (@var{object_points}, @var{image_points1}, @var{image_points2}, @var{npoints}, @var{camera_matrix1}, @var{dist_coeffs1}, @var{camera_matrix2}, @var{dist_coeffs2}, @var{image_size}, @var{R}, @var{T}, @var{E} = 0, @var{F} = 0, @var{term_crit} = cvTermCriteria( 1 +2,30,1e-6), @var{flags} = 256)\n\
@var{object_points} is of type CvMat. @var{image_points1} is of type CvMat. @var{image_points2} is of type CvMat. @var{npoints} is of type CvMat. @var{camera_matrix1} is of type CvMat. @var{dist_coeffs1} is of type CvMat. @var{camera_matrix2} is of type CvMat. @var{dist_coeffs2} is of type CvMat. @var{image_size} is of type CvSize. @var{R} is of type CvMat. @var{T} is of type CvMat. @var{E} is of type CvMat. @var{F} is of type CvMat. @var{term_crit} is of type CvTermCriteria. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSetReal1D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetReal1D (@var{arr}, @var{idx0}, @var{value})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{value} is of type double. \n\
@end deftypefn";
const char* _wrap_cvGetReal1D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetReal1D (@var{arr}, @var{idx0})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvSVD_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSVD (@var{A}, @var{W}, @var{U} = nil, @var{V} = nil, @var{flags} = 0)\n\
@var{A} is of type CvArr. @var{W} is of type CvArr. @var{U} is of type CvArr. @var{V} is of type CvArr. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_CvMatrix_read_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = read (@var{self}, @var{fs}, @var{seqname}, @var{idx})\n\
@var{self} is of type CvMatrix. @var{fs} is of type CvFileStorage. @var{seqname} is of type char. @var{idx} is of type int. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvConnectedComp_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type CvSeq_CvConnectedComp. @var{retval} is of type CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_cvThreshHist_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvThreshHist (@var{hist}, @var{threshold})\n\
@var{hist} is of type CvHistogram. @var{threshold} is of type double. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_CONTOUR_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_CONTOUR (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_CHAIN_CONTOUR_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_CHAIN_CONTOUR (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGet3D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGet3D (@var{arr}, @var{idx0}, @var{idx1}, @var{idx2})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{idx1} is of type int. @var{idx2} is of type int. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_delete_CvMatND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMatND (@var{self})\n\
@var{self} is of type CvMatND. \n\
@end deftypefn";
const char* _wrap_cvFindFeaturesBoxed_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindFeaturesBoxed (@var{tr}, @var{bounds_min}, @var{bounds_max}, @var{out_indices})\n\
@var{tr} is of type CvFeatureTree. @var{bounds_min} is of type CvMat. @var{bounds_max} is of type CvMat. @var{out_indices} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvImage_set_coi_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} set_coi (@var{self}, @var{coi})\n\
@var{self} is of type CvImage. @var{coi} is of type int. \n\
@end deftypefn";
const char* _wrap_cvFillPoly_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFillPoly (@var{img}, @var{pts}, @var{npts}, @var{contours}, @var{color}, @var{line_type} = 8, @var{shift} = 0)\n\
@var{img} is of type CvArr. @var{pts} is of type CvPoint. @var{npts} is of type int. @var{contours} is of type int. @var{color} is of type CvScalar. @var{line_type} is of type int. @var{shift} is of type int. \n\
@end deftypefn";
const char* _wrap_cvTypeOf_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvTypeOf (@var{struct_ptr})\n\
@var{struct_ptr} is of type void. @var{retval} is of type CvTypeInfo. \n\
@end deftypefn";
const char* _wrap_cvPolyLine_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPolyLine (@var{img}, @var{pts}, @var{npts}, @var{contours}, @var{is_closed}, @var{color}, @var{thickness} = 1, @var{line_type} = 8, @var{shift} = 0)\n\
@var{img} is of type CvArr. @var{pts} is of type CvPoint. @var{npts} is of type int. @var{contours} is of type int. @var{is_closed} is of type int. @var{color} is of type CvScalar. @var{thickness} is of type int. @var{line_type} is of type int. @var{shift} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPointVector_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{x})\n\
@var{self} is of type CvPointVector. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_FloatVector_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{x})\n\
@var{self} is of type FloatVector. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{obj})\n\
@var{self} is of type CvSeq_CvPoint. @var{obj} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint2D32f_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{obj})\n\
@var{self} is of type CvSeq_CvPoint2D32f. @var{obj} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvRect_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{obj})\n\
@var{self} is of type CvSeq_CvRect. @var{obj} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvSeq_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{obj})\n\
@var{self} is of type CvSeq_CvSeq. @var{obj} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvQuadEdge2D_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{obj})\n\
@var{self} is of type CvSeq_CvQuadEdge2D. @var{obj} is of type CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvConnectedComp_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{obj})\n\
@var{self} is of type CvSeq_CvConnectedComp. @var{obj} is of type CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint_2_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{obj})\n\
@var{self} is of type CvSeq_CvPoint_2. @var{obj} is of type CvTuple_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_2_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{obj})\n\
@var{self} is of type CvSeq_float_2. @var{obj} is of type CvTuple_float_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_3_append_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} append (@var{self}, @var{obj})\n\
@var{self} is of type CvSeq_float_3. @var{obj} is of type CvTuple_float_3. \n\
@end deftypefn";
const char* _wrap_cvInitTreeNodeIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInitTreeNodeIterator (@var{tree_iterator}, @var{first}, @var{max_level})\n\
@var{tree_iterator} is of type CvTreeNodeIterator. @var{first} is of type void. @var{max_level} is of type int. \n\
@end deftypefn";
const char* _wrap_delete_CvTreeNodeIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTreeNodeIterator::~CvTreeNodeIterator (@var{self})\n\
@var{self} is of type CvTreeNodeIterator. \n\
@end deftypefn";
const char* _wrap_new_CvTreeNodeIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTreeNodeIterator::CvTreeNodeIterator ()\n\
@var{retval} is of type CvTreeNodeIterator. \n\
@end deftypefn";
const char* _wrap_cvInitLineIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvInitLineIterator (@var{image}, @var{pt1}, @var{pt2}, @var{line_iterator}, @var{connectivity} = 8, @var{left_to_right} = 0)\n\
@var{image} is of type CvArr. @var{pt1} is of type CvPoint. @var{pt2} is of type CvPoint. @var{line_iterator} is of type CvLineIterator. @var{connectivity} is of type int. @var{left_to_right} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvInitNArrayIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvInitNArrayIterator (@var{count}, @var{arrs}, @var{mask}, @var{stubs}, @var{array_iterator}, @var{flags} = 0)\n\
@var{count} is of type int. @var{arrs} is of type CvArr. @var{mask} is of type CvArr. @var{stubs} is of type CvMatND. @var{array_iterator} is of type CvNArrayIterator. @var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_delete_CvNArrayIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvNArrayIterator::~CvNArrayIterator (@var{self})\n\
@var{self} is of type CvNArrayIterator. \n\
@end deftypefn";
const char* _wrap_new_CvNArrayIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvNArrayIterator::CvNArrayIterator ()\n\
@var{retval} is of type CvNArrayIterator. \n\
@end deftypefn";
const char* _wrap_cvInitSparseMatIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvInitSparseMatIterator (@var{mat}, @var{mat_iterator})\n\
@var{mat} is of type CvSparseMat. @var{mat_iterator} is of type CvSparseMatIterator. @var{retval} is of type CvSparseNode. \n\
@end deftypefn";
const char* _wrap_delete_OctSwigIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} swig::~OctSwigIterator (@var{self})\n\
@var{self} is of type OctSwigIterator. \n\
@end deftypefn";
const char* _wrap_new_CvSparseMatIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSparseMatIterator::CvSparseMatIterator ()\n\
@var{retval} is of type CvSparseMatIterator. \n\
@end deftypefn";
const char* _wrap_delete_CvSparseMatIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSparseMatIterator::~CvSparseMatIterator (@var{self})\n\
@var{self} is of type CvSparseMatIterator. \n\
@end deftypefn";
const char* _wrap_new_CvLineIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvLineIterator::CvLineIterator ()\n\
@var{retval} is of type CvLineIterator. \n\
@end deftypefn";
const char* _wrap_delete_CvLineIterator_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvLineIterator::~CvLineIterator (@var{self})\n\
@var{self} is of type CvLineIterator. \n\
@end deftypefn";
const char* _wrap_CV_NODE_IS_COLLECTION_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_IS_COLLECTION (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvFindStereoCorrespondenceBM_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFindStereoCorrespondenceBM (@var{left}, @var{right}, @var{disparity}, @var{state})\n\
@var{left} is of type CvArr. @var{right} is of type CvArr. @var{disparity} is of type CvArr. @var{state} is of type CvStereoBMState. \n\
@end deftypefn";
const char* _wrap_cvFindNearestPoint2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindNearestPoint2D (@var{subdiv}, @var{pt})\n\
@var{subdiv} is of type CvSubdiv2D. @var{pt} is of type CvPoint2D32f. @var{retval} is of type CvSubdiv2DPoint. \n\
@end deftypefn";
const char* _wrap_cvSetReal2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetReal2D (@var{arr}, @var{idx0}, @var{idx1}, @var{value})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{idx1} is of type int. @var{value} is of type double. \n\
@end deftypefn";
const char* _wrap_cvGetReal2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetReal2D (@var{arr}, @var{idx0}, @var{idx1})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{idx1} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvIsInf_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvIsInf (@var{value})\n\
@var{value} is of type double. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_SEQ_ELTYPE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_SEQ_ELTYPE (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPointVector_end_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = end (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type const_iterator. \n\
@end deftypefn";
const char* _wrap_FloatVector_end_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = end (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type const_iterator. \n\
@end deftypefn";
const char* _wrap_CvMatrix_row_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = row (@var{self}, @var{i})\n\
@var{self} is of type CvMatrix. @var{i} is of type int. @var{retval} is of type uchar. \n\
@end deftypefn";
const char* _wrap_delete_Cv32suf_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} Cv32suf::~Cv32suf (@var{self})\n\
@var{self} is of type Cv32suf. \n\
@end deftypefn";
const char* _wrap_new_Cv32suf_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = Cv32suf::Cv32suf ()\n\
@var{retval} is of type Cv32suf. \n\
@end deftypefn";
const char* _wrap_IplImage___rlt___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rlt__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMat___rlt___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rlt__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvCalcBackProject_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcBackProject (@var{image}, @var{dst}, @var{hist})\n\
@var{image} is of type . @var{dst} is of type CvArr. @var{hist} is of type CvHistogram. \n\
@end deftypefn";
const char* _wrap_cvCalcArrBackProject_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcArrBackProject (@var{image}, @var{dst}, @var{hist})\n\
@var{image} is of type CvArr. @var{dst} is of type CvArr. @var{hist} is of type CvHistogram. \n\
@end deftypefn";
const char* _wrap_cvFilter2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFilter2D (@var{src}, @var{dst}, @var{kernel}, @var{anchor} = cvPoint(-1,-1))\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{kernel} is of type CvMat. @var{anchor} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type CvSeq_CvPoint. @var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CV_IS_SET_ELEM_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SET_ELEM (@var{ptr})\n\
@var{ptr} is of type void. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvPOSIT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPOSIT (@var{posit_object}, @var{image_points}, @var{focal_length}, @var{criteria}, @var{rotation_matrix}, @var{translation_vector})\n\
@var{posit_object} is of type CvPOSITObject. @var{image_points} is of type CvPoint2D32f. @var{focal_length} is of type double. @var{criteria} is of type CvTermCriteria. @var{rotation_matrix} is of type CvMatr32f. @var{translation_vector} is of type CvVect32f. \n\
@end deftypefn";
const char* _wrap_cvConvertScaleAbs_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvConvertScaleAbs (@var{src}, @var{dst}, @var{scale} = 1, @var{shift} = 0)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{scale} is of type double. @var{shift} is of type double. \n\
@end deftypefn";
const char* _wrap_cvCalcOpticalFlowHS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcOpticalFlowHS (@var{prev}, @var{curr}, @var{use_previous}, @var{velx}, @var{vely}, @var{lambda}, @var{criteria})\n\
@var{prev} is of type CvArr. @var{curr} is of type CvArr. @var{use_previous} is of type int. @var{velx} is of type CvArr. @var{vely} is of type CvArr. @var{lambda} is of type double. @var{criteria} is of type CvTermCriteria. \n\
@end deftypefn";
const char* _wrap_cvMaxRect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMaxRect (@var{rect1}, @var{rect2})\n\
@var{rect1} is of type CvRect. @var{rect2} is of type CvRect. @var{retval} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_cvRANSACUpdateNumIters_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRANSACUpdateNumIters (@var{p}, @var{err_prob}, @var{model_points}, @var{max_iters})\n\
@var{p} is of type double. @var{err_prob} is of type double. @var{model_points} is of type int. @var{max_iters} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_3_cast_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvTuple<(float,3)>)>::cast (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type CvSeq_float_3. \n\
@end deftypefn";
const char* _wrap_cvRepeat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRepeat (@var{src}, @var{dst})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvReleaseLSH_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseLSH (@var{lsh})\n\
@var{lsh} is of type CvLSH. \n\
@end deftypefn";
const char* _wrap_cvCalcSubdivVoronoi2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcSubdivVoronoi2D (@var{subdiv})\n\
@var{subdiv} is of type CvSubdiv2D. \n\
@end deftypefn";
const char* _wrap_cvClearSubdivVoronoi2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvClearSubdivVoronoi2D (@var{subdiv})\n\
@var{subdiv} is of type CvSubdiv2D. \n\
@end deftypefn";
const char* _wrap_cvApproxPoly_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvApproxPoly_Shadow (@var{src_seq}, @var{header_size}, @var{storage}, @var{method}, @var{parameter})\n\
@var{src_seq} is of type void. @var{header_size} is of type int. @var{storage} is of type CvMemStorage. @var{method} is of type int. @var{parameter} is of type double. @var{retval} is of type CvSeq_CvPoint. \n\
@end deftypefn";
const char* _wrap_cvSetReal3D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetReal3D (@var{arr}, @var{idx0}, @var{idx1}, @var{idx2}, @var{value})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{idx1} is of type int. @var{idx2} is of type int. @var{value} is of type double. \n\
@end deftypefn";
const char* _wrap_cvGetReal3D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetReal3D (@var{arr}, @var{idx0}, @var{idx1}, @var{idx2})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{idx1} is of type int. @var{idx2} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvAnd_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAnd (@var{src1}, @var{src2}, @var{dst}, @var{mask} = nil)\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvError_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvError (@var{status}, @var{func_name}, @var{err_msg}, @var{file_name}, @var{line})\n\
@var{status} is of type int. @var{func_name} is of type char. @var{err_msg} is of type char. @var{file_name} is of type char. @var{line} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSampleLine_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSampleLine (@var{image}, @var{pt1}, @var{pt2}, @var{buffer}, @var{connectivity} = 8)\n\
@var{image} is of type CvArr. @var{pt1} is of type CvPoint. @var{pt2} is of type CvPoint. @var{buffer} is of type void. @var{connectivity} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvInitFont_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInitFont (@var{font}, @var{hscale}, @var{vscale}, @var{shear} = 0, @var{thickness} = 1, @var{line_type} = 8)\n\
@var{font} is of type CvFont. @var{hscale} is of type double. @var{vscale} is of type double. @var{shear} is of type double. @var{thickness} is of type int. @var{line_type} is of type int. \n\
@end deftypefn";
const char* _wrap_CvMatrix_rows_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = rows (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCheckContourConvexity_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCheckContourConvexity (@var{contour})\n\
@var{contour} is of type CvArr. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvAbsDiff_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAbsDiff (@var{src1}, @var{src2}, @var{dst})\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvMemStorageAlloc_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMemStorageAlloc (@var{storage}, @var{size})\n\
@var{storage} is of type CvMemStorage. @var{size} is of type size_t. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_cvConDensUpdateByTime_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvConDensUpdateByTime (@var{condens})\n\
@var{condens} is of type CvConDensation. \n\
@end deftypefn";
const char* _wrap_new_CvTuple_CvPoint_2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTuple<(CvPoint,2)>::CvTuple<(CvPoint,2)> ()\n\
@var{retval} is of type CvTuple_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_delete_CvTuple_CvPoint_2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTuple<(CvPoint,2)>::~CvTuple<(CvPoint,2)> (@var{self})\n\
@var{self} is of type CvTuple_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_new_CvSeq_CvPoint_2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvTuple<(CvPoint,2)>)>::CvTypedSeq<(CvTuple<(CvPoint,2)>)> ()\n\
@var{retval} is of type CvSeq_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_delete_CvSeq_CvPoint_2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTypedSeq<(CvTuple<(CvPoint,2)>)>::~CvTypedSeq<(CvTuple<(CvPoint,2)>)> (@var{self})\n\
@var{self} is of type CvSeq_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_delete_CvPluginFuncInfo_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvPluginFuncInfo::~CvPluginFuncInfo (@var{self})\n\
@var{self} is of type CvPluginFuncInfo. \n\
@end deftypefn";
const char* _wrap_new_CvPluginFuncInfo_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvPluginFuncInfo::CvPluginFuncInfo ()\n\
@var{retval} is of type CvPluginFuncInfo. \n\
@end deftypefn";
const char* _wrap_cvRNG_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRNG ()\n\
@var{retval} is of type CvRNG. \n\
@end deftypefn";
const char* _wrap_CV_8SC_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_8SC (@var{n})\n\
@var{n} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvMatrix_load_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = load (@var{self}, @var{filename})\n\
@var{self} is of type CvMatrix. @var{filename} is of type char. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_cvScaleAdd_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvScaleAdd (@var{src1}, @var{scale}, @var{src2}, @var{dst})\n\
@var{src1} is of type CvArr. @var{scale} is of type CvScalar. @var{src2} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_IplImage___div___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator / (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___div___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator / (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvUndistort2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvUndistort2 (@var{src}, @var{dst}, @var{camera_matrix}, @var{distortion_coeffs})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{camera_matrix} is of type CvMat. @var{distortion_coeffs} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CvMatrix_clear_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} clear (@var{self})\n\
@var{self} is of type CvMatrix. \n\
@end deftypefn";
const char* _wrap_CvPointVector_clear_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} clear (@var{self})\n\
@var{self} is of type CvPointVector. \n\
@end deftypefn";
const char* _wrap_FloatVector_clear_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} clear (@var{self})\n\
@var{self} is of type FloatVector. \n\
@end deftypefn";
const char* _wrap_CvPointVector___paren_asgn___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn__ (@var{self}, @var{i}, @var{x})\n\
@var{self} is of type CvPointVector. @var{i} is of type difference_type. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_FloatVector___paren_asgn___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __paren_asgn__ (@var{self}, @var{i}, @var{x})\n\
@var{self} is of type FloatVector. @var{i} is of type difference_type. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_cvReadReal_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvReadReal (@var{node}, @var{default_value} = 0.)\n\
@var{node} is of type CvFileNode. @var{default_value} is of type double. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvStereoRectifyUncalibrated_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvStereoRectifyUncalibrated (@var{points1}, @var{points2}, @var{F}, @var{img_size}, @var{H1}, @var{H2}, @var{threshold} = 5)\n\
@var{points1} is of type CvMat. @var{points2} is of type CvMat. @var{F} is of type CvMat. @var{img_size} is of type CvSize. @var{H1} is of type CvMat. @var{H2} is of type CvMat. @var{threshold} is of type double. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_delete_CvHistogram_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvHistogram (@var{self})\n\
@var{self} is of type CvHistogram. \n\
@end deftypefn";
const char* _wrap_CV_READ_EDGE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_READ_EDGE (@var{pt1}, @var{pt2}, @var{reader})\n\
@var{pt1} is of type CvPoint. @var{pt2} is of type CvPoint. @var{reader} is of type CvSeqReader. \n\
@end deftypefn";
const char* _wrap_cvCalibrationMatrixValues_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalibrationMatrixValues (@var{camera_matrix}, @var{image_size}, @var{aperture_width} = 0, @var{aperture_height} = 0, @var{fovx} = nil, @var{fovy} = nil, @var{focal_length} = nil, @var{principal_point} = nil, @var{pixel_aspect_ratio} = nil)\n\
@var{camera_matrix} is of type CvMat. @var{image_size} is of type CvSize. @var{aperture_width} is of type double. @var{aperture_height} is of type double. @var{fovx} is of type double. @var{fovy} is of type double. @var{focal_length} is of type double. @var{principal_point} is of type CvPoint2D64f. @var{pixel_aspect_ratio} is of type double. \n\
@end deftypefn";
const char* _wrap_cvCartToPolar_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCartToPolar (@var{x}, @var{y}, @var{magnitude}, @var{angle} = nil, @var{angle_in_degrees} = 0)\n\
@var{x} is of type CvArr. @var{y} is of type CvArr. @var{magnitude} is of type CvArr. @var{angle} is of type CvArr. @var{angle_in_degrees} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvType_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvType (@var{type_name}, @var{is_instance})\n\
@var{type_name} is of type char. @var{is_instance} is of type CvIsInstanceFunc. @var{retval} is of type CvType. \n\
@end deftypefn";
const char* _wrap_delete_CvType_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvType (@var{self})\n\
@var{self} is of type CvType. \n\
@end deftypefn";
const char* _wrap_cvDrawContours_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvDrawContours (@var{img}, @var{contour}, @var{external_color}, @var{hole_color}, @var{max_level}, @var{thickness} = 1, @var{line_type} = 8, @var{offset} = cvPoint(0,0))\n\
@var{img} is of type CvArr. @var{contour} is of type CvSeq. @var{external_color} is of type CvScalar. @var{hole_color} is of type CvScalar. @var{max_level} is of type int. @var{thickness} is of type int. @var{line_type} is of type int. @var{offset} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_cvStartFindContours_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvStartFindContours (@var{image}, @var{storage}, @var{header_size} = sizeof(CvContour), @var{mode} = 1, @var{method} = 2, @var{offset} = cvPoint(0,0))\n\
@var{image} is of type CvArr. @var{storage} is of type CvMemStorage. @var{header_size} is of type int. @var{mode} is of type int. @var{method} is of type int. @var{offset} is of type CvPoint. @var{retval} is of type CvContourScanner. \n\
@end deftypefn";
const char* _wrap_cvEndFindContours_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvEndFindContours (@var{scanner})\n\
@var{scanner} is of type CvContourScanner. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_CV_IS_HIST_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_HIST (@var{hist})\n\
@var{hist} is of type CvHistogram. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvScalarAll_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvScalarAll (@var{val0123})\n\
@var{val0123} is of type double. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvCalcMotionGradient_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcMotionGradient (@var{mhi}, @var{mask}, @var{orientation}, @var{delta1}, @var{delta2}, @var{aperture_size} = 3)\n\
@var{mhi} is of type CvArr. @var{mask} is of type CvArr. @var{orientation} is of type CvArr. @var{delta1} is of type double. @var{delta2} is of type double. @var{aperture_size} is of type int. \n\
@end deftypefn";
const char* _wrap_cvAXPY_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAXPY (@var{A}, @var{real_scalar}, @var{B}, @var{C})\n\
@var{A} is of type CvArr. @var{real_scalar} is of type double. @var{B} is of type CvArr. @var{C} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvExtractMSER_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvExtractMSER (@var{_img}, @var{_mask}, @var{contours}, @var{storage}, @var{params})\n\
@var{_img} is of type CvArr. @var{_mask} is of type CvArr. @var{contours} is of type CvSeq. @var{storage} is of type CvMemStorage. @var{params} is of type CvMSERParams. \n\
@end deftypefn";
const char* _wrap_cvRandInt_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRandInt (@var{rng})\n\
@var{rng} is of type CvRNG. @var{retval} is of type unsigned int. \n\
@end deftypefn";
const char* _wrap_delete_CvConDensation_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvConDensation (@var{self})\n\
@var{self} is of type CvConDensation. \n\
@end deftypefn";
const char* _wrap_cvCreateConDensation_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateConDensation (@var{dynam_params}, @var{measure_params}, @var{sample_count})\n\
@var{dynam_params} is of type int. @var{measure_params} is of type int. @var{sample_count} is of type int. @var{retval} is of type CvConDensation. \n\
@end deftypefn";
const char* _wrap_cvReleaseConDensation_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseConDensation (@var{condens})\n\
@var{condens} is of type CvConDensation. \n\
@end deftypefn";
const char* _wrap_cvSqrt_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSqrt (@var{value})\n\
@var{value} is of type double. \n\
@end deftypefn";
const char* _wrap_CV_NODE_IS_FLOW_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_IS_FLOW (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvDet_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvDet (@var{mat})\n\
@var{mat} is of type CvArr. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvPointTo32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPointTo32f (@var{point})\n\
@var{point} is of type CvPoint. @var{retval} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_CV_SUBDIV2D_NEXT_EDGE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_SUBDIV2D_NEXT_EDGE (@var{edge})\n\
@var{edge} is of type CvSubdiv2DEdge. @var{retval} is of type CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_CV_HIST_HAS_RANGES_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_HIST_HAS_RANGES (@var{hist})\n\
@var{hist} is of type CvHistogram. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_8UC_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_8UC (@var{n})\n\
@var{n} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_delete_CvHaarClassifierCascade_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvHaarClassifierCascade (@var{self})\n\
@var{self} is of type CvHaarClassifierCascade. \n\
@end deftypefn";
const char* _wrap_cvLoadHaarClassifierCascade_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvLoadHaarClassifierCascade (@var{directory}, @var{orig_window_size})\n\
@var{directory} is of type char. @var{orig_window_size} is of type CvSize. @var{retval} is of type CvHaarClassifierCascade. \n\
@end deftypefn";
const char* _wrap_cvReleaseHaarClassifierCascade_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseHaarClassifierCascade (@var{cascade})\n\
@var{cascade} is of type CvHaarClassifierCascade. \n\
@end deftypefn";
const char* _wrap_cvSetImagesForHaarClassifierCascade_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetImagesForHaarClassifierCascade (@var{cascade}, @var{sum}, @var{sqsum}, @var{tilted_sum}, @var{scale})\n\
@var{cascade} is of type CvHaarClassifierCascade. @var{sum} is of type CvArr. @var{sqsum} is of type CvArr. @var{tilted_sum} is of type CvArr. @var{scale} is of type double. \n\
@end deftypefn";
const char* _wrap_cvRunHaarClassifierCascade_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRunHaarClassifierCascade (@var{cascade}, @var{pt}, @var{start_stage} = 0)\n\
@var{cascade} is of type CvHaarClassifierCascade. @var{pt} is of type CvPoint. @var{start_stage} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvAndS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAndS (@var{src}, @var{value}, @var{dst}, @var{mask} = nil)\n\
@var{src} is of type CvArr. @var{value} is of type CvScalar. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvImage_roi_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = roi (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_CvSubdiv2DEdge_Wrapper_ref_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = ref (@var{self})\n\
@var{self} is of type CvSubdiv2DEdge_Wrapper. @var{retval} is of type CvSubdiv2DEdge. \n\
@end deftypefn";
const char* _wrap_CvRNG_Wrapper_ref_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = ref (@var{self})\n\
@var{self} is of type CvRNG_Wrapper. @var{retval} is of type CvRNG. \n\
@end deftypefn";
const char* _wrap_cvInpaint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInpaint (@var{src}, @var{inpaint_mask}, @var{dst}, @var{inpaintRange}, @var{flags})\n\
@var{src} is of type CvArr. @var{inpaint_mask} is of type CvArr. @var{dst} is of type CvArr. @var{inpaintRange} is of type double. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_cvStartNextStream_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvStartNextStream (@var{fs})\n\
@var{fs} is of type CvFileStorage. \n\
@end deftypefn";
const char* _wrap_cvWatershed_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvWatershed (@var{image}, @var{markers})\n\
@var{image} is of type CvArr. @var{markers} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvResetImageROI_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvResetImageROI (@var{image})\n\
@var{image} is of type . \n\
@end deftypefn";
const char* _wrap_cvCalcOpticalFlowLK_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcOpticalFlowLK (@var{prev}, @var{curr}, @var{win_size}, @var{velx}, @var{vely})\n\
@var{prev} is of type CvArr. @var{curr} is of type CvArr. @var{win_size} is of type CvSize. @var{velx} is of type CvArr. @var{vely} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvImage_clear_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} clear (@var{self})\n\
@var{self} is of type CvImage. \n\
@end deftypefn";
const char* _wrap_new_CvPoint3D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvPoint3D32f::CvPoint3D32f ()\n\
@var{retval} is of type CvPoint3D32f. \n\
@end deftypefn";
const char* _wrap_delete_CvPoint3D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvPoint3D32f::~CvPoint3D32f (@var{self})\n\
@var{self} is of type CvPoint3D32f. \n\
@end deftypefn";
const char* _wrap_cvPoint3D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPoint3D32f (@var{x}, @var{y}, @var{z})\n\
@var{x} is of type double. @var{y} is of type double. @var{z} is of type double. @var{retval} is of type CvPoint3D32f. \n\
@end deftypefn";
const char* _wrap_CV_NEXT_GRAPH_EDGE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NEXT_GRAPH_EDGE (@var{edge}, @var{vertex})\n\
@var{edge} is of type CvGraphEdge. @var{vertex} is of type CvGraphVtx. @var{retval} is of type CvGraphEdge. \n\
@end deftypefn";
const char* _wrap_cvGraphRemoveEdge_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGraphRemoveEdge (@var{graph}, @var{start_idx}, @var{end_idx})\n\
@var{graph} is of type CvGraph. @var{start_idx} is of type int. @var{end_idx} is of type int. \n\
@end deftypefn";
const char* _wrap_cvFindStereoCorrespondenceGC_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFindStereoCorrespondenceGC (@var{left}, @var{right}, @var{disparityLeft}, @var{disparityRight}, @var{state}, @var{useDisparityGuess} = 0)\n\
@var{left} is of type CvArr. @var{right} is of type CvArr. @var{disparityLeft} is of type CvArr. @var{disparityRight} is of type CvArr. @var{state} is of type CvStereoGCState. @var{useDisparityGuess} is of type int. \n\
@end deftypefn";
const char* _wrap_cvFlip_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFlip (@var{src}, @var{dst} = nil, @var{flip_mode} = 0)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{flip_mode} is of type int. \n\
@end deftypefn";
const char* _wrap_cvKalmanPredict_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvKalmanPredict (@var{kalman}, @var{control} = nil)\n\
@var{kalman} is of type CvKalman. @var{control} is of type CvMat. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvGetDiag_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetDiag (@var{arr}, @var{submat}, @var{diag} = 0)\n\
@var{arr} is of type CvArr. @var{submat} is of type CvMat. @var{diag} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvMinMaxLoc_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMinMaxLoc (@var{arr}, @var{min_val}, @var{max_val}, @var{min_loc} = nil, @var{max_loc} = nil, @var{mask} = nil)\n\
@var{arr} is of type CvArr. @var{min_val} is of type double. @var{max_val} is of type double. @var{min_loc} is of type CvPoint. @var{max_loc} is of type CvPoint. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvPointVector_swap_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} swap (@var{self}, @var{v})\n\
@var{self} is of type CvPointVector. @var{v} is of type CvPointVector. \n\
@end deftypefn";
const char* _wrap_FloatVector_swap_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} swap (@var{self}, @var{v})\n\
@var{self} is of type FloatVector. @var{v} is of type FloatVector. \n\
@end deftypefn";
const char* _wrap_cvEndWriteSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvEndWriteSeq (@var{writer})\n\
@var{writer} is of type CvSeqWriter. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvStartWriteSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvStartWriteSeq (@var{seq_flags}, @var{header_size}, @var{elem_size}, @var{storage}, @var{writer})\n\
@var{seq_flags} is of type int. @var{header_size} is of type int. @var{elem_size} is of type int. @var{storage} is of type CvMemStorage. @var{writer} is of type CvSeqWriter. \n\
@end deftypefn";
const char* _wrap_cvRectToROI_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRectToROI (@var{rect}, @var{coi})\n\
@var{rect} is of type CvRect. @var{coi} is of type int. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_cvSave_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSave (@var{filename}, @var{struct_ptr}, @var{name} = nil, @var{comment} = nil, @var{attributes} = cvAttrList())\n\
@var{filename} is of type char. @var{struct_ptr} is of type void. @var{name} is of type char. @var{comment} is of type char. @var{attributes} is of type CvAttrList. \n\
@end deftypefn";
const char* _wrap_IplImage___rxor___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rxor__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___rxor___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rxor__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvLogPolar_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvLogPolar (@var{src}, @var{dst}, @var{center}, @var{M}, @var{flags} = 1+8)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{center} is of type CvPoint2D32f. @var{M} is of type double. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCvtSeqToArray_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCvtSeqToArray_Shadow (@var{seq}, @var{elements})\n\
@var{seq} is of type CvSeq. @var{elements} is of type CvArr. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CV_MAT_DEPTH_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_MAT_DEPTH (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvThreshold_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvThreshold (@var{src}, @var{dst}, @var{threshold}, @var{max_value}, @var{threshold_type})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{threshold} is of type double. @var{max_value} is of type double. @var{threshold_type} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvAdaptiveThreshold_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAdaptiveThreshold (@var{src}, @var{dst}, @var{max_value}, @var{adaptive_method} = 0, @var{threshold_type} = 0, @var{block_size} = 3, @var{param1} = 5)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{max_value} is of type double. @var{adaptive_method} is of type int. @var{threshold_type} is of type int. @var{block_size} is of type int. @var{param1} is of type double. \n\
@end deftypefn";
const char* _wrap_cvEndWriteStruct_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvEndWriteStruct (@var{fs})\n\
@var{fs} is of type CvFileStorage. \n\
@end deftypefn";
const char* _wrap_cvStartWriteStruct_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvStartWriteStruct (@var{fs}, @var{name}, @var{struct_flags}, @var{type_name} = nil, @var{attributes} = cvAttrList())\n\
@var{fs} is of type CvFileStorage. @var{name} is of type char. @var{struct_flags} is of type int. @var{type_name} is of type char. @var{attributes} is of type CvAttrList. \n\
@end deftypefn";
const char* _wrap_new_CvMatrix3_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvMatrix3::CvMatrix3 ()\n\
@var{retval} is of type CvMatrix3. \n\
@end deftypefn";
const char* _wrap_delete_CvMatrix3_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMatrix3::~CvMatrix3 (@var{self})\n\
@var{self} is of type CvMatrix3. \n\
@end deftypefn";
const char* _wrap_CV_IS_GRAPH_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_GRAPH (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvPointSeqFromMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPointSeqFromMat (@var{seq_kind}, @var{mat}, @var{contour_header}, @var{block})\n\
@var{seq_kind} is of type int. @var{mat} is of type CvArr. @var{contour_header} is of type CvContour. @var{block} is of type CvSeqBlock. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvReleaseMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseMat (@var{mat})\n\
@var{mat} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvConvert_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvConvert (@var{src}, @var{dst})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvSeqPush_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSeqPush (@var{seq}, @var{element} = nil)\n\
@var{seq} is of type CvSeq. @var{element} is of type void. @var{retval} is of type schar. \n\
@end deftypefn";
const char* _wrap_delete_CvGraph_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvGraph::~CvGraph (@var{self})\n\
@var{self} is of type CvGraph. \n\
@end deftypefn";
const char* _wrap_new_CvGraph_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvGraph::CvGraph ()\n\
@var{retval} is of type CvGraph. \n\
@end deftypefn";
const char* _wrap_cvFirstType_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFirstType ()\n\
@var{retval} is of type CvTypeInfo. \n\
@end deftypefn";
const char* _wrap_CvTuple_CvPoint_2___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvTuple_CvPoint_2. @var{i} is of type int. @var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CvTuple_float_2___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvTuple_float_2. @var{i} is of type int. @var{retval} is of type float. \n\
@end deftypefn";
const char* _wrap_CvTuple_float_3___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvTuple_float_3. @var{i} is of type int. @var{retval} is of type float. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvPoint. @var{i} is of type int. @var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint2D32f___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvPoint2D32f. @var{i} is of type int. @var{retval} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvRect___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvRect. @var{i} is of type int. @var{retval} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvSeq___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvSeq. @var{i} is of type int. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvQuadEdge2D___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvQuadEdge2D. @var{i} is of type int. @var{retval} is of type CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvConnectedComp___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvConnectedComp. @var{i} is of type int. @var{retval} is of type CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint_2___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_CvPoint_2. @var{i} is of type int. @var{retval} is of type CvTuple_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_2___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_float_2. @var{i} is of type int. @var{retval} is of type CvTuple_float_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_3___brace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __brace (@var{self}, @var{i})\n\
@var{self} is of type CvSeq_float_3. @var{i} is of type int. @var{retval} is of type CvTuple_float_3. \n\
@end deftypefn";
const char* _wrap_cvRandArr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRandArr (@var{rng}, @var{arr}, @var{dist_type}, @var{param1}, @var{param2})\n\
@var{rng} is of type CvRNG. @var{arr} is of type CvArr. @var{dist_type} is of type int. @var{param1} is of type CvScalar. @var{param2} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvClearGraph_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvClearGraph (@var{graph})\n\
@var{graph} is of type CvGraph. \n\
@end deftypefn";
const char* _wrap_cvGetHashedKey_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetHashedKey (@var{fs}, @var{name}, @var{len} = -1, @var{create_missing} = 0)\n\
@var{fs} is of type CvFileStorage. @var{name} is of type char. @var{len} is of type int. @var{create_missing} is of type int. @var{retval} is of type CvStringHashNode. \n\
@end deftypefn";
const char* _wrap_cvGEMM_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGEMM (@var{src1}, @var{src2}, @var{alpha}, @var{src3}, @var{beta}, @var{dst}, @var{tABC} = 0)\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{alpha} is of type double. @var{src3} is of type CvArr. @var{beta} is of type double. @var{dst} is of type CvArr. @var{tABC} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCreateKalman_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateKalman (@var{dynam_params}, @var{measure_params}, @var{control_params} = 0)\n\
@var{dynam_params} is of type int. @var{measure_params} is of type int. @var{control_params} is of type int. @var{retval} is of type CvKalman. \n\
@end deftypefn";
const char* _wrap_cvReleaseKalman_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseKalman (@var{kalman})\n\
@var{kalman} is of type CvKalman. \n\
@end deftypefn";
const char* _wrap_cvmGet_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvmGet (@var{mat}, @var{row}, @var{col})\n\
@var{mat} is of type CvMat. @var{row} is of type int. @var{col} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_delete_CvSeqReader_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSeqReader::~CvSeqReader (@var{self})\n\
@var{self} is of type CvSeqReader. \n\
@end deftypefn";
const char* _wrap_new_CvSeqReader_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSeqReader::CvSeqReader ()\n\
@var{retval} is of type CvSeqReader. \n\
@end deftypefn";
const char* _wrap_CV_IS_IMAGE_HDR_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_IMAGE_HDR (@var{img})\n\
@var{img} is of type CvArr. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCloneImage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCloneImageMat (@var{mat})\n\
@var{mat} is of type CvMat. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvCreateImage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateImageMat (@var{size}, @var{depth}, @var{channels})\n\
@var{size} is of type CvSize. @var{depth} is of type int. @var{channels} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CvPointVector_size_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = size (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type size_type. \n\
@end deftypefn";
const char* _wrap_FloatVector_size_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = size (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type size_type. \n\
@end deftypefn";
const char* _wrap_IplImage___gt___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator > (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___gt___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator > (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_new_CvSURFParams_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSURFParams::CvSURFParams ()\n\
@var{retval} is of type CvSURFParams. \n\
@end deftypefn";
const char* _wrap_delete_CvSURFParams_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSURFParams::~CvSURFParams (@var{self})\n\
@var{self} is of type CvSURFParams. \n\
@end deftypefn";
const char* _wrap_cvSURFParams_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSURFParams (@var{hessianThreshold}, @var{extended} = 0)\n\
@var{hessianThreshold} is of type double. @var{extended} is of type int. @var{retval} is of type CvSURFParams. \n\
@end deftypefn";
const char* _wrap_new_CvMSERParams_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvMSERParams::CvMSERParams ()\n\
@var{retval} is of type CvMSERParams. \n\
@end deftypefn";
const char* _wrap_delete_CvMSERParams_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMSERParams::~CvMSERParams (@var{self})\n\
@var{self} is of type CvMSERParams. \n\
@end deftypefn";
const char* _wrap_cvMSERParams_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMSERParams (@var{delta} = 5, @var{min_area} = 60, @var{max_area} = 14400, @var{max_variation} = .25, @var{min_diversity} = .2, @var{max_evolution} = 200, @var{area_threshold} = 1.01, @var{min_margin} = .003, @var{edge_blur_size} = 5)\n\
@var{delta} is of type int. @var{min_area} is of type int. @var{max_area} is of type int. @var{max_variation} is of type float. @var{min_diversity} is of type float. @var{max_evolution} is of type int. @var{area_threshold} is of type double. @var{min_margin} is of type double. @var{edge_blur_size} is of type int. @var{retval} is of type CvMSERParams. \n\
@end deftypefn";
const char* _wrap_new_CvStarDetectorParams_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvStarDetectorParams::CvStarDetectorParams ()\n\
@var{retval} is of type CvStarDetectorParams. \n\
@end deftypefn";
const char* _wrap_delete_CvStarDetectorParams_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvStarDetectorParams::~CvStarDetectorParams (@var{self})\n\
@var{self} is of type CvStarDetectorParams. \n\
@end deftypefn";
const char* _wrap_cvStarDetectorParams_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvStarDetectorParams (@var{maxSize} = 45, @var{responseThreshold} = 30, @var{lineThresholdProjected} = 10, @var{lineThresholdBinarized} = 8, @var{suppressNonmaxSize} = 5)\n\
@var{maxSize} is of type int. @var{responseThreshold} is of type int. @var{lineThresholdProjected} is of type int. @var{lineThresholdBinarized} is of type int. @var{suppressNonmaxSize} is of type int. @var{retval} is of type CvStarDetectorParams. \n\
@end deftypefn";
const char* _wrap_CvMatrix_is_valid_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = is_valid (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_CvImage_is_valid_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = is_valid (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_cvGraphRemoveVtx_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphRemoveVtx (@var{graph}, @var{index})\n\
@var{graph} is of type CvGraph. @var{index} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_IplImage___rmul___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rmul__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMat___rmul___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rmul__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvPyrDown_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPyrDown (@var{src}, @var{dst}, @var{filter} = CV_GAUSSIAN_5x5)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{filter} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSeq::CvSeq ()\n\
@var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_delete_CvSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSeq::~CvSeq (@var{self})\n\
@var{self} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_new_CvSeq_CvSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(p.CvSeq)>::CvTypedSeq<(p.CvSeq)> ()\n\
@var{retval} is of type CvSeq_CvSeq. \n\
@end deftypefn";
const char* _wrap_delete_CvSeq_CvSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTypedSeq<(p.CvSeq)>::~CvTypedSeq<(p.CvSeq)> (@var{self})\n\
@var{self} is of type CvSeq_CvSeq. \n\
@end deftypefn";
const char* _wrap_delete_CvSet_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSet::~CvSet (@var{self})\n\
@var{self} is of type CvSet. \n\
@end deftypefn";
const char* _wrap_new_CvSet_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSet::CvSet ()\n\
@var{retval} is of type CvSet. \n\
@end deftypefn";
const char* _wrap_CV_NODE_IDX_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_IDX (@var{mat}, @var{node})\n\
@var{mat} is of type CvSparseMat. @var{node} is of type CvSparseNode. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_POLYGON_TREE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_POLYGON_TREE (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvDiv_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvDiv (@var{src1}, @var{src2}, @var{dst}, @var{scale} = 1)\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. @var{scale} is of type double. \n\
@end deftypefn";
const char* _wrap_cvReduce_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReduce (@var{src}, @var{dst}, @var{dim} = -1, @var{op} = 0)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{dim} is of type int. @var{op} is of type int. \n\
@end deftypefn";
const char* _wrap_cvComputeCorrespondEpilines_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvComputeCorrespondEpilines (@var{points}, @var{which_image}, @var{fundamental_matrix}, @var{correspondent_lines})\n\
@var{points} is of type CvMat. @var{which_image} is of type int. @var{fundamental_matrix} is of type CvMat. @var{correspondent_lines} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_new_CvSize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSize::CvSize ()\n\
@var{retval} is of type CvSize. \n\
@end deftypefn";
const char* _wrap_delete_CvSize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSize::~CvSize (@var{self})\n\
@var{self} is of type CvSize. \n\
@end deftypefn";
const char* _wrap_cvClipLine_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvClipLine (@var{img_size}, @var{pt1}, @var{pt2})\n\
@var{img_size} is of type CvSize. @var{pt1} is of type CvPoint. @var{pt2} is of type CvPoint. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetSubRect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetSubRect (@var{arr}, @var{submat}, @var{rect})\n\
@var{arr} is of type CvArr. @var{submat} is of type CvMat. @var{rect} is of type CvRect. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvNorm_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvNorm (@var{arr1}, @var{arr2} = nil, @var{norm_type} = 4, @var{mask} = nil)\n\
@var{arr1} is of type CvArr. @var{arr2} is of type CvArr. @var{norm_type} is of type int. @var{mask} is of type CvArr. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvCalcArrHist_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcArrHist (@var{arr}, @var{hist}, @var{accumulate} = 0, @var{mask} = nil)\n\
@var{arr} is of type CvArr. @var{hist} is of type CvHistogram. @var{accumulate} is of type int. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvSetZero_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetZero (@var{arr})\n\
@var{arr} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvCreateSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateSeq (@var{seq_flags}, @var{header_size}, @var{elem_size}, @var{storage})\n\
@var{seq_flags} is of type int. @var{header_size} is of type int. @var{elem_size} is of type int. @var{storage} is of type CvMemStorage. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvmSet_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvmSet (@var{mat}, @var{row}, @var{col}, @var{value})\n\
@var{mat} is of type CvMat. @var{row} is of type int. @var{col} is of type int. @var{value} is of type double. \n\
@end deftypefn";
const char* _wrap_CV_CMP_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_CMP (@var{a}, @var{b})\n\
@var{a} is of type int. @var{b} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCreateSet_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateSet (@var{set_flags}, @var{header_size}, @var{elem_size}, @var{storage})\n\
@var{set_flags} is of type int. @var{header_size} is of type int. @var{elem_size} is of type int. @var{storage} is of type CvMemStorage. @var{retval} is of type CvSet. \n\
@end deftypefn";
const char* _wrap_cvSubdiv2DEdgeDst_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSubdiv2DEdgeDst (@var{edge})\n\
@var{edge} is of type CvSubdiv2DEdge. @var{retval} is of type CvSubdiv2DPoint. \n\
@end deftypefn";
const char* _wrap_cvSeqInsertSlice_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSeqInsertSlice (@var{seq}, @var{before_index}, @var{from_arr})\n\
@var{seq} is of type CvSeq. @var{before_index} is of type int. @var{from_arr} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CV_ARE_DEPTHS_EQ_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_ARE_DEPTHS_EQ (@var{mat1}, @var{mat2})\n\
@var{mat1} is of type CvMat. @var{mat2} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_MAT_TYPE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_MAT_TYPE (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGraphAddEdge_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphAddEdge (@var{graph}, @var{start_idx}, @var{end_idx}, @var{edge} = nil, @var{inserted_edge} = nil)\n\
@var{graph} is of type CvGraph. @var{start_idx} is of type int. @var{end_idx} is of type int. @var{edge} is of type CvGraphEdge. @var{inserted_edge} is of type CvGraphEdge. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_NODE_IS_SEQ_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_IS_SEQ (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_SET_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SET (@var{set})\n\
@var{set} is of type CvSet. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_delete_CvGraphVtx_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvGraphVtx::~CvGraphVtx (@var{self})\n\
@var{self} is of type CvGraphVtx. \n\
@end deftypefn";
const char* _wrap_new_CvGraphVtx_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvGraphVtx::CvGraphVtx ()\n\
@var{retval} is of type CvGraphVtx. \n\
@end deftypefn";
const char* _wrap_cvGetGraphVtx_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGetGraphVtx (@var{graph}, @var{idx})\n\
@var{graph} is of type CvGraph. @var{idx} is of type int. \n\
@end deftypefn";
const char* _wrap_cvTranspose_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvTranspose (@var{src}, @var{dst})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvUpdateMotionHistory_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvUpdateMotionHistory (@var{silhouette}, @var{mhi}, @var{timestamp}, @var{duration})\n\
@var{silhouette} is of type CvArr. @var{mhi} is of type CvArr. @var{timestamp} is of type double. @var{duration} is of type double. \n\
@end deftypefn";
const char* _wrap_cvGetNextSparseNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetNextSparseNode (@var{mat_iterator})\n\
@var{mat_iterator} is of type CvSparseMatIterator. @var{retval} is of type CvSparseNode. \n\
@end deftypefn";
const char* _wrap_new_CvSparseNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSparseNode::CvSparseNode ()\n\
@var{retval} is of type CvSparseNode. \n\
@end deftypefn";
const char* _wrap_delete_CvSparseNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSparseNode::~CvSparseNode (@var{self})\n\
@var{self} is of type CvSparseNode. \n\
@end deftypefn";
const char* _wrap_cvGetThreadNum_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetThreadNum ()\n\
@var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetSeqElem_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetSeqElem (@var{seq}, @var{index})\n\
@var{seq} is of type CvSeq. @var{index} is of type int. @var{retval} is of type schar. \n\
@end deftypefn";
const char* _wrap_cvGraphRemoveVtxByPtr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphRemoveVtxByPtr (@var{graph}, @var{vtx})\n\
@var{graph} is of type CvGraph. @var{vtx} is of type CvGraphVtx. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetFileNodeName_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetFileNodeName (@var{node})\n\
@var{node} is of type CvFileNode. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_FloatVector_capacity_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = capacity (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type size_type. \n\
@end deftypefn";
const char* _wrap_CvPointVector_capacity_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = capacity (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type size_type. \n\
@end deftypefn";
const char* _wrap_cvAvgSdv_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAvgSdv (@var{arr}, @var{mean}, @var{std_dev}, @var{mask} = nil)\n\
@var{arr} is of type CvArr. @var{mean} is of type CvScalar. @var{std_dev} is of type CvScalar. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_delete_CvKalman_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvKalman (@var{self})\n\
@var{self} is of type CvKalman. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint_cast_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvPoint)>::cast (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type CvSeq_CvPoint. \n\
@end deftypefn";
const char* _wrap_new_CvMoments_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvMoments::CvMoments ()\n\
@var{retval} is of type CvMoments. \n\
@end deftypefn";
const char* _wrap_delete_CvMoments_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMoments::~CvMoments (@var{self})\n\
@var{self} is of type CvMoments. \n\
@end deftypefn";
const char* _wrap_new_CvHuMoments_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvHuMoments::CvHuMoments ()\n\
@var{retval} is of type CvHuMoments. \n\
@end deftypefn";
const char* _wrap_delete_CvHuMoments_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvHuMoments::~CvHuMoments (@var{self})\n\
@var{self} is of type CvHuMoments. \n\
@end deftypefn";
const char* _wrap_new_CvChainPtReader_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvChainPtReader::CvChainPtReader ()\n\
@var{retval} is of type CvChainPtReader. \n\
@end deftypefn";
const char* _wrap_delete_CvChainPtReader_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvChainPtReader::~CvChainPtReader (@var{self})\n\
@var{self} is of type CvChainPtReader. \n\
@end deftypefn";
const char* _wrap_cvMoments_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMoments (@var{arr}, @var{moments}, @var{binary} = 0)\n\
@var{arr} is of type CvArr. @var{moments} is of type CvMoments. @var{binary} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetHuMoments_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGetHuMoments (@var{moments}, @var{hu_moments})\n\
@var{moments} is of type CvMoments. @var{hu_moments} is of type CvHuMoments. \n\
@end deftypefn";
const char* _wrap_cvSetImageIOFunctions_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSetImageIOFunctions (@var{_load_image}, @var{_load_image_m}, @var{_save_image}, @var{_show_image})\n\
@var{_load_image} is of type CvLoadImageFunc. @var{_load_image_m} is of type CvLoadImageMFunc. @var{_save_image} is of type CvSaveImageFunc. @var{_show_image} is of type CvShowImageFunc. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvAvg_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvAvg (@var{arr}, @var{mask} = nil)\n\
@var{arr} is of type CvArr. @var{mask} is of type CvArr. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_IplImage___req___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __req__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMat___req___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __req__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvReleaseImage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseImage (@var{image})\n\
@var{image} is of type . \n\
@end deftypefn";
const char* _wrap_cvSnakeImage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSnakeImage_Shadow (@var{image}, @var{points}, @var{alpha}, @var{beta}, @var{gamma}, @var{win}, @var{criteria})\n\
@var{image} is of type CvMat. @var{points} is of type CvPointVector. @var{alpha} is of type FloatVector. @var{beta} is of type FloatVector. @var{gamma} is of type FloatVector. @var{win} is of type CvSize. @var{criteria} is of type CvTermCriteria. @var{retval} is of type CvPointVector. \n\
@end deftypefn";
const char* _wrap_CvImage_origin_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = origin (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetRows_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetRows (@var{arr}, @var{submat}, @var{start_row}, @var{end_row}, @var{delta_row} = 1)\n\
@var{arr} is of type CvArr. @var{submat} is of type CvMat. @var{start_row} is of type int. @var{end_row} is of type int. @var{delta_row} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvWriteReal_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvWriteReal (@var{fs}, @var{name}, @var{value})\n\
@var{fs} is of type CvFileStorage. @var{name} is of type char. @var{value} is of type double. \n\
@end deftypefn";
const char* _wrap_cvMul_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMul (@var{src1}, @var{src2}, @var{dst}, @var{scale} = 1)\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. @var{scale} is of type double. \n\
@end deftypefn";
const char* _wrap_cvOr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvOr (@var{src1}, @var{src2}, @var{dst}, @var{mask} = nil)\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvSetSeqReaderPos_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetSeqReaderPos (@var{reader}, @var{index}, @var{is_relative} = 0)\n\
@var{reader} is of type CvSeqReader. @var{index} is of type int. @var{is_relative} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetSeqReaderPos_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetSeqReaderPos (@var{reader})\n\
@var{reader} is of type CvSeqReader. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvReleaseGraphScanner_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseGraphScanner (@var{scanner})\n\
@var{scanner} is of type CvGraphScanner. \n\
@end deftypefn";
const char* _wrap_cvCreateGraphScanner_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateGraphScanner (@var{graph}, @var{vtx} = nil, @var{mask} = -1)\n\
@var{graph} is of type CvGraph. @var{vtx} is of type CvGraphVtx. @var{mask} is of type int. @var{retval} is of type CvGraphScanner. \n\
@end deftypefn";
const char* _wrap_delete_CvGraphScanner_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvGraphScanner (@var{self})\n\
@var{self} is of type CvGraphScanner. \n\
@end deftypefn";
const char* _wrap_cvNormalize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvNormalize (@var{src}, @var{dst}, @var{a} = 1., @var{b} = 0., @var{norm_type} = 4, @var{mask} = nil)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{a} is of type double. @var{b} is of type double. @var{norm_type} is of type int. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvSize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSize (@var{width}, @var{height})\n\
@var{width} is of type int. @var{height} is of type int. @var{retval} is of type CvSize. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator_copy_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = copy (@var{self})\n\
@var{self} is of type OctSwigIterator. @var{retval} is of type OctSwigIterator. \n\
@end deftypefn";
const char* _wrap_CV_IS_TEMP_MAT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_TEMP_MAT (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvReleaseFileStorage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseFileStorage (@var{fs})\n\
@var{fs} is of type CvFileStorage. \n\
@end deftypefn";
const char* _wrap_cvOpenFileStorage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvOpenFileStorage (@var{filename}, @var{memstorage}, @var{flags})\n\
@var{filename} is of type char. @var{memstorage} is of type CvMemStorage. @var{flags} is of type int. @var{retval} is of type CvFileStorage. \n\
@end deftypefn";
const char* _wrap_cvClearMemStorage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvClearMemStorage (@var{storage})\n\
@var{storage} is of type CvMemStorage. \n\
@end deftypefn";
const char* _wrap_cvReleaseMemStorage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseMemStorage (@var{storage})\n\
@var{storage} is of type CvMemStorage. \n\
@end deftypefn";
const char* _wrap_cvCreateChildMemStorage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateChildMemStorage (@var{parent})\n\
@var{parent} is of type CvMemStorage. @var{retval} is of type CvMemStorage. \n\
@end deftypefn";
const char* _wrap_cvCreateMemStorage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateMemStorage (@var{block_size} = 0)\n\
@var{block_size} is of type int. @var{retval} is of type CvMemStorage. \n\
@end deftypefn";
const char* _wrap_delete_CvMemStorage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMemStorage (@var{self})\n\
@var{self} is of type CvMemStorage. \n\
@end deftypefn";
const char* _wrap_cvIncRefData_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvIncRefData (@var{arr})\n\
@var{arr} is of type CvArr. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvDecRefData_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvDecRefData (@var{arr})\n\
@var{arr} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvSVBkSb_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSVBkSb (@var{W}, @var{U}, @var{V}, @var{B}, @var{X}, @var{flags})\n\
@var{W} is of type CvArr. @var{U} is of type CvArr. @var{V} is of type CvArr. @var{B} is of type CvArr. @var{X} is of type CvArr. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCalibrateCamera2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalibrateCamera2 (@var{object_points}, @var{image_points}, @var{point_counts}, @var{image_size}, @var{camera_matrix}, @var{distortion_coeffs}, @var{rotation_vectors} = nil, @var{translation_vectors} = nil, @var{flags} = 0)\n\
@var{object_points} is of type CvMat. @var{image_points} is of type CvMat. @var{point_counts} is of type CvMat. @var{image_size} is of type CvSize. @var{camera_matrix} is of type CvMat. @var{distortion_coeffs} is of type CvMat. @var{rotation_vectors} is of type CvMat. @var{translation_vectors} is of type CvMat. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_NODE_IS_EMPTY_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_IS_EMPTY (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvNextGraphItem_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvNextGraphItem (@var{scanner})\n\
@var{scanner} is of type CvGraphScanner. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_NODE_IS_USER_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_IS_USER (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCreateStructuringElementEx_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateStructuringElementEx (@var{cols}, @var{rows}, @var{anchor_x}, @var{anchor_y}, @var{shape}, @var{values} = nil)\n\
@var{cols} is of type int. @var{rows} is of type int. @var{anchor_x} is of type int. @var{anchor_y} is of type int. @var{shape} is of type int. @var{values} is of type int. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_cvInitUndistortMap_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInitUndistortMap (@var{camera_matrix}, @var{distortion_coeffs}, @var{mapx}, @var{mapy})\n\
@var{camera_matrix} is of type CvMat. @var{distortion_coeffs} is of type CvMat. @var{mapx} is of type CvArr. @var{mapy} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMat___str_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __str (@var{self})\n\
@var{self} is of type CvMat. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_cvSetMemoryManager_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetMemoryManager (@var{alloc_func} = nil, @var{free_func} = nil, @var{userdata} = nil)\n\
@var{alloc_func} is of type CvAllocFunc. @var{free_func} is of type CvFreeFunc. @var{userdata} is of type void. \n\
@end deftypefn";
const char* _wrap_cvDCT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvDCT (@var{src}, @var{dst}, @var{flags})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCreateKDTree_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateKDTree (@var{desc})\n\
@var{desc} is of type CvMat. @var{retval} is of type CvFeatureTree. \n\
@end deftypefn";
const char* _wrap_CvImage_read_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = read (@var{self}, @var{fs}, @var{seqname}, @var{idx})\n\
@var{self} is of type CvImage. @var{fs} is of type CvFileStorage. @var{seqname} is of type char. @var{idx} is of type int. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_IplImage___le___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator <= (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___le___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator <= (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvAlloc_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvAlloc (@var{size})\n\
@var{size} is of type size_t. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_cvKalmanCorrect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvKalmanCorrect (@var{kalman}, @var{measurement})\n\
@var{kalman} is of type CvKalman. @var{measurement} is of type CvMat. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CV_REV_READ_SEQ_ELEM_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_REV_READ_SEQ_ELEM (@var{elem}, @var{reader})\n\
@var{elem} is of type CvPoint. @var{reader} is of type CvSeqReader. \n\
@end deftypefn";
const char* _wrap_CV_READ_SEQ_ELEM_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_READ_SEQ_ELEM (@var{elem}, @var{reader})\n\
@var{elem} is of type CvPoint. @var{reader} is of type CvSeqReader. \n\
@end deftypefn";
const char* _wrap_CV_PREV_SEQ_ELEM_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_PREV_SEQ_ELEM (@var{elem_size}, @var{reader})\n\
@var{elem_size} is of type int. @var{reader} is of type CvSeqReader. \n\
@end deftypefn";
const char* _wrap_CV_NEXT_SEQ_ELEM_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_NEXT_SEQ_ELEM (@var{elem_size}, @var{reader})\n\
@var{elem_size} is of type int. @var{reader} is of type CvSeqReader. \n\
@end deftypefn";
const char* _wrap_CV_WRITE_SEQ_ELEM_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_WRITE_SEQ_ELEM (@var{elem}, @var{writer})\n\
@var{elem} is of type CvPoint. @var{writer} is of type CvSeqWriter. \n\
@end deftypefn";
const char* _wrap_delete_CvGraphVtx2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvGraphVtx2D::~CvGraphVtx2D (@var{self})\n\
@var{self} is of type CvGraphVtx2D. \n\
@end deftypefn";
const char* _wrap_new_CvGraphVtx2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvGraphVtx2D::CvGraphVtx2D ()\n\
@var{retval} is of type CvGraphVtx2D. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvRect_cast_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvRect)>::cast (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type CvSeq_CvRect. \n\
@end deftypefn";
const char* _wrap_cvSliceLength_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSliceLength (@var{slice}, @var{seq})\n\
@var{slice} is of type CvSlice. @var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvArcLength_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvArcLength_Shadow (@var{arr})\n\
@var{arr} is of type CvArr. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_new_CvHaarFeature_rect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvHaarFeature_rect::CvHaarFeature_rect ()\n\
@var{retval} is of type CvHaarFeature_rect. \n\
@end deftypefn";
const char* _wrap_delete_CvHaarFeature_rect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvHaarFeature_rect::~CvHaarFeature_rect (@var{self})\n\
@var{self} is of type CvHaarFeature_rect. \n\
@end deftypefn";
const char* _wrap_cvPtrND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPtrND (@var{arr}, @var{idx}, @var{type} = nil, @var{create_node} = 1, @var{precalc_hashval} = nil)\n\
@var{arr} is of type CvArr. @var{idx} is of type int. @var{type} is of type int. @var{create_node} is of type int. @var{precalc_hashval} is of type unsigned int. @var{retval} is of type uchar. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator___decr___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator -- (@var{self})\n\
@var{self} is of type OctSwigIterator. @var{retval} is of type OctSwigIterator. \n\
@end deftypefn";
const char* _wrap_new_CvAvgComp_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvAvgComp::CvAvgComp ()\n\
@var{retval} is of type CvAvgComp. \n\
@end deftypefn";
const char* _wrap_delete_CvAvgComp_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvAvgComp::~CvAvgComp (@var{self})\n\
@var{self} is of type CvAvgComp. \n\
@end deftypefn";
const char* _wrap_IplImage___rand___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rand__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___rand___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rand__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvConnectedComp_cast_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvConnectedComp)>::cast (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type CvSeq_CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_cvReshapeND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReshapeND (@var{arr}, @var{header}, @var{new_cn}, @var{new_dims}, @var{new_sizes})\n\
@var{arr} is of type CvArr. @var{header} is of type CvMat. @var{new_cn} is of type int. @var{new_dims} is of type int. @var{new_sizes} is of type int. \n\
@end deftypefn";
const char* _wrap_CvImage_reset_roi_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} reset_roi (@var{self})\n\
@var{self} is of type CvImage. \n\
@end deftypefn";
const char* _wrap_CvImage_set_roi_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} set_roi (@var{self}, @var{roi})\n\
@var{self} is of type CvImage. @var{roi} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_delete_CvMatrix_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMatrix (@var{self})\n\
@var{self} is of type CvMatrix. \n\
@end deftypefn";
const char* _wrap_new_CvMatrix_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvMatrix (@var{fs}, @var{seqname}, @var{idx})\n\
@var{fs} is of type CvFileStorage. @var{seqname} is of type char. @var{idx} is of type int. @var{retval} is of type CvMatrix. \n\
@end deftypefn";
const char* _wrap_cvCalcCovarMatrix_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcCovarMatrix (@var{vects}, @var{count}, @var{cov_mat}, @var{avg}, @var{flags})\n\
@var{vects} is of type CvArr. @var{count} is of type int. @var{cov_mat} is of type CvArr. @var{avg} is of type CvArr. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_cv2DRotationMatrix_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cv2DRotationMatrix (@var{center}, @var{angle}, @var{scale}, @var{map_matrix})\n\
@var{center} is of type CvPoint2D32f. @var{angle} is of type double. @var{scale} is of type double. @var{map_matrix} is of type CvMat. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvDecomposeProjectionMatrix_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvDecomposeProjectionMatrix (@var{projMatr}, @var{calibMatr}, @var{rotMatr}, @var{posVect}, @var{rotMatrX} = nil, @var{rotMatrY} = nil, @var{rotMatrZ} = nil, @var{eulerAngles} = nil)\n\
@var{projMatr} is of type CvMat. @var{calibMatr} is of type CvMat. @var{rotMatr} is of type CvMat. @var{posVect} is of type CvMat. @var{rotMatrX} is of type CvMat. @var{rotMatrY} is of type CvMat. @var{rotMatrZ} is of type CvMat. @var{eulerAngles} is of type CvPoint3D64f. \n\
@end deftypefn";
const char* _wrap_cvMultiplyAcc_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMultiplyAcc (@var{image1}, @var{image2}, @var{acc}, @var{mask} = nil)\n\
@var{image1} is of type CvArr. @var{image2} is of type CvArr. @var{acc} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvRect_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type CvSeq_CvRect. @var{retval} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_cvExp_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvExp (@var{src}, @var{dst})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_new_CvContourTree_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvContourTree::CvContourTree ()\n\
@var{retval} is of type CvContourTree. \n\
@end deftypefn";
const char* _wrap_delete_CvContourTree_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvContourTree::~CvContourTree (@var{self})\n\
@var{self} is of type CvContourTree. \n\
@end deftypefn";
const char* _wrap_cvCreateContourTree_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateContourTree (@var{contour}, @var{storage}, @var{threshold})\n\
@var{contour} is of type CvSeq. @var{storage} is of type CvMemStorage. @var{threshold} is of type double. @var{retval} is of type CvContourTree. \n\
@end deftypefn";
const char* _wrap_cvReadInt_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvReadInt (@var{node}, @var{default_value} = 0)\n\
@var{node} is of type CvFileNode. @var{default_value} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCamShift_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCamShift (@var{prob_image}, @var{window}, @var{criteria}, @var{comp}, @var{box} = nil)\n\
@var{prob_image} is of type CvArr. @var{window} is of type CvRect. @var{criteria} is of type CvTermCriteria. @var{comp} is of type CvConnectedComp. @var{box} is of type CvBox2D. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSet1D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSet1D (@var{arr}, @var{idx0}, @var{value})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{value} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvSubdiv2DNextEdge_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSubdiv2DNextEdge (@var{edge})\n\
@var{edge} is of type CvSubdiv2DEdge. @var{retval} is of type CvSubdiv2DEdge. \n\
@end deftypefn";
const char* _wrap_cvRandReal_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRandReal (@var{rng})\n\
@var{rng} is of type CvRNG. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvStereoRectify_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvStereoRectify (@var{camera_matrix1}, @var{camera_matrix2}, @var{dist_coeffs1}, @var{dist_coeffs2}, @var{image_size}, @var{R}, @var{T}, @var{R1}, @var{R2}, @var{P1}, @var{P2}, @var{Q} = 0, @var{flags} = 1024)\n\
@var{camera_matrix1} is of type CvMat. @var{camera_matrix2} is of type CvMat. @var{dist_coeffs1} is of type CvMat. @var{dist_coeffs2} is of type CvMat. @var{image_size} is of type CvSize. @var{R} is of type CvMat. @var{T} is of type CvMat. @var{R1} is of type CvMat. @var{R2} is of type CvMat. @var{P1} is of type CvMat. @var{P2} is of type CvMat. @var{Q} is of type CvMat. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_3_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type CvSeq_float_3. @var{retval} is of type CvTuple_float_3. \n\
@end deftypefn";
const char* _wrap_CV_ARE_SIZES_EQ_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_ARE_SIZES_EQ (@var{mat1}, @var{mat2})\n\
@var{mat1} is of type CvMat. @var{mat2} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvQuadEdge2D_cast_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvQuadEdge2D)>::cast (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type CvSeq_CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_delete_IplConvKernel_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} IplConvKernel (@var{self})\n\
@var{self} is of type . \n\
@end deftypefn";
const char* _wrap_CvMatrix_addref_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} addref (@var{self})\n\
@var{self} is of type CvMatrix. \n\
@end deftypefn";
const char* _wrap_cvSolvePoly_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSolvePoly (@var{coeffs}, @var{roots2}, @var{maxiter} = 20, @var{fig} = 100)\n\
@var{coeffs} is of type CvMat. @var{roots2} is of type CvMat. @var{maxiter} is of type int. @var{fig} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSet2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSet2D (@var{arr}, @var{idx0}, @var{idx1}, @var{value})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{idx1} is of type int. @var{value} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvCopy_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCopy (@var{src}, @var{dst}, @var{mask} = nil)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CV_IS_GRAPH_EDGE_VISITED_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_GRAPH_EDGE_VISITED (@var{edge})\n\
@var{edge} is of type CvGraphEdge. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_GRAPH_VERTEX_VISITED_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_GRAPH_VERTEX_VISITED (@var{vtx})\n\
@var{vtx} is of type CvGraphVtx. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSeqElemIdx_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSeqElemIdx (@var{seq}, @var{element}, @var{block} = nil)\n\
@var{seq} is of type CvSeq. @var{element} is of type void. @var{block} is of type CvSeqBlock. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetSpatialMoment_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetSpatialMoment (@var{moments}, @var{x_order}, @var{y_order})\n\
@var{moments} is of type CvMoments. @var{x_order} is of type int. @var{y_order} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvGetCentralMoment_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetCentralMoment (@var{moments}, @var{x_order}, @var{y_order})\n\
@var{moments} is of type CvMoments. @var{x_order} is of type int. @var{y_order} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvGetNormalizedCentralMoment_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetNormalizedCentralMoment (@var{moments}, @var{x_order}, @var{y_order})\n\
@var{moments} is of type CvMoments. @var{x_order} is of type int. @var{y_order} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_CV_MAT_CN_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_MAT_CN (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvRange_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRange (@var{mat}, @var{start}, @var{end})\n\
@var{mat} is of type CvArr. @var{start} is of type double. @var{end} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvPointVector_back_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = back (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type value_type. \n\
@end deftypefn";
const char* _wrap_FloatVector_back_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = back (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type value_type. \n\
@end deftypefn";
const char* _wrap_IplImage___str_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __str (@var{self})\n\
@var{self} is of type . @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_cvFindChessboardCorners_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindChessboardCorners (@var{image}, @var{pattern_size}, @var{flags} = 1+2)\n\
@var{image} is of type void. @var{pattern_size} is of type CvSize. @var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvDrawChessboardCorners_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvDrawChessboardCorners (@var{image}, @var{pattern_size}, @var{corners}, @var{pattern_was_found})\n\
@var{image} is of type CvArr. @var{pattern_size} is of type CvSize. @var{corners} is of type CvPoint2D32f. @var{pattern_was_found} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGraphVtxIdx_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphVtxIdx (@var{graph}, @var{vtx})\n\
@var{graph} is of type CvGraph. @var{vtx} is of type CvGraphVtx. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPointVector_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type value_type. \n\
@end deftypefn";
const char* _wrap_FloatVector_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type value_type. \n\
@end deftypefn";
const char* _wrap_IplImage___rsub___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rsub__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___rsub___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rsub__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CV_64FC_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_64FC (@var{n})\n\
@var{n} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvFindFundamentalMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindFundamentalMat (@var{points1}, @var{points2}, @var{fundamental_matrix}, @var{method} = 8, @var{param1} = 3., @var{param2} = 0.99, @var{status} = nil)\n\
@var{points1} is of type CvMat. @var{points2} is of type CvMat. @var{fundamental_matrix} is of type CvMat. @var{method} is of type int. @var{param1} is of type double. @var{param2} is of type double. @var{status} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_RGB_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_RGB (@var{r}, @var{g}, @var{b})\n\
@var{r} is of type double. @var{g} is of type double. @var{b} is of type int. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvInRange_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInRange (@var{src}, @var{lower}, @var{upper}, @var{dst})\n\
@var{src} is of type CvArr. @var{lower} is of type CvArr. @var{upper} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CV_ELEM_SIZE1_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_ELEM_SIZE1 (@var{type})\n\
@var{type} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCalcGlobalOrientation_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCalcGlobalOrientation (@var{orientation}, @var{mask}, @var{mhi}, @var{timestamp}, @var{duration})\n\
@var{orientation} is of type CvArr. @var{mask} is of type CvArr. @var{mhi} is of type CvArr. @var{timestamp} is of type double. @var{duration} is of type double. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvRestoreMemStoragePos_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRestoreMemStoragePos (@var{storage}, @var{pos})\n\
@var{storage} is of type CvMemStorage. @var{pos} is of type CvMemStoragePos. \n\
@end deftypefn";
const char* _wrap_cvSaveMemStoragePos_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSaveMemStoragePos (@var{storage}, @var{pos})\n\
@var{storage} is of type CvMemStorage. @var{pos} is of type CvMemStoragePos. \n\
@end deftypefn";
const char* _wrap_new_CvMemStoragePos_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvMemStoragePos::CvMemStoragePos ()\n\
@var{retval} is of type CvMemStoragePos. \n\
@end deftypefn";
const char* _wrap_delete_CvMemStoragePos_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMemStoragePos::~CvMemStoragePos (@var{self})\n\
@var{self} is of type CvMemStoragePos. \n\
@end deftypefn";
const char* _wrap_CvSubdiv2D_typed_edges_get_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = typed_edges_get (@var{self})\n\
@var{self} is of type CvSubdiv2D. @var{retval} is of type CvSeq_CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_cvEigenVV_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvEigenVV (@var{mat}, @var{evects}, @var{evals}, @var{eps} = 0, @var{lowindex} = -1, @var{highindex} = -1)\n\
@var{mat} is of type CvArr. @var{evects} is of type CvArr. @var{evals} is of type CvArr. @var{eps} is of type double. @var{lowindex} is of type int. @var{highindex} is of type int. \n\
@end deftypefn";
const char* _wrap_cvLog_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvLog (@var{src}, @var{dst})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvImage_load_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = load (@var{self}, @var{filename})\n\
@var{self} is of type CvImage. @var{filename} is of type char. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_cvSet3D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSet3D (@var{arr}, @var{idx0}, @var{idx1}, @var{idx2}, @var{value})\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{idx1} is of type int. @var{idx2} is of type int. @var{value} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvReleaseData_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseData (@var{arr})\n\
@var{arr} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvDFT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvDFT (@var{src}, @var{dst}, @var{flags}, @var{nonzero_rows} = 0)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{flags} is of type int. @var{nonzero_rows} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_MAT_CONT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_MAT_CONT (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCloneMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCloneMat (@var{mat})\n\
@var{mat} is of type CvMat. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvExtractSURF_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvExtractSURF (@var{img}, @var{mask}, @var{keypoints}, @var{descriptors}, @var{storage}, @var{params}, @var{useProvidedKeyPts} = 0)\n\
@var{img} is of type CvArr. @var{mask} is of type CvArr. @var{keypoints} is of type CvSeq. @var{descriptors} is of type CvSeq. @var{storage} is of type CvMemStorage. @var{params} is of type CvSURFParams. @var{useProvidedKeyPts} is of type int. \n\
@end deftypefn";
const char* _wrap_cvRectangle_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRectangle (@var{img}, @var{pt1}, @var{pt2}, @var{color}, @var{thickness} = 1, @var{line_type} = 8, @var{shift} = 0)\n\
@var{img} is of type CvArr. @var{pt1} is of type CvPoint. @var{pt2} is of type CvPoint. @var{color} is of type CvScalar. @var{thickness} is of type int. @var{line_type} is of type int. @var{shift} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetCol_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetCol (@var{arr}, @var{submat}, @var{col})\n\
@var{arr} is of type CvArr. @var{submat} is of type CvMat. @var{col} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvSetSeqBlockSize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetSeqBlockSize (@var{seq}, @var{delta_elems})\n\
@var{seq} is of type CvSeq. @var{delta_elems} is of type int. \n\
@end deftypefn";
const char* _wrap_IplImage___rge___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rge__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMat___rge___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rge__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvCalcBackProjectPatch_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcBackProjectPatch (@var{image}, @var{dst}, @var{range}, @var{hist}, @var{method}, @var{factor})\n\
@var{image} is of type . @var{dst} is of type CvArr. @var{range} is of type CvSize. @var{hist} is of type CvHistogram. @var{method} is of type int. @var{factor} is of type double. \n\
@end deftypefn";
const char* _wrap_cvCalcArrBackProjectPatch_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcArrBackProjectPatch (@var{image}, @var{dst}, @var{range}, @var{hist}, @var{method}, @var{factor})\n\
@var{image} is of type CvArr. @var{dst} is of type CvArr. @var{range} is of type CvSize. @var{hist} is of type CvHistogram. @var{method} is of type int. @var{factor} is of type double. \n\
@end deftypefn";
const char* _wrap_CvMatrix_data_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = data (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type uchar. \n\
@end deftypefn";
const char* _wrap_cvPow_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPow (@var{src}, @var{dst}, @var{power})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{power} is of type double. \n\
@end deftypefn";
const char* _wrap_CV_IS_MAT_HDR_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_MAT_HDR (@var{mat})\n\
@var{mat} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_SPARSE_MAT_HDR_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SPARSE_MAT_HDR (@var{mat})\n\
@var{mat} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvConDensInitSampleSet_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvConDensInitSampleSet (@var{condens}, @var{lower_bound}, @var{upper_bound})\n\
@var{condens} is of type CvConDensation. @var{lower_bound} is of type CvMat. @var{upper_bound} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_POINT_SUBSET_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_POINT_SUBSET (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvMat_data_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvMat_data::CvMat_data ()\n\
@var{retval} is of type CvMat_data. \n\
@end deftypefn";
const char* _wrap_delete_CvMat_data_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMat_data::~CvMat_data (@var{self})\n\
@var{self} is of type CvMat_data. \n\
@end deftypefn";
const char* _wrap_CvMatrix_set_data_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} set_data (@var{self}, @var{data})\n\
@var{self} is of type CvMatrix. @var{data} is of type void. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_CLOSED_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_CLOSED (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvWriteString_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvWriteString (@var{fs}, @var{name}, @var{str}, @var{quote} = 0)\n\
@var{fs} is of type CvFileStorage. @var{name} is of type char. @var{str} is of type char. @var{quote} is of type int. \n\
@end deftypefn";
const char* _wrap_cvMemStorageAllocString_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMemStorageAllocString (@var{storage}, @var{ptr}, @var{len} = -1)\n\
@var{storage} is of type CvMemStorage. @var{ptr} is of type char. @var{len} is of type int. @var{retval} is of type CvString. \n\
@end deftypefn";
const char* _wrap_CvSubdiv2D_typed_edges_set_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} typed_edges_set (@var{self}, @var{?})\n\
@var{self} is of type CvSubdiv2D. @var{?} is of type CvSeq_CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_CV_NODE_HAS_NAME_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_HAS_NAME (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCloneSparseMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCloneSparseMat (@var{mat})\n\
@var{mat} is of type CvSparseMat. @var{retval} is of type CvSparseMat. \n\
@end deftypefn";
const char* _wrap_cvReleaseSparseMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseSparseMat (@var{mat})\n\
@var{mat} is of type CvSparseMat. \n\
@end deftypefn";
const char* _wrap_cvCreateSparseMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateSparseMat (@var{dims}, @var{type})\n\
@var{dims} is of type int. @var{type} is of type int. @var{retval} is of type CvSparseMat. \n\
@end deftypefn";
const char* _wrap_delete_CvSparseMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSparseMat (@var{self})\n\
@var{self} is of type CvSparseMat. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator_equal_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = equal (@var{self}, @var{x})\n\
@var{self} is of type OctSwigIterator. @var{x} is of type OctSwigIterator. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_POLYGON_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_POLYGON (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvXor_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvXor (@var{src1}, @var{src2}, @var{dst}, @var{mask} = nil)\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvLaplace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvLaplace (@var{src}, @var{dst}, @var{aperture_size} = 3)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{aperture_size} is of type int. \n\
@end deftypefn";
const char* _wrap_cvLSHQuery_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvLSHQuery (@var{lsh}, @var{query_points}, @var{indices}, @var{dist}, @var{k}, @var{emax})\n\
@var{lsh} is of type CvLSH. @var{query_points} is of type CvMat. @var{indices} is of type CvMat. @var{dist} is of type CvMat. @var{k} is of type int. @var{emax} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSetNew_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSetNew (@var{set_header})\n\
@var{set_header} is of type CvSet. @var{retval} is of type CvSetElem. \n\
@end deftypefn";
const char* _wrap_CV_SIGN_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CV_SIGN (@var{a})\n\
@var{a} is of type int. \n\
@end deftypefn";
const char* _wrap_cvConvertMaps_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvConvertMaps (@var{mapx}, @var{mapy}, @var{mapxy}, @var{mapalpha})\n\
@var{mapx} is of type CvArr. @var{mapy} is of type CvArr. @var{mapxy} is of type CvArr. @var{mapalpha} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvSet_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSet (@var{arr}, @var{value}, @var{mask} = nil)\n\
@var{arr} is of type CvArr. @var{value} is of type CvScalar. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvSeqInsert_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSeqInsert (@var{seq}, @var{before_index}, @var{element} = nil)\n\
@var{seq} is of type CvSeq. @var{before_index} is of type int. @var{element} is of type void. @var{retval} is of type schar. \n\
@end deftypefn";
const char* _wrap_cvCreateSpillTree_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateSpillTree (@var{raw_data}, @var{naive} = 50, @var{rho} = .7, @var{tau} = .1)\n\
@var{raw_data} is of type CvMat. @var{naive} is of type int. @var{rho} is of type double. @var{tau} is of type double. @var{retval} is of type CvFeatureTree. \n\
@end deftypefn";
const char* _wrap_cvHaarDetectObjects_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvHaarDetectObjects_Shadow (@var{image}, @var{cascade}, @var{storage})\n\
@var{image} is of type CvArr. @var{cascade} is of type CvHaarClassifierCascade. @var{storage} is of type CvMemStorage. @var{retval} is of type CvSeq_CvRect. \n\
@end deftypefn";
const char* _wrap_cvCalcImageHomography_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcImageHomography (@var{line}, @var{center}, @var{intrinsic}, @var{homography})\n\
@var{line} is of type float. @var{center} is of type CvPoint3D32f. @var{intrinsic} is of type float. @var{homography} is of type float. \n\
@end deftypefn";
const char* _wrap_cvFindHomography_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindHomography (@var{src_points}, @var{dst_points}, @var{homography}, @var{method} = 0, @var{ransacReprojThreshold} = 0, @var{mask} = 0)\n\
@var{src_points} is of type CvMat. @var{dst_points} is of type CvMat. @var{homography} is of type CvMat. @var{method} is of type int. @var{ransacReprojThreshold} is of type double. @var{mask} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_MAKETYPE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_MAKETYPE (@var{depth}, @var{cn})\n\
@var{depth} is of type int. @var{cn} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvWrite_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvWrite (@var{fs}, @var{name}, @var{ptr}, @var{attributes} = cvAttrList())\n\
@var{fs} is of type CvFileStorage. @var{name} is of type char. @var{ptr} is of type void. @var{attributes} is of type CvAttrList. \n\
@end deftypefn";
const char* _wrap_new_CvMatND_data_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvMatND_data::CvMatND_data ()\n\
@var{retval} is of type CvMatND_data. \n\
@end deftypefn";
const char* _wrap_delete_CvMatND_data_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMatND_data::~CvMatND_data (@var{self})\n\
@var{self} is of type CvMatND_data. \n\
@end deftypefn";
const char* _wrap_cvCalcPCA_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcPCA (@var{data}, @var{mean}, @var{eigenvals}, @var{eigenvects}, @var{flags})\n\
@var{data} is of type CvArr. @var{mean} is of type CvArr. @var{eigenvals} is of type CvArr. @var{eigenvects} is of type CvArr. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_cvRodrigues2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRodrigues2 (@var{src}, @var{dst}, @var{jacobian} = 0)\n\
@var{src} is of type CvMat. @var{dst} is of type CvMat. @var{jacobian} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvNormalizeHist_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvNormalizeHist (@var{hist}, @var{factor})\n\
@var{hist} is of type CvHistogram. @var{factor} is of type double. \n\
@end deftypefn";
const char* _wrap_cvEqualizeHist_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvEqualizeHist (@var{src}, @var{dst})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvClone_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvClone (@var{struct_ptr})\n\
@var{struct_ptr} is of type void. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_new_CvHaarClassifier_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvHaarClassifier::CvHaarClassifier ()\n\
@var{retval} is of type CvHaarClassifier. \n\
@end deftypefn";
const char* _wrap_delete_CvHaarClassifier_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvHaarClassifier::~CvHaarClassifier (@var{self})\n\
@var{self} is of type CvHaarClassifier. \n\
@end deftypefn";
const char* _wrap_new_CvHaarStageClassifier_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvHaarStageClassifier::CvHaarStageClassifier ()\n\
@var{retval} is of type CvHaarStageClassifier. \n\
@end deftypefn";
const char* _wrap_delete_CvHaarStageClassifier_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvHaarStageClassifier::~CvHaarStageClassifier (@var{self})\n\
@var{self} is of type CvHaarStageClassifier. \n\
@end deftypefn";
const char* _wrap_cvMinAreaRect2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMinAreaRect2 (@var{points}, @var{storage} = nil)\n\
@var{points} is of type CvArr. @var{storage} is of type CvMemStorage. @var{retval} is of type CvBox2D. \n\
@end deftypefn";
const char* _wrap_cvStartAppendToSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvStartAppendToSeq (@var{seq}, @var{writer})\n\
@var{seq} is of type CvSeq. @var{writer} is of type CvSeqWriter. \n\
@end deftypefn";
const char* _wrap_CV_NODE_IS_REAL_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_IS_REAL (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_FloatVector_reserve_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} reserve (@var{self}, @var{n})\n\
@var{self} is of type FloatVector. @var{n} is of type size_type. \n\
@end deftypefn";
const char* _wrap_CvPointVector_reserve_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} reserve (@var{self}, @var{n})\n\
@var{self} is of type CvPointVector. @var{n} is of type size_type. \n\
@end deftypefn";
const char* _wrap_cvCompareHist_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCompareHist (@var{hist1}, @var{hist2}, @var{method})\n\
@var{hist1} is of type CvHistogram. @var{hist2} is of type CvHistogram. @var{method} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvMerge_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMerge (@var{src0}, @var{src1}, @var{src2}, @var{src3}, @var{dst})\n\
@var{src0} is of type CvArr. @var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{src3} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator_value_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = value (@var{self})\n\
@var{self} is of type OctSwigIterator. @var{retval} is of type octave_value. \n\
@end deftypefn";
const char* _wrap_cvGetDims_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetDims (@var{arr})\n\
@var{arr} is of type CvArr. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPointVector___paren___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren__ (@var{self}, @var{i})\n\
@var{self} is of type CvPointVector. @var{i} is of type difference_type. @var{retval} is of type value_type. \n\
@end deftypefn";
const char* _wrap_FloatVector___paren___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __paren__ (@var{self}, @var{i})\n\
@var{self} is of type FloatVector. @var{i} is of type difference_type. @var{retval} is of type value_type. \n\
@end deftypefn";
const char* _wrap_cvInitIntrinsicParams2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInitIntrinsicParams2D (@var{object_points}, @var{image_points}, @var{npoints}, @var{image_size}, @var{camera_matrix}, @var{aspect_ratio} = 1.)\n\
@var{object_points} is of type CvMat. @var{image_points} is of type CvMat. @var{npoints} is of type CvMat. @var{image_size} is of type CvSize. @var{camera_matrix} is of type CvMat. @var{aspect_ratio} is of type double. \n\
@end deftypefn";
const char* _wrap_IplImage___xor___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator ^ (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type CvScalar. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___xor___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator ^ (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type CvScalar. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvReadString_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvReadString (@var{node}, @var{default_value} = nil)\n\
@var{node} is of type CvFileNode. @var{default_value} is of type char. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_delete_CvString_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvString::~CvString (@var{self})\n\
@var{self} is of type CvString. \n\
@end deftypefn";
const char* _wrap_new_CvString_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvString::CvString ()\n\
@var{retval} is of type CvString. \n\
@end deftypefn";
const char* _wrap_CvPointVector_assign_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} assign (@var{self}, @var{n}, @var{x})\n\
@var{self} is of type CvPointVector. @var{n} is of type size_type. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_FloatVector_assign_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} assign (@var{self}, @var{n}, @var{x})\n\
@var{self} is of type FloatVector. @var{n} is of type size_type. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_new_CvPoint3D64f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvPoint3D64f::CvPoint3D64f ()\n\
@var{retval} is of type CvPoint3D64f. \n\
@end deftypefn";
const char* _wrap_delete_CvPoint3D64f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvPoint3D64f::~CvPoint3D64f (@var{self})\n\
@var{self} is of type CvPoint3D64f. \n\
@end deftypefn";
const char* _wrap_cvPoint3D64f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPoint3D64f (@var{x}, @var{y}, @var{z})\n\
@var{x} is of type double. @var{y} is of type double. @var{z} is of type double. @var{retval} is of type CvPoint3D64f. \n\
@end deftypefn";
const char* _wrap_cvGetTickCount_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetTickCount ()\n\
@var{retval} is of type int64. \n\
@end deftypefn";
const char* _wrap_cvSubdiv2DSymEdge_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSubdiv2DSymEdge (@var{edge})\n\
@var{edge} is of type CvSubdiv2DEdge. @var{retval} is of type CvSubdiv2DEdge. \n\
@end deftypefn";
const char* _wrap_cvPerspectiveTransform_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvPerspectiveTransform (@var{src}, @var{dst}, @var{mat})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{mat} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvTransform_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvTransform (@var{src}, @var{dst}, @var{transmat}, @var{shiftvec} = nil)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{transmat} is of type CvMat. @var{shiftvec} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_IplImage___ne___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator != (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvSubdiv2DEdge_Wrapper___ne___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator != (@var{self}, @var{x})\n\
@var{self} is of type CvSubdiv2DEdge_Wrapper. @var{x} is of type CvSubdiv2DEdge_Wrapper. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_CvRNG_Wrapper___ne___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator != (@var{self}, @var{x})\n\
@var{self} is of type CvRNG_Wrapper. @var{x} is of type CvRNG_Wrapper. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator___ne___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator != (@var{self}, @var{x})\n\
@var{self} is of type OctSwigIterator. @var{x} is of type OctSwigIterator. @var{retval} is of type bool. \n\
@end deftypefn";
const char* _wrap_CvMat___ne___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator != (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvGetAffineTransform_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetAffineTransform (@var{src}, @var{dst}, @var{map_matrix})\n\
@var{src} is of type CvPoint2D32f. @var{dst} is of type CvPoint2D32f. @var{map_matrix} is of type CvMat. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvGetPerspectiveTransform_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetPerspectiveTransform (@var{src}, @var{dst}, @var{map_matrix})\n\
@var{src} is of type CvPoint2D32f. @var{dst} is of type CvPoint2D32f. @var{map_matrix} is of type CvMat. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvEstimateRigidTransform_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvEstimateRigidTransform (@var{A}, @var{B}, @var{M}, @var{full_affine})\n\
@var{A} is of type CvArr. @var{B} is of type CvArr. @var{M} is of type CvMat. @var{full_affine} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvDistTransform_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvDistTransform (@var{src}, @var{dst}, @var{distance_type} = 2, @var{mask_size} = 3, @var{mask} = nil, @var{labels} = nil)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{distance_type} is of type int. @var{mask_size} is of type int. @var{mask} is of type float. @var{labels} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvSubdiv2DLocate_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSubdiv2DLocate (@var{subdiv}, @var{pt}, @var{edge})\n\
@var{subdiv} is of type CvSubdiv2D. @var{pt} is of type CvPoint2D32f. @var{edge} is of type CvSubdiv2DEdge. @var{retval} is of type CvSubdiv2DPointLocation. \n\
@end deftypefn";
const char* _wrap_cvLine_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvLine (@var{img}, @var{pt1}, @var{pt2}, @var{color}, @var{thickness} = 1, @var{line_type} = 8, @var{shift} = 0)\n\
@var{img} is of type CvArr. @var{pt1} is of type CvPoint. @var{pt2} is of type CvPoint. @var{color} is of type CvScalar. @var{thickness} is of type int. @var{line_type} is of type int. @var{shift} is of type int. \n\
@end deftypefn";
const char* _wrap_CvMatrix_release_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} release (@var{self})\n\
@var{self} is of type CvMatrix. \n\
@end deftypefn";
const char* _wrap_CvImage_release_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} release (@var{self})\n\
@var{self} is of type CvImage. \n\
@end deftypefn";
const char* _wrap_cvRelease_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRelease (@var{struct_ptr})\n\
@var{struct_ptr} is of type void. \n\
@end deftypefn";
const char* _wrap_cvGetMinMaxHistValue_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGetMinMaxHistValue (@var{hist}, @var{min_value}, @var{max_value}, @var{min_idx} = nil, @var{max_idx} = nil)\n\
@var{hist} is of type CvHistogram. @var{min_value} is of type float. @var{max_value} is of type float. @var{min_idx} is of type int. @var{max_idx} is of type int. \n\
@end deftypefn";
const char* _wrap_FloatVector_insert_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} insert (@var{self}, @var{pos}, @var{n}, @var{x})\n\
@var{self} is of type FloatVector. @var{pos} is of type iterator. @var{n} is of type size_type. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_CvPointVector_insert_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} insert (@var{self}, @var{pos}, @var{n}, @var{x})\n\
@var{self} is of type CvPointVector. @var{pos} is of type iterator. @var{n} is of type size_type. @var{x} is of type value_type. \n\
@end deftypefn";
const char* _wrap_cvSubdivDelaunay2DInsert_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSubdivDelaunay2DInsert (@var{subdiv}, @var{pt})\n\
@var{subdiv} is of type CvSubdiv2D. @var{pt} is of type CvPoint2D32f. @var{retval} is of type CvSubdiv2DPoint. \n\
@end deftypefn";
const char* _wrap_cvEllipse2Poly_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvEllipse2Poly (@var{center}, @var{axes}, @var{angle}, @var{arc_start}, @var{arc_end}, @var{pts}, @var{delta})\n\
@var{center} is of type CvPoint. @var{axes} is of type CvSize. @var{angle} is of type int. @var{arc_start} is of type int. @var{arc_end} is of type int. @var{pts} is of type CvPoint. @var{delta} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_CHAIN_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_CHAIN (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_IMAGE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_IMAGE (@var{img})\n\
@var{img} is of type CvArr. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_delete_CvTypeInfo_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTypeInfo::~CvTypeInfo (@var{self})\n\
@var{self} is of type CvTypeInfo. \n\
@end deftypefn";
const char* _wrap_new_CvTypeInfo_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypeInfo::CvTypeInfo ()\n\
@var{retval} is of type CvTypeInfo. \n\
@end deftypefn";
const char* _wrap_cvSubdiv2DEdgeOrg_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSubdiv2DEdgeOrg (@var{edge})\n\
@var{edge} is of type CvSubdiv2DEdge. @var{retval} is of type CvSubdiv2DPoint. \n\
@end deftypefn";
const char* _wrap_delete_CvFont_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvFont::~CvFont (@var{self})\n\
@var{self} is of type CvFont. \n\
@end deftypefn";
const char* _wrap_new_CvFont_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvFont::CvFont ()\n\
@var{retval} is of type CvFont. \n\
@end deftypefn";
const char* _wrap_new_CvSubdiv2DPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSubdiv2DPoint::CvSubdiv2DPoint ()\n\
@var{retval} is of type CvSubdiv2DPoint. \n\
@end deftypefn";
const char* _wrap_delete_CvSubdiv2DPoint_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSubdiv2DPoint::~CvSubdiv2DPoint (@var{self})\n\
@var{self} is of type CvSubdiv2DPoint. \n\
@end deftypefn";
const char* _wrap_cvLSHAdd_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvLSHAdd (@var{lsh}, @var{data}, @var{indices} = 0)\n\
@var{lsh} is of type CvLSH. @var{data} is of type CvMat. @var{indices} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvAddWeighted_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAddWeighted (@var{src1}, @var{alpha}, @var{src2}, @var{beta}, @var{gamma}, @var{dst})\n\
@var{src1} is of type CvArr. @var{alpha} is of type double. @var{src2} is of type CvArr. @var{beta} is of type double. @var{gamma} is of type double. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvGetModuleInfo_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGetModuleInfo (@var{module_name}, @var{version}, @var{loaded_addon_plugins})\n\
@var{module_name} is of type char. @var{version} is of type char. @var{loaded_addon_plugins} is of type char. \n\
@end deftypefn";
const char* _wrap_delete_CvModuleInfo_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvModuleInfo::~CvModuleInfo (@var{self})\n\
@var{self} is of type CvModuleInfo. \n\
@end deftypefn";
const char* _wrap_new_CvModuleInfo_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvModuleInfo::CvModuleInfo ()\n\
@var{retval} is of type CvModuleInfo. \n\
@end deftypefn";
const char* _wrap_cvCalcProbDensity_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcProbDensity (@var{hist1}, @var{hist2}, @var{dst_hist}, @var{scale} = 255)\n\
@var{hist1} is of type CvHistogram. @var{hist2} is of type CvHistogram. @var{dst_hist} is of type CvHistogram. @var{scale} is of type double. \n\
@end deftypefn";
const char* _wrap_delete_CvChain_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvChain::~CvChain (@var{self})\n\
@var{self} is of type CvChain. \n\
@end deftypefn";
const char* _wrap_new_CvChain_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvChain::CvChain ()\n\
@var{retval} is of type CvChain. \n\
@end deftypefn";
const char* _wrap_delete_CvImage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvImage (@var{self})\n\
@var{self} is of type CvImage. \n\
@end deftypefn";
const char* _wrap_new_CvImage_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvImage (@var{fs}, @var{seqname}, @var{idx})\n\
@var{fs} is of type CvFileStorage. @var{seqname} is of type char. @var{idx} is of type int. @var{retval} is of type CvImage. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvSeq_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type CvSeq_CvSeq. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvFree__texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFree_ (@var{ptr})\n\
@var{ptr} is of type void. \n\
@end deftypefn";
const char* _wrap_cvIsNaN_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvIsNaN (@var{value})\n\
@var{value} is of type double. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvColorToScalar_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvColorToScalar (@var{packed_color}, @var{arrtype})\n\
@var{packed_color} is of type double. @var{arrtype} is of type int. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvRawDataToScalar_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRawDataToScalar (@var{data}, @var{type}, @var{scalar})\n\
@var{data} is of type void. @var{type} is of type int. @var{scalar} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_CvMatrix_step_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = step (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvDilate_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvDilate (@var{src}, @var{dst}, @var{element} = nil, @var{iterations} = 1)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{element} is of type . @var{iterations} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCreateSeqBlock_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCreateSeqBlock (@var{writer})\n\
@var{writer} is of type CvSeqWriter. \n\
@end deftypefn";
const char* _wrap_cvChangeSeqBlock_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvChangeSeqBlock (@var{reader}, @var{direction})\n\
@var{reader} is of type void. @var{direction} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvSeqBlock_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSeqBlock::CvSeqBlock ()\n\
@var{retval} is of type CvSeqBlock. \n\
@end deftypefn";
const char* _wrap_delete_CvSeqBlock_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSeqBlock::~CvSeqBlock (@var{self})\n\
@var{self} is of type CvSeqBlock. \n\
@end deftypefn";
const char* _wrap_cvMulSpectrums_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMulSpectrums (@var{src1}, @var{src2}, @var{dst}, @var{flags})\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_IplImage___mul___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator * (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___mul___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator * (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvRunningAvg_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRunningAvg (@var{image}, @var{acc}, @var{alpha}, @var{mask} = nil)\n\
@var{image} is of type CvArr. @var{acc} is of type CvArr. @var{alpha} is of type double. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_delete_CvLSH_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvLSH (@var{self})\n\
@var{self} is of type CvLSH. \n\
@end deftypefn";
const char* _wrap_new_CvMemBlock_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvMemBlock::CvMemBlock ()\n\
@var{retval} is of type CvMemBlock. \n\
@end deftypefn";
const char* _wrap_delete_CvMemBlock_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMemBlock::~CvMemBlock (@var{self})\n\
@var{self} is of type CvMemBlock. \n\
@end deftypefn";
const char* _wrap_cvSplit_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSplit (@var{src}, @var{dst0}, @var{dst1}, @var{dst2}, @var{dst3})\n\
@var{src} is of type CvArr. @var{dst0} is of type CvArr. @var{dst1} is of type CvArr. @var{dst2} is of type CvArr. @var{dst3} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CV_IS_GRAPH_ORIENTED_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_GRAPH_ORIENTED (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvPointFrom32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPointFrom32f (@var{point})\n\
@var{point} is of type CvPoint2D32f. @var{retval} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_cvConvexHull2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvConvexHull2_Shadow (@var{points})\n\
@var{points} is of type CvArr. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvCalcBayesianProb_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcBayesianProb (@var{src}, @var{number}, @var{dst})\n\
@var{src} is of type CvHistogram. @var{number} is of type int. @var{dst} is of type CvHistogram. \n\
@end deftypefn";
const char* _wrap_cvSeqRemoveSlice_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSeqRemoveSlice (@var{seq}, @var{slice})\n\
@var{seq} is of type CvSeq. @var{slice} is of type CvSlice. \n\
@end deftypefn";
const char* _wrap_new_CvMatND_dim_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvMatND_dim::CvMatND_dim ()\n\
@var{retval} is of type CvMatND_dim. \n\
@end deftypefn";
const char* _wrap_delete_CvMatND_dim_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMatND_dim::~CvMatND_dim (@var{self})\n\
@var{self} is of type CvMatND_dim. \n\
@end deftypefn";
const char* _wrap_cvCreateLSH_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateLSH (@var{ops}, @var{d}, @var{L} = 10, @var{k} = 10, @var{type} = (((6) &((1 << 3) -1)) +(((1) -1) << 3)), @var{r} = 4, @var{seed} = -1)\n\
@var{ops} is of type CvLSHOperations. @var{d} is of type int. @var{L} is of type int. @var{k} is of type int. @var{type} is of type int. @var{r} is of type double. @var{seed} is of type int64. @var{retval} is of type CvLSH. \n\
@end deftypefn";
const char* _wrap_CvImage_width_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = width (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IABS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IABS (@var{a})\n\
@var{a} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvReadRawDataSlice_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReadRawDataSlice (@var{fs}, @var{reader}, @var{count}, @var{dst}, @var{dt})\n\
@var{fs} is of type CvFileStorage. @var{reader} is of type CvSeqReader. @var{count} is of type int. @var{dst} is of type void. @var{dt} is of type char. \n\
@end deftypefn";
const char* _wrap_cvErrorStr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvErrorStr (@var{status})\n\
@var{status} is of type int. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator_decr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = decr (@var{self})\n\
@var{self} is of type OctSwigIterator. @var{retval} is of type OctSwigIterator. \n\
@end deftypefn";
const char* _wrap_cvCalcPGH_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCalcPGH (@var{contour}, @var{hist})\n\
@var{contour} is of type CvSeq. @var{hist} is of type CvHistogram. \n\
@end deftypefn";
const char* _wrap_CV_IMAX_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IMAX (@var{a}, @var{b})\n\
@var{a} is of type int. @var{b} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvMinS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMinS (@var{src}, @var{value}, @var{dst})\n\
@var{src} is of type CvArr. @var{value} is of type double. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvNextNArraySlice_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvNextNArraySlice (@var{array_iterator})\n\
@var{array_iterator} is of type CvNArrayIterator. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvFont_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFont (@var{scale}, @var{thickness} = 1)\n\
@var{scale} is of type double. @var{thickness} is of type int. @var{retval} is of type CvFont. \n\
@end deftypefn";
const char* _wrap_cvTreeToNodeSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvTreeToNodeSeq (@var{first}, @var{header_size}, @var{storage})\n\
@var{first} is of type void. @var{header_size} is of type int. @var{storage} is of type CvMemStorage. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvSetRemoveByPtr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetRemoveByPtr (@var{set_header}, @var{elem})\n\
@var{set_header} is of type CvSet. @var{elem} is of type void. \n\
@end deftypefn";
const char* _wrap_cvSetNumThreads_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetNumThreads (@var{threads} = 0)\n\
@var{threads} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetNumThreads_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetNumThreads ()\n\
@var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_delete_Cv64suf_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} Cv64suf::~Cv64suf (@var{self})\n\
@var{self} is of type Cv64suf. \n\
@end deftypefn";
const char* _wrap_new_Cv64suf_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = Cv64suf::Cv64suf ()\n\
@var{retval} is of type Cv64suf. \n\
@end deftypefn";
const char* _wrap_new_CvStereoBMState_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvStereoBMState::CvStereoBMState ()\n\
@var{retval} is of type CvStereoBMState. \n\
@end deftypefn";
const char* _wrap_delete_CvStereoBMState_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvStereoBMState::~CvStereoBMState (@var{self})\n\
@var{self} is of type CvStereoBMState. \n\
@end deftypefn";
const char* _wrap_cvCreateStereoBMState_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateStereoBMState (@var{preset} = 0, @var{numberOfDisparities} = 0)\n\
@var{preset} is of type int. @var{numberOfDisparities} is of type int. @var{retval} is of type CvStereoBMState. \n\
@end deftypefn";
const char* _wrap_cvReleaseStereoBMState_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseStereoBMState (@var{state})\n\
@var{state} is of type CvStereoBMState. \n\
@end deftypefn";
const char* _wrap_cvSeqSlice_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSeqSlice (@var{seq}, @var{slice}, @var{storage} = nil, @var{copy_data} = 0)\n\
@var{seq} is of type CvSeq. @var{slice} is of type CvSlice. @var{storage} is of type CvMemStorage. @var{copy_data} is of type int. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_new_CvScalar_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvScalar::CvScalar ()\n\
@var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_delete_CvScalar_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvScalar::~CvScalar (@var{self})\n\
@var{self} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvScalar_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvScalar (@var{val0})\n\
@var{val0} is of type double. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvRealScalar_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRealScalar (@var{val0})\n\
@var{val0} is of type double. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvErode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvErode (@var{src}, @var{dst}, @var{element} = nil, @var{iterations} = 1)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{element} is of type . @var{iterations} is of type int. \n\
@end deftypefn";
const char* _wrap_IplImage___radd___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __radd__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___radd___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __radd__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_new_CvBox2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvBox2D::CvBox2D ()\n\
@var{retval} is of type CvBox2D. \n\
@end deftypefn";
const char* _wrap_delete_CvBox2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvBox2D::~CvBox2D (@var{self})\n\
@var{self} is of type CvBox2D. \n\
@end deftypefn";
const char* _wrap_CV_IS_MATND_HDR_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_MATND_HDR (@var{mat})\n\
@var{mat} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvRemoveNodeFromTree_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvRemoveNodeFromTree (@var{node}, @var{frame})\n\
@var{node} is of type void. @var{frame} is of type void. \n\
@end deftypefn";
const char* _wrap_CV_IS_SEQ_CURVE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SEQ_CURVE (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvProjectPoints2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvProjectPoints2 (@var{object_points}, @var{rotation_vector}, @var{translation_vector}, @var{camera_matrix}, @var{distortion_coeffs}, @var{image_points}, @var{dpdrot} = nil, @var{dpdt} = nil, @var{dpdf} = nil, @var{dpdc} = nil, @var{dpddist} = nil, @var{aspect_ratio} = 0)\n\
@var{object_points} is of type CvMat. @var{rotation_vector} is of type CvMat. @var{translation_vector} is of type CvMat. @var{camera_matrix} is of type CvMat. @var{distortion_coeffs} is of type CvMat. @var{image_points} is of type CvMat. @var{dpdrot} is of type CvMat. @var{dpdt} is of type CvMat. @var{dpdf} is of type CvMat. @var{dpdc} is of type CvMat. @var{dpddist} is of type CvMat. @var{aspect_ratio} is of type double. \n\
@end deftypefn";
const char* _wrap_cvSetIdentity_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetIdentity (@var{mat}, @var{value} = cvRealScalar(1))\n\
@var{mat} is of type CvArr. @var{value} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvCmp_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCmp (@var{src1}, @var{src2}, @var{dst}, @var{cmp_op})\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. @var{cmp_op} is of type int. \n\
@end deftypefn";
const char* _wrap_cvWriteFileNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvWriteFileNode (@var{fs}, @var{new_node_name}, @var{node}, @var{embed})\n\
@var{fs} is of type CvFileStorage. @var{new_node_name} is of type char. @var{node} is of type CvFileNode. @var{embed} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetFileNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetFileNode (@var{fs}, @var{map}, @var{key}, @var{create_missing} = 0)\n\
@var{fs} is of type CvFileStorage. @var{map} is of type CvFileNode. @var{key} is of type CvStringHashNode. @var{create_missing} is of type int. @var{retval} is of type CvFileNode. \n\
@end deftypefn";
const char* _wrap_cvGetRootFileNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetRootFileNode (@var{fs}, @var{stream_index} = 0)\n\
@var{fs} is of type CvFileStorage. @var{stream_index} is of type int. @var{retval} is of type CvFileNode. \n\
@end deftypefn";
const char* _wrap_delete_CvFileNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvFileNode::~CvFileNode (@var{self})\n\
@var{self} is of type CvFileNode. \n\
@end deftypefn";
const char* _wrap_new_CvFileNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvFileNode::CvFileNode ()\n\
@var{retval} is of type CvFileNode. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator___incr___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator ++ (@var{self})\n\
@var{self} is of type OctSwigIterator. @var{retval} is of type OctSwigIterator. \n\
@end deftypefn";
const char* _wrap_CV_NODE_TYPE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_TYPE (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvQuadEdge2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvQuadEdge2D::CvQuadEdge2D ()\n\
@var{retval} is of type CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_delete_CvQuadEdge2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvQuadEdge2D::~CvQuadEdge2D (@var{self})\n\
@var{self} is of type CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_new_CvSeq_CvQuadEdge2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvQuadEdge2D)>::CvTypedSeq<(CvQuadEdge2D)> ()\n\
@var{retval} is of type CvSeq_CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_delete_CvSeq_CvQuadEdge2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTypedSeq<(CvQuadEdge2D)>::~CvTypedSeq<(CvQuadEdge2D)> (@var{self})\n\
@var{self} is of type CvSeq_CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_cvFree_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFree (@var{ptr})\n\
@var{ptr} is of type void. \n\
@end deftypefn";
const char* _wrap_CvMatrix_set_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} set (@var{self}, @var{m}, @var{add_ref})\n\
@var{self} is of type CvMatrix. @var{m} is of type CvMat. @var{add_ref} is of type bool. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvSeq_cast_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(p.CvSeq)>::cast (@var{seq})\n\
@var{seq} is of type CvSeq. @var{retval} is of type CvSeq_CvSeq. \n\
@end deftypefn";
const char* _wrap_cvCheckTermCriteria_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCheckTermCriteria (@var{criteria}, @var{default_eps}, @var{default_max_iters})\n\
@var{criteria} is of type CvTermCriteria. @var{default_eps} is of type double. @var{default_max_iters} is of type int. @var{retval} is of type CvTermCriteria. \n\
@end deftypefn";
const char* _wrap_new_CvTermCriteria_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTermCriteria::CvTermCriteria ()\n\
@var{retval} is of type CvTermCriteria. \n\
@end deftypefn";
const char* _wrap_delete_CvTermCriteria_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTermCriteria::~CvTermCriteria (@var{self})\n\
@var{self} is of type CvTermCriteria. \n\
@end deftypefn";
const char* _wrap_cvTermCriteria_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvTermCriteria (@var{type}, @var{max_iter}, @var{epsilon})\n\
@var{type} is of type int. @var{max_iter} is of type int. @var{epsilon} is of type double. @var{retval} is of type CvTermCriteria. \n\
@end deftypefn";
const char* _wrap_CvScalar___getitem___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __getitem__ (@var{self}, @var{index})\n\
@var{self} is of type CvScalar. @var{index} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_CvScalar___setitem___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __setitem__ (@var{self}, @var{index}, @var{value})\n\
@var{self} is of type CvScalar. @var{index} is of type int. @var{value} is of type double. \n\
@end deftypefn";
const char* _wrap_cvMeanShift_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMeanShift (@var{prob_image}, @var{window}, @var{criteria}, @var{comp})\n\
@var{prob_image} is of type CvArr. @var{window} is of type CvRect. @var{criteria} is of type CvTermCriteria. @var{comp} is of type CvConnectedComp. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCreatePOSITObject_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreatePOSITObject (@var{points}, @var{point_count})\n\
@var{points} is of type CvPoint3D32f. @var{point_count} is of type int. @var{retval} is of type CvPOSITObject. \n\
@end deftypefn";
const char* _wrap_cvReleasePOSITObject_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleasePOSITObject (@var{posit_object})\n\
@var{posit_object} is of type CvPOSITObject. \n\
@end deftypefn";
const char* _wrap_cvRedirectError_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRedirectError (@var{error_handler}, @var{userdata} = nil, @var{prev_userdata} = nil)\n\
@var{error_handler} is of type CvErrorCallback. @var{userdata} is of type void. @var{prev_userdata} is of type void. @var{retval} is of type CvErrorCallback. \n\
@end deftypefn";
const char* _wrap_CvMatrix_asCvMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator CvMat* (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvSetData_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetData (@var{arr}, @var{data}, @var{step})\n\
@var{arr} is of type CvArr. @var{data} is of type void. @var{step} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPointVector_rbegin_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = rbegin (@var{self})\n\
@var{self} is of type CvPointVector. @var{retval} is of type const_reverse_iterator. \n\
@end deftypefn";
const char* _wrap_FloatVector_rbegin_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = rbegin (@var{self})\n\
@var{self} is of type FloatVector. @var{retval} is of type const_reverse_iterator. \n\
@end deftypefn";
const char* _wrap_CvMatrix_type_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = type (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvInitSubdivDelaunay2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInitSubdivDelaunay2D (@var{subdiv}, @var{rect})\n\
@var{subdiv} is of type CvSubdiv2D. @var{rect} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_cvCreateSubdivDelaunay2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateSubdivDelaunay2D (@var{rect}, @var{storage})\n\
@var{rect} is of type CvRect. @var{storage} is of type CvMemStorage. @var{retval} is of type CvSubdiv2D. \n\
@end deftypefn";
const char* _wrap_cvGetMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetMat (@var{arr}, @var{header}, @var{coi} = nil, @var{allowND} = 0)\n\
@var{arr} is of type CvArr. @var{header} is of type CvMat. @var{coi} is of type int. @var{allowND} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvFillConvexPoly_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvFillConvexPoly (@var{img}, @var{pts}, @var{npts}, @var{color}, @var{line_type} = 8, @var{shift} = 0)\n\
@var{img} is of type CvArr. @var{pts} is of type CvPoint. @var{npts} is of type int. @var{color} is of type CvScalar. @var{line_type} is of type int. @var{shift} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGraphVtxDegreeByPtr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphVtxDegreeByPtr (@var{graph}, @var{vtx})\n\
@var{graph} is of type CvGraph. @var{vtx} is of type CvGraphVtx. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvFindGraphEdgeByPtr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindGraphEdgeByPtr (@var{graph}, @var{start_vtx}, @var{end_vtx})\n\
@var{graph} is of type CvGraph. @var{start_vtx} is of type CvGraphVtx. @var{end_vtx} is of type CvGraphVtx. @var{retval} is of type CvGraphEdge. \n\
@end deftypefn";
const char* _wrap_cvGraphRemoveEdgeByPtr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGraphRemoveEdgeByPtr (@var{graph}, @var{start_vtx}, @var{end_vtx})\n\
@var{graph} is of type CvGraph. @var{start_vtx} is of type CvGraphVtx. @var{end_vtx} is of type CvGraphVtx. \n\
@end deftypefn";
const char* _wrap_cvGraphAddEdgeByPtr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphAddEdgeByPtr (@var{graph}, @var{start_vtx}, @var{end_vtx}, @var{edge} = nil, @var{inserted_edge} = nil)\n\
@var{graph} is of type CvGraph. @var{start_vtx} is of type CvGraphVtx. @var{end_vtx} is of type CvGraphVtx. @var{edge} is of type CvGraphEdge. @var{inserted_edge} is of type CvGraphEdge. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetSetElem_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetSetElem (@var{set_header}, @var{index})\n\
@var{set_header} is of type CvSet. @var{index} is of type int. @var{retval} is of type CvSetElem. \n\
@end deftypefn";
const char* _wrap_new_CvSetElem_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSetElem::CvSetElem ()\n\
@var{retval} is of type CvSetElem. \n\
@end deftypefn";
const char* _wrap_delete_CvSetElem_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSetElem::~CvSetElem (@var{self})\n\
@var{self} is of type CvSetElem. \n\
@end deftypefn";
const char* _wrap_CvMatrix_save_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} save (@var{self}, @var{filename}, @var{matname})\n\
@var{self} is of type CvMatrix. @var{filename} is of type char. @var{matname} is of type char. \n\
@end deftypefn";
const char* _wrap_cvCreatePyramid_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreatePyramid (@var{img}, @var{extra_layers}, @var{rate}, @var{layer_sizes} = 0, @var{bufarr} = 0, @var{calc} = 1, @var{filter} = CV_GAUSSIAN_5x5)\n\
@var{img} is of type CvArr. @var{extra_layers} is of type int. @var{rate} is of type double. @var{layer_sizes} is of type CvSize. @var{bufarr} is of type CvArr. @var{calc} is of type int. @var{filter} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvReleasePyramid_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleasePyramid (@var{pyramid}, @var{extra_layers})\n\
@var{pyramid} is of type CvMat. @var{extra_layers} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSetAdd_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSetAdd (@var{set_header}, @var{elem} = nil, @var{inserted_elem} = nil)\n\
@var{set_header} is of type CvSet. @var{elem} is of type CvSetElem. @var{inserted_elem} is of type CvSetElem. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_IplImage___lt___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator < (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___lt___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator < (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvGetElemType_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetElemType (@var{arr})\n\
@var{arr} is of type CvArr. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvIntegral_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvIntegral (@var{image}, @var{sum}, @var{sqsum} = nil, @var{tilted_sum} = nil)\n\
@var{image} is of type CvArr. @var{sum} is of type CvArr. @var{sqsum} is of type CvArr. @var{tilted_sum} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvReprojectImageTo3D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReprojectImageTo3D (@var{disparityImage}, @var{_3dImage}, @var{Q}, @var{handleMissingValues} = 0)\n\
@var{disparityImage} is of type CvArr. @var{_3dImage} is of type CvArr. @var{Q} is of type CvMat. @var{handleMissingValues} is of type int. \n\
@end deftypefn";
const char* _wrap_cvErrorFromIppStatus_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvErrorFromIppStatus (@var{ipp_status})\n\
@var{ipp_status} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSetErrStatus_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetErrStatus (@var{status})\n\
@var{status} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetErrStatus_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetErrStatus ()\n\
@var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvPoint___str___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __str__ (@var{self})\n\
@var{self} is of type CvPoint. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_CvPoint2D32f___str___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __str__ (@var{self})\n\
@var{self} is of type CvPoint2D32f. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_CvScalar___str___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __str__ (@var{self})\n\
@var{self} is of type CvScalar. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_cvGetTextSize_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGetTextSize (@var{text_string}, @var{font}, @var{text_size})\n\
@var{text_string} is of type char. @var{font} is of type CvFont. @var{text_size} is of type CvSize. \n\
@end deftypefn";
const char* _wrap_cvRead_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRead (@var{fs}, @var{node}, @var{attributes} = nil)\n\
@var{fs} is of type CvFileStorage. @var{node} is of type CvFileNode. @var{attributes} is of type CvAttrList. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_cvReadStringByName_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvReadStringByName (@var{fs}, @var{map}, @var{name}, @var{default_value} = nil)\n\
@var{fs} is of type CvFileStorage. @var{map} is of type CvFileNode. @var{name} is of type char. @var{default_value} is of type char. @var{retval} is of type char. \n\
@end deftypefn";
const char* _wrap_cvGetFileNodeByName_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetFileNodeByName (@var{fs}, @var{map}, @var{name})\n\
@var{fs} is of type CvFileStorage. @var{map} is of type CvFileNode. @var{name} is of type char. @var{retval} is of type CvFileNode. \n\
@end deftypefn";
const char* _wrap_cvSubdiv2DGetEdge_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSubdiv2DGetEdge (@var{edge}, @var{type})\n\
@var{edge} is of type CvSubdiv2DEdge. @var{type} is of type CvNextEdgeType. @var{retval} is of type CvSubdiv2DEdge. \n\
@end deftypefn";
const char* _wrap_delete_CvMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvMat (@var{self})\n\
@var{self} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_new_CvRect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvRect::CvRect ()\n\
@var{retval} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_delete_CvRect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvRect::~CvRect (@var{self})\n\
@var{self} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_cvCalcEMD2_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCalcEMD2 (@var{signature1}, @var{signature2}, @var{distance_type}, @var{distance_func} = nil, @var{cost_matrix} = nil, @var{flow} = nil, @var{lower_bound} = nil, @var{userdata} = nil)\n\
@var{signature1} is of type CvArr. @var{signature2} is of type CvArr. @var{distance_type} is of type int. @var{distance_func} is of type CvDistanceFunction. @var{cost_matrix} is of type CvArr. @var{flow} is of type CvArr. @var{lower_bound} is of type float. @var{userdata} is of type void. @var{retval} is of type float. \n\
@end deftypefn";
const char* _wrap_cvPointPolygonTest_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPointPolygonTest (@var{contour}, @var{pt}, @var{measure_dist})\n\
@var{contour} is of type CvArr. @var{pt} is of type CvPoint2D32f. @var{measure_dist} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_new_CvSeq_CvRect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvRect)>::CvTypedSeq<(CvRect)> ()\n\
@var{retval} is of type CvSeq_CvRect. \n\
@end deftypefn";
const char* _wrap_delete_CvSeq_CvRect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTypedSeq<(CvRect)>::~CvTypedSeq<(CvRect)> (@var{self})\n\
@var{self} is of type CvSeq_CvRect. \n\
@end deftypefn";
const char* _wrap_cvAddS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvAddS (@var{src}, @var{value}, @var{dst}, @var{mask} = nil)\n\
@var{src} is of type CvArr. @var{value} is of type CvScalar. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvCbrt_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCbrt (@var{value})\n\
@var{value} is of type float. @var{retval} is of type float. \n\
@end deftypefn";
const char* _wrap_cvMatMulAdd_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMatMulAdd (@var{src1}, @var{src2}, @var{src3}, @var{dst})\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{src3} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CV_ELEM_SIZE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_ELEM_SIZE (@var{type})\n\
@var{type} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvSort_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSort (@var{src}, @var{dst} = nil, @var{idxmat} = nil, @var{flags} = 0)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{idxmat} is of type CvArr. @var{flags} is of type int. \n\
@end deftypefn";
const char* _wrap_delete_CvFileNode_data_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvFileNode_data::~CvFileNode_data (@var{self})\n\
@var{self} is of type CvFileNode_data. \n\
@end deftypefn";
const char* _wrap_new_CvFileNode_data_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvFileNode_data::CvFileNode_data ()\n\
@var{retval} is of type CvFileNode_data. \n\
@end deftypefn";
const char* _wrap_delete_IplROI_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} IplROI::~IplROI (@var{self})\n\
@var{self} is of type . \n\
@end deftypefn";
const char* _wrap_new_IplROI_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = IplROI::IplROI ()\n\
@var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_cvCreateData_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCreateData (@var{arr})\n\
@var{arr} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvCreateMat_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateMat (@var{rows}, @var{cols}, @var{type})\n\
@var{rows} is of type int. @var{cols} is of type int. @var{type} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvCreateMemoryLSH_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCreateMemoryLSH (@var{d}, @var{n}, @var{L} = 10, @var{k} = 10, @var{type} = (((6) &((1 << 3) -1)) +(((1) -1) << 3)), @var{r} = 4, @var{seed} = -1)\n\
@var{d} is of type int. @var{n} is of type int. @var{L} is of type int. @var{k} is of type int. @var{type} is of type int. @var{r} is of type double. @var{seed} is of type int64. @var{retval} is of type CvLSH. \n\
@end deftypefn";
const char* _wrap_delete_CvContour_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvContour::~CvContour (@var{self})\n\
@var{self} is of type CvContour. \n\
@end deftypefn";
const char* _wrap_new_CvContour_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvContour::CvContour ()\n\
@var{retval} is of type CvContour. \n\
@end deftypefn";
const char* _wrap_cvFindNextContour_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindNextContour (@var{scanner})\n\
@var{scanner} is of type CvContourScanner. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvSubstituteContour_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSubstituteContour (@var{scanner}, @var{new_contour})\n\
@var{scanner} is of type CvContourScanner. @var{new_contour} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_CV_NODE_IS_MAP_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_NODE_IS_MAP (@var{flags})\n\
@var{flags} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_MAT_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_MAT (@var{mat})\n\
@var{mat} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_32FC_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_32FC (@var{n})\n\
@var{n} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGraphGetVtxCount_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphGetVtxCount (@var{graph})\n\
@var{graph} is of type CvGraph. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvPtr1D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPtr1D (@var{arr}, @var{idx0}, @var{type} = nil)\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{type} is of type int. @var{retval} is of type uchar. \n\
@end deftypefn";
const char* _wrap_CV_ARE_CNS_EQ_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_ARE_CNS_EQ (@var{mat1}, @var{mat2})\n\
@var{mat1} is of type CvMat. @var{mat2} is of type CvMat. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvCrossProduct_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCrossProduct (@var{src1}, @var{src2}, @var{dst})\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvDotProduct_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvDotProduct (@var{src1}, @var{src2})\n\
@var{src1} is of type CvArr. @var{src2} is of type CvArr. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvStartReadSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvStartReadSeq (@var{seq}, @var{reader}, @var{reverse} = 0)\n\
@var{seq} is of type CvSeq. @var{reader} is of type CvSeqReader. @var{reverse} is of type int. \n\
@end deftypefn";
const char* _wrap_delete_CvStringHashNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvStringHashNode::~CvStringHashNode (@var{self})\n\
@var{self} is of type CvStringHashNode. \n\
@end deftypefn";
const char* _wrap_new_CvStringHashNode_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvStringHashNode::CvStringHashNode ()\n\
@var{retval} is of type CvStringHashNode. \n\
@end deftypefn";
const char* _wrap_CV_IS_SPARSE_HIST_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_SPARSE_HIST (@var{hist})\n\
@var{hist} is of type CvHistogram. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_IplImage___sub___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator - (@var{self}, @var{val})\n\
@var{self} is of type . @var{val} is of type CvScalar. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_OctSwigIterator___sub___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator - (@var{self}, @var{x})\n\
@var{self} is of type OctSwigIterator. @var{x} is of type OctSwigIterator. @var{retval} is of type ptrdiff_t. \n\
@end deftypefn";
const char* _wrap_CvMat___sub___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = operator - (@var{self}, @var{val})\n\
@var{self} is of type CvMat. @var{val} is of type CvScalar. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvSeqInvert_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSeqInvert (@var{seq})\n\
@var{seq} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvGraphAddVtx_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphAddVtx (@var{graph}, @var{vtx} = nil, @var{inserted_vtx} = nil)\n\
@var{graph} is of type CvGraph. @var{vtx} is of type CvGraphVtx. @var{inserted_vtx} is of type CvGraphVtx. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvRegisterModule_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRegisterModule (@var{module_info})\n\
@var{module_info} is of type CvModuleInfo. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGraphEdgeIdx_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGraphEdgeIdx (@var{graph}, @var{edge})\n\
@var{graph} is of type CvGraph. @var{edge} is of type CvGraphEdge. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvModule_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvModule (@var{_info})\n\
@var{_info} is of type CvModuleInfo. @var{retval} is of type CvModule. \n\
@end deftypefn";
const char* _wrap_delete_CvModule_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvModule (@var{self})\n\
@var{self} is of type CvModule. \n\
@end deftypefn";
const char* _wrap_IplImage___pow___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __pow__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type . \n\
@end deftypefn";
const char* _wrap_CvMat___pow___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __pow__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvTriangulatePoints_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvTriangulatePoints (@var{projMatr1}, @var{projMatr2}, @var{projPoints1}, @var{projPoints2}, @var{points4D})\n\
@var{projMatr1} is of type CvMat. @var{projMatr2} is of type CvMat. @var{projPoints1} is of type CvMat. @var{projPoints2} is of type CvMat. @var{points4D} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvMahalanobis_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvMahalanobis (@var{vec1}, @var{vec2}, @var{mat})\n\
@var{vec1} is of type CvArr. @var{vec2} is of type CvArr. @var{mat} is of type CvArr. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvReleaseStructuringElement_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseStructuringElement (@var{element})\n\
@var{element} is of type . \n\
@end deftypefn";
const char* _wrap_delete_CvSubdiv2DEdge_Wrapper_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvSubdiv2DEdge_Wrapper::~CvSubdiv2DEdge_Wrapper (@var{self})\n\
@var{self} is of type CvSubdiv2DEdge_Wrapper. \n\
@end deftypefn";
const char* _wrap_new_CvSubdiv2DEdge_Wrapper_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvSubdiv2DEdge_Wrapper (@var{val})\n\
@var{val} is of type CvSubdiv2DEdge. @var{retval} is of type CvSubdiv2DEdge_Wrapper. \n\
@end deftypefn";
const char* _wrap_delete_CvRNG_Wrapper_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvRNG_Wrapper::~CvRNG_Wrapper (@var{self})\n\
@var{self} is of type CvRNG_Wrapper. \n\
@end deftypefn";
const char* _wrap_new_CvRNG_Wrapper_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvRNG_Wrapper (@var{val})\n\
@var{val} is of type CvRNG. @var{retval} is of type CvRNG_Wrapper. \n\
@end deftypefn";
const char* _wrap_cvCeil_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvCeil (@var{value})\n\
@var{value} is of type double. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator_distance_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = distance (@var{self}, @var{x})\n\
@var{self} is of type OctSwigIterator. @var{x} is of type OctSwigIterator. @var{retval} is of type ptrdiff_t. \n\
@end deftypefn";
const char* _wrap_cvSubdiv2DRotateEdge_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvSubdiv2DRotateEdge (@var{edge}, @var{rotate})\n\
@var{edge} is of type CvSubdiv2DEdge. @var{rotate} is of type int. @var{retval} is of type CvSubdiv2DEdge. \n\
@end deftypefn";
const char* _wrap_cvPtr2D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPtr2D (@var{arr}, @var{idx0}, @var{idx1}, @var{type} = nil)\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{idx1} is of type int. @var{type} is of type int. @var{retval} is of type uchar. \n\
@end deftypefn";
const char* _wrap_cvBackProjectPCA_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvBackProjectPCA (@var{proj}, @var{mean}, @var{eigenvects}, @var{result})\n\
@var{proj} is of type CvArr. @var{mean} is of type CvArr. @var{eigenvects} is of type CvArr. @var{result} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvProjectPCA_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvProjectPCA (@var{data}, @var{mean}, @var{eigenvects}, @var{result})\n\
@var{data} is of type CvArr. @var{mean} is of type CvArr. @var{eigenvects} is of type CvArr. @var{result} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvReadByName_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvReadByName (@var{fs}, @var{map}, @var{name}, @var{attributes} = nil)\n\
@var{fs} is of type CvFileStorage. @var{map} is of type CvFileNode. @var{name} is of type char. @var{attributes} is of type CvAttrList. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_cvReadRealByName_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvReadRealByName (@var{fs}, @var{map}, @var{name}, @var{default_value} = 0.)\n\
@var{fs} is of type CvFileStorage. @var{map} is of type CvFileNode. @var{name} is of type char. @var{default_value} is of type double. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvReadIntByName_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvReadIntByName (@var{fs}, @var{map}, @var{name}, @var{default_value} = 0)\n\
@var{fs} is of type CvFileStorage. @var{map} is of type CvFileNode. @var{name} is of type char. @var{default_value} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvRect_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvRect (@var{x}, @var{y}, @var{width}, @var{height})\n\
@var{x} is of type int. @var{y} is of type int. @var{width} is of type int. @var{height} is of type int. @var{retval} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_cvGetND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetND (@var{arr}, @var{idx})\n\
@var{arr} is of type CvArr. @var{idx} is of type int. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvTrace_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvTrace (@var{mat})\n\
@var{mat} is of type CvArr. @var{retval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvCompleteSymm_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCompleteSymm (@var{matrix}, @var{LtoR} = 0)\n\
@var{matrix} is of type CvMat. @var{LtoR} is of type int. \n\
@end deftypefn";
const char* _wrap_cvLoad_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvLoad (@var{filename}, @var{memstorage} = nil, @var{name} = nil, @var{real_name} = nil)\n\
@var{filename} is of type char. @var{memstorage} is of type CvMemStorage. @var{name} is of type char. @var{real_name} is of type char. @var{retval} is of type void. \n\
@end deftypefn";
const char* _wrap_IplImage___rgt___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rgt__ (@var{self}, @var{arg})\n\
@var{self} is of type . @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvMat___rgt___texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = __rgt__ (@var{self}, @var{arg})\n\
@var{self} is of type CvMat. @var{arg} is of type double. @var{retval} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_CvImage_data_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = data (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type uchar. \n\
@end deftypefn";
const char* _wrap_CvMatrix_cols_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cols (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvGetRow_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetRow (@var{arr}, @var{submat}, @var{row})\n\
@var{arr} is of type CvArr. @var{submat} is of type CvMat. @var{row} is of type int. @var{retval} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvQuadEdge2D_pop_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pop (@var{self})\n\
@var{self} is of type CvSeq_CvQuadEdge2D. @var{retval} is of type CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_CV_IS_UNIFORM_HIST_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_UNIFORM_HIST (@var{hist})\n\
@var{hist} is of type CvHistogram. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_OctSwigIterator_incr_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = incr (@var{self})\n\
@var{self} is of type OctSwigIterator. @var{retval} is of type OctSwigIterator. \n\
@end deftypefn";
const char* _wrap_cvPtr3D_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPtr3D (@var{arr}, @var{idx0}, @var{idx1}, @var{idx2}, @var{type} = nil)\n\
@var{arr} is of type CvArr. @var{idx0} is of type int. @var{idx1} is of type int. @var{idx2} is of type int. @var{type} is of type int. @var{retval} is of type uchar. \n\
@end deftypefn";
const char* _wrap_new_CvPointVector_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = std::vector<(CvPoint)> (@var{size}, @var{value})\n\
@var{size} is of type size_type. @var{value} is of type value_type. @var{retval} is of type CvPointVector. \n\
@end deftypefn";
const char* _wrap_delete_FloatVector_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} std::vector<(float)>::~vector<(float)> (@var{self})\n\
@var{self} is of type FloatVector. \n\
@end deftypefn";
const char* _wrap_new_FloatVector_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = std::vector<(float)> (@var{size}, @var{value})\n\
@var{size} is of type size_type. @var{value} is of type value_type. @var{retval} is of type FloatVector. \n\
@end deftypefn";
const char* _wrap_delete_CvPointVector_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} std::vector<(CvPoint)>::~vector<(CvPoint)> (@var{self})\n\
@var{self} is of type CvPointVector. \n\
@end deftypefn";
const char* _wrap_cvOrS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvOrS (@var{src}, @var{value}, @var{dst}, @var{mask} = nil)\n\
@var{src} is of type CvArr. @var{value} is of type CvScalar. @var{dst} is of type CvArr. @var{mask} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvInsertNodeIntoTree_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInsertNodeIntoTree (@var{node}, @var{parent}, @var{frame})\n\
@var{node} is of type void. @var{parent} is of type void. @var{frame} is of type void. \n\
@end deftypefn";
const char* _wrap_cvCornerEigenValsAndVecs_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvCornerEigenValsAndVecs (@var{image}, @var{eigenvv}, @var{block_size}, @var{aperture_size} = 3)\n\
@var{image} is of type CvArr. @var{eigenvv} is of type CvArr. @var{block_size} is of type int. @var{aperture_size} is of type int. \n\
@end deftypefn";
const char* _wrap_cvUseOptimized_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvUseOptimized (@var{on_off})\n\
@var{on_off} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CV_IS_STORAGE_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IS_STORAGE (@var{storage})\n\
@var{storage} is of type CvMemStorage. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvTuple_CvPoint_2___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvTuple_CvPoint_2. @var{i} is of type int. @var{obj} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CvTuple_float_2___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvTuple_float_2. @var{i} is of type int. @var{obj} is of type float. \n\
@end deftypefn";
const char* _wrap_CvTuple_float_3___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvTuple_float_3. @var{i} is of type int. @var{obj} is of type float. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvPoint. @var{i} is of type int. @var{obj} is of type CvPoint. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint2D32f___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvPoint2D32f. @var{i} is of type int. @var{obj} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvRect___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvRect. @var{i} is of type int. @var{obj} is of type CvRect. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvSeq___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvSeq. @var{i} is of type int. @var{obj} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvQuadEdge2D___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvQuadEdge2D. @var{i} is of type int. @var{obj} is of type CvQuadEdge2D. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvConnectedComp___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvConnectedComp. @var{i} is of type int. @var{obj} is of type CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_CvSeq_CvPoint_2___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_CvPoint_2. @var{i} is of type int. @var{obj} is of type CvTuple_CvPoint_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_2___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_float_2. @var{i} is of type int. @var{obj} is of type CvTuple_float_2. \n\
@end deftypefn";
const char* _wrap_CvSeq_float_3___brace_asgn_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} __brace_asgn (@var{self}, @var{i}, @var{obj})\n\
@var{self} is of type CvSeq_float_3. @var{i} is of type int. @var{obj} is of type CvTuple_float_3. \n\
@end deftypefn";
const char* _wrap_cvReleaseHist_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvReleaseHist (@var{hist})\n\
@var{hist} is of type CvHistogram. \n\
@end deftypefn";
const char* _wrap_cvWarpPerspective_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvWarpPerspective (@var{src}, @var{dst}, @var{map_matrix}, @var{flags} = 1+8, @var{fillval} = cvScalarAll(0))\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{map_matrix} is of type CvMat. @var{flags} is of type int. @var{fillval} is of type CvScalar. \n\
@end deftypefn";
const char* _wrap_cvInvert_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvInvert (@var{src}, @var{dst}, @var{method} = 0)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{method} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvMulTransposed_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvMulTransposed (@var{src}, @var{dst}, @var{order}, @var{delta} = nil, @var{scale} = 1.)\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{order} is of type int. @var{delta} is of type CvArr. @var{scale} is of type double. \n\
@end deftypefn";
const char* _wrap_CvMatrix_pix_size_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pix_size (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvMatrix_size_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = size (@var{self})\n\
@var{self} is of type CvMatrix. @var{retval} is of type CvSize. \n\
@end deftypefn";
const char* _wrap_CvImage_pix_size_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = pix_size (@var{self})\n\
@var{self} is of type CvImage. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_CvMatrix_show_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} show (@var{self}, @var{window_name})\n\
@var{self} is of type CvMatrix. @var{window_name} is of type char. \n\
@end deftypefn";
const char* _wrap_cvIplDepth_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvIplDepth (@var{type})\n\
@var{type} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_new_CvConnectedComp_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvConnectedComp::CvConnectedComp ()\n\
@var{retval} is of type CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_delete_CvConnectedComp_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvConnectedComp::~CvConnectedComp (@var{self})\n\
@var{self} is of type CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_new_CvSeq_CvConnectedComp_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvConnectedComp)>::CvTypedSeq<(CvConnectedComp)> ()\n\
@var{retval} is of type CvSeq_CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_delete_CvSeq_CvConnectedComp_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTypedSeq<(CvConnectedComp)>::~CvTypedSeq<(CvConnectedComp)> (@var{self})\n\
@var{self} is of type CvSeq_CvConnectedComp. \n\
@end deftypefn";
const char* _wrap_new_CvPoint2D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvPoint2D32f::CvPoint2D32f ()\n\
@var{retval} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_delete_CvPoint2D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvPoint2D32f::~CvPoint2D32f (@var{self})\n\
@var{self} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_cvPoint2D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvPoint2D32f (@var{x}, @var{y})\n\
@var{x} is of type double. @var{y} is of type double. @var{retval} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_cvSetRealND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvSetRealND (@var{arr}, @var{idx}, @var{value})\n\
@var{arr} is of type CvArr. @var{idx} is of type int. @var{value} is of type double. \n\
@end deftypefn";
const char* _wrap_cvGetRealND_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetRealND (@var{arr}, @var{idx})\n\
@var{arr} is of type CvArr. @var{idx} is of type int. @var{retval} is of type double. \n\
@end deftypefn";
const char* _wrap_cvStartReadChainPoints_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvStartReadChainPoints (@var{chain}, @var{reader})\n\
@var{chain} is of type CvChain. @var{reader} is of type CvChainPtReader. \n\
@end deftypefn";
const char* _wrap_cvFindDominantPoints_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvFindDominantPoints (@var{contour}, @var{storage}, @var{method} = 1, @var{parameter1} = 0, @var{parameter2} = 0, @var{parameter3} = 0, @var{parameter4} = 0)\n\
@var{contour} is of type CvSeq. @var{storage} is of type CvMemStorage. @var{method} is of type int. @var{parameter1} is of type double. @var{parameter2} is of type double. @var{parameter3} is of type double. @var{parameter4} is of type double. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvBoxPoints_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvBoxPoints (@var{box}, @var{pt})\n\
@var{box} is of type CvBox2D. @var{pt} is of type CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_cvGetStarKeypoints_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = cvGetStarKeypoints (@var{img}, @var{storage}, @var{params} = cvStarDetectorParams())\n\
@var{img} is of type CvArr. @var{storage} is of type CvMemStorage. @var{params} is of type CvStarDetectorParams. @var{retval} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvUndistortPoints_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvUndistortPoints (@var{src}, @var{dst}, @var{camera_matrix}, @var{dist_coeffs}, @var{R} = 0, @var{P} = 0)\n\
@var{src} is of type CvMat. @var{dst} is of type CvMat. @var{camera_matrix} is of type CvMat. @var{dist_coeffs} is of type CvMat. @var{R} is of type CvMat. @var{P} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_new_CvSeq_CvPoint2D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CvTypedSeq<(CvPoint2D32f)>::CvTypedSeq<(CvPoint2D32f)> ()\n\
@var{retval} is of type CvSeq_CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_delete_CvSeq_CvPoint2D32f_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} CvTypedSeq<(CvPoint2D32f)>::~CvTypedSeq<(CvPoint2D32f)> (@var{self})\n\
@var{self} is of type CvSeq_CvPoint2D32f. \n\
@end deftypefn";
const char* _wrap_CV_IMIN_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} @var{retval} = CV_IMIN (@var{a}, @var{b})\n\
@var{a} is of type int. @var{b} is of type int. @var{retval} is of type int. \n\
@end deftypefn";
const char* _wrap_cvClearSeq_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvClearSeq (@var{seq})\n\
@var{seq} is of type CvSeq. \n\
@end deftypefn";
const char* _wrap_cvInRangeS_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvInRangeS (@var{src}, @var{lower}, @var{upper}, @var{dst})\n\
@var{src} is of type CvArr. @var{lower} is of type CvScalar. @var{upper} is of type CvScalar. @var{dst} is of type CvArr. \n\
@end deftypefn";
const char* _wrap_cvGetQuadrangleSubPix_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvGetQuadrangleSubPix (@var{src}, @var{dst}, @var{map_matrix})\n\
@var{src} is of type CvArr. @var{dst} is of type CvArr. @var{map_matrix} is of type CvMat. \n\
@end deftypefn";
const char* _wrap_cvClearSet_texinfo = "-*- texinfo -*-\n\
@deftypefn {Loadable Function} cvClearSet (@var{set_header})\n\
@var{set_header} is of type CvSet. \n\
@end deftypefn";

static octave_value_list _wrap_new_CvRNG_Wrapper (const octave_value_list& args, int nargout) {
  CvRNG *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRNG_Wrapper *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvRNG_Wrapper",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_uint64_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvRNG_Wrapper" "', argument " "1"" of type '" "CvRNG const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CvRNG_Wrapper" "', argument " "1"" of type '" "CvRNG const &""'"); 
  }
  arg1 = (CvRNG *)(argp1);
  result = (CvRNG_Wrapper *)new CvRNG_Wrapper((CvRNG const &)*arg1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvRNG_Wrapper, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRNG_Wrapper_ptr (const octave_value_list& args, int nargout) {
  CvRNG_Wrapper *arg1 = (CvRNG_Wrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRNG *result = 0 ;
  
  if (!SWIG_check_num_args("CvRNG_Wrapper_ptr",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRNG_Wrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRNG_Wrapper_ptr" "', argument " "1"" of type '" "CvRNG_Wrapper *""'"); 
  }
  arg1 = (CvRNG_Wrapper *)(argp1);
  result = (CvRNG *)(arg1)->ptr();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_uint64_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRNG_Wrapper_ref (const octave_value_list& args, int nargout) {
  CvRNG_Wrapper *arg1 = (CvRNG_Wrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRNG *result = 0 ;
  
  if (!SWIG_check_num_args("CvRNG_Wrapper_ref",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRNG_Wrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRNG_Wrapper_ref" "', argument " "1"" of type '" "CvRNG_Wrapper *""'"); 
  }
  arg1 = (CvRNG_Wrapper *)(argp1);
  result = (CvRNG *) &(arg1)->ref();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_uint64_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRNG_Wrapper___eq__ (const octave_value_list& args, int nargout) {
  CvRNG_Wrapper *arg1 = (CvRNG_Wrapper *) 0 ;
  CvRNG_Wrapper *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvRNG_Wrapper___eq__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRNG_Wrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRNG_Wrapper___eq__" "', argument " "1"" of type '" "CvRNG_Wrapper *""'"); 
  }
  arg1 = (CvRNG_Wrapper *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvRNG_Wrapper,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvRNG_Wrapper___eq__" "', argument " "2"" of type '" "CvRNG_Wrapper const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvRNG_Wrapper___eq__" "', argument " "2"" of type '" "CvRNG_Wrapper const &""'"); 
  }
  arg2 = (CvRNG_Wrapper *)(argp2);
  result = (bool)(arg1)->operator ==((CvRNG_Wrapper const &)*arg2);
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRNG_Wrapper___ne__ (const octave_value_list& args, int nargout) {
  CvRNG_Wrapper *arg1 = (CvRNG_Wrapper *) 0 ;
  CvRNG_Wrapper *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvRNG_Wrapper___ne__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRNG_Wrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRNG_Wrapper___ne__" "', argument " "1"" of type '" "CvRNG_Wrapper *""'"); 
  }
  arg1 = (CvRNG_Wrapper *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvRNG_Wrapper,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvRNG_Wrapper___ne__" "', argument " "2"" of type '" "CvRNG_Wrapper const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvRNG_Wrapper___ne__" "', argument " "2"" of type '" "CvRNG_Wrapper const &""'"); 
  }
  arg2 = (CvRNG_Wrapper *)(argp2);
  result = (bool)(arg1)->operator !=((CvRNG_Wrapper const &)*arg2);
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvRNG_Wrapper (const octave_value_list& args, int nargout) {
  CvRNG_Wrapper *arg1 = (CvRNG_Wrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvRNG_Wrapper",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRNG_Wrapper, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvRNG_Wrapper" "', argument " "1"" of type '" "CvRNG_Wrapper *""'"); 
  }
  arg1 = (CvRNG_Wrapper *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvRNG_Wrapper_members[] = {
{"ptr",_wrap_CvRNG_Wrapper_ptr,0,0,0,0},
{"ref",_wrap_CvRNG_Wrapper_ref,0,0,0,0},
{"__eq__",_wrap_CvRNG_Wrapper___eq__,0,0,0,0},
{"__ne__",_wrap_CvRNG_Wrapper___ne__,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvRNG_Wrapper_base_names[] = {0};
static const swig_type_info *swig_CvRNG_Wrapper_base[] = {0};
static swig_octave_class _wrap_class_CvRNG_Wrapper = {"CvRNG_Wrapper", &SWIGTYPE_p_CvRNG_Wrapper,0,_wrap_new_CvRNG_Wrapper,0,_wrap_delete_CvRNG_Wrapper,swig_CvRNG_Wrapper_members,swig_CvRNG_Wrapper_base_names,swig_CvRNG_Wrapper_base };

static octave_value_list _wrap_new_CvSubdiv2DEdge_Wrapper (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge *arg1 = 0 ;
  CvSubdiv2DEdge temp1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DEdge_Wrapper *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSubdiv2DEdge_Wrapper",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvSubdiv2DEdge_Wrapper" "', argument " "1"" of type '" "CvSubdiv2DEdge""'");
  } 
  temp1 = (CvSubdiv2DEdge)(val1);
  arg1 = &temp1;
  result = (CvSubdiv2DEdge_Wrapper *)new CvSubdiv2DEdge_Wrapper((CvSubdiv2DEdge const &)*arg1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2DEdge_Wrapper_ptr (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge_Wrapper *arg1 = (CvSubdiv2DEdge_Wrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DEdge *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2DEdge_Wrapper_ptr",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2DEdge_Wrapper_ptr" "', argument " "1"" of type '" "CvSubdiv2DEdge_Wrapper *""'"); 
  }
  arg1 = (CvSubdiv2DEdge_Wrapper *)(argp1);
  result = (CvSubdiv2DEdge *)(arg1)->ptr();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_size_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2DEdge_Wrapper_ref (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge_Wrapper *arg1 = (CvSubdiv2DEdge_Wrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DEdge *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2DEdge_Wrapper_ref",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2DEdge_Wrapper_ref" "', argument " "1"" of type '" "CvSubdiv2DEdge_Wrapper *""'"); 
  }
  arg1 = (CvSubdiv2DEdge_Wrapper *)(argp1);
  result = (CvSubdiv2DEdge *) &(arg1)->ref();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_size_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2DEdge_Wrapper___eq__ (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge_Wrapper *arg1 = (CvSubdiv2DEdge_Wrapper *) 0 ;
  CvSubdiv2DEdge_Wrapper *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvSubdiv2DEdge_Wrapper___eq__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2DEdge_Wrapper___eq__" "', argument " "1"" of type '" "CvSubdiv2DEdge_Wrapper *""'"); 
  }
  arg1 = (CvSubdiv2DEdge_Wrapper *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2DEdge_Wrapper___eq__" "', argument " "2"" of type '" "CvSubdiv2DEdge_Wrapper const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvSubdiv2DEdge_Wrapper___eq__" "', argument " "2"" of type '" "CvSubdiv2DEdge_Wrapper const &""'"); 
  }
  arg2 = (CvSubdiv2DEdge_Wrapper *)(argp2);
  result = (bool)(arg1)->operator ==((CvSubdiv2DEdge_Wrapper const &)*arg2);
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2DEdge_Wrapper___ne__ (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge_Wrapper *arg1 = (CvSubdiv2DEdge_Wrapper *) 0 ;
  CvSubdiv2DEdge_Wrapper *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvSubdiv2DEdge_Wrapper___ne__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2DEdge_Wrapper___ne__" "', argument " "1"" of type '" "CvSubdiv2DEdge_Wrapper *""'"); 
  }
  arg1 = (CvSubdiv2DEdge_Wrapper *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2DEdge_Wrapper___ne__" "', argument " "2"" of type '" "CvSubdiv2DEdge_Wrapper const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvSubdiv2DEdge_Wrapper___ne__" "', argument " "2"" of type '" "CvSubdiv2DEdge_Wrapper const &""'"); 
  }
  arg2 = (CvSubdiv2DEdge_Wrapper *)(argp2);
  result = (bool)(arg1)->operator !=((CvSubdiv2DEdge_Wrapper const &)*arg2);
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSubdiv2DEdge_Wrapper (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge_Wrapper *arg1 = (CvSubdiv2DEdge_Wrapper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSubdiv2DEdge_Wrapper",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSubdiv2DEdge_Wrapper" "', argument " "1"" of type '" "CvSubdiv2DEdge_Wrapper *""'"); 
  }
  arg1 = (CvSubdiv2DEdge_Wrapper *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSubdiv2DEdge_Wrapper_members[] = {
{"ptr",_wrap_CvSubdiv2DEdge_Wrapper_ptr,0,0,0,0},
{"ref",_wrap_CvSubdiv2DEdge_Wrapper_ref,0,0,0,0},
{"__eq__",_wrap_CvSubdiv2DEdge_Wrapper___eq__,0,0,0,0},
{"__ne__",_wrap_CvSubdiv2DEdge_Wrapper___ne__,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSubdiv2DEdge_Wrapper_base_names[] = {0};
static const swig_type_info *swig_CvSubdiv2DEdge_Wrapper_base[] = {0};
static swig_octave_class _wrap_class_CvSubdiv2DEdge_Wrapper = {"CvSubdiv2DEdge_Wrapper", &SWIGTYPE_p_CvSubdiv2DEdge_Wrapper,0,_wrap_new_CvSubdiv2DEdge_Wrapper,0,_wrap_delete_CvSubdiv2DEdge_Wrapper,swig_CvSubdiv2DEdge_Wrapper_members,swig_CvSubdiv2DEdge_Wrapper_base_names,swig_CvSubdiv2DEdge_Wrapper_base };

static octave_value_list _wrap_delete_OctSwigIterator (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_OctSwigIterator",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OctSwigIterator" "', argument " "1"" of type '" "swig::OctSwigIterator *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  delete arg1;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_value (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  octave_value result;
  
  if (!SWIG_check_num_args("OctSwigIterator_value",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_value" "', argument " "1"" of type '" "swig::OctSwigIterator const *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  try {
    result = ((swig::OctSwigIterator const *)arg1)->value();
  }
  catch(swig::stop_iteration &_e) {
    {
      error("stop_iteration exception");
      SWIG_fail;
    }
  }
  
  _outv = result;
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_incr__SWIG_0 (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  swig::OctSwigIterator *result = 0 ;
  
  if (!SWIG_check_num_args("OctSwigIterator_incr",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_incr" "', argument " "1"" of type '" "swig::OctSwigIterator *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OctSwigIterator_incr" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  try {
    result = (swig::OctSwigIterator *)(arg1)->incr(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      error("stop_iteration exception");
      SWIG_fail;
    }
  }
  
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_incr__SWIG_1 (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  swig::OctSwigIterator *result = 0 ;
  
  if (!SWIG_check_num_args("OctSwigIterator_incr",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_incr" "', argument " "1"" of type '" "swig::OctSwigIterator *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  try {
    result = (swig::OctSwigIterator *)(arg1)->incr();
  }
  catch(swig::stop_iteration &_e) {
    {
      error("stop_iteration exception");
      SWIG_fail;
    }
  }
  
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_incr (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__OctSwigIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OctSwigIterator_incr__SWIG_1(args, nargout);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__OctSwigIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OctSwigIterator_incr__SWIG_0(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_OctSwigIterator_decr__SWIG_0 (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  swig::OctSwigIterator *result = 0 ;
  
  if (!SWIG_check_num_args("OctSwigIterator_decr",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_decr" "', argument " "1"" of type '" "swig::OctSwigIterator *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OctSwigIterator_decr" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  try {
    result = (swig::OctSwigIterator *)(arg1)->decr(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      error("stop_iteration exception");
      SWIG_fail;
    }
  }
  
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_decr__SWIG_1 (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  swig::OctSwigIterator *result = 0 ;
  
  if (!SWIG_check_num_args("OctSwigIterator_decr",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_decr" "', argument " "1"" of type '" "swig::OctSwigIterator *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  try {
    result = (swig::OctSwigIterator *)(arg1)->decr();
  }
  catch(swig::stop_iteration &_e) {
    {
      error("stop_iteration exception");
      SWIG_fail;
    }
  }
  
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_decr (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__OctSwigIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OctSwigIterator_decr__SWIG_1(args, nargout);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__OctSwigIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OctSwigIterator_decr__SWIG_0(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_OctSwigIterator_distance (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  swig::OctSwigIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  ptrdiff_t result;
  
  if (!SWIG_check_num_args("OctSwigIterator_distance",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_distance" "', argument " "1"" of type '" "swig::OctSwigIterator const *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_swig__OctSwigIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OctSwigIterator_distance" "', argument " "2"" of type '" "swig::OctSwigIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OctSwigIterator_distance" "', argument " "2"" of type '" "swig::OctSwigIterator const &""'"); 
  }
  arg2 = (swig::OctSwigIterator *)(argp2);
  try {
    result = ((swig::OctSwigIterator const *)arg1)->distance((swig::OctSwigIterator const &)*arg2);
  }
  catch(std::invalid_argument &_e) {
    error("C++ side threw an exception of type " "std::invalid_argument"); SWIG_fail;
  }
  
  _outv = SWIG_From_ptrdiff_t((ptrdiff_t)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_equal (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  swig::OctSwigIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("OctSwigIterator_equal",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_equal" "', argument " "1"" of type '" "swig::OctSwigIterator const *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_swig__OctSwigIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OctSwigIterator_equal" "', argument " "2"" of type '" "swig::OctSwigIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OctSwigIterator_equal" "', argument " "2"" of type '" "swig::OctSwigIterator const &""'"); 
  }
  arg2 = (swig::OctSwigIterator *)(argp2);
  try {
    result = (bool)((swig::OctSwigIterator const *)arg1)->equal((swig::OctSwigIterator const &)*arg2);
  }
  catch(std::invalid_argument &_e) {
    error("C++ side threw an exception of type " "std::invalid_argument"); SWIG_fail;
  }
  
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_copy (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  swig::OctSwigIterator *result = 0 ;
  
  if (!SWIG_check_num_args("OctSwigIterator_copy",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_copy" "', argument " "1"" of type '" "swig::OctSwigIterator const *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  result = (swig::OctSwigIterator *)((swig::OctSwigIterator const *)arg1)->copy();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__OctSwigIterator, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_next (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  octave_value result;
  
  if (!SWIG_check_num_args("OctSwigIterator_next",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_next" "', argument " "1"" of type '" "swig::OctSwigIterator *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  try {
    result = (arg1)->next();
  }
  catch(swig::stop_iteration &_e) {
    {
      error("stop_iteration exception");
      SWIG_fail;
    }
  }
  
  _outv = result;
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_previous (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  octave_value result;
  
  if (!SWIG_check_num_args("OctSwigIterator_previous",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_previous" "', argument " "1"" of type '" "swig::OctSwigIterator *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  try {
    result = (arg1)->previous();
  }
  catch(swig::stop_iteration &_e) {
    {
      error("stop_iteration exception");
      SWIG_fail;
    }
  }
  
  _outv = result;
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator_advance (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  swig::OctSwigIterator *result = 0 ;
  
  if (!SWIG_check_num_args("OctSwigIterator_advance",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator_advance" "', argument " "1"" of type '" "swig::OctSwigIterator *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OctSwigIterator_advance" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = (ptrdiff_t)(val2);
  try {
    result = (swig::OctSwigIterator *)(arg1)->advance(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      error("stop_iteration exception");
      SWIG_fail;
    }
  }
  
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator___eq__ (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  swig::OctSwigIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("OctSwigIterator___eq__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator___eq__" "', argument " "1"" of type '" "swig::OctSwigIterator const *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_swig__OctSwigIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OctSwigIterator___eq__" "', argument " "2"" of type '" "swig::OctSwigIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OctSwigIterator___eq__" "', argument " "2"" of type '" "swig::OctSwigIterator const &""'"); 
  }
  arg2 = (swig::OctSwigIterator *)(argp2);
  result = (bool)((swig::OctSwigIterator const *)arg1)->operator ==((swig::OctSwigIterator const &)*arg2);
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator___ne__ (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  swig::OctSwigIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("OctSwigIterator___ne__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator___ne__" "', argument " "1"" of type '" "swig::OctSwigIterator const *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_swig__OctSwigIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OctSwigIterator___ne__" "', argument " "2"" of type '" "swig::OctSwigIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OctSwigIterator___ne__" "', argument " "2"" of type '" "swig::OctSwigIterator const &""'"); 
  }
  arg2 = (swig::OctSwigIterator *)(argp2);
  result = (bool)((swig::OctSwigIterator const *)arg1)->operator !=((swig::OctSwigIterator const &)*arg2);
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator___incr__ (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  swig::OctSwigIterator *result = 0 ;
  
  if (!SWIG_check_num_args("OctSwigIterator___incr__",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator___incr__" "', argument " "1"" of type '" "swig::OctSwigIterator *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  result = (swig::OctSwigIterator *)(arg1)->operator ++();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator___decr__ (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  swig::OctSwigIterator *result = 0 ;
  
  if (!SWIG_check_num_args("OctSwigIterator___decr__",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator___decr__" "', argument " "1"" of type '" "swig::OctSwigIterator *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  result = (swig::OctSwigIterator *)(arg1)->operator --();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator___add__ (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  swig::OctSwigIterator *result = 0 ;
  
  if (!SWIG_check_num_args("OctSwigIterator___add__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator___add__" "', argument " "1"" of type '" "swig::OctSwigIterator const *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OctSwigIterator___add__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = (ptrdiff_t)(val2);
  try {
    result = (swig::OctSwigIterator *)((swig::OctSwigIterator const *)arg1)->operator +(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      error("stop_iteration exception");
      SWIG_fail;
    }
  }
  
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__OctSwigIterator, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator___sub____SWIG_0 (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  swig::OctSwigIterator *result = 0 ;
  
  if (!SWIG_check_num_args("OctSwigIterator___sub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator___sub__" "', argument " "1"" of type '" "swig::OctSwigIterator const *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OctSwigIterator___sub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = (ptrdiff_t)(val2);
  try {
    result = (swig::OctSwigIterator *)((swig::OctSwigIterator const *)arg1)->operator -(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      error("stop_iteration exception");
      SWIG_fail;
    }
  }
  
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__OctSwigIterator, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator___sub____SWIG_1 (const octave_value_list& args, int nargout) {
  swig::OctSwigIterator *arg1 = (swig::OctSwigIterator *) 0 ;
  swig::OctSwigIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  ptrdiff_t result;
  
  if (!SWIG_check_num_args("OctSwigIterator___sub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_swig__OctSwigIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OctSwigIterator___sub__" "', argument " "1"" of type '" "swig::OctSwigIterator const *""'"); 
  }
  arg1 = (swig::OctSwigIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_swig__OctSwigIterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "OctSwigIterator___sub__" "', argument " "2"" of type '" "swig::OctSwigIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OctSwigIterator___sub__" "', argument " "2"" of type '" "swig::OctSwigIterator const &""'"); 
  }
  arg2 = (swig::OctSwigIterator *)(argp2);
  result = ((swig::OctSwigIterator const *)arg1)->operator -((swig::OctSwigIterator const &)*arg2);
  _outv = SWIG_From_ptrdiff_t((ptrdiff_t)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_OctSwigIterator___sub__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__OctSwigIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__OctSwigIterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_OctSwigIterator___sub____SWIG_1(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__OctSwigIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_OctSwigIterator___sub____SWIG_0(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static swig_octave_member swig_OctSwigIterator_members[] = {
{"value",_wrap_OctSwigIterator_value,0,0,0,0},
{"incr",_wrap_OctSwigIterator_incr,0,0,0,0},
{"decr",_wrap_OctSwigIterator_decr,0,0,0,0},
{"distance",_wrap_OctSwigIterator_distance,0,0,0,0},
{"equal",_wrap_OctSwigIterator_equal,0,0,0,0},
{"copy",_wrap_OctSwigIterator_copy,0,0,0,0},
{"next",_wrap_OctSwigIterator_next,0,0,0,0},
{"previous",_wrap_OctSwigIterator_previous,0,0,0,0},
{"advance",_wrap_OctSwigIterator_advance,0,0,0,0},
{"__eq__",_wrap_OctSwigIterator___eq__,0,0,0,0},
{"__ne__",_wrap_OctSwigIterator___ne__,0,0,0,0},
{"__incr__",_wrap_OctSwigIterator___incr__,0,0,0,0},
{"__decr__",_wrap_OctSwigIterator___decr__,0,0,0,0},
{"__add__",_wrap_OctSwigIterator___add__,0,0,0,0},
{"__sub__",_wrap_OctSwigIterator___sub__,0,0,0,0},
{0,0,0,0}
};
static const char *swig_OctSwigIterator_base_names[] = {0};
static const swig_type_info *swig_OctSwigIterator_base[] = {0};
static swig_octave_class _wrap_class_OctSwigIterator = {"OctSwigIterator", &SWIGTYPE_p_swig__OctSwigIterator,0,0,0,_wrap_delete_OctSwigIterator,swig_OctSwigIterator_members,swig_OctSwigIterator_base_names,swig_OctSwigIterator_base };

static octave_value_list _wrap_FloatVector_pop (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::value_type result;
  
  if (!SWIG_check_num_args("FloatVector_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_pop" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  try {
    result = (std::vector< float >::value_type)std_vector_Sl_float_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector___paren__ (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::value_type result;
  
  if (!SWIG_check_num_args("FloatVector___paren__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector___paren__" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FloatVector___paren__" "', argument " "2"" of type '" "std::vector< float >::difference_type""'");
  } 
  arg2 = (std::vector< float >::difference_type)(val2);
  try {
    result = (std::vector< float >::value_type)std_vector_Sl_float_Sg____paren__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector___paren_asgn__ (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::difference_type arg2 ;
  std::vector< float >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector___paren_asgn__",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector___paren_asgn__" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FloatVector___paren_asgn__" "', argument " "2"" of type '" "std::vector< float >::difference_type""'");
  } 
  arg2 = (std::vector< float >::difference_type)(val2);
  ecode3 = SWIG_AsVal_float(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "FloatVector___paren_asgn__" "', argument " "3"" of type '" "std::vector< float >::value_type""'");
  } 
  arg3 = (std::vector< float >::value_type)(val3);
  try {
    std_vector_Sl_float_Sg____paren_asgn__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_append (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::value_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_append" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FloatVector_append" "', argument " "2"" of type '" "std::vector< float >::value_type""'");
  } 
  arg2 = (std::vector< float >::value_type)(val2);
  std_vector_Sl_float_Sg__append(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_FloatVector__SWIG_0 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float > *result = 0 ;
  
  if (!SWIG_check_num_args("new_FloatVector",args.length(),0,0,0)) {
    SWIG_fail;
  }
  result = (std::vector< float > *)new std::vector< float >();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_FloatVector__SWIG_1 (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float > *result = 0 ;
  
  if (!SWIG_check_num_args("new_FloatVector",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    std::vector<float,std::allocator< float > > *ptr = (std::vector<float,std::allocator< float > > *)0;
    res1 = swig::asptr(args(0), &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_FloatVector" "', argument " "1"" of type '" "std::vector< float > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FloatVector" "', argument " "1"" of type '" "std::vector< float > const &""'"); 
    }
    arg1 = ptr;
  }
  result = (std::vector< float > *)new std::vector< float >((std::vector< float > const &)*arg1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (SWIG_IsNewObj(res1)) delete arg1;
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_empty (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("FloatVector_empty",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_empty" "', argument " "1"" of type '" "std::vector< float > const *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  result = (bool)((std::vector< float > const *)arg1)->empty();
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_size (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::size_type result;
  
  if (!SWIG_check_num_args("FloatVector_size",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_size" "', argument " "1"" of type '" "std::vector< float > const *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  result = ((std::vector< float > const *)arg1)->size();
  _outv = SWIG_From_size_t((size_t)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_clear (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector_clear",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_clear" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  (arg1)->clear();
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_swap (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector_swap",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_swap" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FloatVector_swap" "', argument " "2"" of type '" "std::vector< float > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FloatVector_swap" "', argument " "2"" of type '" "std::vector< float > &""'"); 
  }
  arg2 = (std::vector< float > *)(argp2);
  (arg1)->swap(*arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_get_allocator (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  SwigValueWrapper< std::allocator< float > > result;
  
  if (!SWIG_check_num_args("FloatVector_get_allocator",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_get_allocator" "', argument " "1"" of type '" "std::vector< float > const *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  result = ((std::vector< float > const *)arg1)->get_allocator();
  _outv = SWIG_NewPointerObj((new std::vector< float >::allocator_type((const std::vector< float >::allocator_type&)(result))), SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_begin (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::const_iterator result;
  
  if (!SWIG_check_num_args("FloatVector_begin",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_begin" "', argument " "1"" of type '" "std::vector< float > const *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  result = ((std::vector< float > const *)arg1)->begin();
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< float >::const_iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_end (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::const_iterator result;
  
  if (!SWIG_check_num_args("FloatVector_end",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_end" "', argument " "1"" of type '" "std::vector< float > const *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  result = ((std::vector< float > const *)arg1)->end();
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< float >::const_iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_rbegin (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::const_reverse_iterator result;
  
  if (!SWIG_check_num_args("FloatVector_rbegin",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_rbegin" "', argument " "1"" of type '" "std::vector< float > const *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  result = ((std::vector< float > const *)arg1)->rbegin();
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< float >::const_reverse_iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_rend (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::const_reverse_iterator result;
  
  if (!SWIG_check_num_args("FloatVector_rend",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_rend" "', argument " "1"" of type '" "std::vector< float > const *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  result = ((std::vector< float > const *)arg1)->rend();
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< float >::const_reverse_iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_FloatVector__SWIG_2 (const octave_value_list& args, int nargout) {
  std::vector< float >::size_type arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float > *result = 0 ;
  
  if (!SWIG_check_num_args("new_FloatVector",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_FloatVector" "', argument " "1"" of type '" "std::vector< float >::size_type""'");
  } 
  arg1 = (std::vector< float >::size_type)(val1);
  result = (std::vector< float > *)new std::vector< float >(arg1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_pop_back (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector_pop_back",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_pop_back" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  (arg1)->pop_back();
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_resize__SWIG_0 (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector_resize",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_resize" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FloatVector_resize" "', argument " "2"" of type '" "std::vector< float >::size_type""'");
  } 
  arg2 = (std::vector< float >::size_type)(val2);
  (arg1)->resize(arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_erase__SWIG_0 (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::OctSwigIterator *iter2 = 0 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::iterator result;
  
  if (!SWIG_check_num_args("FloatVector_erase",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_erase" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), SWIG_as_voidptrptr(&iter2), swig::OctSwigIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "FloatVector_erase" "', argument " "2"" of type '" "std::vector< float >::iterator""'");
  } else {
    swig::OctSwigIterator_T<std::vector< float >::iterator > *iter_t = dynamic_cast<swig::OctSwigIterator_T<std::vector< float >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "FloatVector_erase" "', argument " "2"" of type '" "std::vector< float >::iterator""'");
    }
  }
  result = (arg1)->erase(arg2);
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< float >::iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_erase__SWIG_1 (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::iterator arg2 ;
  std::vector< float >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::OctSwigIterator *iter2 = 0 ;
  int res2 ;
  swig::OctSwigIterator *iter3 = 0 ;
  int res3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::iterator result;
  
  if (!SWIG_check_num_args("FloatVector_erase",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_erase" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), SWIG_as_voidptrptr(&iter2), swig::OctSwigIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "FloatVector_erase" "', argument " "2"" of type '" "std::vector< float >::iterator""'");
  } else {
    swig::OctSwigIterator_T<std::vector< float >::iterator > *iter_t = dynamic_cast<swig::OctSwigIterator_T<std::vector< float >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "FloatVector_erase" "', argument " "2"" of type '" "std::vector< float >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(args(2), SWIG_as_voidptrptr(&iter3), swig::OctSwigIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "FloatVector_erase" "', argument " "3"" of type '" "std::vector< float >::iterator""'");
  } else {
    swig::OctSwigIterator_T<std::vector< float >::iterator > *iter_t = dynamic_cast<swig::OctSwigIterator_T<std::vector< float >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "FloatVector_erase" "', argument " "3"" of type '" "std::vector< float >::iterator""'");
    }
  }
  result = (arg1)->erase(arg2,arg3);
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< float >::iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_erase (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<float,std::allocator< float > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::OctSwigIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::OctSwigIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::OctSwigIterator_T<std::vector< float >::iterator > *>(iter) != 0));
      if (_v) {
        return _wrap_FloatVector_erase__SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<float,std::allocator< float > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::OctSwigIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::OctSwigIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::OctSwigIterator_T<std::vector< float >::iterator > *>(iter) != 0));
      if (_v) {
        swig::OctSwigIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::OctSwigIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::OctSwigIterator_T<std::vector< float >::iterator > *>(iter) != 0));
        if (_v) {
          return _wrap_FloatVector_erase__SWIG_1(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_new_FloatVector__SWIG_3 (const octave_value_list& args, int nargout) {
  std::vector< float >::size_type arg1 ;
  std::vector< float >::value_type *arg2 = 0 ;
  size_t val1 ;
  int ecode1 = 0 ;
  std::vector< float >::value_type temp2 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float > *result = 0 ;
  
  if (!SWIG_check_num_args("new_FloatVector",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_FloatVector" "', argument " "1"" of type '" "std::vector< float >::size_type""'");
  } 
  arg1 = (std::vector< float >::size_type)(val1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_FloatVector" "', argument " "2"" of type '" "std::vector< float >::value_type""'");
  } 
  temp2 = (std::vector< float >::value_type)(val2);
  arg2 = &temp2;
  result = (std::vector< float > *)new std::vector< float >(arg1,(std::vector< float >::value_type const &)*arg2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_FloatVector (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 0) {
    return _wrap_new_FloatVector__SWIG_0(args, nargout);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_FloatVector__SWIG_2(args, nargout);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<float,std::allocator< float > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FloatVector__SWIG_1(args, nargout);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_float(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_FloatVector__SWIG_3(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_FloatVector_push_back (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< float >::value_type temp2 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector_push_back",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_push_back" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FloatVector_push_back" "', argument " "2"" of type '" "std::vector< float >::value_type""'");
  } 
  temp2 = (std::vector< float >::value_type)(val2);
  arg2 = &temp2;
  (arg1)->push_back((std::vector< float >::value_type const &)*arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_front (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::value_type *result = 0 ;
  
  if (!SWIG_check_num_args("FloatVector_front",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_front" "', argument " "1"" of type '" "std::vector< float > const *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  result = (std::vector< float >::value_type *) &((std::vector< float > const *)arg1)->front();
  _outv = SWIG_From_float((float)(*result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_back (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::value_type *result = 0 ;
  
  if (!SWIG_check_num_args("FloatVector_back",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_back" "', argument " "1"" of type '" "std::vector< float > const *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  result = (std::vector< float >::value_type *) &((std::vector< float > const *)arg1)->back();
  _outv = SWIG_From_float((float)(*result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_assign (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  std::vector< float >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  std::vector< float >::value_type temp3 ;
  float val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector_assign",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_assign" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FloatVector_assign" "', argument " "2"" of type '" "std::vector< float >::size_type""'");
  } 
  arg2 = (std::vector< float >::size_type)(val2);
  ecode3 = SWIG_AsVal_float(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "FloatVector_assign" "', argument " "3"" of type '" "std::vector< float >::value_type""'");
  } 
  temp3 = (std::vector< float >::value_type)(val3);
  arg3 = &temp3;
  (arg1)->assign(arg2,(std::vector< float >::value_type const &)*arg3);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_resize__SWIG_1 (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  std::vector< float >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  std::vector< float >::value_type temp3 ;
  float val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector_resize",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_resize" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FloatVector_resize" "', argument " "2"" of type '" "std::vector< float >::size_type""'");
  } 
  arg2 = (std::vector< float >::size_type)(val2);
  ecode3 = SWIG_AsVal_float(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "FloatVector_resize" "', argument " "3"" of type '" "std::vector< float >::value_type""'");
  } 
  temp3 = (std::vector< float >::value_type)(val3);
  arg3 = &temp3;
  (arg1)->resize(arg2,(std::vector< float >::value_type const &)*arg3);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_resize (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<float,std::allocator< float > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FloatVector_resize__SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<float,std::allocator< float > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_float(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FloatVector_resize__SWIG_1(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_FloatVector_insert__SWIG_0 (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::iterator arg2 ;
  std::vector< float >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::OctSwigIterator *iter2 = 0 ;
  int res2 ;
  std::vector< float >::value_type temp3 ;
  float val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::iterator result;
  
  if (!SWIG_check_num_args("FloatVector_insert",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_insert" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), SWIG_as_voidptrptr(&iter2), swig::OctSwigIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "FloatVector_insert" "', argument " "2"" of type '" "std::vector< float >::iterator""'");
  } else {
    swig::OctSwigIterator_T<std::vector< float >::iterator > *iter_t = dynamic_cast<swig::OctSwigIterator_T<std::vector< float >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "FloatVector_insert" "', argument " "2"" of type '" "std::vector< float >::iterator""'");
    }
  }
  ecode3 = SWIG_AsVal_float(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "FloatVector_insert" "', argument " "3"" of type '" "std::vector< float >::value_type""'");
  } 
  temp3 = (std::vector< float >::value_type)(val3);
  arg3 = &temp3;
  result = (arg1)->insert(arg2,(std::vector< float >::value_type const &)*arg3);
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< float >::iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_insert__SWIG_1 (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::iterator arg2 ;
  std::vector< float >::size_type arg3 ;
  std::vector< float >::value_type *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::OctSwigIterator *iter2 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  std::vector< float >::value_type temp4 ;
  float val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector_insert",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_insert" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), SWIG_as_voidptrptr(&iter2), swig::OctSwigIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "FloatVector_insert" "', argument " "2"" of type '" "std::vector< float >::iterator""'");
  } else {
    swig::OctSwigIterator_T<std::vector< float >::iterator > *iter_t = dynamic_cast<swig::OctSwigIterator_T<std::vector< float >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "FloatVector_insert" "', argument " "2"" of type '" "std::vector< float >::iterator""'");
    }
  }
  ecode3 = SWIG_AsVal_size_t(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "FloatVector_insert" "', argument " "3"" of type '" "std::vector< float >::size_type""'");
  } 
  arg3 = (std::vector< float >::size_type)(val3);
  ecode4 = SWIG_AsVal_float(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "FloatVector_insert" "', argument " "4"" of type '" "std::vector< float >::value_type""'");
  } 
  temp4 = (std::vector< float >::value_type)(val4);
  arg4 = &temp4;
  (arg1)->insert(arg2,arg3,(std::vector< float >::value_type const &)*arg4);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_insert (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[4]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3)
  };
  
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<float,std::allocator< float > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::OctSwigIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::OctSwigIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::OctSwigIterator_T<std::vector< float >::iterator > *>(iter) != 0));
      if (_v) {
        {
          int res = SWIG_AsVal_float(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_FloatVector_insert__SWIG_0(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<float,std::allocator< float > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::OctSwigIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::OctSwigIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::OctSwigIterator_T<std::vector< float >::iterator > *>(iter) != 0));
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_float(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_FloatVector_insert__SWIG_1(args, nargout);
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_FloatVector_reserve (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  std::vector< float >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("FloatVector_reserve",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_reserve" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FloatVector_reserve" "', argument " "2"" of type '" "std::vector< float >::size_type""'");
  } 
  arg2 = (std::vector< float >::size_type)(val2);
  (arg1)->reserve(arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_FloatVector_capacity (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< float >::size_type result;
  
  if (!SWIG_check_num_args("FloatVector_capacity",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FloatVector_capacity" "', argument " "1"" of type '" "std::vector< float > const *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  result = ((std::vector< float > const *)arg1)->capacity();
  _outv = SWIG_From_size_t((size_t)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_FloatVector (const octave_value_list& args, int nargout) {
  std::vector< float > *arg1 = (std::vector< float > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_FloatVector",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FloatVector" "', argument " "1"" of type '" "std::vector< float > *""'"); 
  }
  arg1 = (std::vector< float > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_FloatVector_members[] = {
{"pop",_wrap_FloatVector_pop,0,0,0,0},
{"__paren__",_wrap_FloatVector___paren__,0,0,0,0},
{"__paren_asgn__",_wrap_FloatVector___paren_asgn__,0,0,0,0},
{"append",_wrap_FloatVector_append,0,0,0,0},
{"empty",_wrap_FloatVector_empty,0,0,0,0},
{"size",_wrap_FloatVector_size,0,0,0,0},
{"clear",_wrap_FloatVector_clear,0,0,0,0},
{"swap",_wrap_FloatVector_swap,0,0,0,0},
{"get_allocator",_wrap_FloatVector_get_allocator,0,0,0,0},
{"begin",_wrap_FloatVector_begin,0,0,0,0},
{"end",_wrap_FloatVector_end,0,0,0,0},
{"rbegin",_wrap_FloatVector_rbegin,0,0,0,0},
{"rend",_wrap_FloatVector_rend,0,0,0,0},
{"pop_back",_wrap_FloatVector_pop_back,0,0,0,0},
{"erase",_wrap_FloatVector_erase,0,0,0,0},
{"push_back",_wrap_FloatVector_push_back,0,0,0,0},
{"front",_wrap_FloatVector_front,0,0,0,0},
{"back",_wrap_FloatVector_back,0,0,0,0},
{"assign",_wrap_FloatVector_assign,0,0,0,0},
{"resize",_wrap_FloatVector_resize,0,0,0,0},
{"insert",_wrap_FloatVector_insert,0,0,0,0},
{"reserve",_wrap_FloatVector_reserve,0,0,0,0},
{"capacity",_wrap_FloatVector_capacity,0,0,0,0},
{0,0,0,0}
};
static const char *swig_FloatVector_base_names[] = {0};
static const swig_type_info *swig_FloatVector_base[] = {0};
static swig_octave_class _wrap_class_FloatVector = {"FloatVector", &SWIGTYPE_p_std__vectorT_float_std__allocatorT_float_t_t,0,_wrap_new_FloatVector,0,_wrap_delete_FloatVector,swig_FloatVector_members,swig_FloatVector_base_names,swig_FloatVector_base };

static octave_value_list _wrap_CvPointVector_pop (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::value_type result;
  
  if (!SWIG_check_num_args("CvPointVector_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_pop" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  try {
    result = std_vector_Sl_CvPoint_Sg__pop(arg1);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  _outv = SWIG_NewPointerObj((new std::vector< CvPoint >::value_type((const std::vector< CvPoint >::value_type&)(result))), SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector___paren__ (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::value_type result;
  
  if (!SWIG_check_num_args("CvPointVector___paren__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector___paren__" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPointVector___paren__" "', argument " "2"" of type '" "std::vector< CvPoint >::difference_type""'");
  } 
  arg2 = (std::vector< CvPoint >::difference_type)(val2);
  try {
    result = std_vector_Sl_CvPoint_Sg____paren__(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  _outv = SWIG_NewPointerObj((new std::vector< CvPoint >::value_type((const std::vector< CvPoint >::value_type&)(result))), SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector___paren_asgn__ (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::difference_type arg2 ;
  std::vector< CvPoint >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector___paren_asgn__",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector___paren_asgn__" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPointVector___paren_asgn__" "', argument " "2"" of type '" "std::vector< CvPoint >::difference_type""'");
  } 
  arg2 = (std::vector< CvPoint >::difference_type)(val2);
  {
    arg3 = OctObject_to_CvPoint(args(2));
  }
  try {
    std_vector_Sl_CvPoint_Sg____paren_asgn__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_append (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::value_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_append" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  {
    arg2 = OctObject_to_CvPoint(args(1));
  }
  std_vector_Sl_CvPoint_Sg__append(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvPointVector__SWIG_0 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvPointVector",args.length(),0,0,0)) {
    SWIG_fail;
  }
  result = (std::vector< CvPoint > *)new std::vector< CvPoint >();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvPointVector__SWIG_1 (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvPointVector",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    std::vector<CvPoint,std::allocator< CvPoint > > *ptr = (std::vector<CvPoint,std::allocator< CvPoint > > *)0;
    res1 = swig::asptr(args(0), &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvPointVector" "', argument " "1"" of type '" "std::vector< CvPoint > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CvPointVector" "', argument " "1"" of type '" "std::vector< CvPoint > const &""'"); 
    }
    arg1 = ptr;
  }
  result = (std::vector< CvPoint > *)new std::vector< CvPoint >((std::vector< CvPoint > const &)*arg1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (SWIG_IsNewObj(res1)) delete arg1;
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_empty (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvPointVector_empty",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_empty" "', argument " "1"" of type '" "std::vector< CvPoint > const *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  result = (bool)((std::vector< CvPoint > const *)arg1)->empty();
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_size (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::size_type result;
  
  if (!SWIG_check_num_args("CvPointVector_size",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_size" "', argument " "1"" of type '" "std::vector< CvPoint > const *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  result = ((std::vector< CvPoint > const *)arg1)->size();
  _outv = SWIG_From_size_t((size_t)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_clear (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector_clear",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_clear" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  (arg1)->clear();
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_swap (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector_swap",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_swap" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvPointVector_swap" "', argument " "2"" of type '" "std::vector< CvPoint > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvPointVector_swap" "', argument " "2"" of type '" "std::vector< CvPoint > &""'"); 
  }
  arg2 = (std::vector< CvPoint > *)(argp2);
  (arg1)->swap(*arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_get_allocator (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  SwigValueWrapper< std::allocator< CvPoint > > result;
  
  if (!SWIG_check_num_args("CvPointVector_get_allocator",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_get_allocator" "', argument " "1"" of type '" "std::vector< CvPoint > const *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  result = ((std::vector< CvPoint > const *)arg1)->get_allocator();
  _outv = SWIG_NewPointerObj((new std::vector< CvPoint >::allocator_type((const std::vector< CvPoint >::allocator_type&)(result))), SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_begin (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::const_iterator result;
  
  if (!SWIG_check_num_args("CvPointVector_begin",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_begin" "', argument " "1"" of type '" "std::vector< CvPoint > const *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  result = ((std::vector< CvPoint > const *)arg1)->begin();
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< CvPoint >::const_iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_end (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::const_iterator result;
  
  if (!SWIG_check_num_args("CvPointVector_end",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_end" "', argument " "1"" of type '" "std::vector< CvPoint > const *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  result = ((std::vector< CvPoint > const *)arg1)->end();
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< CvPoint >::const_iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_rbegin (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::const_reverse_iterator result;
  
  if (!SWIG_check_num_args("CvPointVector_rbegin",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_rbegin" "', argument " "1"" of type '" "std::vector< CvPoint > const *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  result = ((std::vector< CvPoint > const *)arg1)->rbegin();
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< CvPoint >::const_reverse_iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_rend (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::const_reverse_iterator result;
  
  if (!SWIG_check_num_args("CvPointVector_rend",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_rend" "', argument " "1"" of type '" "std::vector< CvPoint > const *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  result = ((std::vector< CvPoint > const *)arg1)->rend();
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< CvPoint >::const_reverse_iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvPointVector__SWIG_2 (const octave_value_list& args, int nargout) {
  std::vector< CvPoint >::size_type arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvPointVector",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvPointVector" "', argument " "1"" of type '" "std::vector< CvPoint >::size_type""'");
  } 
  arg1 = (std::vector< CvPoint >::size_type)(val1);
  result = (std::vector< CvPoint > *)new std::vector< CvPoint >(arg1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_pop_back (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector_pop_back",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_pop_back" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  (arg1)->pop_back();
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_resize__SWIG_0 (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector_resize",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_resize" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPointVector_resize" "', argument " "2"" of type '" "std::vector< CvPoint >::size_type""'");
  } 
  arg2 = (std::vector< CvPoint >::size_type)(val2);
  (arg1)->resize(arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_erase__SWIG_0 (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::OctSwigIterator *iter2 = 0 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::iterator result;
  
  if (!SWIG_check_num_args("CvPointVector_erase",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_erase" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), SWIG_as_voidptrptr(&iter2), swig::OctSwigIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "CvPointVector_erase" "', argument " "2"" of type '" "std::vector< CvPoint >::iterator""'");
  } else {
    swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *iter_t = dynamic_cast<swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "CvPointVector_erase" "', argument " "2"" of type '" "std::vector< CvPoint >::iterator""'");
    }
  }
  result = (arg1)->erase(arg2);
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< CvPoint >::iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_erase__SWIG_1 (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::iterator arg2 ;
  std::vector< CvPoint >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::OctSwigIterator *iter2 = 0 ;
  int res2 ;
  swig::OctSwigIterator *iter3 = 0 ;
  int res3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::iterator result;
  
  if (!SWIG_check_num_args("CvPointVector_erase",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_erase" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), SWIG_as_voidptrptr(&iter2), swig::OctSwigIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "CvPointVector_erase" "', argument " "2"" of type '" "std::vector< CvPoint >::iterator""'");
  } else {
    swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *iter_t = dynamic_cast<swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "CvPointVector_erase" "', argument " "2"" of type '" "std::vector< CvPoint >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(args(2), SWIG_as_voidptrptr(&iter3), swig::OctSwigIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "CvPointVector_erase" "', argument " "3"" of type '" "std::vector< CvPoint >::iterator""'");
  } else {
    swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *iter_t = dynamic_cast<swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "CvPointVector_erase" "', argument " "3"" of type '" "std::vector< CvPoint >::iterator""'");
    }
  }
  result = (arg1)->erase(arg2,arg3);
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< CvPoint >::iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_erase (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<CvPoint,std::allocator< CvPoint > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::OctSwigIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::OctSwigIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *>(iter) != 0));
      if (_v) {
        return _wrap_CvPointVector_erase__SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<CvPoint,std::allocator< CvPoint > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::OctSwigIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::OctSwigIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *>(iter) != 0));
      if (_v) {
        swig::OctSwigIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::OctSwigIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *>(iter) != 0));
        if (_v) {
          return _wrap_CvPointVector_erase__SWIG_1(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_new_CvPointVector__SWIG_3 (const octave_value_list& args, int nargout) {
  std::vector< CvPoint >::size_type arg1 ;
  std::vector< CvPoint >::value_type *arg2 = 0 ;
  size_t val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvPointVector",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvPointVector" "', argument " "1"" of type '" "std::vector< CvPoint >::size_type""'");
  } 
  arg1 = (std::vector< CvPoint >::size_type)(val1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CvPointVector" "', argument " "2"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CvPointVector" "', argument " "2"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  arg2 = (std::vector< CvPoint >::value_type *)(argp2);
  result = (std::vector< CvPoint > *)new std::vector< CvPoint >(arg1,(std::vector< CvPoint >::value_type const &)*arg2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvPointVector (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 0) {
    return _wrap_new_CvPointVector__SWIG_0(args, nargout);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_CvPointVector__SWIG_2(args, nargout);
    }
  }
  if (argc == 1) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<CvPoint,std::allocator< CvPoint > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CvPointVector__SWIG_1(args, nargout);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_CvPointVector__SWIG_3(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvPointVector_push_back (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::value_type *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector_push_back",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_push_back" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvPointVector_push_back" "', argument " "2"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvPointVector_push_back" "', argument " "2"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  arg2 = (std::vector< CvPoint >::value_type *)(argp2);
  (arg1)->push_back((std::vector< CvPoint >::value_type const &)*arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_front (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::value_type *result = 0 ;
  
  if (!SWIG_check_num_args("CvPointVector_front",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_front" "', argument " "1"" of type '" "std::vector< CvPoint > const *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  result = (std::vector< CvPoint >::value_type *) &((std::vector< CvPoint > const *)arg1)->front();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_back (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::value_type *result = 0 ;
  
  if (!SWIG_check_num_args("CvPointVector_back",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_back" "', argument " "1"" of type '" "std::vector< CvPoint > const *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  result = (std::vector< CvPoint >::value_type *) &((std::vector< CvPoint > const *)arg1)->back();
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_assign (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::size_type arg2 ;
  std::vector< CvPoint >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector_assign",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_assign" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPointVector_assign" "', argument " "2"" of type '" "std::vector< CvPoint >::size_type""'");
  } 
  arg2 = (std::vector< CvPoint >::size_type)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvPointVector_assign" "', argument " "3"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvPointVector_assign" "', argument " "3"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  arg3 = (std::vector< CvPoint >::value_type *)(argp3);
  (arg1)->assign(arg2,(std::vector< CvPoint >::value_type const &)*arg3);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_resize__SWIG_1 (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::size_type arg2 ;
  std::vector< CvPoint >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector_resize",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_resize" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPointVector_resize" "', argument " "2"" of type '" "std::vector< CvPoint >::size_type""'");
  } 
  arg2 = (std::vector< CvPoint >::size_type)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvPointVector_resize" "', argument " "3"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvPointVector_resize" "', argument " "3"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  arg3 = (std::vector< CvPoint >::value_type *)(argp3);
  (arg1)->resize(arg2,(std::vector< CvPoint >::value_type const &)*arg3);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_resize (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 2) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<CvPoint,std::allocator< CvPoint > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvPointVector_resize__SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<CvPoint,std::allocator< CvPoint > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_CvPointVector_resize__SWIG_1(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvPointVector_insert__SWIG_0 (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::iterator arg2 ;
  std::vector< CvPoint >::value_type *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::OctSwigIterator *iter2 = 0 ;
  int res2 ;
  void *argp3 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::iterator result;
  
  if (!SWIG_check_num_args("CvPointVector_insert",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_insert" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), SWIG_as_voidptrptr(&iter2), swig::OctSwigIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "CvPointVector_insert" "', argument " "2"" of type '" "std::vector< CvPoint >::iterator""'");
  } else {
    swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *iter_t = dynamic_cast<swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "CvPointVector_insert" "', argument " "2"" of type '" "std::vector< CvPoint >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvPointVector_insert" "', argument " "3"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvPointVector_insert" "', argument " "3"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  arg3 = (std::vector< CvPoint >::value_type *)(argp3);
  result = (arg1)->insert(arg2,(std::vector< CvPoint >::value_type const &)*arg3);
  _outv = SWIG_NewPointerObj(swig::make_output_iterator((const std::vector< CvPoint >::iterator &)(result)),
    swig::OctSwigIterator::descriptor(),SWIG_POINTER_OWN);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_insert__SWIG_1 (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::iterator arg2 ;
  std::vector< CvPoint >::size_type arg3 ;
  std::vector< CvPoint >::value_type *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::OctSwigIterator *iter2 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector_insert",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_insert" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), SWIG_as_voidptrptr(&iter2), swig::OctSwigIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "CvPointVector_insert" "', argument " "2"" of type '" "std::vector< CvPoint >::iterator""'");
  } else {
    swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *iter_t = dynamic_cast<swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "CvPointVector_insert" "', argument " "2"" of type '" "std::vector< CvPoint >::iterator""'");
    }
  }
  ecode3 = SWIG_AsVal_size_t(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CvPointVector_insert" "', argument " "3"" of type '" "std::vector< CvPoint >::size_type""'");
  } 
  arg3 = (std::vector< CvPoint >::size_type)(val3);
  res4 = SWIG_ConvertPtr(args(3), &argp4, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CvPointVector_insert" "', argument " "4"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvPointVector_insert" "', argument " "4"" of type '" "std::vector< CvPoint >::value_type const &""'"); 
  }
  arg4 = (std::vector< CvPoint >::value_type *)(argp4);
  (arg1)->insert(arg2,arg3,(std::vector< CvPoint >::value_type const &)*arg4);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_insert (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[4]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3)
  };
  
  if (argc == 3) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<CvPoint,std::allocator< CvPoint > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::OctSwigIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::OctSwigIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *>(iter) != 0));
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_CvPointVector_insert__SWIG_0(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = swig::asptr(argv[0], (std::vector<CvPoint,std::allocator< CvPoint > >**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::OctSwigIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::OctSwigIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::OctSwigIterator_T<std::vector< CvPoint >::iterator > *>(iter) != 0));
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_CvPointVector_insert__SWIG_1(args, nargout);
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvPointVector_reserve (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  std::vector< CvPoint >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPointVector_reserve",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_reserve" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPointVector_reserve" "', argument " "2"" of type '" "std::vector< CvPoint >::size_type""'");
  } 
  arg2 = (std::vector< CvPoint >::size_type)(val2);
  (arg1)->reserve(arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPointVector_capacity (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint >::size_type result;
  
  if (!SWIG_check_num_args("CvPointVector_capacity",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPointVector_capacity" "', argument " "1"" of type '" "std::vector< CvPoint > const *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  result = ((std::vector< CvPoint > const *)arg1)->capacity();
  _outv = SWIG_From_size_t((size_t)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvPointVector (const octave_value_list& args, int nargout) {
  std::vector< CvPoint > *arg1 = (std::vector< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvPointVector",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvPointVector" "', argument " "1"" of type '" "std::vector< CvPoint > *""'"); 
  }
  arg1 = (std::vector< CvPoint > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvPointVector_members[] = {
{"pop",_wrap_CvPointVector_pop,0,0,0,0},
{"__paren__",_wrap_CvPointVector___paren__,0,0,0,0},
{"__paren_asgn__",_wrap_CvPointVector___paren_asgn__,0,0,0,0},
{"append",_wrap_CvPointVector_append,0,0,0,0},
{"empty",_wrap_CvPointVector_empty,0,0,0,0},
{"size",_wrap_CvPointVector_size,0,0,0,0},
{"clear",_wrap_CvPointVector_clear,0,0,0,0},
{"swap",_wrap_CvPointVector_swap,0,0,0,0},
{"get_allocator",_wrap_CvPointVector_get_allocator,0,0,0,0},
{"begin",_wrap_CvPointVector_begin,0,0,0,0},
{"end",_wrap_CvPointVector_end,0,0,0,0},
{"rbegin",_wrap_CvPointVector_rbegin,0,0,0,0},
{"rend",_wrap_CvPointVector_rend,0,0,0,0},
{"pop_back",_wrap_CvPointVector_pop_back,0,0,0,0},
{"erase",_wrap_CvPointVector_erase,0,0,0,0},
{"push_back",_wrap_CvPointVector_push_back,0,0,0,0},
{"front",_wrap_CvPointVector_front,0,0,0,0},
{"back",_wrap_CvPointVector_back,0,0,0,0},
{"assign",_wrap_CvPointVector_assign,0,0,0,0},
{"resize",_wrap_CvPointVector_resize,0,0,0,0},
{"insert",_wrap_CvPointVector_insert,0,0,0,0},
{"reserve",_wrap_CvPointVector_reserve,0,0,0,0},
{"capacity",_wrap_CvPointVector_capacity,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvPointVector_base_names[] = {0};
static const swig_type_info *swig_CvPointVector_base[] = {0};
static swig_octave_class _wrap_class_CvPointVector = {"CvPointVector", &SWIGTYPE_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t,0,_wrap_new_CvPointVector,0,_wrap_delete_CvPointVector,swig_CvPointVector_members,swig_CvPointVector_base_names,swig_CvPointVector_base };

static octave_value_list _wrap_cvCvtSeqToArray__SWIG_0 (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvSlice arg3 ;
  void *ptr1 ;
  bool freearg2 = false ;
  void *argp3 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("cvCvtSeqToArray",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvSlice,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCvtSeqToArray" "', argument " "3"" of type '" "CvSlice""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCvtSeqToArray" "', argument " "3"" of type '" "CvSlice""'");
    } else {
      arg3 = *((CvSlice *)(argp3));
    }
  }
  result = (CvArr *)cvCvtSeqToArray_Shadow((CvSeq const *)arg1,arg2,arg3);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCvtSeqToArray__SWIG_1 (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *ptr1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("cvCvtSeqToArray",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  result = (CvArr *)cvCvtSeqToArray_Shadow((CvSeq const *)arg1,arg2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCvtSeqToArray (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvSeq, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_cvCvtSeqToArray__SWIG_1(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvSeq, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvSlice, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_cvCvtSeqToArray__SWIG_0(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_cvArcLength__SWIG_0 (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSlice arg2 ;
  int arg3 ;
  void *ptr1 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvArcLength",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvArcLength" "', argument " "2"" of type '" "CvSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvArcLength" "', argument " "2"" of type '" "CvSlice""'");
    } else {
      arg2 = *((CvSlice *)(argp2));
    }
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvArcLength" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (double)cvArcLength_Shadow((CvSeq const *)arg1,arg2,arg3);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvArcLength__SWIG_1 (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSlice arg2 ;
  void *ptr1 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvArcLength",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvArcLength" "', argument " "2"" of type '" "CvSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvArcLength" "', argument " "2"" of type '" "CvSlice""'");
    } else {
      arg2 = *((CvSlice *)(argp2));
    }
  }
  result = (double)cvArcLength_Shadow((CvSeq const *)arg1,arg2);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvArcLength__SWIG_2 (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvArcLength",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (double)cvArcLength_Shadow((CvSeq const *)arg1);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvArcLength__SWIG_3 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvSlice arg2 ;
  int arg3 ;
  bool freearg1 = false ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvArcLength",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvArcLength" "', argument " "2"" of type '" "CvSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvArcLength" "', argument " "2"" of type '" "CvSlice""'");
    } else {
      arg2 = *((CvSlice *)(argp2));
    }
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvArcLength" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (double)cvArcLength_Shadow((void const *)arg1,arg2,arg3);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvArcLength__SWIG_4 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvSlice arg2 ;
  bool freearg1 = false ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvArcLength",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvArcLength" "', argument " "2"" of type '" "CvSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvArcLength" "', argument " "2"" of type '" "CvSlice""'");
    } else {
      arg2 = *((CvSlice *)(argp2));
    }
  }
  result = (double)cvArcLength_Shadow((void const *)arg1,arg2);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvArcLength__SWIG_5 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvArcLength",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  result = (double)cvArcLength_Shadow((void const *)arg1);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvArcLength (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvSeq, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_cvArcLength__SWIG_2(args, nargout);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_cvArcLength__SWIG_5(args, nargout);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvSlice, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_cvArcLength__SWIG_4(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvSeq, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvSlice, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_cvArcLength__SWIG_1(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvSeq, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvSlice, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_cvArcLength__SWIG_0(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvSlice, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_cvArcLength__SWIG_3(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_cvContourPerimeter__SWIG_0 (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvContourPerimeter",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (double)cvContourPerimeter_Shadow(arg1);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvContourPerimeter__SWIG_1 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvContourPerimeter",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  result = (double)cvContourPerimeter_Shadow(arg1);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvContourPerimeter (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[1]={
    octave_value_ref(args,0)
  };
  
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvSeq, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_cvContourPerimeter__SWIG_0(args, nargout);
    }
  }
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_cvContourPerimeter__SWIG_1(args, nargout);
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_cvHaarDetectObjects__SWIG_0 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvHaarClassifierCascade *arg2 = (CvHaarClassifierCascade *) 0 ;
  CvMemStorage *arg3 = (CvMemStorage *) 0 ;
  double arg4 ;
  int arg5 ;
  int arg6 ;
  CvSize arg7 ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 ;
  int res7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvRect > *result = 0 ;
  
  if (!SWIG_check_num_args("cvHaarDetectObjects",args.length(),7,7,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvHaarDetectObjects" "', argument " "2"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg2 = (CvHaarClassifierCascade *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvHaarDetectObjects" "', argument " "3"" of type '" "CvMemStorage *""'"); 
  }
  arg3 = (CvMemStorage *)(argp3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvHaarDetectObjects" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvHaarDetectObjects" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvHaarDetectObjects" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  {
    res7 = SWIG_ConvertPtr(args(6), &argp7, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvHaarDetectObjects" "', argument " "7"" of type '" "CvSize""'"); 
    }  
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvHaarDetectObjects" "', argument " "7"" of type '" "CvSize""'");
    } else {
      arg7 = *((CvSize *)(argp7));
    }
  }
  result = (CvTypedSeq< CvRect > *)cvHaarDetectObjects_Shadow((void const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvHaarDetectObjects__SWIG_1 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvHaarClassifierCascade *arg2 = (CvHaarClassifierCascade *) 0 ;
  CvMemStorage *arg3 = (CvMemStorage *) 0 ;
  double arg4 ;
  int arg5 ;
  int arg6 ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvRect > *result = 0 ;
  
  if (!SWIG_check_num_args("cvHaarDetectObjects",args.length(),6,6,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvHaarDetectObjects" "', argument " "2"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg2 = (CvHaarClassifierCascade *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvHaarDetectObjects" "', argument " "3"" of type '" "CvMemStorage *""'"); 
  }
  arg3 = (CvMemStorage *)(argp3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvHaarDetectObjects" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvHaarDetectObjects" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvHaarDetectObjects" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  result = (CvTypedSeq< CvRect > *)cvHaarDetectObjects_Shadow((void const *)arg1,arg2,arg3,arg4,arg5,arg6);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvHaarDetectObjects__SWIG_2 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvHaarClassifierCascade *arg2 = (CvHaarClassifierCascade *) 0 ;
  CvMemStorage *arg3 = (CvMemStorage *) 0 ;
  double arg4 ;
  int arg5 ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvRect > *result = 0 ;
  
  if (!SWIG_check_num_args("cvHaarDetectObjects",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvHaarDetectObjects" "', argument " "2"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg2 = (CvHaarClassifierCascade *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvHaarDetectObjects" "', argument " "3"" of type '" "CvMemStorage *""'"); 
  }
  arg3 = (CvMemStorage *)(argp3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvHaarDetectObjects" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvHaarDetectObjects" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  result = (CvTypedSeq< CvRect > *)cvHaarDetectObjects_Shadow((void const *)arg1,arg2,arg3,arg4,arg5);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvHaarDetectObjects__SWIG_3 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvHaarClassifierCascade *arg2 = (CvHaarClassifierCascade *) 0 ;
  CvMemStorage *arg3 = (CvMemStorage *) 0 ;
  double arg4 ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvRect > *result = 0 ;
  
  if (!SWIG_check_num_args("cvHaarDetectObjects",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvHaarDetectObjects" "', argument " "2"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg2 = (CvHaarClassifierCascade *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvHaarDetectObjects" "', argument " "3"" of type '" "CvMemStorage *""'"); 
  }
  arg3 = (CvMemStorage *)(argp3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvHaarDetectObjects" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  result = (CvTypedSeq< CvRect > *)cvHaarDetectObjects_Shadow((void const *)arg1,arg2,arg3,arg4);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvHaarDetectObjects__SWIG_4 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvHaarClassifierCascade *arg2 = (CvHaarClassifierCascade *) 0 ;
  CvMemStorage *arg3 = (CvMemStorage *) 0 ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvRect > *result = 0 ;
  
  if (!SWIG_check_num_args("cvHaarDetectObjects",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvHaarDetectObjects" "', argument " "2"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg2 = (CvHaarClassifierCascade *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvHaarDetectObjects" "', argument " "3"" of type '" "CvMemStorage *""'"); 
  }
  arg3 = (CvMemStorage *)(argp3);
  result = (CvTypedSeq< CvRect > *)cvHaarDetectObjects_Shadow((void const *)arg1,arg2,arg3);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvHaarDetectObjects (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[7]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3),octave_value_ref(args,4),octave_value_ref(args,5),octave_value_ref(args,6)
  };
  
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvHaarClassifierCascade, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvMemStorage, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_cvHaarDetectObjects__SWIG_4(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvHaarClassifierCascade, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvMemStorage, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_cvHaarDetectObjects__SWIG_3(args, nargout);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvHaarClassifierCascade, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvMemStorage, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_cvHaarDetectObjects__SWIG_2(args, nargout);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvHaarClassifierCascade, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvMemStorage, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_cvHaarDetectObjects__SWIG_1(args, nargout);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvHaarClassifierCascade, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvMemStorage, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                void *vptr = 0;
                int res = SWIG_ConvertPtr(argv[6], &vptr, SWIGTYPE_p_CvSize, 0);
                _v = SWIG_CheckState(res);
                if (_v) {
                  return _wrap_cvHaarDetectObjects__SWIG_0(args, nargout);
                }
              }
            }
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_cvSegmentMotion (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMemStorage *arg3 = (CvMemStorage *) 0 ;
  double arg4 ;
  double arg5 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvConnectedComp > *result = 0 ;
  
  if (!SWIG_check_num_args("cvSegmentMotion",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvSegmentMotion" "', argument " "3"" of type '" "CvMemStorage *""'"); 
  }
  arg3 = (CvMemStorage *)(argp3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSegmentMotion" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvSegmentMotion" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  result = (CvTypedSeq< CvConnectedComp > *)cvSegmentMotion_Shadow((void const *)arg1,arg2,arg3,arg4,arg5);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvApproxPoly__SWIG_0 (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  int arg2 ;
  CvMemStorage *arg3 = (CvMemStorage *) 0 ;
  int arg4 ;
  double arg5 ;
  int arg6 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvPoint > *result = 0 ;
  
  if (!SWIG_check_num_args("cvApproxPoly",args.length(),6,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvApproxPoly" "', argument " "1"" of type '" "void const *""'"); 
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvApproxPoly" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvApproxPoly" "', argument " "3"" of type '" "CvMemStorage *""'"); 
  }
  arg3 = (CvMemStorage *)(argp3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvApproxPoly" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvApproxPoly" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_int(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvApproxPoly" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  result = (CvTypedSeq< CvPoint > *)cvApproxPoly_Shadow((void const *)arg1,arg2,arg3,arg4,arg5,arg6);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvPoint_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvApproxPoly__SWIG_1 (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  int arg2 ;
  CvMemStorage *arg3 = (CvMemStorage *) 0 ;
  int arg4 ;
  double arg5 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvPoint > *result = 0 ;
  
  if (!SWIG_check_num_args("cvApproxPoly",args.length(),5,5,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvApproxPoly" "', argument " "1"" of type '" "void const *""'"); 
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvApproxPoly" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvApproxPoly" "', argument " "3"" of type '" "CvMemStorage *""'"); 
  }
  arg3 = (CvMemStorage *)(argp3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvApproxPoly" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvApproxPoly" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  result = (CvTypedSeq< CvPoint > *)cvApproxPoly_Shadow((void const *)arg1,arg2,arg3,arg4,arg5);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvPoint_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvApproxPoly (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[6]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3),octave_value_ref(args,4),octave_value_ref(args,5)
  };
  
  if (argc == 5) {
    int _v;
    void *ptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &ptr, 0, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvMemStorage, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_double(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_cvApproxPoly__SWIG_1(args, nargout);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    void *ptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &ptr, 0, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvMemStorage, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_double(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_cvApproxPoly__SWIG_0(args, nargout);
              }
            }
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_cvConvexHull2__SWIG_0 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvConvexHull2",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvConvexHull2" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvConvexHull2" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (CvMat *)cvConvexHull2_Shadow((void const *)arg1,arg2,arg3);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvConvexHull2__SWIG_1 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvConvexHull2",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvConvexHull2" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = (CvMat *)cvConvexHull2_Shadow((void const *)arg1,arg2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvConvexHull2__SWIG_2 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvConvexHull2",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  result = (CvMat *)cvConvexHull2_Shadow((void const *)arg1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvConvexHull2 (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 1) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_cvConvexHull2__SWIG_2(args, nargout);
    }
  }
  if (argc == 2) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_cvConvexHull2__SWIG_1(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      void *ptr;
      if(OctList_Check(argv[0]) || OctTuple_Check(argv[0])) {
        _v = 1;
      }
      else if (SWIG_ConvertPtr(argv[0], &ptr, 0, 0) == -1) {
        _v = 0;
      }
      else{
        _v = 1;
      }
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_cvConvexHull2__SWIG_0(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_cvSnakeImage__SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  std::vector< CvPoint,std::allocator< CvPoint > > arg2 ;
  std::vector< float,std::allocator< float > > arg3 ;
  std::vector< float,std::allocator< float > > arg4 ;
  std::vector< float,std::allocator< float > > arg5 ;
  CvSize arg6 ;
  CvTermCriteria arg7 ;
  int arg8 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  void *argp7 ;
  int res7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint,std::allocator< CvPoint > > result;
  
  if (!SWIG_check_num_args("cvSnakeImage",args.length(),8,8,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSnakeImage" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    std::vector<CvPoint,std::allocator< CvPoint > > *ptr = (std::vector<CvPoint,std::allocator< CvPoint > > *)0;
    int res = swig::asptr(args(1), &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "cvSnakeImage" "', argument " "2"" of type '" "std::vector< CvPoint,std::allocator< CvPoint > >""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::vector<float,std::allocator< float > > *ptr = (std::vector<float,std::allocator< float > > *)0;
    int res = swig::asptr(args(2), &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "cvSnakeImage" "', argument " "3"" of type '" "std::vector< float,std::allocator< float > >""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::vector<float,std::allocator< float > > *ptr = (std::vector<float,std::allocator< float > > *)0;
    int res = swig::asptr(args(3), &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "cvSnakeImage" "', argument " "4"" of type '" "std::vector< float,std::allocator< float > >""'"); 
    }
    arg4 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::vector<float,std::allocator< float > > *ptr = (std::vector<float,std::allocator< float > > *)0;
    int res = swig::asptr(args(4), &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "cvSnakeImage" "', argument " "5"" of type '" "std::vector< float,std::allocator< float > >""'"); 
    }
    arg5 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    res6 = SWIG_ConvertPtr(args(5), &argp6, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvSnakeImage" "', argument " "6"" of type '" "CvSize""'"); 
    }  
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvSnakeImage" "', argument " "6"" of type '" "CvSize""'");
    } else {
      arg6 = *((CvSize *)(argp6));
    }
  }
  {
    res7 = SWIG_ConvertPtr(args(6), &argp7, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvSnakeImage" "', argument " "7"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvSnakeImage" "', argument " "7"" of type '" "CvTermCriteria""'");
    } else {
      arg7 = *((CvTermCriteria *)(argp7));
    }
  }
  ecode8 = SWIG_AsVal_int(args(7), &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cvSnakeImage" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  result = cvSnakeImage_Shadow((CvMat const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  _outv = swig::from((std::vector<CvPoint,std::allocator< CvPoint > >)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSnakeImage__SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  std::vector< CvPoint,std::allocator< CvPoint > > arg2 ;
  std::vector< float,std::allocator< float > > arg3 ;
  std::vector< float,std::allocator< float > > arg4 ;
  std::vector< float,std::allocator< float > > arg5 ;
  CvSize arg6 ;
  CvTermCriteria arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  void *argp7 ;
  int res7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  std::vector< CvPoint,std::allocator< CvPoint > > result;
  
  if (!SWIG_check_num_args("cvSnakeImage",args.length(),7,7,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSnakeImage" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    std::vector<CvPoint,std::allocator< CvPoint > > *ptr = (std::vector<CvPoint,std::allocator< CvPoint > > *)0;
    int res = swig::asptr(args(1), &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "cvSnakeImage" "', argument " "2"" of type '" "std::vector< CvPoint,std::allocator< CvPoint > >""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::vector<float,std::allocator< float > > *ptr = (std::vector<float,std::allocator< float > > *)0;
    int res = swig::asptr(args(2), &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "cvSnakeImage" "', argument " "3"" of type '" "std::vector< float,std::allocator< float > >""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::vector<float,std::allocator< float > > *ptr = (std::vector<float,std::allocator< float > > *)0;
    int res = swig::asptr(args(3), &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "cvSnakeImage" "', argument " "4"" of type '" "std::vector< float,std::allocator< float > >""'"); 
    }
    arg4 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::vector<float,std::allocator< float > > *ptr = (std::vector<float,std::allocator< float > > *)0;
    int res = swig::asptr(args(4), &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "cvSnakeImage" "', argument " "5"" of type '" "std::vector< float,std::allocator< float > >""'"); 
    }
    arg5 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    res6 = SWIG_ConvertPtr(args(5), &argp6, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvSnakeImage" "', argument " "6"" of type '" "CvSize""'"); 
    }  
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvSnakeImage" "', argument " "6"" of type '" "CvSize""'");
    } else {
      arg6 = *((CvSize *)(argp6));
    }
  }
  {
    res7 = SWIG_ConvertPtr(args(6), &argp7, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvSnakeImage" "', argument " "7"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvSnakeImage" "', argument " "7"" of type '" "CvTermCriteria""'");
    } else {
      arg7 = *((CvTermCriteria *)(argp7));
    }
  }
  result = cvSnakeImage_Shadow((CvMat const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  _outv = swig::from((std::vector<CvPoint,std::allocator< CvPoint > >)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSnakeImage (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[8]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3),octave_value_ref(args,4),octave_value_ref(args,5),octave_value_ref(args,6),octave_value_ref(args,7)
  };
  
  if (argc == 7) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = swig::asptr(argv[1], (std::vector<CvPoint,std::allocator< CvPoint > >**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = swig::asptr(argv[2], (std::vector<float,std::allocator< float > >**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = swig::asptr(argv[3], (std::vector<float,std::allocator< float > >**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = swig::asptr(argv[4], (std::vector<float,std::allocator< float > >**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_CvSize, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                void *vptr = 0;
                int res = SWIG_ConvertPtr(argv[6], &vptr, SWIGTYPE_p_CvTermCriteria, 0);
                _v = SWIG_CheckState(res);
                if (_v) {
                  return _wrap_cvSnakeImage__SWIG_1(args, nargout);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = swig::asptr(argv[1], (std::vector<CvPoint,std::allocator< CvPoint > >**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = swig::asptr(argv[2], (std::vector<float,std::allocator< float > >**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = swig::asptr(argv[3], (std::vector<float,std::allocator< float > >**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = swig::asptr(argv[4], (std::vector<float,std::allocator< float > >**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              void *vptr = 0;
              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_CvSize, 0);
              _v = SWIG_CheckState(res);
              if (_v) {
                void *vptr = 0;
                int res = SWIG_ConvertPtr(argv[6], &vptr, SWIGTYPE_p_CvTermCriteria, 0);
                _v = SWIG_CheckState(res);
                if (_v) {
                  {
                    int res = SWIG_AsVal_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_cvSnakeImage__SWIG_0(args, nargout);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_cvFree (const octave_value_list& args, int nargout) {
  void **arg1 = (void **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFree",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_void, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFree" "', argument " "1"" of type '" "void **""'"); 
  }
  arg1 = (void **)(argp1);
  cvFree(arg1);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_READ_CHAIN_POINT (const octave_value_list& args, int nargout) {
  CvPoint arg1 ;
  CvChainPtReader arg2 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_READ_CHAIN_POINT",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint(args(0));
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvChainPtReader,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_READ_CHAIN_POINT" "', argument " "2"" of type '" "CvChainPtReader""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_READ_CHAIN_POINT" "', argument " "2"" of type '" "CvChainPtReader""'");
    } else {
      arg2 = *((CvChainPtReader *)(argp2));
    }
  }
  CV_READ_CHAIN_POINT(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_MAT_ELEM_PTR (const octave_value_list& args, int nargout) {
  CvMat arg1 ;
  int arg2 ;
  int arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("CV_MAT_ELEM_PTR",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvMat,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_MAT_ELEM_PTR" "', argument " "1"" of type '" "CvMat""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_MAT_ELEM_PTR" "', argument " "1"" of type '" "CvMat""'");
    } else {
      arg1 = *((CvMat *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CV_MAT_ELEM_PTR" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CV_MAT_ELEM_PTR" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = (void *)CV_MAT_ELEM_PTR(arg1,arg2,arg3);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_MAT_ELEM_PTR_FAST (const octave_value_list& args, int nargout) {
  CvMat arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("CV_MAT_ELEM_PTR_FAST",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvMat,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_MAT_ELEM_PTR_FAST" "', argument " "1"" of type '" "CvMat""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_MAT_ELEM_PTR_FAST" "', argument " "1"" of type '" "CvMat""'");
    } else {
      arg1 = *((CvMat *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CV_MAT_ELEM_PTR_FAST" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CV_MAT_ELEM_PTR_FAST" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CV_MAT_ELEM_PTR_FAST" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  result = (void *)CV_MAT_ELEM_PTR_FAST(arg1,arg2,arg3,arg4);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_VAL (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  CvSparseNode *arg2 = (CvSparseNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("CV_NODE_VAL",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_NODE_VAL" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSparseNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_NODE_VAL" "', argument " "2"" of type '" "CvSparseNode *""'"); 
  }
  arg2 = (CvSparseNode *)(argp2);
  result = (void *)CV_NODE_VAL(arg1,arg2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_IDX (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  CvSparseNode *arg2 = (CvSparseNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CV_NODE_IDX",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_NODE_IDX" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSparseNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_NODE_IDX" "', argument " "2"" of type '" "CvSparseNode *""'"); 
  }
  arg2 = (CvSparseNode *)(argp2);
  result = (int *)CV_NODE_IDX(arg1,arg2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_SUBDIV2D_NEXT_EDGE (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge arg1 ;
  CvSubdiv2DEdge_Wrapper *wrapper1 ;
  CvQuadEdge2D *qedge1 ;
  void *vptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvQuadEdge2D *result = 0 ;
  
  if (!SWIG_check_num_args("CV_SUBDIV2D_NEXT_EDGE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0) != -1 ){
      wrapper1 = (CvSubdiv2DEdge_Wrapper *) vptr1;
      arg1 = wrapper1->ref();
    }
    else if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvQuadEdge2D, 0) != -1 ){
      qedge1 = (CvQuadEdge2D *) vptr1;
      arg1 = (CvSubdiv2DEdge)qedge1;
    }
    else{
      SWIG_exception( SWIG_TypeError, "could not convert to CvSubdiv2DEdge");
      SWIG_fail;
    }
  }
  result = (CvQuadEdge2D *)CV_SUBDIV2D_NEXT_EDGE(arg1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_SWAP (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_SWAP",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_SWAP" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CV_SWAP" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CV_SWAP" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  CV_SWAP(arg1,arg2,arg3);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IMIN (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IMIN",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_IMIN" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CV_IMIN" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = (int)CV_IMIN(arg1,arg2);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IMAX (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IMAX",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_IMAX" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CV_IMAX" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = (int)CV_IMAX(arg1,arg2);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IABS (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IABS",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_IABS" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_IABS(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_CMP (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_CMP",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_CMP" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CV_CMP" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  CV_CMP(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_SIGN (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_SIGN",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_SIGN" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  CV_SIGN(arg1);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvInvSqrt (const octave_value_list& args, int nargout) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInvSqrt",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvInvSqrt" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  cvInvSqrt(arg1);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSqrt (const octave_value_list& args, int nargout) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSqrt",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvSqrt" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  cvSqrt(arg1);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_IMAGE_HDR (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_IMAGE_HDR",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  result = (int)CV_IS_IMAGE_HDR(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_IMAGE (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_IMAGE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  result = (int)CV_IS_IMAGE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CV_MAT_DEPTH (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_MAT_DEPTH",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_MAT_DEPTH" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_MAT_DEPTH(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_MAKETYPE (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_MAKETYPE",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_MAKETYPE" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CV_MAKETYPE" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  result = (int)CV_MAKETYPE(arg1,arg2);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_8UC (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_8UC",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_8UC" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_8UC(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_8SC (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_8SC",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_8SC" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_8SC(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_16UC (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_16UC",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_16UC" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_16UC(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_16SC (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_16SC",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_16SC" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_16SC(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_32SC (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_32SC",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_32SC" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_32SC(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_32FC (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_32FC",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_32FC" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_32FC(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_64FC (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_64FC",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_64FC" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_64FC(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_MAT_CN (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_MAT_CN",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_MAT_CN" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_MAT_CN(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_MAT_TYPE (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_MAT_TYPE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_MAT_TYPE" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_MAT_TYPE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_MAT_CONT (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_MAT_CONT",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_IS_MAT_CONT" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_IS_MAT_CONT(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_TEMP_MAT (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_TEMP_MAT",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_IS_TEMP_MAT" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_IS_TEMP_MAT(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_MAT_HDR (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_MAT_HDR",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_MAT_HDR" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int)CV_IS_MAT_HDR(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_MAT (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_MAT",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_MAT" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int)CV_IS_MAT(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_MASK_ARR (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_MASK_ARR",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_MASK_ARR" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int)CV_IS_MASK_ARR(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_ARE_TYPES_EQ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_ARE_TYPES_EQ",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_ARE_TYPES_EQ" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_ARE_TYPES_EQ" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  result = (int)CV_ARE_TYPES_EQ(arg1,arg2);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_ARE_CNS_EQ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_ARE_CNS_EQ",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_ARE_CNS_EQ" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_ARE_CNS_EQ" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  result = (int)CV_ARE_CNS_EQ(arg1,arg2);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_ARE_DEPTHS_EQ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_ARE_DEPTHS_EQ",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_ARE_DEPTHS_EQ" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_ARE_DEPTHS_EQ" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  result = (int)CV_ARE_DEPTHS_EQ(arg1,arg2);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_ARE_SIZES_EQ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_ARE_SIZES_EQ",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_ARE_SIZES_EQ" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_ARE_SIZES_EQ" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  result = (int)CV_ARE_SIZES_EQ(arg1,arg2);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_MAT_CONST (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_MAT_CONST",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_MAT_CONST" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int)CV_IS_MAT_CONST(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_ELEM_SIZE1 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_ELEM_SIZE1",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_ELEM_SIZE1" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_ELEM_SIZE1(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_ELEM_SIZE (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_ELEM_SIZE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_ELEM_SIZE" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_ELEM_SIZE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_MATND_HDR (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_MATND_HDR",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_MATND_HDR" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int)CV_IS_MATND_HDR(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_MATND (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_MATND",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_MATND" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int)CV_IS_MATND(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SPARSE_MAT_HDR (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SPARSE_MAT_HDR",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_SPARSE_MAT_HDR" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int)CV_IS_SPARSE_MAT_HDR(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SPARSE_MAT (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SPARSE_MAT",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_SPARSE_MAT" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int)CV_IS_SPARSE_MAT(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_HIST (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_HIST",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_HIST" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  result = (int)CV_IS_HIST(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_UNIFORM_HIST (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_UNIFORM_HIST",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_UNIFORM_HIST" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  result = (int)CV_IS_UNIFORM_HIST(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SPARSE_HIST (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SPARSE_HIST",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_SPARSE_HIST" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  result = (int)CV_IS_SPARSE_HIST(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_HIST_HAS_RANGES (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_HIST_HAS_RANGES",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_HIST_HAS_RANGES" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  result = (int)CV_HIST_HAS_RANGES(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_STORAGE (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_STORAGE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_STORAGE" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  result = (int)CV_IS_STORAGE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SET_ELEM (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  int res1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SET_ELEM",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_SET_ELEM" "', argument " "1"" of type '" "void *""'"); 
  }
  result = (int)CV_IS_SET_ELEM(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SET (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SET",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (int)CV_IS_SET(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_SEQ_ELTYPE (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_SEQ_ELTYPE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_SEQ_ELTYPE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_SEQ_KIND (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_SEQ_KIND",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_SEQ_KIND(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_INDEX (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_INDEX",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_INDEX(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_CURVE (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_CURVE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_CURVE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_CLOSED (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_CLOSED",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_CLOSED(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_CONVEX (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_CONVEX",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_CONVEX(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_HOLE (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_HOLE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_HOLE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_SIMPLE (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_SIMPLE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_SIMPLE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_POINT_SET (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_POINT_SET",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_POINT_SET(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_POINT_SUBSET (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_POINT_SUBSET",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_POINT_SUBSET(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_POLYLINE (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_POLYLINE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_POLYLINE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_POLYGON (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_POLYGON",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_POLYGON(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_CHAIN (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_CHAIN",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_CHAIN(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_CONTOUR (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_CONTOUR",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_CONTOUR(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_CHAIN_CONTOUR (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_CHAIN_CONTOUR",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_CHAIN_CONTOUR(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SEQ_POLYGON_TREE (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SEQ_POLYGON_TREE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SEQ_POLYGON_TREE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_GRAPH (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_GRAPH",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_GRAPH(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_GRAPH_ORIENTED (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_GRAPH_ORIENTED",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_GRAPH_ORIENTED(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_SUBDIV2D (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_SUBDIV2D",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_IS_SUBDIV2D(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_WRITE_SEQ_ELEM_VAR (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  CvSeqWriter arg2 ;
  int res1 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_WRITE_SEQ_ELEM_VAR",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_WRITE_SEQ_ELEM_VAR" "', argument " "1"" of type '" "void *""'"); 
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSeqWriter,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_WRITE_SEQ_ELEM_VAR" "', argument " "2"" of type '" "CvSeqWriter""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_WRITE_SEQ_ELEM_VAR" "', argument " "2"" of type '" "CvSeqWriter""'");
    } else {
      arg2 = *((CvSeqWriter *)(argp2));
    }
  }
  CV_WRITE_SEQ_ELEM_VAR(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_WRITE_SEQ_ELEM (const octave_value_list& args, int nargout) {
  CvPoint arg1 ;
  CvSeqWriter arg2 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_WRITE_SEQ_ELEM",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint(args(0));
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSeqWriter,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_WRITE_SEQ_ELEM" "', argument " "2"" of type '" "CvSeqWriter""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_WRITE_SEQ_ELEM" "', argument " "2"" of type '" "CvSeqWriter""'");
    } else {
      arg2 = *((CvSeqWriter *)(argp2));
    }
  }
  CV_WRITE_SEQ_ELEM(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NEXT_SEQ_ELEM (const octave_value_list& args, int nargout) {
  int arg1 ;
  CvSeqReader arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_NEXT_SEQ_ELEM",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NEXT_SEQ_ELEM" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSeqReader,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_NEXT_SEQ_ELEM" "', argument " "2"" of type '" "CvSeqReader""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_NEXT_SEQ_ELEM" "', argument " "2"" of type '" "CvSeqReader""'");
    } else {
      arg2 = *((CvSeqReader *)(argp2));
    }
  }
  CV_NEXT_SEQ_ELEM(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_PREV_SEQ_ELEM (const octave_value_list& args, int nargout) {
  int arg1 ;
  CvSeqReader arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_PREV_SEQ_ELEM",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_PREV_SEQ_ELEM" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSeqReader,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_PREV_SEQ_ELEM" "', argument " "2"" of type '" "CvSeqReader""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_PREV_SEQ_ELEM" "', argument " "2"" of type '" "CvSeqReader""'");
    } else {
      arg2 = *((CvSeqReader *)(argp2));
    }
  }
  CV_PREV_SEQ_ELEM(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_READ_SEQ_ELEM (const octave_value_list& args, int nargout) {
  CvPoint arg1 ;
  CvSeqReader arg2 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_READ_SEQ_ELEM",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint(args(0));
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSeqReader,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_READ_SEQ_ELEM" "', argument " "2"" of type '" "CvSeqReader""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_READ_SEQ_ELEM" "', argument " "2"" of type '" "CvSeqReader""'");
    } else {
      arg2 = *((CvSeqReader *)(argp2));
    }
  }
  CV_READ_SEQ_ELEM(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_REV_READ_SEQ_ELEM (const octave_value_list& args, int nargout) {
  CvPoint arg1 ;
  CvSeqReader arg2 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_REV_READ_SEQ_ELEM",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint(args(0));
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSeqReader,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_REV_READ_SEQ_ELEM" "', argument " "2"" of type '" "CvSeqReader""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_REV_READ_SEQ_ELEM" "', argument " "2"" of type '" "CvSeqReader""'");
    } else {
      arg2 = *((CvSeqReader *)(argp2));
    }
  }
  CV_REV_READ_SEQ_ELEM(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_CURRENT_POINT (const octave_value_list& args, int nargout) {
  CvSeqReader arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint result;
  
  if (!SWIG_check_num_args("CV_CURRENT_POINT",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvSeqReader,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_CURRENT_POINT" "', argument " "1"" of type '" "CvSeqReader""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_CURRENT_POINT" "', argument " "1"" of type '" "CvSeqReader""'");
    } else {
      arg1 = *((CvSeqReader *)(argp1));
    }
  }
  result = CV_CURRENT_POINT(arg1);
  _outv = SWIG_NewPointerObj((new CvPoint((const CvPoint&)(result))), SWIGTYPE_p_CvPoint, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_PREV_POINT (const octave_value_list& args, int nargout) {
  CvSeqReader arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint result;
  
  if (!SWIG_check_num_args("CV_PREV_POINT",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvSeqReader,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_PREV_POINT" "', argument " "1"" of type '" "CvSeqReader""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_PREV_POINT" "', argument " "1"" of type '" "CvSeqReader""'");
    } else {
      arg1 = *((CvSeqReader *)(argp1));
    }
  }
  result = CV_PREV_POINT(arg1);
  _outv = SWIG_NewPointerObj((new CvPoint((const CvPoint&)(result))), SWIGTYPE_p_CvPoint, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_READ_EDGE (const octave_value_list& args, int nargout) {
  CvPoint arg1 ;
  CvPoint arg2 ;
  CvSeqReader arg3 ;
  void *argp3 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_READ_EDGE",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint(args(0));
  }
  {
    arg2 = OctObject_to_CvPoint(args(1));
  }
  {
    res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvSeqReader,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CV_READ_EDGE" "', argument " "3"" of type '" "CvSeqReader""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_READ_EDGE" "', argument " "3"" of type '" "CvSeqReader""'");
    } else {
      arg3 = *((CvSeqReader *)(argp3));
    }
  }
  CV_READ_EDGE(arg1,arg2,arg3);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NEXT_GRAPH_EDGE (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphEdge *result = 0 ;
  
  if (!SWIG_check_num_args("CV_NEXT_GRAPH_EDGE",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_NEXT_GRAPH_EDGE" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CV_NEXT_GRAPH_EDGE" "', argument " "2"" of type '" "CvGraphVtx *""'"); 
  }
  arg2 = (CvGraphVtx *)(argp2);
  result = (CvGraphEdge *)CV_NEXT_GRAPH_EDGE(arg1,arg2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_TYPE (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_TYPE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_TYPE" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_TYPE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_IS_INT (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_IS_INT",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_IS_INT" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_IS_INT(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_IS_REAL (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_IS_REAL",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_IS_REAL" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_IS_REAL(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_IS_STRING (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_IS_STRING",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_IS_STRING" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_IS_STRING(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_IS_SEQ (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_IS_SEQ",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_IS_SEQ" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_IS_SEQ(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_IS_MAP (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_IS_MAP",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_IS_MAP" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_IS_MAP(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_IS_COLLECTION (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_IS_COLLECTION",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_IS_COLLECTION" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_IS_COLLECTION(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_IS_FLOW (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_IS_FLOW",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_IS_FLOW" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_IS_FLOW(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_IS_EMPTY (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_IS_EMPTY",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_IS_EMPTY" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_IS_EMPTY(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_IS_USER (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_IS_USER",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_IS_USER" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_IS_USER(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_HAS_NAME (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_HAS_NAME",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_NODE_HAS_NAME" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  result = (int)CV_NODE_HAS_NAME(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NODE_SEQ_IS_SIMPLE (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_NODE_SEQ_IS_SIMPLE",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int)CV_NODE_SEQ_IS_SIMPLE(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReshapeND (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  int arg3 ;
  int arg4 ;
  int *arg5 = (int *) 0 ;
  bool freearg1 = false ;
  CvMat *header2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  {
    header2 = (CvMat *)cvAlloc(sizeof(CvMat));
    arg2 = header2;
  }
  if (!SWIG_check_num_args("cvReshapeND",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode3 = SWIG_AsVal_int(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvReshapeND" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(2), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvReshapeND" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  res5 = SWIG_ConvertPtr(args(3), &argp5,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvReshapeND" "', argument " "5"" of type '" "int *""'"); 
  }
  arg5 = (int *)(argp5);
  cvReshapeND(arg1,arg2,arg3,arg4,arg5);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvConvert (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvConvert",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  cvConvert(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAXPY (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  double arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  bool freearg1 = false ;
  double val2 ;
  int ecode2 = 0 ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAXPY",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvAXPY" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  cvAXPY(arg1,arg2,arg3,arg4);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAbs (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAbs",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  cvAbs(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMatMulAdd (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMatMulAdd",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  cvMatMulAdd(arg1,arg2,arg3,arg4);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMatMul (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMatMul",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  cvMatMul(arg1,arg2,arg3);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetGraphVtx (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvGetGraphVtx",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetGraphVtx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  cvGetGraphVtx(arg1,arg2);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphVtxIdx (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphVtxIdx",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGraphVtxIdx" "', argument " "2"" of type '" "CvGraphVtx *""'"); 
  }
  arg2 = (CvGraphVtx *)(argp2);
  result = (int)cvGraphVtxIdx(arg1,arg2);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphEdgeIdx (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvGraphEdge *arg2 = (CvGraphEdge *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphEdgeIdx",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGraphEdgeIdx" "', argument " "2"" of type '" "CvGraphEdge *""'"); 
  }
  arg2 = (CvGraphEdge *)(argp2);
  result = (int)cvGraphEdgeIdx(arg1,arg2);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphGetVtxCount (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphGetVtxCount",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (int)cvGraphGetVtxCount(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphGetEdgeCount (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphGetEdgeCount",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (int)cvGraphGetEdgeCount(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_GRAPH_VERTEX_VISITED (const octave_value_list& args, int nargout) {
  CvGraphVtx *arg1 = (CvGraphVtx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_GRAPH_VERTEX_VISITED",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_GRAPH_VERTEX_VISITED" "', argument " "1"" of type '" "CvGraphVtx *""'"); 
  }
  arg1 = (CvGraphVtx *)(argp1);
  result = (int)CV_IS_GRAPH_VERTEX_VISITED(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_GRAPH_EDGE_VISITED (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_GRAPH_EDGE_VISITED",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_GRAPH_EDGE_VISITED" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  result = (int)CV_IS_GRAPH_EDGE_VISITED(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_RGB (const octave_value_list& args, int nargout) {
  double arg1 ;
  double arg2 ;
  int arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("CV_RGB",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "CV_RGB" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CV_RGB" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CV_RGB" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  result = CV_RGB(arg1,arg2,arg3);
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_NEXT_LINE_POINT (const octave_value_list& args, int nargout) {
  CvLineIterator arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_NEXT_LINE_POINT",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvLineIterator,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_NEXT_LINE_POINT" "', argument " "1"" of type '" "CvLineIterator""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CV_NEXT_LINE_POINT" "', argument " "1"" of type '" "CvLineIterator""'");
    } else {
      arg1 = *((CvLineIterator *)(argp1));
    }
  }
  CV_NEXT_LINE_POINT(arg1);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_INIT_3X3_DELTAS (const octave_value_list& args, int nargout) {
  double *arg1 = (double *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CV_INIT_3X3_DELTAS",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_INIT_3X3_DELTAS" "', argument " "1"" of type '" "double *""'"); 
  }
  arg1 = (double *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CV_INIT_3X3_DELTAS" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CV_INIT_3X3_DELTAS" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  CV_INIT_3X3_DELTAS(arg1,arg2,arg3);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CV_IS_HAAR_CLASSIFIER (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  int res1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CV_IS_HAAR_CLASSIFIER",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CV_IS_HAAR_CLASSIFIER" "', argument " "1"" of type '" "void *""'"); 
  }
  result = (int)CV_IS_HAAR_CLASSIFIER(arg1);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcBackProject (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvHistogram *arg3 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcBackProject",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCalcBackProject" "', argument " "1"" of type '" "IplImage *""'"); 
  }
  arg1 = (IplImage *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCalcBackProject" "', argument " "3"" of type '" "CvHistogram *""'"); 
  }
  arg3 = (CvHistogram *)(argp3);
  cvCalcBackProject(arg1,arg2,arg3);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcBackProjectPatch (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvSize arg3 ;
  CvHistogram *arg4 = (CvHistogram *) 0 ;
  int arg5 ;
  double arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcBackProjectPatch",args.length(),6,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCalcBackProjectPatch" "', argument " "1"" of type '" "IplImage *""'"); 
  }
  arg1 = (IplImage *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCalcBackProjectPatch" "', argument " "3"" of type '" "CvSize""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcBackProjectPatch" "', argument " "3"" of type '" "CvSize""'");
    } else {
      arg3 = *((CvSize *)(argp3));
    }
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCalcBackProjectPatch" "', argument " "4"" of type '" "CvHistogram *""'"); 
  }
  arg4 = (CvHistogram *)(argp4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCalcBackProjectPatch" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_double(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvCalcBackProjectPatch" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  cvCalcBackProjectPatch(arg1,arg2,arg3,arg4,arg5,arg6);
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateImage (const octave_value_list& args, int nargout) {
  CvSize arg1 ;
  int arg2 ;
  int arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateImage",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCreateImage" "', argument " "1"" of type '" "CvSize""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCreateImage" "', argument " "1"" of type '" "CvSize""'");
    } else {
      arg1 = *((CvSize *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateImage" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateImage" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvMat *)cvCreateImageMat(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCloneImage (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvCloneImage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCloneImage" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (CvMat *)cvCloneImageMat(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv32suf_i_set (const octave_value_list& args, int nargout) {
  Cv32suf *arg1 = (Cv32suf *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("Cv32suf_i_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv32suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv32suf_i_set" "', argument " "1"" of type '" "Cv32suf *""'"); 
  }
  arg1 = (Cv32suf *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Cv32suf_i_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->i = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv32suf_i_get (const octave_value_list& args, int nargout) {
  Cv32suf *arg1 = (Cv32suf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("Cv32suf_i_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv32suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv32suf_i_get" "', argument " "1"" of type '" "Cv32suf *""'"); 
  }
  arg1 = (Cv32suf *)(argp1);
  result = (int) ((arg1)->i);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv32suf_u_set (const octave_value_list& args, int nargout) {
  Cv32suf *arg1 = (Cv32suf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("Cv32suf_u_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv32suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv32suf_u_set" "', argument " "1"" of type '" "Cv32suf *""'"); 
  }
  arg1 = (Cv32suf *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Cv32suf_u_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->u = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv32suf_u_get (const octave_value_list& args, int nargout) {
  Cv32suf *arg1 = (Cv32suf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  unsigned int result;
  
  if (!SWIG_check_num_args("Cv32suf_u_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv32suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv32suf_u_get" "', argument " "1"" of type '" "Cv32suf *""'"); 
  }
  arg1 = (Cv32suf *)(argp1);
  result = (unsigned int) ((arg1)->u);
  _outv = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv32suf_f_set (const octave_value_list& args, int nargout) {
  Cv32suf *arg1 = (Cv32suf *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("Cv32suf_f_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv32suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv32suf_f_set" "', argument " "1"" of type '" "Cv32suf *""'"); 
  }
  arg1 = (Cv32suf *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Cv32suf_f_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->f = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv32suf_f_get (const octave_value_list& args, int nargout) {
  Cv32suf *arg1 = (Cv32suf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("Cv32suf_f_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv32suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv32suf_f_get" "', argument " "1"" of type '" "Cv32suf *""'"); 
  }
  arg1 = (Cv32suf *)(argp1);
  result = (float) ((arg1)->f);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_Cv32suf (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  Cv32suf *result = 0 ;
  
  if (!SWIG_check_num_args("new_Cv32suf",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (Cv32suf *)new Cv32suf(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Cv32suf, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_Cv32suf (const octave_value_list& args, int nargout) {
  Cv32suf *arg1 = (Cv32suf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_Cv32suf",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv32suf, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Cv32suf" "', argument " "1"" of type '" "Cv32suf *""'"); 
  }
  arg1 = (Cv32suf *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_Cv32suf_members[] = {
{"i",0,_wrap_Cv32suf_i_get,_wrap_Cv32suf_i_set,0,0},
{"u",0,_wrap_Cv32suf_u_get,_wrap_Cv32suf_u_set,0,0},
{"f",0,_wrap_Cv32suf_f_get,_wrap_Cv32suf_f_set,0,0},
{0,0,0,0}
};
static const char *swig_Cv32suf_base_names[] = {0};
static const swig_type_info *swig_Cv32suf_base[] = {0};
static swig_octave_class _wrap_class_Cv32suf = {"Cv32suf", &SWIGTYPE_p_Cv32suf,0,_wrap_new_Cv32suf,0,_wrap_delete_Cv32suf,swig_Cv32suf_members,swig_Cv32suf_base_names,swig_Cv32suf_base };

static octave_value_list _wrap_Cv64suf_i_set (const octave_value_list& args, int nargout) {
  Cv64suf *arg1 = (Cv64suf *) 0 ;
  int64 arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("Cv64suf_i_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv64suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv64suf_i_set" "', argument " "1"" of type '" "Cv64suf *""'"); 
  }
  arg1 = (Cv64suf *)(argp1);
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_int64_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Cv64suf_i_set" "', argument " "2"" of type '" "int64""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Cv64suf_i_set" "', argument " "2"" of type '" "int64""'");
    } else {
      arg2 = *((int64 *)(argp2));
    }
  }
  if (arg1) (arg1)->i = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv64suf_i_get (const octave_value_list& args, int nargout) {
  Cv64suf *arg1 = (Cv64suf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int64 result;
  
  if (!SWIG_check_num_args("Cv64suf_i_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv64suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv64suf_i_get" "', argument " "1"" of type '" "Cv64suf *""'"); 
  }
  arg1 = (Cv64suf *)(argp1);
  result =  ((arg1)->i);
  _outv = SWIG_NewPointerObj((new int64((const int64&)(result))), SWIGTYPE_p_int64_t, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv64suf_u_set (const octave_value_list& args, int nargout) {
  Cv64suf *arg1 = (Cv64suf *) 0 ;
  uint64 arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("Cv64suf_u_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv64suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv64suf_u_set" "', argument " "1"" of type '" "Cv64suf *""'"); 
  }
  arg1 = (Cv64suf *)(argp1);
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_uint64_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Cv64suf_u_set" "', argument " "2"" of type '" "uint64""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Cv64suf_u_set" "', argument " "2"" of type '" "uint64""'");
    } else {
      arg2 = *((uint64 *)(argp2));
    }
  }
  if (arg1) (arg1)->u = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv64suf_u_get (const octave_value_list& args, int nargout) {
  Cv64suf *arg1 = (Cv64suf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uint64 result;
  
  if (!SWIG_check_num_args("Cv64suf_u_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv64suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv64suf_u_get" "', argument " "1"" of type '" "Cv64suf *""'"); 
  }
  arg1 = (Cv64suf *)(argp1);
  result =  ((arg1)->u);
  _outv = SWIG_NewPointerObj((new uint64((const uint64&)(result))), SWIGTYPE_p_uint64_t, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv64suf_f_set (const octave_value_list& args, int nargout) {
  Cv64suf *arg1 = (Cv64suf *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("Cv64suf_f_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv64suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv64suf_f_set" "', argument " "1"" of type '" "Cv64suf *""'"); 
  }
  arg1 = (Cv64suf *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Cv64suf_f_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->f = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_Cv64suf_f_get (const octave_value_list& args, int nargout) {
  Cv64suf *arg1 = (Cv64suf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("Cv64suf_f_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv64suf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cv64suf_f_get" "', argument " "1"" of type '" "Cv64suf *""'"); 
  }
  arg1 = (Cv64suf *)(argp1);
  result = (double) ((arg1)->f);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_Cv64suf (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  Cv64suf *result = 0 ;
  
  if (!SWIG_check_num_args("new_Cv64suf",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (Cv64suf *)new Cv64suf(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Cv64suf, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_Cv64suf (const octave_value_list& args, int nargout) {
  Cv64suf *arg1 = (Cv64suf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_Cv64suf",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_Cv64suf, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Cv64suf" "', argument " "1"" of type '" "Cv64suf *""'"); 
  }
  arg1 = (Cv64suf *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_Cv64suf_members[] = {
{"i",0,_wrap_Cv64suf_i_get,_wrap_Cv64suf_i_set,0,0},
{"u",0,_wrap_Cv64suf_u_get,_wrap_Cv64suf_u_set,0,0},
{"f",0,_wrap_Cv64suf_f_get,_wrap_Cv64suf_f_set,0,0},
{0,0,0,0}
};
static const char *swig_Cv64suf_base_names[] = {0};
static const swig_type_info *swig_Cv64suf_base[] = {0};
static swig_octave_class _wrap_class_Cv64suf = {"Cv64suf", &SWIGTYPE_p_Cv64suf,0,_wrap_new_Cv64suf,0,_wrap_delete_Cv64suf,swig_Cv64suf_members,swig_Cv64suf_base_names,swig_Cv64suf_base };

static octave_value_list _wrap_cvRound (const octave_value_list& args, int nargout) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvRound",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvRound" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    try {
      result = (int)cvRound(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFloor (const octave_value_list& args, int nargout) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvFloor",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvFloor" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    try {
      result = (int)cvFloor(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCeil (const octave_value_list& args, int nargout) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvCeil",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCeil" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    try {
      result = (int)cvCeil(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvIsNaN (const octave_value_list& args, int nargout) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvIsNaN",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvIsNaN" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    try {
      result = (int)cvIsNaN(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvIsInf (const octave_value_list& args, int nargout) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvIsInf",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvIsInf" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    try {
      result = (int)cvIsInf(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRNG__SWIG_0 (const octave_value_list& args, int nargout) {
  int64 arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRNG result;
  
  if (!SWIG_check_num_args("cvRNG",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_int64_t,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRNG" "', argument " "1"" of type '" "int64""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvRNG" "', argument " "1"" of type '" "int64""'");
    } else {
      arg1 = *((int64 *)(argp1));
    }
  }
  {
    try {
      result = cvRNG(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    CvRNG_Wrapper * wrapper = new CvRNG_Wrapper( result );
    _outv = SWIG_NewPointerObj( wrapper, SWIGTYPE_p_CvRNG_Wrapper, 1 );
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRNG__SWIG_1 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRNG result;
  
  if (!SWIG_check_num_args("cvRNG",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = cvRNG(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    CvRNG_Wrapper * wrapper = new CvRNG_Wrapper( result );
    _outv = SWIG_NewPointerObj( wrapper, SWIGTYPE_p_CvRNG_Wrapper, 1 );
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRNG (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[1]={
    octave_value_ref(args,0)
  };
  
  if (argc == 0) {
    return _wrap_cvRNG__SWIG_1(args, nargout);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_int64_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_cvRNG__SWIG_0(args, nargout);
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_cvRandInt (const octave_value_list& args, int nargout) {
  CvRNG *arg1 = (CvRNG *) 0 ;
  void *vptr1 ;
  CvRNG_Wrapper *wrapper1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  unsigned int result;
  
  if (!SWIG_check_num_args("cvRandInt",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if(SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvRNG_Wrapper, 0)==-1){
      SWIG_exception( SWIG_TypeError, "could not convert Octave object to C value");
      SWIG_fail;
    }
    wrapper1 = (CvRNG_Wrapper *) vptr1;
    arg1 = wrapper1->ptr();
  }
  {
    try {
      result = (unsigned int)cvRandInt(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRandReal (const octave_value_list& args, int nargout) {
  CvRNG *arg1 = (CvRNG *) 0 ;
  void *vptr1 ;
  CvRNG_Wrapper *wrapper1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvRandReal",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if(SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvRNG_Wrapper, 0)==-1){
      SWIG_exception( SWIG_TypeError, "could not convert Octave object to C value");
      SWIG_fail;
    }
    wrapper1 = (CvRNG_Wrapper *) vptr1;
    arg1 = wrapper1->ptr();
  }
  {
    try {
      result = (double)cvRandReal(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_ID_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  int arg2 ;
  IplImage header1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_ID_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage_ID_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->ID = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_ID_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplImage_ID_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (int) ((arg1)->ID);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_nChannels_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  int arg2 ;
  IplImage header1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_nChannels_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage_nChannels_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nChannels = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_nChannels_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplImage_nChannels_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (int) ((arg1)->nChannels);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_depth_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  int arg2 ;
  IplImage header1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_depth_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage_depth_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->depth = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_depth_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplImage_depth_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (int) ((arg1)->depth);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_dataOrder_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  int arg2 ;
  IplImage header1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_dataOrder_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage_dataOrder_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->dataOrder = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_dataOrder_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplImage_dataOrder_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (int) ((arg1)->dataOrder);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_origin_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  int arg2 ;
  IplImage header1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_origin_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage_origin_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->origin = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_origin_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplImage_origin_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (int) ((arg1)->origin);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_align_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  int arg2 ;
  IplImage header1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_align_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage_align_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->align = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_align_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplImage_align_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (int) ((arg1)->align);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_width_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  int arg2 ;
  IplImage header1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_width_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage_width_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->width = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_width_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplImage_width_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (int) ((arg1)->width);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_height_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  int arg2 ;
  IplImage header1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_height_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage_height_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->height = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_height_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplImage_height_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (int) ((arg1)->height);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_roi_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  _IplROI *arg2 = (_IplROI *) 0 ;
  IplImage header1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_roi_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p__IplROI, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IplImage_roi_set" "', argument " "2"" of type '" "_IplROI *""'"); 
  }
  arg2 = (_IplROI *)(argp2);
  if (arg1) (arg1)->roi = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_roi_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  _IplROI *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage_roi_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (_IplROI *) ((arg1)->roi);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__IplROI, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_imageSize_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  int arg2 ;
  IplImage header1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_imageSize_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage_imageSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->imageSize = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_imageSize_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplImage_imageSize_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (int) ((arg1)->imageSize);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_widthStep_set (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  int arg2 ;
  IplImage header1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage_widthStep_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage_widthStep_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->widthStep = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage_widthStep_get (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplImage_widthStep_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  result = (int) ((arg1)->widthStep);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_IplImage (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_IplImage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    try {
      delete_IplImage(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___add____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___add__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Sa___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___mul____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___mul__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Sm___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___sub____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___sub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Ss___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___div____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___div__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Sd___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___xor____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___xor__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Sx___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___add____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvScalar arg2 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___add__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Sa___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___add__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___add____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_IplImage___add____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___xor____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvScalar arg2 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___xor__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Sx___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___xor__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___xor____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_IplImage___xor____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___sub____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvScalar arg2 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___sub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Ss___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___sub__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___sub____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_IplImage___sub____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___ge____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___ge__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Sg__Se___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___ge____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___ge__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___ge__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage_operator_Sg__Se___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___ge__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___ge____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___ge____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___eq____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___eq__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Se__Se___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___eq____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___eq__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___eq__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage_operator_Se__Se___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___eq__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___eq____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___eq____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___le____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___le__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Sl__Se___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___le____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___le__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___le__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage_operator_Sl__Se___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___le__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___le____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___le____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___ne____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___ne__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_SN__Se___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___ne____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___ne__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___ne__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage_operator_SN__Se___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___ne__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___ne____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___ne____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___lt____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___lt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Sl___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___lt____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___lt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___lt__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage_operator_Sl___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___lt__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___lt____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___lt____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___gt____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___gt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage_operator_Sg___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___gt____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___gt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___gt__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage_operator_Sg___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___gt__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___gt____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___gt____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___mul____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___mul__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___mul__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage_operator_Sm___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___mul__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___mul____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___mul____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___div____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___div__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___div__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage_operator_Sd___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___div__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___div____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___div____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___radd____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___radd__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage___radd____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rsub____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rsub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage___rsub____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rdiv____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rdiv__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage___rdiv____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rmul____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rmul__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (IplImage *)IplImage___rmul____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___radd____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvScalar arg2 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___radd__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (IplImage *)IplImage___radd____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___radd____SWIG_2 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___radd__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___radd__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage___radd____SWIG_2(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___radd__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___radd____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_IplImage___radd____SWIG_1(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___radd____SWIG_2(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___rsub____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvScalar arg2 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rsub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (IplImage *)IplImage___rsub____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rsub____SWIG_2 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rsub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___rsub__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage___rsub____SWIG_2(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rsub__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___rsub____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_IplImage___rsub____SWIG_1(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___rsub____SWIG_2(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___rmul____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rmul__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___rmul__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)IplImage___rmul____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rmul__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___rmul____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___rmul____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___rdiv____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rdiv__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___rdiv__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)IplImage___rdiv____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rdiv__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_IplImage___rdiv____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___rdiv____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___ror____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvScalar arg2 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___ror__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (IplImage *)IplImage___ror____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___ror____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___ror__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___ror__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage___ror____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___ror__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_IplImage___ror____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___ror____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___rand____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvScalar arg2 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rand__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (IplImage *)IplImage___rand____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rand____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rand__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___rand__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage___rand____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rand__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_IplImage___rand____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___rand____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___rxor____SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  CvScalar arg2 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rxor__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (IplImage *)IplImage___rxor____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rxor____SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rxor__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___rxor__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage___rxor____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rxor__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_IplImage___rxor____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_IplImage___rxor____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___req__ (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___req__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___req__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)IplImage___req__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rgt__ (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rgt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___rgt__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)IplImage___rgt__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rge__ (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rge__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___rge__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)IplImage___rge__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rlt__ (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rlt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___rlt__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)IplImage___rlt__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rle__ (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rle__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___rle__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)IplImage___rle__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___rne__ (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___rne__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___rne__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)IplImage___rne__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___pow__ (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  double arg2 ;
  IplImage header1 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___pow__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplImage___pow__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (IplImage *)IplImage___pow__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___str (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("IplImage___str",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    try {
      result = (char *)IplImage___str(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___paren_asgn__SWIG_0 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  octave_value arg2 ;
  double arg3 ;
  IplImage header1 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  arg2 = args(1);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IplImage___paren_asgn" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      IplImage___paren_asgn__SWIG_0(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___paren_asgn__SWIG_1 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  octave_value arg2 ;
  CvPoint arg3 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  arg2 = args(1);
  {
    arg3 = OctObject_to_CvPoint(args(2));
  }
  {
    try {
      IplImage___paren_asgn__SWIG_1(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___paren_asgn__SWIG_2 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  octave_value arg2 ;
  CvPoint2D32f arg3 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  arg2 = args(1);
  {
    arg3 = OctObject_to_CvPoint2D32f(args(2));
  }
  {
    try {
      IplImage___paren_asgn__SWIG_2(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___paren_asgn__SWIG_3 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  octave_value arg2 ;
  CvScalar arg3 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  arg2 = args(1);
  {
    arg3 = OctObject_to_CvScalar( args(2) );
  }
  {
    try {
      IplImage___paren_asgn__SWIG_3(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___paren_asgn__SWIG_4 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  octave_value arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  IplImage header1 ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplImage___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  arg2 = args(1);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      IplImage___paren_asgn__SWIG_4(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_IplImage___paren_asgn (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (*argv[1]).is_defined();
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvPoint, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_IplImage___paren_asgn__SWIG_1(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (*argv[1]).is_defined();
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvPoint2D32f, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_IplImage___paren_asgn__SWIG_2(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (*argv[1]).is_defined();
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvScalar, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_IplImage___paren_asgn__SWIG_3(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (*argv[1]).is_defined();
      if (_v) {
        {
          void *ptr;
          if(OctList_Check(argv[2]) || OctTuple_Check(argv[2])) {
            _v = 1;
          }
          else if (SWIG_ConvertPtr(argv[2], &ptr, 0, 0) == -1) {
            _v = 0;
          }
          else{
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_IplImage___paren_asgn__SWIG_4(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (*argv[1]).is_defined();
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_IplImage___paren_asgn__SWIG_0(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_IplImage___paren (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  octave_value arg2 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  octave_value result;
  
  if (!SWIG_check_num_args("IplImage___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  arg2 = args(1);
  {
    try {
      result = IplImage___paren(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = result;
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_IplImage_members[] = {
{"ID",0,_wrap_IplImage_ID_get,_wrap_IplImage_ID_set,0,0},
{"nChannels",0,_wrap_IplImage_nChannels_get,_wrap_IplImage_nChannels_set,0,0},
{"depth",0,_wrap_IplImage_depth_get,_wrap_IplImage_depth_set,0,0},
{"dataOrder",0,_wrap_IplImage_dataOrder_get,_wrap_IplImage_dataOrder_set,0,0},
{"origin",0,_wrap_IplImage_origin_get,_wrap_IplImage_origin_set,0,0},
{"align",0,_wrap_IplImage_align_get,_wrap_IplImage_align_set,0,0},
{"width",0,_wrap_IplImage_width_get,_wrap_IplImage_width_set,0,0},
{"height",0,_wrap_IplImage_height_get,_wrap_IplImage_height_set,0,0},
{"roi",0,_wrap_IplImage_roi_get,_wrap_IplImage_roi_set,0,0},
{"imageSize",0,_wrap_IplImage_imageSize_get,_wrap_IplImage_imageSize_set,0,0},
{"widthStep",0,_wrap_IplImage_widthStep_get,_wrap_IplImage_widthStep_set,0,0},
{"__add__",_wrap_IplImage___add__,0,0,0,0},
{"__xor__",_wrap_IplImage___xor__,0,0,0,0},
{"__sub__",_wrap_IplImage___sub__,0,0,0,0},
{"__ge__",_wrap_IplImage___ge__,0,0,0,0},
{"__eq__",_wrap_IplImage___eq__,0,0,0,0},
{"__le__",_wrap_IplImage___le__,0,0,0,0},
{"__ne__",_wrap_IplImage___ne__,0,0,0,0},
{"__lt__",_wrap_IplImage___lt__,0,0,0,0},
{"__gt__",_wrap_IplImage___gt__,0,0,0,0},
{"__mul__",_wrap_IplImage___mul__,0,0,0,0},
{"__div__",_wrap_IplImage___div__,0,0,0,0},
{"__radd__",_wrap_IplImage___radd__,0,0,0,0},
{"__rsub__",_wrap_IplImage___rsub__,0,0,0,0},
{"__rmul__",_wrap_IplImage___rmul__,0,0,0,0},
{"__rdiv__",_wrap_IplImage___rdiv__,0,0,0,0},
{"__ror__",_wrap_IplImage___ror__,0,0,0,0},
{"__rand__",_wrap_IplImage___rand__,0,0,0,0},
{"__rxor__",_wrap_IplImage___rxor__,0,0,0,0},
{"__req__",_wrap_IplImage___req__,0,0,0,0},
{"__rgt__",_wrap_IplImage___rgt__,0,0,0,0},
{"__rge__",_wrap_IplImage___rge__,0,0,0,0},
{"__rlt__",_wrap_IplImage___rlt__,0,0,0,0},
{"__rle__",_wrap_IplImage___rle__,0,0,0,0},
{"__rne__",_wrap_IplImage___rne__,0,0,0,0},
{"__pow__",_wrap_IplImage___pow__,0,0,0,0},
{"__str",_wrap_IplImage___str,0,0,0,0},
{"__paren_asgn",_wrap_IplImage___paren_asgn,0,0,0,0},
{"__paren",_wrap_IplImage___paren,0,0,0,0},
{0,0,0,0}
};
static const char *swig_IplImage_base_names[] = {0};
static const swig_type_info *swig_IplImage_base[] = {0};
static swig_octave_class _wrap_class_IplImage = {"IplImage", &SWIGTYPE_p__IplImage,0,0,0,_wrap_delete_IplImage,swig_IplImage_members,swig_IplImage_base_names,swig_IplImage_base };

static octave_value_list _wrap_IplROI_coi_set (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplROI_coi_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplROI_coi_set" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplROI_coi_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->coi = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplROI_coi_get (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplROI_coi_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplROI_coi_get" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  result = (int) ((arg1)->coi);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplROI_xOffset_set (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplROI_xOffset_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplROI_xOffset_set" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplROI_xOffset_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->xOffset = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplROI_xOffset_get (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplROI_xOffset_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplROI_xOffset_get" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  result = (int) ((arg1)->xOffset);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplROI_yOffset_set (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplROI_yOffset_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplROI_yOffset_set" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplROI_yOffset_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->yOffset = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplROI_yOffset_get (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplROI_yOffset_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplROI_yOffset_get" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  result = (int) ((arg1)->yOffset);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplROI_width_set (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplROI_width_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplROI_width_set" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplROI_width_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->width = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplROI_width_get (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplROI_width_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplROI_width_get" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  result = (int) ((arg1)->width);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplROI_height_set (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplROI_height_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplROI_height_set" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplROI_height_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->height = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplROI_height_get (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplROI_height_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplROI_height_get" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  result = (int) ((arg1)->height);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_IplROI (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplROI *result = 0 ;
  
  if (!SWIG_check_num_args("new_IplROI",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (IplROI *)new IplROI(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__IplROI, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_IplROI (const octave_value_list& args, int nargout) {
  IplROI *arg1 = (IplROI *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_IplROI",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplROI, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IplROI" "', argument " "1"" of type '" "IplROI *""'"); 
  }
  arg1 = (IplROI *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_IplROI_members[] = {
{"coi",0,_wrap_IplROI_coi_get,_wrap_IplROI_coi_set,0,0},
{"xOffset",0,_wrap_IplROI_xOffset_get,_wrap_IplROI_xOffset_set,0,0},
{"yOffset",0,_wrap_IplROI_yOffset_get,_wrap_IplROI_yOffset_set,0,0},
{"width",0,_wrap_IplROI_width_get,_wrap_IplROI_width_set,0,0},
{"height",0,_wrap_IplROI_height_get,_wrap_IplROI_height_set,0,0},
{0,0,0,0}
};
static const char *swig_IplROI_base_names[] = {0};
static const swig_type_info *swig_IplROI_base[] = {0};
static swig_octave_class _wrap_class_IplROI = {"IplROI", &SWIGTYPE_p__IplROI,0,_wrap_new_IplROI,0,_wrap_delete_IplROI,swig_IplROI_members,swig_IplROI_base_names,swig_IplROI_base };

static octave_value_list _wrap_IplConvKernel_nCols_set (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernel_nCols_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_nCols_set" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplConvKernel_nCols_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nCols = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_nCols_get (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplConvKernel_nCols_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_nCols_get" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  result = (int) ((arg1)->nCols);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_nRows_set (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernel_nRows_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_nRows_set" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplConvKernel_nRows_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nRows = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_nRows_get (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplConvKernel_nRows_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_nRows_get" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  result = (int) ((arg1)->nRows);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_anchorX_set (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernel_anchorX_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_anchorX_set" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplConvKernel_anchorX_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->anchorX = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_anchorX_get (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplConvKernel_anchorX_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_anchorX_get" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  result = (int) ((arg1)->anchorX);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_anchorY_set (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernel_anchorY_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_anchorY_set" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplConvKernel_anchorY_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->anchorY = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_anchorY_get (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplConvKernel_anchorY_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_anchorY_get" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  result = (int) ((arg1)->anchorY);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_values_set (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernel_values_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_values_set" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IplConvKernel_values_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->values = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_values_get (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("IplConvKernel_values_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_values_get" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  result = (int *) ((arg1)->values);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_nShiftR_set (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernel_nShiftR_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_nShiftR_set" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplConvKernel_nShiftR_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nShiftR = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernel_nShiftR_get (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplConvKernel_nShiftR_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernel_nShiftR_get" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  result = (int) ((arg1)->nShiftR);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_IplConvKernel (const octave_value_list& args, int nargout) {
  IplConvKernel *arg1 = (IplConvKernel *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_IplConvKernel",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernel, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IplConvKernel" "', argument " "1"" of type '" "IplConvKernel *""'"); 
  }
  arg1 = (IplConvKernel *)(argp1);
  {
    try {
      delete_IplConvKernel(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_IplConvKernel_members[] = {
{"nCols",0,_wrap_IplConvKernel_nCols_get,_wrap_IplConvKernel_nCols_set,0,0},
{"nRows",0,_wrap_IplConvKernel_nRows_get,_wrap_IplConvKernel_nRows_set,0,0},
{"anchorX",0,_wrap_IplConvKernel_anchorX_get,_wrap_IplConvKernel_anchorX_set,0,0},
{"anchorY",0,_wrap_IplConvKernel_anchorY_get,_wrap_IplConvKernel_anchorY_set,0,0},
{"values",0,_wrap_IplConvKernel_values_get,_wrap_IplConvKernel_values_set,0,0},
{"nShiftR",0,_wrap_IplConvKernel_nShiftR_get,_wrap_IplConvKernel_nShiftR_set,0,0},
{0,0,0,0}
};
static const char *swig_IplConvKernel_base_names[] = {0};
static const swig_type_info *swig_IplConvKernel_base[] = {0};
static swig_octave_class _wrap_class_IplConvKernel = {"IplConvKernel", &SWIGTYPE_p__IplConvKernel,0,0,0,_wrap_delete_IplConvKernel,swig_IplConvKernel_members,swig_IplConvKernel_base_names,swig_IplConvKernel_base };

static octave_value_list _wrap_IplConvKernelFP_nCols_set (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernelFP_nCols_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernelFP_nCols_set" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplConvKernelFP_nCols_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nCols = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernelFP_nCols_get (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplConvKernelFP_nCols_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernelFP_nCols_get" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  result = (int) ((arg1)->nCols);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernelFP_nRows_set (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernelFP_nRows_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernelFP_nRows_set" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplConvKernelFP_nRows_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nRows = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernelFP_nRows_get (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplConvKernelFP_nRows_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernelFP_nRows_get" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  result = (int) ((arg1)->nRows);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernelFP_anchorX_set (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernelFP_anchorX_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernelFP_anchorX_set" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplConvKernelFP_anchorX_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->anchorX = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernelFP_anchorX_get (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplConvKernelFP_anchorX_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernelFP_anchorX_get" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  result = (int) ((arg1)->anchorX);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernelFP_anchorY_set (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernelFP_anchorY_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernelFP_anchorY_set" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IplConvKernelFP_anchorY_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->anchorY = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernelFP_anchorY_get (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("IplConvKernelFP_anchorY_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernelFP_anchorY_get" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  result = (int) ((arg1)->anchorY);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernelFP_values_set (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("IplConvKernelFP_values_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernelFP_values_set" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IplConvKernelFP_values_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->values = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_IplConvKernelFP_values_get (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("IplConvKernelFP_values_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IplConvKernelFP_values_get" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  result = (float *) ((arg1)->values);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_IplConvKernelFP (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplConvKernelFP *result = 0 ;
  
  if (!SWIG_check_num_args("new_IplConvKernelFP",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (IplConvKernelFP *)new IplConvKernelFP(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__IplConvKernelFP, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_IplConvKernelFP (const octave_value_list& args, int nargout) {
  IplConvKernelFP *arg1 = (IplConvKernelFP *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_IplConvKernelFP",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__IplConvKernelFP, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IplConvKernelFP" "', argument " "1"" of type '" "IplConvKernelFP *""'"); 
  }
  arg1 = (IplConvKernelFP *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_IplConvKernelFP_members[] = {
{"nCols",0,_wrap_IplConvKernelFP_nCols_get,_wrap_IplConvKernelFP_nCols_set,0,0},
{"nRows",0,_wrap_IplConvKernelFP_nRows_get,_wrap_IplConvKernelFP_nRows_set,0,0},
{"anchorX",0,_wrap_IplConvKernelFP_anchorX_get,_wrap_IplConvKernelFP_anchorX_set,0,0},
{"anchorY",0,_wrap_IplConvKernelFP_anchorY_get,_wrap_IplConvKernelFP_anchorY_set,0,0},
{"values",0,_wrap_IplConvKernelFP_values_get,_wrap_IplConvKernelFP_values_set,0,0},
{0,0,0,0}
};
static const char *swig_IplConvKernelFP_base_names[] = {0};
static const swig_type_info *swig_IplConvKernelFP_base[] = {0};
static swig_octave_class _wrap_class_IplConvKernelFP = {"IplConvKernelFP", &SWIGTYPE_p__IplConvKernelFP,0,_wrap_new_IplConvKernelFP,0,_wrap_delete_IplConvKernelFP,swig_IplConvKernelFP_members,swig_IplConvKernelFP_base_names,swig_IplConvKernelFP_base };

static octave_value_list _wrap_CvMat_type_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_type_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_type_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_type_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->type = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_type_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_type_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_type_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int) ((arg1)->type);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_step_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_step_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_step_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_step_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->step = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_step_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_step_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_step_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int) ((arg1)->step);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_refcount_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_refcount_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_refcount_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMat_refcount_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->refcount = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_refcount_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat_refcount_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_refcount_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int *) ((arg1)->refcount);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_hdr_refcount_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_hdr_refcount_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_hdr_refcount_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_hdr_refcount_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->hdr_refcount = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_hdr_refcount_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_hdr_refcount_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_hdr_refcount_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (int) ((arg1)->hdr_refcount);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_data_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat_data *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat_data_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  result = (CvMat_data *)& ((arg1)->data);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMat (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMat",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMat" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      delete_CvMat(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_depth_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_depth_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_depth_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_depth_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      CvMat_depth_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_depth_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_depth_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_depth_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (int)CvMat_depth_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_nChannels_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_nChannels_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_nChannels_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_nChannels_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      CvMat_nChannels_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_nChannels_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_nChannels_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_nChannels_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (int)CvMat_nChannels_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_dataOrder_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_dataOrder_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_dataOrder_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_dataOrder_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      CvMat_dataOrder_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_dataOrder_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_dataOrder_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_dataOrder_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (int)CvMat_dataOrder_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_origin_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_origin_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_origin_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_origin_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      CvMat_origin_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_origin_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_origin_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_origin_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (int)CvMat_origin_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_width_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_width_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_width_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_width_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      CvMat_width_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_width_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_width_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_width_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (int)CvMat_width_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_height_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_height_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_height_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_height_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      CvMat_height_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_height_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_height_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_height_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (int)CvMat_height_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_imageSize_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_imageSize_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_imageSize_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_imageSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      CvMat_imageSize_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_imageSize_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_imageSize_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_imageSize_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (int)CvMat_imageSize_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_widthStep_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_widthStep_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_widthStep_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_widthStep_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      CvMat_widthStep_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_widthStep_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_widthStep_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_widthStep_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (int)CvMat_widthStep_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_rows_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_rows_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_rows_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_rows_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      CvMat_rows_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_rows_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_rows_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_rows_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (int)CvMat_rows_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_cols_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_cols_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_cols_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat_cols_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      CvMat_cols_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_cols_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMat_cols_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_cols_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (int)CvMat_cols_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___add____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___add__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___add__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Sa___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___mul____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___mul__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___mul__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Sm___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___sub____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___sub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___sub__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Ss___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___div____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___div__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___div__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Sd___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___xor____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___xor__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___xor__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Sx___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___add____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvScalar arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___add__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___add__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Sa___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___add__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___add____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvMat___add____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___xor____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvScalar arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___xor__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___xor__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Sx___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___xor__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___xor____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvMat___xor____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___sub____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvScalar arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___sub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___sub__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Ss___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___sub__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___sub____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvMat___sub____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___ge____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___ge__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___ge__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Sg__Se___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___ge____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___ge__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___ge__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___ge__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat_operator_Sg__Se___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___ge__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___ge____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___ge____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___eq____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___eq__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___eq__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Se__Se___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___eq____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___eq__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___eq__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___eq__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat_operator_Se__Se___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___eq__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___eq____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___eq____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___le____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___le__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___le__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Sl__Se___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___le____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___le__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___le__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___le__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat_operator_Sl__Se___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___le__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___le____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___le____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___ne____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___ne__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___ne__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_SN__Se___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___ne____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___ne__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___ne__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___ne__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat_operator_SN__Se___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___ne__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___ne____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___ne____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___lt____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___lt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___lt__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Sl___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___lt____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___lt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___lt__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___lt__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat_operator_Sl___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___lt__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___lt____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___lt____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___gt____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___gt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___gt__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat_operator_Sg___SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___gt____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___gt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___gt__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___gt__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat_operator_Sg___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___gt__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___gt____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___gt____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___mul____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___mul__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___mul__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___mul__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat_operator_Sm___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___mul__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___mul____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___mul____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___div____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___div__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___div__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___div__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat_operator_Sd___SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___div__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___div____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___div____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___radd____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___radd__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___radd__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat___radd____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rsub____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rsub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rsub__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat___rsub____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rdiv____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rdiv__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rdiv__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat___rdiv____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rmul____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rmul__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rmul__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (CvMat *)CvMat___rmul____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___radd____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvScalar arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___radd__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___radd__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (CvMat *)CvMat___radd____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___radd____SWIG_2 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___radd__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___radd__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___radd__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat___radd____SWIG_2(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___radd__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___radd____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvMat___radd____SWIG_1(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___radd____SWIG_2(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___rsub____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvScalar arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rsub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rsub__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (CvMat *)CvMat___rsub____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rsub____SWIG_2 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rsub__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rsub__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___rsub__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat___rsub____SWIG_2(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rsub__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___rsub____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvMat___rsub____SWIG_1(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___rsub____SWIG_2(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___rmul____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rmul__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rmul__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___rmul__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)CvMat___rmul____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rmul__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___rmul____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___rmul____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___rdiv____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rdiv__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rdiv__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___rdiv__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)CvMat___rdiv____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rdiv__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        void *ptr;
        if(OctList_Check(argv[1]) || OctTuple_Check(argv[1])) {
          _v = 1;
        }
        else if (SWIG_ConvertPtr(argv[1], &ptr, 0, 0) == -1) {
          _v = 0;
        }
        else{
          _v = 1;
        }
      }
      if (_v) {
        return _wrap_CvMat___rdiv____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___rdiv____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___ror____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvScalar arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___ror__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___ror__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (CvMat *)CvMat___ror____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___ror____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___ror__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___ror__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___ror__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat___ror____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___ror__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvMat___ror____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___ror____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___rand____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvScalar arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rand__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rand__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (CvMat *)CvMat___rand____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rand____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rand__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rand__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___rand__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat___rand____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rand__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvMat___rand____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___rand____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___rxor____SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvScalar arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rxor__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rxor__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    try {
      result = (CvMat *)CvMat___rxor____SWIG_0(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rxor____SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rxor__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rxor__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___rxor__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat___rxor____SWIG_1(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rxor__ (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvScalar, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvMat___rxor____SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMat___rxor____SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___req__ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___req__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___req__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___req__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)CvMat___req__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rgt__ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rgt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rgt__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___rgt__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)CvMat___rgt__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rge__ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rge__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rge__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___rge__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)CvMat___rge__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rlt__ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rlt__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rlt__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___rlt__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)CvMat___rlt__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rle__ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rle__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rle__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___rle__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)CvMat___rle__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___rne__ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___rne__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___rne__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___rne__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvArr *)CvMat___rne__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___pow__ (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___pow__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___pow__" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMat___pow__" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = (CvMat *)CvMat___pow__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___str (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat___str",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___str" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (char *)CvMat___str(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___paren_asgn__SWIG_0 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  octave_value arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___paren_asgn" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  arg2 = args(1);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CvMat___paren_asgn" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      CvMat___paren_asgn__SWIG_0(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___paren_asgn__SWIG_1 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  octave_value arg2 ;
  CvPoint arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___paren_asgn" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  arg2 = args(1);
  {
    arg3 = OctObject_to_CvPoint(args(2));
  }
  {
    try {
      CvMat___paren_asgn__SWIG_1(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___paren_asgn__SWIG_2 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  octave_value arg2 ;
  CvPoint2D32f arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___paren_asgn" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  arg2 = args(1);
  {
    arg3 = OctObject_to_CvPoint2D32f(args(2));
  }
  {
    try {
      CvMat___paren_asgn__SWIG_2(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___paren_asgn__SWIG_3 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  octave_value arg2 ;
  CvScalar arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___paren_asgn" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  arg2 = args(1);
  {
    arg3 = OctObject_to_CvScalar( args(2) );
  }
  {
    try {
      CvMat___paren_asgn__SWIG_3(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___paren_asgn__SWIG_4 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  octave_value arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___paren_asgn" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  arg2 = args(1);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      CvMat___paren_asgn__SWIG_4(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMat___paren_asgn (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (*argv[1]).is_defined();
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvPoint, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_CvMat___paren_asgn__SWIG_1(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (*argv[1]).is_defined();
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvPoint2D32f, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_CvMat___paren_asgn__SWIG_2(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (*argv[1]).is_defined();
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_CvScalar, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_CvMat___paren_asgn__SWIG_3(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (*argv[1]).is_defined();
      if (_v) {
        {
          void *ptr;
          if(OctList_Check(argv[2]) || OctTuple_Check(argv[2])) {
            _v = 1;
          }
          else if (SWIG_ConvertPtr(argv[2], &ptr, 0, 0) == -1) {
            _v = 0;
          }
          else{
            _v = 1;
          }
        }
        if (_v) {
          return _wrap_CvMat___paren_asgn__SWIG_4(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = (*argv[1]).is_defined();
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_CvMat___paren_asgn__SWIG_0(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMat___paren (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  octave_value arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  octave_value result;
  
  if (!SWIG_check_num_args("CvMat___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat___paren" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  arg2 = args(1);
  {
    try {
      result = CvMat___paren(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = result;
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_imageData_set (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  octave_value arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_imageData_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_imageData_set" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  arg2 = args(1);
  {
    try {
      CvMat_imageData_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_imageData_get (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  octave_value result;
  
  if (!SWIG_check_num_args("CvMat_imageData_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_imageData_get" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = CvMat_imageData_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = result;
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMat_members[] = {
{"type",0,_wrap_CvMat_type_get,_wrap_CvMat_type_set,0,0},
{"step",0,_wrap_CvMat_step_get,_wrap_CvMat_step_set,0,0},
{"refcount",0,_wrap_CvMat_refcount_get,_wrap_CvMat_refcount_set,0,0},
{"hdr_refcount",0,_wrap_CvMat_hdr_refcount_get,_wrap_CvMat_hdr_refcount_set,0,0},
{"data",0,_wrap_CvMat_data_get,octave_set_immutable,0,0},
{"depth",0,_wrap_CvMat_depth_get,_wrap_CvMat_depth_set,0,0},
{"nChannels",0,_wrap_CvMat_nChannels_get,_wrap_CvMat_nChannels_set,0,0},
{"dataOrder",0,_wrap_CvMat_dataOrder_get,_wrap_CvMat_dataOrder_set,0,0},
{"origin",0,_wrap_CvMat_origin_get,_wrap_CvMat_origin_set,0,0},
{"width",0,_wrap_CvMat_width_get,_wrap_CvMat_width_set,0,0},
{"height",0,_wrap_CvMat_height_get,_wrap_CvMat_height_set,0,0},
{"imageSize",0,_wrap_CvMat_imageSize_get,_wrap_CvMat_imageSize_set,0,0},
{"widthStep",0,_wrap_CvMat_widthStep_get,_wrap_CvMat_widthStep_set,0,0},
{"rows",0,_wrap_CvMat_rows_get,_wrap_CvMat_rows_set,0,0},
{"cols",0,_wrap_CvMat_cols_get,_wrap_CvMat_cols_set,0,0},
{"__add__",_wrap_CvMat___add__,0,0,0,0},
{"__xor__",_wrap_CvMat___xor__,0,0,0,0},
{"__sub__",_wrap_CvMat___sub__,0,0,0,0},
{"__ge__",_wrap_CvMat___ge__,0,0,0,0},
{"__eq__",_wrap_CvMat___eq__,0,0,0,0},
{"__le__",_wrap_CvMat___le__,0,0,0,0},
{"__ne__",_wrap_CvMat___ne__,0,0,0,0},
{"__lt__",_wrap_CvMat___lt__,0,0,0,0},
{"__gt__",_wrap_CvMat___gt__,0,0,0,0},
{"__mul__",_wrap_CvMat___mul__,0,0,0,0},
{"__div__",_wrap_CvMat___div__,0,0,0,0},
{"__radd__",_wrap_CvMat___radd__,0,0,0,0},
{"__rsub__",_wrap_CvMat___rsub__,0,0,0,0},
{"__rmul__",_wrap_CvMat___rmul__,0,0,0,0},
{"__rdiv__",_wrap_CvMat___rdiv__,0,0,0,0},
{"__ror__",_wrap_CvMat___ror__,0,0,0,0},
{"__rand__",_wrap_CvMat___rand__,0,0,0,0},
{"__rxor__",_wrap_CvMat___rxor__,0,0,0,0},
{"__req__",_wrap_CvMat___req__,0,0,0,0},
{"__rgt__",_wrap_CvMat___rgt__,0,0,0,0},
{"__rge__",_wrap_CvMat___rge__,0,0,0,0},
{"__rlt__",_wrap_CvMat___rlt__,0,0,0,0},
{"__rle__",_wrap_CvMat___rle__,0,0,0,0},
{"__rne__",_wrap_CvMat___rne__,0,0,0,0},
{"__pow__",_wrap_CvMat___pow__,0,0,0,0},
{"__str",_wrap_CvMat___str,0,0,0,0},
{"__paren_asgn",_wrap_CvMat___paren_asgn,0,0,0,0},
{"__paren",_wrap_CvMat___paren,0,0,0,0},
{"imageData",0,_wrap_CvMat_imageData_get,_wrap_CvMat_imageData_set,0,0},
{0,0,0,0}
};
static const char *swig_CvMat_base_names[] = {0};
static const swig_type_info *swig_CvMat_base[] = {0};
static swig_octave_class _wrap_class_CvMat = {"CvMat", &SWIGTYPE_p_CvMat,0,0,0,_wrap_delete_CvMat,swig_CvMat_members,swig_CvMat_base_names,swig_CvMat_base };

static octave_value_list _wrap_CvMat_data_ptr_set (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  uchar *arg2 = (uchar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_data_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_ptr_set" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_unsigned_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMat_data_ptr_set" "', argument " "2"" of type '" "uchar *""'"); 
  }
  arg2 = (uchar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_data_ptr_get (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat_data_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_ptr_get" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  result = (uchar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_data_s_set (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  short *arg2 = (short *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_data_s_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_s_set" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_short, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMat_data_s_set" "', argument " "2"" of type '" "short *""'"); 
  }
  arg2 = (short *)(argp2);
  if (arg1) (arg1)->s = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_data_s_get (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  short *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat_data_s_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_s_get" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  result = (short *) ((arg1)->s);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_short, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_data_i_set (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_data_i_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_i_set" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMat_data_i_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->i = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_data_i_get (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat_data_i_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_i_get" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  result = (int *) ((arg1)->i);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_data_fl_set (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_data_fl_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_fl_set" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMat_data_fl_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->fl = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_data_fl_get (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat_data_fl_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_fl_get" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  result = (float *) ((arg1)->fl);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_data_db_set (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMat_data_db_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_db_set" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMat_data_db_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->db = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMat_data_db_get (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double *result = 0 ;
  
  if (!SWIG_check_num_args("CvMat_data_db_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMat_data_db_get" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  result = (double *) ((arg1)->db);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMat_data (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat_data *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMat_data",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvMat_data *)new CvMat_data(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat_data, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMat_data (const octave_value_list& args, int nargout) {
  CvMat_data *arg1 = (CvMat_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMat_data",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat_data, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMat_data" "', argument " "1"" of type '" "CvMat_data *""'"); 
  }
  arg1 = (CvMat_data *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMat_data_members[] = {
{"ptr",0,_wrap_CvMat_data_ptr_get,_wrap_CvMat_data_ptr_set,0,0},
{"s",0,_wrap_CvMat_data_s_get,_wrap_CvMat_data_s_set,0,0},
{"i",0,_wrap_CvMat_data_i_get,_wrap_CvMat_data_i_set,0,0},
{"fl",0,_wrap_CvMat_data_fl_get,_wrap_CvMat_data_fl_set,0,0},
{"db",0,_wrap_CvMat_data_db_get,_wrap_CvMat_data_db_set,0,0},
{0,0,0,0}
};
static const char *swig_CvMat_data_base_names[] = {0};
static const swig_type_info *swig_CvMat_data_base[] = {0};
static swig_octave_class _wrap_class_CvMat_data = {"CvMat_data", &SWIGTYPE_p_CvMat_data,0,_wrap_new_CvMat_data,0,_wrap_delete_CvMat_data,swig_CvMat_data_members,swig_CvMat_data_base_names,swig_CvMat_data_base };

static octave_value_list _wrap_cvMat__SWIG_0 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  void *arg4 = (void *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat result;
  
  if (!SWIG_check_num_args("cvMat",args.length(),4,4,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvMat" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvMat" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvMat" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3),SWIG_as_voidptrptr(&arg4), 0, 0);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvMat" "', argument " "4"" of type '" "void *""'"); 
  }
  {
    try {
      result = cvMat(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvMat((const CvMat&)(result))), SWIGTYPE_p_CvMat, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvMat__SWIG_1 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat result;
  
  if (!SWIG_check_num_args("cvMat",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvMat" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvMat" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvMat" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = cvMat(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvMat((const CvMat&)(result))), SWIGTYPE_p_CvMat, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvMat (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[4]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3)
  };
  
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_cvMat__SWIG_1(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *ptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &ptr, 0, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_cvMat__SWIG_0(args, nargout);
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_cvmGet (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvmGet",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvmGet" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvmGet" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvmGet" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (double)cvmGet((CvMat const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvmSet (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvmSet",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvmSet" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvmSet" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvmSet" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvmSet" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    try {
      cvmSet(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvIplDepth (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvIplDepth",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvIplDepth" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    try {
      result = (int)cvIplDepth(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_type_set (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_type_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_type_set" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMatND_type_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->type = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_type_get (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatND_type_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_type_get" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  result = (int) ((arg1)->type);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_dims_set (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_dims_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_dims_set" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMatND_dims_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->dims = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_dims_get (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatND_dims_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_dims_get" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  result = (int) ((arg1)->dims);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_refcount_set (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_refcount_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_refcount_set" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatND_refcount_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->refcount = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_refcount_get (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatND_refcount_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_refcount_get" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  result = (int *) ((arg1)->refcount);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_hdr_refcount_set (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_hdr_refcount_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_hdr_refcount_set" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMatND_hdr_refcount_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->hdr_refcount = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_hdr_refcount_get (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatND_hdr_refcount_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_hdr_refcount_get" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  result = (int) ((arg1)->hdr_refcount);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_dim_get (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatND_dim *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatND_dim_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_dim_get" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  result = (CvMatND_dim *)(CvMatND_dim *) ((arg1)->dim);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatND_dim, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_data_get (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatND_data *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatND_data_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_get" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  result = (CvMatND_data *)& ((arg1)->data);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMatND (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMatND",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMatND" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  {
    try {
      delete_CvMatND(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMatND_members[] = {
{"type",0,_wrap_CvMatND_type_get,_wrap_CvMatND_type_set,0,0},
{"dims",0,_wrap_CvMatND_dims_get,_wrap_CvMatND_dims_set,0,0},
{"refcount",0,_wrap_CvMatND_refcount_get,_wrap_CvMatND_refcount_set,0,0},
{"hdr_refcount",0,_wrap_CvMatND_hdr_refcount_get,_wrap_CvMatND_hdr_refcount_set,0,0},
{"dim",0,_wrap_CvMatND_dim_get,octave_set_immutable,0,0},
{"data",0,_wrap_CvMatND_data_get,octave_set_immutable,0,0},
{0,0,0,0}
};
static const char *swig_CvMatND_base_names[] = {0};
static const swig_type_info *swig_CvMatND_base[] = {0};
static swig_octave_class _wrap_class_CvMatND = {"CvMatND", &SWIGTYPE_p_CvMatND,0,0,0,_wrap_delete_CvMatND,swig_CvMatND_members,swig_CvMatND_base_names,swig_CvMatND_base };

static octave_value_list _wrap_CvMatND_dim_size_set (const octave_value_list& args, int nargout) {
  CvMatND_dim *arg1 = (CvMatND_dim *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_dim_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_dim, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_dim_size_set" "', argument " "1"" of type '" "CvMatND_dim *""'"); 
  }
  arg1 = (CvMatND_dim *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMatND_dim_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_dim_size_get (const octave_value_list& args, int nargout) {
  CvMatND_dim *arg1 = (CvMatND_dim *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatND_dim_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_dim, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_dim_size_get" "', argument " "1"" of type '" "CvMatND_dim *""'"); 
  }
  arg1 = (CvMatND_dim *)(argp1);
  result = (int) ((arg1)->size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_dim_step_set (const octave_value_list& args, int nargout) {
  CvMatND_dim *arg1 = (CvMatND_dim *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_dim_step_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_dim, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_dim_step_set" "', argument " "1"" of type '" "CvMatND_dim *""'"); 
  }
  arg1 = (CvMatND_dim *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMatND_dim_step_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->step = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_dim_step_get (const octave_value_list& args, int nargout) {
  CvMatND_dim *arg1 = (CvMatND_dim *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatND_dim_step_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_dim, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_dim_step_get" "', argument " "1"" of type '" "CvMatND_dim *""'"); 
  }
  arg1 = (CvMatND_dim *)(argp1);
  result = (int) ((arg1)->step);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatND_dim (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatND_dim *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatND_dim",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvMatND_dim *)new CvMatND_dim(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatND_dim, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMatND_dim (const octave_value_list& args, int nargout) {
  CvMatND_dim *arg1 = (CvMatND_dim *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMatND_dim",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_dim, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMatND_dim" "', argument " "1"" of type '" "CvMatND_dim *""'"); 
  }
  arg1 = (CvMatND_dim *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMatND_dim_members[] = {
{"size",0,_wrap_CvMatND_dim_size_get,_wrap_CvMatND_dim_size_set,0,0},
{"step",0,_wrap_CvMatND_dim_step_get,_wrap_CvMatND_dim_step_set,0,0},
{0,0,0,0}
};
static const char *swig_CvMatND_dim_base_names[] = {0};
static const swig_type_info *swig_CvMatND_dim_base[] = {0};
static swig_octave_class _wrap_class_CvMatND_dim = {"CvMatND_dim", &SWIGTYPE_p_CvMatND_dim,0,_wrap_new_CvMatND_dim,0,_wrap_delete_CvMatND_dim,swig_CvMatND_dim_members,swig_CvMatND_dim_base_names,swig_CvMatND_dim_base };

static octave_value_list _wrap_CvMatND_data_ptr_set (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  uchar *arg2 = (uchar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_data_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_ptr_set" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_unsigned_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatND_data_ptr_set" "', argument " "2"" of type '" "uchar *""'"); 
  }
  arg2 = (uchar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_data_ptr_get (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatND_data_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_ptr_get" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  result = (uchar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_data_fl_set (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_data_fl_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_fl_set" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatND_data_fl_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->fl = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_data_fl_get (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatND_data_fl_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_fl_get" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  result = (float *) ((arg1)->fl);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_data_db_set (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  double *arg2 = (double *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_data_db_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_db_set" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatND_data_db_set" "', argument " "2"" of type '" "double *""'"); 
  }
  arg2 = (double *)(argp2);
  if (arg1) (arg1)->db = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_data_db_get (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatND_data_db_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_db_get" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  result = (double *) ((arg1)->db);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_data_i_set (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_data_i_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_i_set" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatND_data_i_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->i = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_data_i_get (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatND_data_i_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_i_get" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  result = (int *) ((arg1)->i);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_data_s_set (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  short *arg2 = (short *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatND_data_s_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_s_set" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_short, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatND_data_s_set" "', argument " "2"" of type '" "short *""'"); 
  }
  arg2 = (short *)(argp2);
  if (arg1) (arg1)->s = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatND_data_s_get (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  short *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatND_data_s_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatND_data_s_get" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  result = (short *) ((arg1)->s);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_short, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatND_data (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatND_data *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatND_data",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvMatND_data *)new CvMatND_data(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatND_data, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMatND_data (const octave_value_list& args, int nargout) {
  CvMatND_data *arg1 = (CvMatND_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMatND_data",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND_data, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMatND_data" "', argument " "1"" of type '" "CvMatND_data *""'"); 
  }
  arg1 = (CvMatND_data *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMatND_data_members[] = {
{"ptr",0,_wrap_CvMatND_data_ptr_get,_wrap_CvMatND_data_ptr_set,0,0},
{"fl",0,_wrap_CvMatND_data_fl_get,_wrap_CvMatND_data_fl_set,0,0},
{"db",0,_wrap_CvMatND_data_db_get,_wrap_CvMatND_data_db_set,0,0},
{"i",0,_wrap_CvMatND_data_i_get,_wrap_CvMatND_data_i_set,0,0},
{"s",0,_wrap_CvMatND_data_s_get,_wrap_CvMatND_data_s_set,0,0},
{0,0,0,0}
};
static const char *swig_CvMatND_data_base_names[] = {0};
static const swig_type_info *swig_CvMatND_data_base[] = {0};
static swig_octave_class _wrap_class_CvMatND_data = {"CvMatND_data", &SWIGTYPE_p_CvMatND_data,0,_wrap_new_CvMatND_data,0,_wrap_delete_CvMatND_data,swig_CvMatND_data_members,swig_CvMatND_data_base_names,swig_CvMatND_data_base };

static octave_value_list _wrap_CvSparseMat_type_set (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMat_type_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_type_set" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSparseMat_type_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->type = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_type_get (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSparseMat_type_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_type_get" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  result = (int) ((arg1)->type);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_dims_set (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMat_dims_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_dims_set" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSparseMat_dims_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->dims = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_dims_get (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSparseMat_dims_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_dims_get" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  result = (int) ((arg1)->dims);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_refcount_set (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMat_refcount_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_refcount_set" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSparseMat_refcount_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->refcount = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_refcount_get (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvSparseMat_refcount_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_refcount_get" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  result = (int *) ((arg1)->refcount);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_hdr_refcount_set (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMat_hdr_refcount_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_hdr_refcount_set" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSparseMat_hdr_refcount_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->hdr_refcount = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_hdr_refcount_get (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSparseMat_hdr_refcount_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_hdr_refcount_get" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  result = (int) ((arg1)->hdr_refcount);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_heap_set (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  CvSet *arg2 = (CvSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMat_heap_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_heap_set" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg2 = (CvSet *)ptr2;
  }
  if (arg1) (arg1)->heap = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_heap_get (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSet *result = 0 ;
  
  if (!SWIG_check_num_args("CvSparseMat_heap_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_heap_get" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  result = (CvSet *) ((arg1)->heap);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSet, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_hashtable_set (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void **arg2 = (void **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *vptr2 ;
  void *buffer2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMat_hashtable_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_hashtable_set" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_void, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (void *) vptr2;
    arg2=&buffer2;
  }
  if (arg1) (arg1)->hashtable = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_hashtable_get (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void **result = 0 ;
  
  if (!SWIG_check_num_args("CvSparseMat_hashtable_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_hashtable_get" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  result = (void **) ((arg1)->hashtable);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_hashsize_set (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMat_hashsize_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_hashsize_set" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSparseMat_hashsize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->hashsize = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_hashsize_get (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSparseMat_hashsize_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_hashsize_get" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  result = (int) ((arg1)->hashsize);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_valoffset_set (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMat_valoffset_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_valoffset_set" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSparseMat_valoffset_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->valoffset = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_valoffset_get (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSparseMat_valoffset_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_valoffset_get" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  result = (int) ((arg1)->valoffset);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_idxoffset_set (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMat_idxoffset_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_idxoffset_set" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSparseMat_idxoffset_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->idxoffset = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_idxoffset_get (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSparseMat_idxoffset_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_idxoffset_get" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  result = (int) ((arg1)->idxoffset);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_size_set (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  int *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMat_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_size_set" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSparseMat_size_set" "', argument " "2"" of type '" "int [32]""'"); 
  } 
  arg2 = (int *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)32; ++ii) arg1->size[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""size""' of type '""int [32]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMat_size_get (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvSparseMat_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMat_size_get" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  result = (int *)(int *) ((arg1)->size);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSparseMat (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSparseMat",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSparseMat" "', argument " "1"" of type '" "CvSparseMat *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  {
    try {
      delete_CvSparseMat(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSparseMat_members[] = {
{"type",0,_wrap_CvSparseMat_type_get,_wrap_CvSparseMat_type_set,0,0},
{"dims",0,_wrap_CvSparseMat_dims_get,_wrap_CvSparseMat_dims_set,0,0},
{"refcount",0,_wrap_CvSparseMat_refcount_get,_wrap_CvSparseMat_refcount_set,0,0},
{"hdr_refcount",0,_wrap_CvSparseMat_hdr_refcount_get,_wrap_CvSparseMat_hdr_refcount_set,0,0},
{"heap",0,_wrap_CvSparseMat_heap_get,_wrap_CvSparseMat_heap_set,0,0},
{"hashtable",0,_wrap_CvSparseMat_hashtable_get,_wrap_CvSparseMat_hashtable_set,0,0},
{"hashsize",0,_wrap_CvSparseMat_hashsize_get,_wrap_CvSparseMat_hashsize_set,0,0},
{"valoffset",0,_wrap_CvSparseMat_valoffset_get,_wrap_CvSparseMat_valoffset_set,0,0},
{"idxoffset",0,_wrap_CvSparseMat_idxoffset_get,_wrap_CvSparseMat_idxoffset_set,0,0},
{"size",0,_wrap_CvSparseMat_size_get,_wrap_CvSparseMat_size_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSparseMat_base_names[] = {0};
static const swig_type_info *swig_CvSparseMat_base[] = {0};
static swig_octave_class _wrap_class_CvSparseMat = {"CvSparseMat", &SWIGTYPE_p_CvSparseMat,0,0,0,_wrap_delete_CvSparseMat,swig_CvSparseMat_members,swig_CvSparseMat_base_names,swig_CvSparseMat_base };

static octave_value_list _wrap_CvSparseNode_hashval_set (const octave_value_list& args, int nargout) {
  CvSparseNode *arg1 = (CvSparseNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseNode_hashval_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseNode_hashval_set" "', argument " "1"" of type '" "CvSparseNode *""'"); 
  }
  arg1 = (CvSparseNode *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSparseNode_hashval_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->hashval = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseNode_hashval_get (const octave_value_list& args, int nargout) {
  CvSparseNode *arg1 = (CvSparseNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  unsigned int result;
  
  if (!SWIG_check_num_args("CvSparseNode_hashval_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseNode_hashval_get" "', argument " "1"" of type '" "CvSparseNode *""'"); 
  }
  arg1 = (CvSparseNode *)(argp1);
  result = (unsigned int) ((arg1)->hashval);
  _outv = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseNode_next_set (const octave_value_list& args, int nargout) {
  CvSparseNode *arg1 = (CvSparseNode *) 0 ;
  CvSparseNode *arg2 = (CvSparseNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseNode_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseNode_next_set" "', argument " "1"" of type '" "CvSparseNode *""'"); 
  }
  arg1 = (CvSparseNode *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSparseNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSparseNode_next_set" "', argument " "2"" of type '" "CvSparseNode *""'"); 
  }
  arg2 = (CvSparseNode *)(argp2);
  if (arg1) (arg1)->next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseNode_next_get (const octave_value_list& args, int nargout) {
  CvSparseNode *arg1 = (CvSparseNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSparseNode *result = 0 ;
  
  if (!SWIG_check_num_args("CvSparseNode_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseNode_next_get" "', argument " "1"" of type '" "CvSparseNode *""'"); 
  }
  arg1 = (CvSparseNode *)(argp1);
  result = (CvSparseNode *) ((arg1)->next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSparseNode, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSparseNode (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSparseNode *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSparseNode",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSparseNode *)new CvSparseNode(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSparseNode, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSparseNode (const octave_value_list& args, int nargout) {
  CvSparseNode *arg1 = (CvSparseNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSparseNode",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSparseNode" "', argument " "1"" of type '" "CvSparseNode *""'"); 
  }
  arg1 = (CvSparseNode *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSparseNode_members[] = {
{"hashval",0,_wrap_CvSparseNode_hashval_get,_wrap_CvSparseNode_hashval_set,0,0},
{"next",0,_wrap_CvSparseNode_next_get,_wrap_CvSparseNode_next_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSparseNode_base_names[] = {0};
static const swig_type_info *swig_CvSparseNode_base[] = {0};
static swig_octave_class _wrap_class_CvSparseNode = {"CvSparseNode", &SWIGTYPE_p_CvSparseNode,0,_wrap_new_CvSparseNode,0,_wrap_delete_CvSparseNode,swig_CvSparseNode_members,swig_CvSparseNode_base_names,swig_CvSparseNode_base };

static octave_value_list _wrap_CvSparseMatIterator_mat_set (const octave_value_list& args, int nargout) {
  CvSparseMatIterator *arg1 = (CvSparseMatIterator *) 0 ;
  CvSparseMat *arg2 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMatIterator_mat_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMatIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMatIterator_mat_set" "', argument " "1"" of type '" "CvSparseMatIterator *""'"); 
  }
  arg1 = (CvSparseMatIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSparseMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSparseMatIterator_mat_set" "', argument " "2"" of type '" "CvSparseMat *""'"); 
  }
  arg2 = (CvSparseMat *)(argp2);
  if (arg1) (arg1)->mat = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMatIterator_mat_get (const octave_value_list& args, int nargout) {
  CvSparseMatIterator *arg1 = (CvSparseMatIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSparseMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvSparseMatIterator_mat_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMatIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMatIterator_mat_get" "', argument " "1"" of type '" "CvSparseMatIterator *""'"); 
  }
  arg1 = (CvSparseMatIterator *)(argp1);
  result = (CvSparseMat *) ((arg1)->mat);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMatIterator_node_set (const octave_value_list& args, int nargout) {
  CvSparseMatIterator *arg1 = (CvSparseMatIterator *) 0 ;
  CvSparseNode *arg2 = (CvSparseNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMatIterator_node_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMatIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMatIterator_node_set" "', argument " "1"" of type '" "CvSparseMatIterator *""'"); 
  }
  arg1 = (CvSparseMatIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSparseNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSparseMatIterator_node_set" "', argument " "2"" of type '" "CvSparseNode *""'"); 
  }
  arg2 = (CvSparseNode *)(argp2);
  if (arg1) (arg1)->node = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMatIterator_node_get (const octave_value_list& args, int nargout) {
  CvSparseMatIterator *arg1 = (CvSparseMatIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSparseNode *result = 0 ;
  
  if (!SWIG_check_num_args("CvSparseMatIterator_node_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMatIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMatIterator_node_get" "', argument " "1"" of type '" "CvSparseMatIterator *""'"); 
  }
  arg1 = (CvSparseMatIterator *)(argp1);
  result = (CvSparseNode *) ((arg1)->node);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSparseNode, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMatIterator_curidx_set (const octave_value_list& args, int nargout) {
  CvSparseMatIterator *arg1 = (CvSparseMatIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSparseMatIterator_curidx_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMatIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMatIterator_curidx_set" "', argument " "1"" of type '" "CvSparseMatIterator *""'"); 
  }
  arg1 = (CvSparseMatIterator *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSparseMatIterator_curidx_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->curidx = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSparseMatIterator_curidx_get (const octave_value_list& args, int nargout) {
  CvSparseMatIterator *arg1 = (CvSparseMatIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSparseMatIterator_curidx_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMatIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSparseMatIterator_curidx_get" "', argument " "1"" of type '" "CvSparseMatIterator *""'"); 
  }
  arg1 = (CvSparseMatIterator *)(argp1);
  result = (int) ((arg1)->curidx);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSparseMatIterator (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSparseMatIterator *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSparseMatIterator",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSparseMatIterator *)new CvSparseMatIterator(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSparseMatIterator, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSparseMatIterator (const octave_value_list& args, int nargout) {
  CvSparseMatIterator *arg1 = (CvSparseMatIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSparseMatIterator",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMatIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSparseMatIterator" "', argument " "1"" of type '" "CvSparseMatIterator *""'"); 
  }
  arg1 = (CvSparseMatIterator *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSparseMatIterator_members[] = {
{"mat",0,_wrap_CvSparseMatIterator_mat_get,_wrap_CvSparseMatIterator_mat_set,0,0},
{"node",0,_wrap_CvSparseMatIterator_node_get,_wrap_CvSparseMatIterator_node_set,0,0},
{"curidx",0,_wrap_CvSparseMatIterator_curidx_get,_wrap_CvSparseMatIterator_curidx_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSparseMatIterator_base_names[] = {0};
static const swig_type_info *swig_CvSparseMatIterator_base[] = {0};
static swig_octave_class _wrap_class_CvSparseMatIterator = {"CvSparseMatIterator", &SWIGTYPE_p_CvSparseMatIterator,0,_wrap_new_CvSparseMatIterator,0,_wrap_delete_CvSparseMatIterator,swig_CvSparseMatIterator_members,swig_CvSparseMatIterator_base_names,swig_CvSparseMatIterator_base };

static octave_value_list _wrap_CvHistogram_type_set (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHistogram_type_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHistogram_type_set" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHistogram_type_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->type = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHistogram_type_get (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvHistogram_type_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHistogram_type_get" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  result = (int) ((arg1)->type);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHistogram_bins_set (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHistogram_bins_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHistogram_bins_set" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (arg1) (arg1)->bins = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvHistogram_bins_get (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("CvHistogram_bins_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHistogram_bins_get" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  result = (CvArr *) ((arg1)->bins);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHistogram_thresh_set (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  float (*arg2)[2] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHistogram_thresh_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHistogram_thresh_set" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_a_2__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHistogram_thresh_set" "', argument " "2"" of type '" "float [32][2]""'"); 
  } 
  arg2 = (float (*)[2])(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)32; ++ii) {
        if (arg2[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)2; ++jj) arg1->thresh[ii][jj] = arg2[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""thresh""' of type '""float [32][2]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""thresh""' of type '""float [32][2]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHistogram_thresh_get (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float (*result)[2] = 0 ;
  
  if (!SWIG_check_num_args("CvHistogram_thresh_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHistogram_thresh_get" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  result = (float (*)[2])(float (*)[2]) ((arg1)->thresh);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_a_2__float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHistogram_thresh2_set (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  float **arg2 = (float **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *vptr2 ;
  float *buffer2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHistogram_thresh2_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHistogram_thresh2_set" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_float, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (float *) vptr2;
    arg2=&buffer2;
  }
  if (arg1) (arg1)->thresh2 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHistogram_thresh2_get (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float **result = 0 ;
  
  if (!SWIG_check_num_args("CvHistogram_thresh2_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHistogram_thresh2_get" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  result = (float **) ((arg1)->thresh2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHistogram_mat_set (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  CvMatND *arg2 = (CvMatND *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHistogram_mat_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHistogram_mat_set" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHistogram_mat_set" "', argument " "2"" of type '" "CvMatND *""'"); 
  }
  arg2 = (CvMatND *)(argp2);
  if (arg1) (arg1)->mat = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHistogram_mat_get (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatND *result = 0 ;
  
  if (!SWIG_check_num_args("CvHistogram_mat_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHistogram_mat_get" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  result = (CvMatND *)& ((arg1)->mat);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatND, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvHistogram (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvHistogram",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvHistogram" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  {
    try {
      delete_CvHistogram(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvHistogram_members[] = {
{"type",0,_wrap_CvHistogram_type_get,_wrap_CvHistogram_type_set,0,0},
{"bins",0,_wrap_CvHistogram_bins_get,_wrap_CvHistogram_bins_set,0,0},
{"thresh",0,_wrap_CvHistogram_thresh_get,_wrap_CvHistogram_thresh_set,0,0},
{"thresh2",0,_wrap_CvHistogram_thresh2_get,_wrap_CvHistogram_thresh2_set,0,0},
{"mat",0,_wrap_CvHistogram_mat_get,_wrap_CvHistogram_mat_set,0,0},
{0,0,0,0}
};
static const char *swig_CvHistogram_base_names[] = {0};
static const swig_type_info *swig_CvHistogram_base[] = {0};
static swig_octave_class _wrap_class_CvHistogram = {"CvHistogram", &SWIGTYPE_p_CvHistogram,0,0,0,_wrap_delete_CvHistogram,swig_CvHistogram_members,swig_CvHistogram_base_names,swig_CvHistogram_base };

static octave_value_list _wrap_CvRect_x_set (const octave_value_list& args, int nargout) {
  CvRect *arg1 = (CvRect *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvRect_x_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRect_x_set" "', argument " "1"" of type '" "CvRect *""'"); 
  }
  arg1 = (CvRect *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvRect_x_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->x = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRect_x_get (const octave_value_list& args, int nargout) {
  CvRect *arg1 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvRect_x_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRect_x_get" "', argument " "1"" of type '" "CvRect *""'"); 
  }
  arg1 = (CvRect *)(argp1);
  result = (int) ((arg1)->x);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRect_y_set (const octave_value_list& args, int nargout) {
  CvRect *arg1 = (CvRect *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvRect_y_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRect_y_set" "', argument " "1"" of type '" "CvRect *""'"); 
  }
  arg1 = (CvRect *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvRect_y_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->y = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRect_y_get (const octave_value_list& args, int nargout) {
  CvRect *arg1 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvRect_y_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRect_y_get" "', argument " "1"" of type '" "CvRect *""'"); 
  }
  arg1 = (CvRect *)(argp1);
  result = (int) ((arg1)->y);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRect_width_set (const octave_value_list& args, int nargout) {
  CvRect *arg1 = (CvRect *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvRect_width_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRect_width_set" "', argument " "1"" of type '" "CvRect *""'"); 
  }
  arg1 = (CvRect *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvRect_width_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->width = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRect_width_get (const octave_value_list& args, int nargout) {
  CvRect *arg1 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvRect_width_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRect_width_get" "', argument " "1"" of type '" "CvRect *""'"); 
  }
  arg1 = (CvRect *)(argp1);
  result = (int) ((arg1)->width);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRect_height_set (const octave_value_list& args, int nargout) {
  CvRect *arg1 = (CvRect *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvRect_height_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRect_height_set" "', argument " "1"" of type '" "CvRect *""'"); 
  }
  arg1 = (CvRect *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvRect_height_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->height = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvRect_height_get (const octave_value_list& args, int nargout) {
  CvRect *arg1 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvRect_height_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvRect_height_get" "', argument " "1"" of type '" "CvRect *""'"); 
  }
  arg1 = (CvRect *)(argp1);
  result = (int) ((arg1)->height);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvRect (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvRect",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvRect *)new CvRect(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvRect, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvRect (const octave_value_list& args, int nargout) {
  CvRect *arg1 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvRect",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRect, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvRect" "', argument " "1"" of type '" "CvRect *""'"); 
  }
  arg1 = (CvRect *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvRect_members[] = {
{"x",0,_wrap_CvRect_x_get,_wrap_CvRect_x_set,0,0},
{"y",0,_wrap_CvRect_y_get,_wrap_CvRect_y_set,0,0},
{"width",0,_wrap_CvRect_width_get,_wrap_CvRect_width_set,0,0},
{"height",0,_wrap_CvRect_height_get,_wrap_CvRect_height_set,0,0},
{0,0,0,0}
};
static const char *swig_CvRect_base_names[] = {0};
static const swig_type_info *swig_CvRect_base[] = {0};
static swig_octave_class _wrap_class_CvRect = {"CvRect", &SWIGTYPE_p_CvRect,0,_wrap_new_CvRect,0,_wrap_delete_CvRect,swig_CvRect_members,swig_CvRect_base_names,swig_CvRect_base };

static octave_value_list _wrap_cvRect (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect result;
  
  if (!SWIG_check_num_args("cvRect",args.length(),4,4,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvRect" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvRect" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvRect" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvRect" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      result = cvRect(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvRect((const CvRect&)(result))), SWIGTYPE_p_CvRect, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRectToROI (const octave_value_list& args, int nargout) {
  CvRect arg1 ;
  int arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplROI result;
  
  if (!SWIG_check_num_args("cvRectToROI",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvRect,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRectToROI" "', argument " "1"" of type '" "CvRect""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvRectToROI" "', argument " "1"" of type '" "CvRect""'");
    } else {
      arg1 = *((CvRect *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvRectToROI" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = cvRectToROI(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new IplROI((const IplROI&)(result))), SWIGTYPE_p__IplROI, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvROIToRect (const octave_value_list& args, int nargout) {
  IplROI arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect result;
  
  if (!SWIG_check_num_args("cvROIToRect",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p__IplROI,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvROIToRect" "', argument " "1"" of type '" "IplROI""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvROIToRect" "', argument " "1"" of type '" "IplROI""'");
    } else {
      arg1 = *((IplROI *)(argp1));
    }
  }
  {
    try {
      result = cvROIToRect(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvRect((const CvRect&)(result))), SWIGTYPE_p_CvRect, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTermCriteria_type_set (const octave_value_list& args, int nargout) {
  CvTermCriteria *arg1 = (CvTermCriteria *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTermCriteria_type_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTermCriteria, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTermCriteria_type_set" "', argument " "1"" of type '" "CvTermCriteria *""'"); 
  }
  arg1 = (CvTermCriteria *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTermCriteria_type_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->type = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTermCriteria_type_get (const octave_value_list& args, int nargout) {
  CvTermCriteria *arg1 = (CvTermCriteria *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvTermCriteria_type_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTermCriteria, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTermCriteria_type_get" "', argument " "1"" of type '" "CvTermCriteria *""'"); 
  }
  arg1 = (CvTermCriteria *)(argp1);
  result = (int) ((arg1)->type);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTermCriteria_max_iter_set (const octave_value_list& args, int nargout) {
  CvTermCriteria *arg1 = (CvTermCriteria *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTermCriteria_max_iter_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTermCriteria, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTermCriteria_max_iter_set" "', argument " "1"" of type '" "CvTermCriteria *""'"); 
  }
  arg1 = (CvTermCriteria *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTermCriteria_max_iter_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->max_iter = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTermCriteria_max_iter_get (const octave_value_list& args, int nargout) {
  CvTermCriteria *arg1 = (CvTermCriteria *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvTermCriteria_max_iter_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTermCriteria, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTermCriteria_max_iter_get" "', argument " "1"" of type '" "CvTermCriteria *""'"); 
  }
  arg1 = (CvTermCriteria *)(argp1);
  result = (int) ((arg1)->max_iter);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTermCriteria_epsilon_set (const octave_value_list& args, int nargout) {
  CvTermCriteria *arg1 = (CvTermCriteria *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTermCriteria_epsilon_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTermCriteria, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTermCriteria_epsilon_set" "', argument " "1"" of type '" "CvTermCriteria *""'"); 
  }
  arg1 = (CvTermCriteria *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTermCriteria_epsilon_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->epsilon = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTermCriteria_epsilon_get (const octave_value_list& args, int nargout) {
  CvTermCriteria *arg1 = (CvTermCriteria *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvTermCriteria_epsilon_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTermCriteria, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTermCriteria_epsilon_get" "', argument " "1"" of type '" "CvTermCriteria *""'"); 
  }
  arg1 = (CvTermCriteria *)(argp1);
  result = (double) ((arg1)->epsilon);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvTermCriteria (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTermCriteria *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvTermCriteria",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTermCriteria *)new CvTermCriteria(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTermCriteria, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvTermCriteria (const octave_value_list& args, int nargout) {
  CvTermCriteria *arg1 = (CvTermCriteria *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvTermCriteria",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTermCriteria, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvTermCriteria" "', argument " "1"" of type '" "CvTermCriteria *""'"); 
  }
  arg1 = (CvTermCriteria *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvTermCriteria_members[] = {
{"type",0,_wrap_CvTermCriteria_type_get,_wrap_CvTermCriteria_type_set,0,0},
{"max_iter",0,_wrap_CvTermCriteria_max_iter_get,_wrap_CvTermCriteria_max_iter_set,0,0},
{"epsilon",0,_wrap_CvTermCriteria_epsilon_get,_wrap_CvTermCriteria_epsilon_set,0,0},
{0,0,0,0}
};
static const char *swig_CvTermCriteria_base_names[] = {0};
static const swig_type_info *swig_CvTermCriteria_base[] = {0};
static swig_octave_class _wrap_class_CvTermCriteria = {"CvTermCriteria", &SWIGTYPE_p_CvTermCriteria,0,_wrap_new_CvTermCriteria,0,_wrap_delete_CvTermCriteria,swig_CvTermCriteria_members,swig_CvTermCriteria_base_names,swig_CvTermCriteria_base };

static octave_value_list _wrap_cvTermCriteria (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  double arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTermCriteria result;
  
  if (!SWIG_check_num_args("cvTermCriteria",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvTermCriteria" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvTermCriteria" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvTermCriteria" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      result = cvTermCriteria(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvTermCriteria((const CvTermCriteria&)(result))), SWIGTYPE_p_CvTermCriteria, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint_x_set (const octave_value_list& args, int nargout) {
  CvPoint *arg1 = (CvPoint *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint_x_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint_x_set" "', argument " "1"" of type '" "CvPoint *""'"); 
  }
  arg1 = (CvPoint *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint_x_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->x = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint_x_get (const octave_value_list& args, int nargout) {
  CvPoint *arg1 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvPoint_x_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint_x_get" "', argument " "1"" of type '" "CvPoint *""'"); 
  }
  arg1 = (CvPoint *)(argp1);
  result = (int) ((arg1)->x);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint_y_set (const octave_value_list& args, int nargout) {
  CvPoint *arg1 = (CvPoint *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint_y_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint_y_set" "', argument " "1"" of type '" "CvPoint *""'"); 
  }
  arg1 = (CvPoint *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint_y_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->y = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint_y_get (const octave_value_list& args, int nargout) {
  CvPoint *arg1 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvPoint_y_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint_y_get" "', argument " "1"" of type '" "CvPoint *""'"); 
  }
  arg1 = (CvPoint *)(argp1);
  result = (int) ((arg1)->y);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint___str__ (const octave_value_list& args, int nargout) {
  CvPoint *arg1 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvPoint___str__",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint___str__" "', argument " "1"" of type '" "CvPoint *""'"); 
  }
  arg1 = (CvPoint *)(argp1);
  {
    try {
      result = (char *)CvPoint___str__(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint___repr__ (const octave_value_list& args, int nargout) {
  CvPoint *arg1 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvPoint___repr__",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint___repr__" "', argument " "1"" of type '" "CvPoint *""'"); 
  }
  arg1 = (CvPoint *)(argp1);
  {
    try {
      result = (char *)CvPoint___repr__(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvPoint (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvPoint",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvPoint *)new CvPoint(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvPoint (const octave_value_list& args, int nargout) {
  CvPoint *arg1 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvPoint",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvPoint" "', argument " "1"" of type '" "CvPoint *""'"); 
  }
  arg1 = (CvPoint *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvPoint_members[] = {
{"x",0,_wrap_CvPoint_x_get,_wrap_CvPoint_x_set,0,0},
{"y",0,_wrap_CvPoint_y_get,_wrap_CvPoint_y_set,0,0},
{"__str__",_wrap_CvPoint___str__,0,0,0,0},
{"__repr__",_wrap_CvPoint___repr__,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvPoint_base_names[] = {0};
static const swig_type_info *swig_CvPoint_base[] = {0};
static swig_octave_class _wrap_class_CvPoint = {"CvPoint", &SWIGTYPE_p_CvPoint,0,_wrap_new_CvPoint,0,_wrap_delete_CvPoint,swig_CvPoint_members,swig_CvPoint_base_names,swig_CvPoint_base };

static octave_value_list _wrap_cvPoint (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint result;
  
  if (!SWIG_check_num_args("cvPoint",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvPoint" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvPoint" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = cvPoint(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvPoint((const CvPoint&)(result))), SWIGTYPE_p_CvPoint, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint2D32f_x_set (const octave_value_list& args, int nargout) {
  CvPoint2D32f *arg1 = (CvPoint2D32f *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint2D32f_x_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint2D32f_x_set" "', argument " "1"" of type '" "CvPoint2D32f *""'"); 
  }
  arg1 = (CvPoint2D32f *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint2D32f_x_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->x = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint2D32f_x_get (const octave_value_list& args, int nargout) {
  CvPoint2D32f *arg1 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvPoint2D32f_x_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint2D32f_x_get" "', argument " "1"" of type '" "CvPoint2D32f *""'"); 
  }
  arg1 = (CvPoint2D32f *)(argp1);
  result = (float) ((arg1)->x);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint2D32f_y_set (const octave_value_list& args, int nargout) {
  CvPoint2D32f *arg1 = (CvPoint2D32f *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint2D32f_y_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint2D32f_y_set" "', argument " "1"" of type '" "CvPoint2D32f *""'"); 
  }
  arg1 = (CvPoint2D32f *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint2D32f_y_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->y = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint2D32f_y_get (const octave_value_list& args, int nargout) {
  CvPoint2D32f *arg1 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvPoint2D32f_y_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint2D32f_y_get" "', argument " "1"" of type '" "CvPoint2D32f *""'"); 
  }
  arg1 = (CvPoint2D32f *)(argp1);
  result = (float) ((arg1)->y);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint2D32f___str__ (const octave_value_list& args, int nargout) {
  CvPoint2D32f *arg1 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvPoint2D32f___str__",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint2D32f___str__" "', argument " "1"" of type '" "CvPoint2D32f *""'"); 
  }
  arg1 = (CvPoint2D32f *)(argp1);
  {
    try {
      result = (char *)CvPoint2D32f___str__(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint2D32f___repr__ (const octave_value_list& args, int nargout) {
  CvPoint2D32f *arg1 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvPoint2D32f___repr__",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint2D32f___repr__" "', argument " "1"" of type '" "CvPoint2D32f *""'"); 
  }
  arg1 = (CvPoint2D32f *)(argp1);
  {
    try {
      result = (char *)CvPoint2D32f___repr__(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvPoint2D32f (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvPoint2D32f",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvPoint2D32f *)new CvPoint2D32f(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D32f, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvPoint2D32f (const octave_value_list& args, int nargout) {
  CvPoint2D32f *arg1 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvPoint2D32f",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D32f, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvPoint2D32f" "', argument " "1"" of type '" "CvPoint2D32f *""'"); 
  }
  arg1 = (CvPoint2D32f *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvPoint2D32f_members[] = {
{"x",0,_wrap_CvPoint2D32f_x_get,_wrap_CvPoint2D32f_x_set,0,0},
{"y",0,_wrap_CvPoint2D32f_y_get,_wrap_CvPoint2D32f_y_set,0,0},
{"__str__",_wrap_CvPoint2D32f___str__,0,0,0,0},
{"__repr__",_wrap_CvPoint2D32f___repr__,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvPoint2D32f_base_names[] = {0};
static const swig_type_info *swig_CvPoint2D32f_base[] = {0};
static swig_octave_class _wrap_class_CvPoint2D32f = {"CvPoint2D32f", &SWIGTYPE_p_CvPoint2D32f,0,_wrap_new_CvPoint2D32f,0,_wrap_delete_CvPoint2D32f,swig_CvPoint2D32f_members,swig_CvPoint2D32f_base_names,swig_CvPoint2D32f_base };

static octave_value_list _wrap_cvPoint2D32f (const octave_value_list& args, int nargout) {
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f result;
  
  if (!SWIG_check_num_args("cvPoint2D32f",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvPoint2D32f" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvPoint2D32f" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = cvPoint2D32f(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvPoint2D32f((const CvPoint2D32f&)(result))), SWIGTYPE_p_CvPoint2D32f, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvPointTo32f (const octave_value_list& args, int nargout) {
  CvPoint arg1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f result;
  
  if (!SWIG_check_num_args("cvPointTo32f",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint(args(0));
  }
  {
    try {
      result = cvPointTo32f(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvPoint2D32f((const CvPoint2D32f&)(result))), SWIGTYPE_p_CvPoint2D32f, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvPointFrom32f (const octave_value_list& args, int nargout) {
  CvPoint2D32f arg1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint result;
  
  if (!SWIG_check_num_args("cvPointFrom32f",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint2D32f(args(0));
  }
  {
    try {
      result = cvPointFrom32f(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvPoint((const CvPoint&)(result))), SWIGTYPE_p_CvPoint, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D32f_x_set (const octave_value_list& args, int nargout) {
  CvPoint3D32f *arg1 = (CvPoint3D32f *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint3D32f_x_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D32f_x_set" "', argument " "1"" of type '" "CvPoint3D32f *""'"); 
  }
  arg1 = (CvPoint3D32f *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint3D32f_x_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->x = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D32f_x_get (const octave_value_list& args, int nargout) {
  CvPoint3D32f *arg1 = (CvPoint3D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvPoint3D32f_x_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D32f_x_get" "', argument " "1"" of type '" "CvPoint3D32f *""'"); 
  }
  arg1 = (CvPoint3D32f *)(argp1);
  result = (float) ((arg1)->x);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D32f_y_set (const octave_value_list& args, int nargout) {
  CvPoint3D32f *arg1 = (CvPoint3D32f *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint3D32f_y_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D32f_y_set" "', argument " "1"" of type '" "CvPoint3D32f *""'"); 
  }
  arg1 = (CvPoint3D32f *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint3D32f_y_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->y = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D32f_y_get (const octave_value_list& args, int nargout) {
  CvPoint3D32f *arg1 = (CvPoint3D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvPoint3D32f_y_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D32f_y_get" "', argument " "1"" of type '" "CvPoint3D32f *""'"); 
  }
  arg1 = (CvPoint3D32f *)(argp1);
  result = (float) ((arg1)->y);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D32f_z_set (const octave_value_list& args, int nargout) {
  CvPoint3D32f *arg1 = (CvPoint3D32f *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint3D32f_z_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D32f_z_set" "', argument " "1"" of type '" "CvPoint3D32f *""'"); 
  }
  arg1 = (CvPoint3D32f *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint3D32f_z_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->z = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D32f_z_get (const octave_value_list& args, int nargout) {
  CvPoint3D32f *arg1 = (CvPoint3D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvPoint3D32f_z_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D32f_z_get" "', argument " "1"" of type '" "CvPoint3D32f *""'"); 
  }
  arg1 = (CvPoint3D32f *)(argp1);
  result = (float) ((arg1)->z);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvPoint3D32f (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint3D32f *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvPoint3D32f",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvPoint3D32f *)new CvPoint3D32f(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint3D32f, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvPoint3D32f (const octave_value_list& args, int nargout) {
  CvPoint3D32f *arg1 = (CvPoint3D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvPoint3D32f",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D32f, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvPoint3D32f" "', argument " "1"" of type '" "CvPoint3D32f *""'"); 
  }
  arg1 = (CvPoint3D32f *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvPoint3D32f_members[] = {
{"x",0,_wrap_CvPoint3D32f_x_get,_wrap_CvPoint3D32f_x_set,0,0},
{"y",0,_wrap_CvPoint3D32f_y_get,_wrap_CvPoint3D32f_y_set,0,0},
{"z",0,_wrap_CvPoint3D32f_z_get,_wrap_CvPoint3D32f_z_set,0,0},
{0,0,0,0}
};
static const char *swig_CvPoint3D32f_base_names[] = {0};
static const swig_type_info *swig_CvPoint3D32f_base[] = {0};
static swig_octave_class _wrap_class_CvPoint3D32f = {"CvPoint3D32f", &SWIGTYPE_p_CvPoint3D32f,0,_wrap_new_CvPoint3D32f,0,_wrap_delete_CvPoint3D32f,swig_CvPoint3D32f_members,swig_CvPoint3D32f_base_names,swig_CvPoint3D32f_base };

static octave_value_list _wrap_cvPoint3D32f (const octave_value_list& args, int nargout) {
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint3D32f result;
  
  if (!SWIG_check_num_args("cvPoint3D32f",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvPoint3D32f" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvPoint3D32f" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPoint3D32f" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      result = cvPoint3D32f(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvPoint3D32f((const CvPoint3D32f&)(result))), SWIGTYPE_p_CvPoint3D32f, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint2D64f_x_set (const octave_value_list& args, int nargout) {
  CvPoint2D64f *arg1 = (CvPoint2D64f *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint2D64f_x_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D64f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint2D64f_x_set" "', argument " "1"" of type '" "CvPoint2D64f *""'"); 
  }
  arg1 = (CvPoint2D64f *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint2D64f_x_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->x = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint2D64f_x_get (const octave_value_list& args, int nargout) {
  CvPoint2D64f *arg1 = (CvPoint2D64f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvPoint2D64f_x_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D64f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint2D64f_x_get" "', argument " "1"" of type '" "CvPoint2D64f *""'"); 
  }
  arg1 = (CvPoint2D64f *)(argp1);
  result = (double) ((arg1)->x);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint2D64f_y_set (const octave_value_list& args, int nargout) {
  CvPoint2D64f *arg1 = (CvPoint2D64f *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint2D64f_y_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D64f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint2D64f_y_set" "', argument " "1"" of type '" "CvPoint2D64f *""'"); 
  }
  arg1 = (CvPoint2D64f *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint2D64f_y_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->y = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint2D64f_y_get (const octave_value_list& args, int nargout) {
  CvPoint2D64f *arg1 = (CvPoint2D64f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvPoint2D64f_y_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D64f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint2D64f_y_get" "', argument " "1"" of type '" "CvPoint2D64f *""'"); 
  }
  arg1 = (CvPoint2D64f *)(argp1);
  result = (double) ((arg1)->y);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvPoint2D64f (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D64f *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvPoint2D64f",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvPoint2D64f *)new CvPoint2D64f(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D64f, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvPoint2D64f (const octave_value_list& args, int nargout) {
  CvPoint2D64f *arg1 = (CvPoint2D64f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvPoint2D64f",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D64f, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvPoint2D64f" "', argument " "1"" of type '" "CvPoint2D64f *""'"); 
  }
  arg1 = (CvPoint2D64f *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvPoint2D64f_members[] = {
{"x",0,_wrap_CvPoint2D64f_x_get,_wrap_CvPoint2D64f_x_set,0,0},
{"y",0,_wrap_CvPoint2D64f_y_get,_wrap_CvPoint2D64f_y_set,0,0},
{0,0,0,0}
};
static const char *swig_CvPoint2D64f_base_names[] = {0};
static const swig_type_info *swig_CvPoint2D64f_base[] = {0};
static swig_octave_class _wrap_class_CvPoint2D64f = {"CvPoint2D64f", &SWIGTYPE_p_CvPoint2D64f,0,_wrap_new_CvPoint2D64f,0,_wrap_delete_CvPoint2D64f,swig_CvPoint2D64f_members,swig_CvPoint2D64f_base_names,swig_CvPoint2D64f_base };

static octave_value_list _wrap_cvPoint2D64f (const octave_value_list& args, int nargout) {
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D64f result;
  
  if (!SWIG_check_num_args("cvPoint2D64f",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvPoint2D64f" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvPoint2D64f" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = cvPoint2D64f(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvPoint2D64f((const CvPoint2D64f&)(result))), SWIGTYPE_p_CvPoint2D64f, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D64f_x_set (const octave_value_list& args, int nargout) {
  CvPoint3D64f *arg1 = (CvPoint3D64f *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint3D64f_x_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D64f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D64f_x_set" "', argument " "1"" of type '" "CvPoint3D64f *""'"); 
  }
  arg1 = (CvPoint3D64f *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint3D64f_x_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->x = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D64f_x_get (const octave_value_list& args, int nargout) {
  CvPoint3D64f *arg1 = (CvPoint3D64f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvPoint3D64f_x_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D64f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D64f_x_get" "', argument " "1"" of type '" "CvPoint3D64f *""'"); 
  }
  arg1 = (CvPoint3D64f *)(argp1);
  result = (double) ((arg1)->x);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D64f_y_set (const octave_value_list& args, int nargout) {
  CvPoint3D64f *arg1 = (CvPoint3D64f *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint3D64f_y_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D64f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D64f_y_set" "', argument " "1"" of type '" "CvPoint3D64f *""'"); 
  }
  arg1 = (CvPoint3D64f *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint3D64f_y_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->y = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D64f_y_get (const octave_value_list& args, int nargout) {
  CvPoint3D64f *arg1 = (CvPoint3D64f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvPoint3D64f_y_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D64f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D64f_y_get" "', argument " "1"" of type '" "CvPoint3D64f *""'"); 
  }
  arg1 = (CvPoint3D64f *)(argp1);
  result = (double) ((arg1)->y);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D64f_z_set (const octave_value_list& args, int nargout) {
  CvPoint3D64f *arg1 = (CvPoint3D64f *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPoint3D64f_z_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D64f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D64f_z_set" "', argument " "1"" of type '" "CvPoint3D64f *""'"); 
  }
  arg1 = (CvPoint3D64f *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPoint3D64f_z_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->z = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPoint3D64f_z_get (const octave_value_list& args, int nargout) {
  CvPoint3D64f *arg1 = (CvPoint3D64f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvPoint3D64f_z_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D64f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPoint3D64f_z_get" "', argument " "1"" of type '" "CvPoint3D64f *""'"); 
  }
  arg1 = (CvPoint3D64f *)(argp1);
  result = (double) ((arg1)->z);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvPoint3D64f (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint3D64f *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvPoint3D64f",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvPoint3D64f *)new CvPoint3D64f(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint3D64f, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvPoint3D64f (const octave_value_list& args, int nargout) {
  CvPoint3D64f *arg1 = (CvPoint3D64f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvPoint3D64f",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D64f, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvPoint3D64f" "', argument " "1"" of type '" "CvPoint3D64f *""'"); 
  }
  arg1 = (CvPoint3D64f *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvPoint3D64f_members[] = {
{"x",0,_wrap_CvPoint3D64f_x_get,_wrap_CvPoint3D64f_x_set,0,0},
{"y",0,_wrap_CvPoint3D64f_y_get,_wrap_CvPoint3D64f_y_set,0,0},
{"z",0,_wrap_CvPoint3D64f_z_get,_wrap_CvPoint3D64f_z_set,0,0},
{0,0,0,0}
};
static const char *swig_CvPoint3D64f_base_names[] = {0};
static const swig_type_info *swig_CvPoint3D64f_base[] = {0};
static swig_octave_class _wrap_class_CvPoint3D64f = {"CvPoint3D64f", &SWIGTYPE_p_CvPoint3D64f,0,_wrap_new_CvPoint3D64f,0,_wrap_delete_CvPoint3D64f,swig_CvPoint3D64f_members,swig_CvPoint3D64f_base_names,swig_CvPoint3D64f_base };

static octave_value_list _wrap_cvPoint3D64f (const octave_value_list& args, int nargout) {
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint3D64f result;
  
  if (!SWIG_check_num_args("cvPoint3D64f",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvPoint3D64f" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvPoint3D64f" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPoint3D64f" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      result = cvPoint3D64f(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvPoint3D64f((const CvPoint3D64f&)(result))), SWIGTYPE_p_CvPoint3D64f, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSize_width_set (const octave_value_list& args, int nargout) {
  CvSize *arg1 = (CvSize *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSize_width_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSize, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSize_width_set" "', argument " "1"" of type '" "CvSize *""'"); 
  }
  arg1 = (CvSize *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSize_width_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->width = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSize_width_get (const octave_value_list& args, int nargout) {
  CvSize *arg1 = (CvSize *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSize_width_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSize, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSize_width_get" "', argument " "1"" of type '" "CvSize *""'"); 
  }
  arg1 = (CvSize *)(argp1);
  result = (int) ((arg1)->width);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSize_height_set (const octave_value_list& args, int nargout) {
  CvSize *arg1 = (CvSize *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSize_height_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSize, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSize_height_set" "', argument " "1"" of type '" "CvSize *""'"); 
  }
  arg1 = (CvSize *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSize_height_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->height = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSize_height_get (const octave_value_list& args, int nargout) {
  CvSize *arg1 = (CvSize *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSize_height_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSize, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSize_height_get" "', argument " "1"" of type '" "CvSize *""'"); 
  }
  arg1 = (CvSize *)(argp1);
  result = (int) ((arg1)->height);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSize (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSize",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSize *)new CvSize(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSize, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSize (const octave_value_list& args, int nargout) {
  CvSize *arg1 = (CvSize *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSize",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSize, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSize" "', argument " "1"" of type '" "CvSize *""'"); 
  }
  arg1 = (CvSize *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSize_members[] = {
{"width",0,_wrap_CvSize_width_get,_wrap_CvSize_width_set,0,0},
{"height",0,_wrap_CvSize_height_get,_wrap_CvSize_height_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSize_base_names[] = {0};
static const swig_type_info *swig_CvSize_base[] = {0};
static swig_octave_class _wrap_class_CvSize = {"CvSize", &SWIGTYPE_p_CvSize,0,_wrap_new_CvSize,0,_wrap_delete_CvSize,swig_CvSize_members,swig_CvSize_base_names,swig_CvSize_base };

static octave_value_list _wrap_cvSize (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize result;
  
  if (!SWIG_check_num_args("cvSize",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvSize" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = cvSize(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvSize((const CvSize&)(result))), SWIGTYPE_p_CvSize, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSize2D32f_width_set (const octave_value_list& args, int nargout) {
  CvSize2D32f *arg1 = (CvSize2D32f *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSize2D32f_width_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSize2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSize2D32f_width_set" "', argument " "1"" of type '" "CvSize2D32f *""'"); 
  }
  arg1 = (CvSize2D32f *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSize2D32f_width_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->width = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSize2D32f_width_get (const octave_value_list& args, int nargout) {
  CvSize2D32f *arg1 = (CvSize2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvSize2D32f_width_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSize2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSize2D32f_width_get" "', argument " "1"" of type '" "CvSize2D32f *""'"); 
  }
  arg1 = (CvSize2D32f *)(argp1);
  result = (float) ((arg1)->width);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSize2D32f_height_set (const octave_value_list& args, int nargout) {
  CvSize2D32f *arg1 = (CvSize2D32f *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSize2D32f_height_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSize2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSize2D32f_height_set" "', argument " "1"" of type '" "CvSize2D32f *""'"); 
  }
  arg1 = (CvSize2D32f *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSize2D32f_height_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->height = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSize2D32f_height_get (const octave_value_list& args, int nargout) {
  CvSize2D32f *arg1 = (CvSize2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvSize2D32f_height_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSize2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSize2D32f_height_get" "', argument " "1"" of type '" "CvSize2D32f *""'"); 
  }
  arg1 = (CvSize2D32f *)(argp1);
  result = (float) ((arg1)->height);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSize2D32f (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSize2D32f",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSize2D32f *)new CvSize2D32f(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSize2D32f, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSize2D32f (const octave_value_list& args, int nargout) {
  CvSize2D32f *arg1 = (CvSize2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSize2D32f",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSize2D32f, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSize2D32f" "', argument " "1"" of type '" "CvSize2D32f *""'"); 
  }
  arg1 = (CvSize2D32f *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSize2D32f_members[] = {
{"width",0,_wrap_CvSize2D32f_width_get,_wrap_CvSize2D32f_width_set,0,0},
{"height",0,_wrap_CvSize2D32f_height_get,_wrap_CvSize2D32f_height_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSize2D32f_base_names[] = {0};
static const swig_type_info *swig_CvSize2D32f_base[] = {0};
static swig_octave_class _wrap_class_CvSize2D32f = {"CvSize2D32f", &SWIGTYPE_p_CvSize2D32f,0,_wrap_new_CvSize2D32f,0,_wrap_delete_CvSize2D32f,swig_CvSize2D32f_members,swig_CvSize2D32f_base_names,swig_CvSize2D32f_base };

static octave_value_list _wrap_cvSize2D32f (const octave_value_list& args, int nargout) {
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize2D32f result;
  
  if (!SWIG_check_num_args("cvSize2D32f",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvSize2D32f" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSize2D32f" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = cvSize2D32f(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvSize2D32f((const CvSize2D32f&)(result))), SWIGTYPE_p_CvSize2D32f, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvBox2D_center_set (const octave_value_list& args, int nargout) {
  CvBox2D *arg1 = (CvBox2D *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvBox2D_center_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvBox2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvBox2D_center_set" "', argument " "1"" of type '" "CvBox2D *""'"); 
  }
  arg1 = (CvBox2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvBox2D_center_set" "', argument " "2"" of type '" "CvPoint2D32f *""'"); 
  }
  arg2 = (CvPoint2D32f *)(argp2);
  if (arg1) (arg1)->center = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvBox2D_center_get (const octave_value_list& args, int nargout) {
  CvBox2D *arg1 = (CvBox2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("CvBox2D_center_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvBox2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvBox2D_center_get" "', argument " "1"" of type '" "CvBox2D *""'"); 
  }
  arg1 = (CvBox2D *)(argp1);
  result = (CvPoint2D32f *)& ((arg1)->center);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvBox2D_size_set (const octave_value_list& args, int nargout) {
  CvBox2D *arg1 = (CvBox2D *) 0 ;
  CvSize2D32f *arg2 = (CvSize2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvBox2D_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvBox2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvBox2D_size_set" "', argument " "1"" of type '" "CvBox2D *""'"); 
  }
  arg1 = (CvBox2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSize2D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvBox2D_size_set" "', argument " "2"" of type '" "CvSize2D32f *""'"); 
  }
  arg2 = (CvSize2D32f *)(argp2);
  if (arg1) (arg1)->size = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvBox2D_size_get (const octave_value_list& args, int nargout) {
  CvBox2D *arg1 = (CvBox2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("CvBox2D_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvBox2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvBox2D_size_get" "', argument " "1"" of type '" "CvBox2D *""'"); 
  }
  arg1 = (CvBox2D *)(argp1);
  result = (CvSize2D32f *)& ((arg1)->size);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSize2D32f, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvBox2D_angle_set (const octave_value_list& args, int nargout) {
  CvBox2D *arg1 = (CvBox2D *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvBox2D_angle_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvBox2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvBox2D_angle_set" "', argument " "1"" of type '" "CvBox2D *""'"); 
  }
  arg1 = (CvBox2D *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvBox2D_angle_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->angle = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvBox2D_angle_get (const octave_value_list& args, int nargout) {
  CvBox2D *arg1 = (CvBox2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvBox2D_angle_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvBox2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvBox2D_angle_get" "', argument " "1"" of type '" "CvBox2D *""'"); 
  }
  arg1 = (CvBox2D *)(argp1);
  result = (float) ((arg1)->angle);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvBox2D (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvBox2D *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvBox2D",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvBox2D *)new CvBox2D(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvBox2D, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvBox2D (const octave_value_list& args, int nargout) {
  CvBox2D *arg1 = (CvBox2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvBox2D",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvBox2D, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvBox2D" "', argument " "1"" of type '" "CvBox2D *""'"); 
  }
  arg1 = (CvBox2D *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvBox2D_members[] = {
{"center",0,_wrap_CvBox2D_center_get,_wrap_CvBox2D_center_set,0,0},
{"size",0,_wrap_CvBox2D_size_get,_wrap_CvBox2D_size_set,0,0},
{"angle",0,_wrap_CvBox2D_angle_get,_wrap_CvBox2D_angle_set,0,0},
{0,0,0,0}
};
static const char *swig_CvBox2D_base_names[] = {0};
static const swig_type_info *swig_CvBox2D_base[] = {0};
static swig_octave_class _wrap_class_CvBox2D = {"CvBox2D", &SWIGTYPE_p_CvBox2D,0,_wrap_new_CvBox2D,0,_wrap_delete_CvBox2D,swig_CvBox2D_members,swig_CvBox2D_base_names,swig_CvBox2D_base };

static octave_value_list _wrap_CvLineIterator_ptr_set (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  uchar *arg2 = (uchar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvLineIterator_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_ptr_set" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_unsigned_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvLineIterator_ptr_set" "', argument " "2"" of type '" "uchar *""'"); 
  }
  arg2 = (uchar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_ptr_get (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvLineIterator_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_ptr_get" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  result = (uchar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_err_set (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvLineIterator_err_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_err_set" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvLineIterator_err_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->err = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_err_get (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvLineIterator_err_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_err_get" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  result = (int) ((arg1)->err);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_plus_delta_set (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvLineIterator_plus_delta_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_plus_delta_set" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvLineIterator_plus_delta_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->plus_delta = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_plus_delta_get (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvLineIterator_plus_delta_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_plus_delta_get" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  result = (int) ((arg1)->plus_delta);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_minus_delta_set (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvLineIterator_minus_delta_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_minus_delta_set" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvLineIterator_minus_delta_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->minus_delta = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_minus_delta_get (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvLineIterator_minus_delta_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_minus_delta_get" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  result = (int) ((arg1)->minus_delta);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_plus_step_set (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvLineIterator_plus_step_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_plus_step_set" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvLineIterator_plus_step_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->plus_step = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_plus_step_get (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvLineIterator_plus_step_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_plus_step_get" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  result = (int) ((arg1)->plus_step);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_minus_step_set (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvLineIterator_minus_step_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_minus_step_set" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvLineIterator_minus_step_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->minus_step = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvLineIterator_minus_step_get (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvLineIterator_minus_step_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvLineIterator_minus_step_get" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  result = (int) ((arg1)->minus_step);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvLineIterator (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvLineIterator *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvLineIterator",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvLineIterator *)new CvLineIterator(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvLineIterator, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvLineIterator (const octave_value_list& args, int nargout) {
  CvLineIterator *arg1 = (CvLineIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvLineIterator",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLineIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvLineIterator" "', argument " "1"" of type '" "CvLineIterator *""'"); 
  }
  arg1 = (CvLineIterator *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvLineIterator_members[] = {
{"ptr",0,_wrap_CvLineIterator_ptr_get,_wrap_CvLineIterator_ptr_set,0,0},
{"err",0,_wrap_CvLineIterator_err_get,_wrap_CvLineIterator_err_set,0,0},
{"plus_delta",0,_wrap_CvLineIterator_plus_delta_get,_wrap_CvLineIterator_plus_delta_set,0,0},
{"minus_delta",0,_wrap_CvLineIterator_minus_delta_get,_wrap_CvLineIterator_minus_delta_set,0,0},
{"plus_step",0,_wrap_CvLineIterator_plus_step_get,_wrap_CvLineIterator_plus_step_set,0,0},
{"minus_step",0,_wrap_CvLineIterator_minus_step_get,_wrap_CvLineIterator_minus_step_set,0,0},
{0,0,0,0}
};
static const char *swig_CvLineIterator_base_names[] = {0};
static const swig_type_info *swig_CvLineIterator_base[] = {0};
static swig_octave_class _wrap_class_CvLineIterator = {"CvLineIterator", &SWIGTYPE_p_CvLineIterator,0,_wrap_new_CvLineIterator,0,_wrap_delete_CvLineIterator,swig_CvLineIterator_members,swig_CvLineIterator_base_names,swig_CvLineIterator_base };

static octave_value_list _wrap_CvSlice_start_index_set (const octave_value_list& args, int nargout) {
  CvSlice *arg1 = (CvSlice *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSlice_start_index_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSlice_start_index_set" "', argument " "1"" of type '" "CvSlice *""'"); 
  }
  arg1 = (CvSlice *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSlice_start_index_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->start_index = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSlice_start_index_get (const octave_value_list& args, int nargout) {
  CvSlice *arg1 = (CvSlice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSlice_start_index_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSlice_start_index_get" "', argument " "1"" of type '" "CvSlice *""'"); 
  }
  arg1 = (CvSlice *)(argp1);
  result = (int) ((arg1)->start_index);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSlice_end_index_set (const octave_value_list& args, int nargout) {
  CvSlice *arg1 = (CvSlice *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSlice_end_index_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSlice_end_index_set" "', argument " "1"" of type '" "CvSlice *""'"); 
  }
  arg1 = (CvSlice *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSlice_end_index_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->end_index = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSlice_end_index_get (const octave_value_list& args, int nargout) {
  CvSlice *arg1 = (CvSlice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSlice_end_index_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSlice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSlice_end_index_get" "', argument " "1"" of type '" "CvSlice *""'"); 
  }
  arg1 = (CvSlice *)(argp1);
  result = (int) ((arg1)->end_index);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSlice (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSlice *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSlice",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSlice *)new CvSlice(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSlice, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSlice (const octave_value_list& args, int nargout) {
  CvSlice *arg1 = (CvSlice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSlice",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSlice, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSlice" "', argument " "1"" of type '" "CvSlice *""'"); 
  }
  arg1 = (CvSlice *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSlice_members[] = {
{"start_index",0,_wrap_CvSlice_start_index_get,_wrap_CvSlice_start_index_set,0,0},
{"end_index",0,_wrap_CvSlice_end_index_get,_wrap_CvSlice_end_index_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSlice_base_names[] = {0};
static const swig_type_info *swig_CvSlice_base[] = {0};
static swig_octave_class _wrap_class_CvSlice = {"CvSlice", &SWIGTYPE_p_CvSlice,0,_wrap_new_CvSlice,0,_wrap_delete_CvSlice,swig_CvSlice_members,swig_CvSlice_base_names,swig_CvSlice_base };

static octave_value_list _wrap_cvSlice (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSlice result;
  
  if (!SWIG_check_num_args("cvSlice",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvSlice" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSlice" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = cvSlice(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvSlice((const CvSlice&)(result))), SWIGTYPE_p_CvSlice, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvScalar_val_set (const octave_value_list& args, int nargout) {
  CvScalar *arg1 = (CvScalar *) 0 ;
  double *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvScalar_val_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvScalar_val_set" "', argument " "1"" of type '" "CvScalar *""'"); 
  }
  arg1 = (CvScalar *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvScalar_val_set" "', argument " "2"" of type '" "double [4]""'"); 
  } 
  arg2 = (double *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)4; ++ii) arg1->val[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""val""' of type '""double [4]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvScalar_val_get (const octave_value_list& args, int nargout) {
  CvScalar *arg1 = (CvScalar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double *result = 0 ;
  
  if (!SWIG_check_num_args("CvScalar_val_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvScalar_val_get" "', argument " "1"" of type '" "CvScalar *""'"); 
  }
  arg1 = (CvScalar *)(argp1);
  result = (double *)(double *) ((arg1)->val);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvScalar___str__ (const octave_value_list& args, int nargout) {
  CvScalar *arg1 = (CvScalar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvScalar___str__",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvScalar___str__" "', argument " "1"" of type '" "CvScalar *""'"); 
  }
  arg1 = (CvScalar *)(argp1);
  {
    try {
      result = (char *)CvScalar___str__(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvScalar___repr__ (const octave_value_list& args, int nargout) {
  CvScalar *arg1 = (CvScalar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvScalar___repr__",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvScalar___repr__" "', argument " "1"" of type '" "CvScalar *""'"); 
  }
  arg1 = (CvScalar *)(argp1);
  {
    try {
      result = (char *)CvScalar___repr__(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvScalar___getitem__ (const octave_value_list& args, int nargout) {
  CvScalar *arg1 = (CvScalar *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvScalar___getitem__",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvScalar___getitem__" "', argument " "1"" of type '" "CvScalar *""'"); 
  }
  arg1 = (CvScalar *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvScalar___getitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (double)CvScalar___getitem__(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvScalar___setitem__ (const octave_value_list& args, int nargout) {
  CvScalar *arg1 = (CvScalar *) 0 ;
  int arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvScalar___setitem__",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvScalar___setitem__" "', argument " "1"" of type '" "CvScalar *""'"); 
  }
  arg1 = (CvScalar *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvScalar___setitem__" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CvScalar___setitem__" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      CvScalar___setitem__(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvScalar (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvScalar",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvScalar *)new CvScalar(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvScalar, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvScalar (const octave_value_list& args, int nargout) {
  CvScalar *arg1 = (CvScalar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvScalar",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvScalar, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvScalar" "', argument " "1"" of type '" "CvScalar *""'"); 
  }
  arg1 = (CvScalar *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvScalar_members[] = {
{"val",0,_wrap_CvScalar_val_get,_wrap_CvScalar_val_set,0,0},
{"__str__",_wrap_CvScalar___str__,0,0,0,0},
{"__repr__",_wrap_CvScalar___repr__,0,0,0,0},
{"__getitem__",_wrap_CvScalar___getitem__,0,0,0,0},
{"__setitem__",_wrap_CvScalar___setitem__,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvScalar_base_names[] = {0};
static const swig_type_info *swig_CvScalar_base[] = {0};
static swig_octave_class _wrap_class_CvScalar = {"CvScalar", &SWIGTYPE_p_CvScalar,0,_wrap_new_CvScalar,0,_wrap_delete_CvScalar,swig_CvScalar_members,swig_CvScalar_base_names,swig_CvScalar_base };

static octave_value_list _wrap_cvScalar__SWIG_0 (const octave_value_list& args, int nargout) {
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvScalar",args.length(),4,4,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvScalar" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvScalar" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvScalar" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvScalar" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    try {
      result = cvScalar(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvScalar__SWIG_1 (const octave_value_list& args, int nargout) {
  double arg1 ;
  double arg2 ;
  double arg3 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvScalar",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvScalar" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvScalar" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvScalar" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      result = cvScalar(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvScalar__SWIG_2 (const octave_value_list& args, int nargout) {
  double arg1 ;
  double arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvScalar",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvScalar" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvScalar" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      result = cvScalar(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvScalar__SWIG_3 (const octave_value_list& args, int nargout) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvScalar",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvScalar" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    try {
      result = cvScalar(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvScalar (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[4]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3)
  };
  
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_cvScalar__SWIG_3(args, nargout);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_cvScalar__SWIG_2(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_cvScalar__SWIG_1(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_double(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_double(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_cvScalar__SWIG_0(args, nargout);
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_cvRealScalar (const octave_value_list& args, int nargout) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvRealScalar",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvRealScalar" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    try {
      result = cvRealScalar(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvScalarAll (const octave_value_list& args, int nargout) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvScalarAll",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvScalarAll" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  {
    try {
      result = cvScalarAll(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemBlock_prev_set (const octave_value_list& args, int nargout) {
  CvMemBlock *arg1 = (CvMemBlock *) 0 ;
  CvMemBlock *arg2 = (CvMemBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMemBlock_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemBlock_prev_set" "', argument " "1"" of type '" "CvMemBlock *""'"); 
  }
  arg1 = (CvMemBlock *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMemBlock_prev_set" "', argument " "2"" of type '" "CvMemBlock *""'"); 
  }
  arg2 = (CvMemBlock *)(argp2);
  if (arg1) (arg1)->prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemBlock_prev_get (const octave_value_list& args, int nargout) {
  CvMemBlock *arg1 = (CvMemBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvMemBlock_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemBlock_prev_get" "', argument " "1"" of type '" "CvMemBlock *""'"); 
  }
  arg1 = (CvMemBlock *)(argp1);
  result = (CvMemBlock *) ((arg1)->prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemBlock_next_set (const octave_value_list& args, int nargout) {
  CvMemBlock *arg1 = (CvMemBlock *) 0 ;
  CvMemBlock *arg2 = (CvMemBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMemBlock_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemBlock_next_set" "', argument " "1"" of type '" "CvMemBlock *""'"); 
  }
  arg1 = (CvMemBlock *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMemBlock_next_set" "', argument " "2"" of type '" "CvMemBlock *""'"); 
  }
  arg2 = (CvMemBlock *)(argp2);
  if (arg1) (arg1)->next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemBlock_next_get (const octave_value_list& args, int nargout) {
  CvMemBlock *arg1 = (CvMemBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvMemBlock_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemBlock_next_get" "', argument " "1"" of type '" "CvMemBlock *""'"); 
  }
  arg1 = (CvMemBlock *)(argp1);
  result = (CvMemBlock *) ((arg1)->next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMemBlock (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemBlock *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMemBlock",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvMemBlock *)new CvMemBlock(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemBlock, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMemBlock (const octave_value_list& args, int nargout) {
  CvMemBlock *arg1 = (CvMemBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMemBlock",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMemBlock" "', argument " "1"" of type '" "CvMemBlock *""'"); 
  }
  arg1 = (CvMemBlock *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMemBlock_members[] = {
{"prev",0,_wrap_CvMemBlock_prev_get,_wrap_CvMemBlock_prev_set,0,0},
{"next",0,_wrap_CvMemBlock_next_get,_wrap_CvMemBlock_next_set,0,0},
{0,0,0,0}
};
static const char *swig_CvMemBlock_base_names[] = {0};
static const swig_type_info *swig_CvMemBlock_base[] = {0};
static swig_octave_class _wrap_class_CvMemBlock = {"CvMemBlock", &SWIGTYPE_p_CvMemBlock,0,_wrap_new_CvMemBlock,0,_wrap_delete_CvMemBlock,swig_CvMemBlock_members,swig_CvMemBlock_base_names,swig_CvMemBlock_base };

static octave_value_list _wrap_CvMemStorage_signature_set (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMemStorage_signature_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_signature_set" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMemStorage_signature_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->signature = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_signature_get (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMemStorage_signature_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_signature_get" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  result = (int) ((arg1)->signature);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_bottom_set (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  CvMemBlock *arg2 = (CvMemBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMemStorage_bottom_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_bottom_set" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMemStorage_bottom_set" "', argument " "2"" of type '" "CvMemBlock *""'"); 
  }
  arg2 = (CvMemBlock *)(argp2);
  if (arg1) (arg1)->bottom = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_bottom_get (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvMemStorage_bottom_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_bottom_get" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  result = (CvMemBlock *) ((arg1)->bottom);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_top_set (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  CvMemBlock *arg2 = (CvMemBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMemStorage_top_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_top_set" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMemStorage_top_set" "', argument " "2"" of type '" "CvMemBlock *""'"); 
  }
  arg2 = (CvMemBlock *)(argp2);
  if (arg1) (arg1)->top = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_top_get (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvMemStorage_top_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_top_get" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  result = (CvMemBlock *) ((arg1)->top);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_parent_set (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMemStorage_parent_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_parent_set" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMemStorage_parent_set" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (arg1) (arg1)->parent = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_parent_get (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStorage *result = 0 ;
  
  if (!SWIG_check_num_args("CvMemStorage_parent_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_parent_get" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  result = (CvMemStorage *) ((arg1)->parent);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_block_size_set (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMemStorage_block_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_block_size_set" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMemStorage_block_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->block_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_block_size_get (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMemStorage_block_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_block_size_get" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  result = (int) ((arg1)->block_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_free_space_set (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMemStorage_free_space_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_free_space_set" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMemStorage_free_space_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->free_space = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStorage_free_space_get (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMemStorage_free_space_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStorage_free_space_get" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  result = (int) ((arg1)->free_space);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMemStorage (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMemStorage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMemStorage" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  {
    try {
      delete_CvMemStorage(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMemStorage_members[] = {
{"signature",0,_wrap_CvMemStorage_signature_get,_wrap_CvMemStorage_signature_set,0,0},
{"bottom",0,_wrap_CvMemStorage_bottom_get,_wrap_CvMemStorage_bottom_set,0,0},
{"top",0,_wrap_CvMemStorage_top_get,_wrap_CvMemStorage_top_set,0,0},
{"parent",0,_wrap_CvMemStorage_parent_get,_wrap_CvMemStorage_parent_set,0,0},
{"block_size",0,_wrap_CvMemStorage_block_size_get,_wrap_CvMemStorage_block_size_set,0,0},
{"free_space",0,_wrap_CvMemStorage_free_space_get,_wrap_CvMemStorage_free_space_set,0,0},
{0,0,0,0}
};
static const char *swig_CvMemStorage_base_names[] = {0};
static const swig_type_info *swig_CvMemStorage_base[] = {0};
static swig_octave_class _wrap_class_CvMemStorage = {"CvMemStorage", &SWIGTYPE_p_CvMemStorage,0,0,0,_wrap_delete_CvMemStorage,swig_CvMemStorage_members,swig_CvMemStorage_base_names,swig_CvMemStorage_base };

static octave_value_list _wrap_CvMemStoragePos_top_set (const octave_value_list& args, int nargout) {
  CvMemStoragePos *arg1 = (CvMemStoragePos *) 0 ;
  CvMemBlock *arg2 = (CvMemBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMemStoragePos_top_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStoragePos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStoragePos_top_set" "', argument " "1"" of type '" "CvMemStoragePos *""'"); 
  }
  arg1 = (CvMemStoragePos *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMemStoragePos_top_set" "', argument " "2"" of type '" "CvMemBlock *""'"); 
  }
  arg2 = (CvMemBlock *)(argp2);
  if (arg1) (arg1)->top = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStoragePos_top_get (const octave_value_list& args, int nargout) {
  CvMemStoragePos *arg1 = (CvMemStoragePos *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvMemStoragePos_top_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStoragePos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStoragePos_top_get" "', argument " "1"" of type '" "CvMemStoragePos *""'"); 
  }
  arg1 = (CvMemStoragePos *)(argp1);
  result = (CvMemBlock *) ((arg1)->top);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStoragePos_free_space_set (const octave_value_list& args, int nargout) {
  CvMemStoragePos *arg1 = (CvMemStoragePos *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMemStoragePos_free_space_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStoragePos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStoragePos_free_space_set" "', argument " "1"" of type '" "CvMemStoragePos *""'"); 
  }
  arg1 = (CvMemStoragePos *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMemStoragePos_free_space_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->free_space = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMemStoragePos_free_space_get (const octave_value_list& args, int nargout) {
  CvMemStoragePos *arg1 = (CvMemStoragePos *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMemStoragePos_free_space_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStoragePos, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMemStoragePos_free_space_get" "', argument " "1"" of type '" "CvMemStoragePos *""'"); 
  }
  arg1 = (CvMemStoragePos *)(argp1);
  result = (int) ((arg1)->free_space);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMemStoragePos (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStoragePos *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMemStoragePos",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvMemStoragePos *)new CvMemStoragePos(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStoragePos, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMemStoragePos (const octave_value_list& args, int nargout) {
  CvMemStoragePos *arg1 = (CvMemStoragePos *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMemStoragePos",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStoragePos, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMemStoragePos" "', argument " "1"" of type '" "CvMemStoragePos *""'"); 
  }
  arg1 = (CvMemStoragePos *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMemStoragePos_members[] = {
{"top",0,_wrap_CvMemStoragePos_top_get,_wrap_CvMemStoragePos_top_set,0,0},
{"free_space",0,_wrap_CvMemStoragePos_free_space_get,_wrap_CvMemStoragePos_free_space_set,0,0},
{0,0,0,0}
};
static const char *swig_CvMemStoragePos_base_names[] = {0};
static const swig_type_info *swig_CvMemStoragePos_base[] = {0};
static swig_octave_class _wrap_class_CvMemStoragePos = {"CvMemStoragePos", &SWIGTYPE_p_CvMemStoragePos,0,_wrap_new_CvMemStoragePos,0,_wrap_delete_CvMemStoragePos,swig_CvMemStoragePos_members,swig_CvMemStoragePos_base_names,swig_CvMemStoragePos_base };

static octave_value_list _wrap_CvSeqBlock_prev_set (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqBlock_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqBlock_prev_set" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqBlock_prev_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqBlock_prev_get (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqBlock_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqBlock_prev_get" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  result = (CvSeqBlock *) ((arg1)->prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqBlock_next_set (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqBlock_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqBlock_next_set" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqBlock_next_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqBlock_next_get (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqBlock_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqBlock_next_get" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  result = (CvSeqBlock *) ((arg1)->next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqBlock_start_index_set (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqBlock_start_index_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqBlock_start_index_set" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeqBlock_start_index_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->start_index = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqBlock_start_index_get (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSeqBlock_start_index_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqBlock_start_index_get" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  result = (int) ((arg1)->start_index);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqBlock_count_set (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqBlock_count_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqBlock_count_set" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeqBlock_count_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->count = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqBlock_count_get (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSeqBlock_count_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqBlock_count_get" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  result = (int) ((arg1)->count);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqBlock_data_set (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqBlock_data_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqBlock_data_set" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqBlock_data_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->data = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqBlock_data_get (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqBlock_data_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqBlock_data_get" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  result = (schar *) ((arg1)->data);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeqBlock (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeqBlock",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSeqBlock *)new CvSeqBlock(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeqBlock (const octave_value_list& args, int nargout) {
  CvSeqBlock *arg1 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeqBlock",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeqBlock" "', argument " "1"" of type '" "CvSeqBlock *""'"); 
  }
  arg1 = (CvSeqBlock *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeqBlock_members[] = {
{"prev",0,_wrap_CvSeqBlock_prev_get,_wrap_CvSeqBlock_prev_set,0,0},
{"next",0,_wrap_CvSeqBlock_next_get,_wrap_CvSeqBlock_next_set,0,0},
{"start_index",0,_wrap_CvSeqBlock_start_index_get,_wrap_CvSeqBlock_start_index_set,0,0},
{"count",0,_wrap_CvSeqBlock_count_get,_wrap_CvSeqBlock_count_set,0,0},
{"data",0,_wrap_CvSeqBlock_data_get,_wrap_CvSeqBlock_data_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSeqBlock_base_names[] = {0};
static const swig_type_info *swig_CvSeqBlock_base[] = {0};
static swig_octave_class _wrap_class_CvSeqBlock = {"CvSeqBlock", &SWIGTYPE_p_CvSeqBlock,0,_wrap_new_CvSeqBlock,0,_wrap_delete_CvSeqBlock,swig_CvSeqBlock_members,swig_CvSeqBlock_base_names,swig_CvSeqBlock_base };

static octave_value_list _wrap_CvSeq_flags_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_flags_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSeq_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_header_size_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_header_size_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSeq_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_h_prev_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_h_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_h_prev_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_h_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (CvSeq *) ((arg1)->h_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_h_next_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_h_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_h_next_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_h_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (CvSeq *) ((arg1)->h_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_v_prev_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_v_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_v_prev_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_v_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (CvSeq *) ((arg1)->v_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_v_next_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_v_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_v_next_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_v_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (CvSeq *) ((arg1)->v_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_total_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_total_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_total_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->total = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_total_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSeq_total_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int) ((arg1)->total);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_elem_size_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_elem_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_elem_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->elem_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_elem_size_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSeq_elem_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int) ((arg1)->elem_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_block_max_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_block_max_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_block_max_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_max = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_block_max_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_block_max_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (schar *) ((arg1)->block_max);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_ptr_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_ptr_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_ptr_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (schar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_delta_elems_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_delta_elems_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_delta_elems_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->delta_elems = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_delta_elems_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSeq_delta_elems_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (int) ((arg1)->delta_elems);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_storage_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_storage_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_storage_set" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (arg1) (arg1)->storage = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_storage_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStorage *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_storage_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (CvMemStorage *) ((arg1)->storage);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_free_blocks_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_free_blocks_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_free_blocks_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->free_blocks = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_free_blocks_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_free_blocks_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (CvSeqBlock *) ((arg1)->free_blocks);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_first_set (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_first_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_first_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->first = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_first_get (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_first_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  result = (CvSeqBlock *) ((arg1)->first);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeq (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeq",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSeq *)new CvSeq(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeq (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeq",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeq_members[] = {
{"flags",0,_wrap_CvSeq_flags_get,_wrap_CvSeq_flags_set,0,0},
{"header_size",0,_wrap_CvSeq_header_size_get,_wrap_CvSeq_header_size_set,0,0},
{"h_prev",0,_wrap_CvSeq_h_prev_get,_wrap_CvSeq_h_prev_set,0,0},
{"h_next",0,_wrap_CvSeq_h_next_get,_wrap_CvSeq_h_next_set,0,0},
{"v_prev",0,_wrap_CvSeq_v_prev_get,_wrap_CvSeq_v_prev_set,0,0},
{"v_next",0,_wrap_CvSeq_v_next_get,_wrap_CvSeq_v_next_set,0,0},
{"total",0,_wrap_CvSeq_total_get,_wrap_CvSeq_total_set,0,0},
{"elem_size",0,_wrap_CvSeq_elem_size_get,_wrap_CvSeq_elem_size_set,0,0},
{"block_max",0,_wrap_CvSeq_block_max_get,_wrap_CvSeq_block_max_set,0,0},
{"ptr",0,_wrap_CvSeq_ptr_get,_wrap_CvSeq_ptr_set,0,0},
{"delta_elems",0,_wrap_CvSeq_delta_elems_get,_wrap_CvSeq_delta_elems_set,0,0},
{"storage",0,_wrap_CvSeq_storage_get,_wrap_CvSeq_storage_set,0,0},
{"free_blocks",0,_wrap_CvSeq_free_blocks_get,_wrap_CvSeq_free_blocks_set,0,0},
{"first",0,_wrap_CvSeq_first_get,_wrap_CvSeq_first_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSeq_base_names[] = {0};
static const swig_type_info *swig_CvSeq_base[] = {0};
static swig_octave_class _wrap_class_CvSeq = {"CvSeq", &SWIGTYPE_p_CvSeq,0,_wrap_new_CvSeq,0,_wrap_delete_CvSeq,swig_CvSeq_members,swig_CvSeq_base_names,swig_CvSeq_base };

static octave_value_list _wrap_CvSetElem_flags_set (const octave_value_list& args, int nargout) {
  CvSetElem *arg1 = (CvSetElem *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSetElem_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSetElem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSetElem_flags_set" "', argument " "1"" of type '" "CvSetElem *""'"); 
  }
  arg1 = (CvSetElem *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSetElem_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSetElem_flags_get (const octave_value_list& args, int nargout) {
  CvSetElem *arg1 = (CvSetElem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSetElem_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSetElem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSetElem_flags_get" "', argument " "1"" of type '" "CvSetElem *""'"); 
  }
  arg1 = (CvSetElem *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSetElem_next_free_set (const octave_value_list& args, int nargout) {
  CvSetElem *arg1 = (CvSetElem *) 0 ;
  CvSetElem *arg2 = (CvSetElem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSetElem_next_free_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSetElem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSetElem_next_free_set" "', argument " "1"" of type '" "CvSetElem *""'"); 
  }
  arg1 = (CvSetElem *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSetElem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSetElem_next_free_set" "', argument " "2"" of type '" "CvSetElem *""'"); 
  }
  arg2 = (CvSetElem *)(argp2);
  if (arg1) (arg1)->next_free = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSetElem_next_free_get (const octave_value_list& args, int nargout) {
  CvSetElem *arg1 = (CvSetElem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSetElem *result = 0 ;
  
  if (!SWIG_check_num_args("CvSetElem_next_free_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSetElem, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSetElem_next_free_get" "', argument " "1"" of type '" "CvSetElem *""'"); 
  }
  arg1 = (CvSetElem *)(argp1);
  result = (CvSetElem *) ((arg1)->next_free);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSetElem, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSetElem (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSetElem *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSetElem",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSetElem *)new CvSetElem(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSetElem, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSetElem (const octave_value_list& args, int nargout) {
  CvSetElem *arg1 = (CvSetElem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSetElem",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSetElem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSetElem" "', argument " "1"" of type '" "CvSetElem *""'"); 
  }
  arg1 = (CvSetElem *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSetElem_members[] = {
{"flags",0,_wrap_CvSetElem_flags_get,_wrap_CvSetElem_flags_set,0,0},
{"next_free",0,_wrap_CvSetElem_next_free_get,_wrap_CvSetElem_next_free_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSetElem_base_names[] = {0};
static const swig_type_info *swig_CvSetElem_base[] = {0};
static swig_octave_class _wrap_class_CvSetElem = {"CvSetElem", &SWIGTYPE_p_CvSetElem,0,_wrap_new_CvSetElem,0,_wrap_delete_CvSetElem,swig_CvSetElem_members,swig_CvSetElem_base_names,swig_CvSetElem_base };

static octave_value_list _wrap_CvSet_flags_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSet_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_flags_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSet_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_header_size_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSet_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_header_size_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSet_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_h_prev_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_h_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_h_prev_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSet_h_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (CvSeq *) ((arg1)->h_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_h_next_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_h_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_h_next_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSet_h_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (CvSeq *) ((arg1)->h_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_v_prev_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_v_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_v_prev_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSet_v_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (CvSeq *) ((arg1)->v_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_v_next_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_v_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_v_next_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSet_v_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (CvSeq *) ((arg1)->v_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_total_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_total_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSet_total_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->total = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_total_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSet_total_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (int) ((arg1)->total);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_elem_size_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_elem_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSet_elem_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->elem_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_elem_size_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSet_elem_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (int) ((arg1)->elem_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_block_max_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_block_max_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSet_block_max_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_max = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_block_max_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSet_block_max_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (schar *) ((arg1)->block_max);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_ptr_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSet_ptr_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_ptr_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSet_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (schar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_delta_elems_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_delta_elems_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSet_delta_elems_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->delta_elems = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_delta_elems_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSet_delta_elems_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (int) ((arg1)->delta_elems);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_storage_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_storage_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSet_storage_set" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (arg1) (arg1)->storage = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_storage_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStorage *result = 0 ;
  
  if (!SWIG_check_num_args("CvSet_storage_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (CvMemStorage *) ((arg1)->storage);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_free_blocks_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_free_blocks_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSet_free_blocks_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->free_blocks = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_free_blocks_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvSet_free_blocks_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (CvSeqBlock *) ((arg1)->free_blocks);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_first_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_first_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSet_first_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->first = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_first_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvSet_first_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (CvSeqBlock *) ((arg1)->first);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_free_elems_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  CvSetElem *arg2 = (CvSetElem *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_free_elems_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSetElem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSet_free_elems_set" "', argument " "2"" of type '" "CvSetElem *""'"); 
  }
  arg2 = (CvSetElem *)(argp2);
  if (arg1) (arg1)->free_elems = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_free_elems_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSetElem *result = 0 ;
  
  if (!SWIG_check_num_args("CvSet_free_elems_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (CvSetElem *) ((arg1)->free_elems);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSetElem, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_active_count_set (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSet_active_count_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSet_active_count_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->active_count = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSet_active_count_get (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSet_active_count_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  result = (int) ((arg1)->active_count);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSet (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSet *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSet",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSet *)new CvSet(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSet, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSet (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSet",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSet_members[] = {
{"flags",0,_wrap_CvSet_flags_get,_wrap_CvSet_flags_set,0,0},
{"header_size",0,_wrap_CvSet_header_size_get,_wrap_CvSet_header_size_set,0,0},
{"h_prev",0,_wrap_CvSet_h_prev_get,_wrap_CvSet_h_prev_set,0,0},
{"h_next",0,_wrap_CvSet_h_next_get,_wrap_CvSet_h_next_set,0,0},
{"v_prev",0,_wrap_CvSet_v_prev_get,_wrap_CvSet_v_prev_set,0,0},
{"v_next",0,_wrap_CvSet_v_next_get,_wrap_CvSet_v_next_set,0,0},
{"total",0,_wrap_CvSet_total_get,_wrap_CvSet_total_set,0,0},
{"elem_size",0,_wrap_CvSet_elem_size_get,_wrap_CvSet_elem_size_set,0,0},
{"block_max",0,_wrap_CvSet_block_max_get,_wrap_CvSet_block_max_set,0,0},
{"ptr",0,_wrap_CvSet_ptr_get,_wrap_CvSet_ptr_set,0,0},
{"delta_elems",0,_wrap_CvSet_delta_elems_get,_wrap_CvSet_delta_elems_set,0,0},
{"storage",0,_wrap_CvSet_storage_get,_wrap_CvSet_storage_set,0,0},
{"free_blocks",0,_wrap_CvSet_free_blocks_get,_wrap_CvSet_free_blocks_set,0,0},
{"first",0,_wrap_CvSet_first_get,_wrap_CvSet_first_set,0,0},
{"free_elems",0,_wrap_CvSet_free_elems_get,_wrap_CvSet_free_elems_set,0,0},
{"active_count",0,_wrap_CvSet_active_count_get,_wrap_CvSet_active_count_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSet_base_names[] = {0};
static const swig_type_info *swig_CvSet_base[] = {0};
static swig_octave_class _wrap_class_CvSet = {"CvSet", &SWIGTYPE_p_CvSet,0,_wrap_new_CvSet,0,_wrap_delete_CvSet,swig_CvSet_members,swig_CvSet_base_names,swig_CvSet_base };

static octave_value_list _wrap_CvGraphEdge_flags_set (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphEdge_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphEdge_flags_set" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraphEdge_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphEdge_flags_get (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraphEdge_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphEdge_flags_get" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphEdge_weight_set (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphEdge_weight_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphEdge_weight_set" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraphEdge_weight_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->weight = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphEdge_weight_get (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvGraphEdge_weight_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphEdge_weight_get" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  result = (float) ((arg1)->weight);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphEdge_next_set (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  CvGraphEdge **arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphEdge_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphEdge_next_set" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraphEdge_next_set" "', argument " "2"" of type '" "CvGraphEdge *[2]""'"); 
  } 
  arg2 = (CvGraphEdge **)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) arg1->next[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""next""' of type '""CvGraphEdge *[2]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphEdge_next_get (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphEdge **result = 0 ;
  
  if (!SWIG_check_num_args("CvGraphEdge_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphEdge_next_get" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  result = (CvGraphEdge **)(CvGraphEdge **) ((arg1)->next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_CvGraphEdge, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphEdge_vtx_set (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  CvGraphVtx **arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphEdge_vtx_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphEdge_vtx_set" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraphEdge_vtx_set" "', argument " "2"" of type '" "CvGraphVtx *[2]""'"); 
  } 
  arg2 = (CvGraphVtx **)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) arg1->vtx[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""vtx""' of type '""CvGraphVtx *[2]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphEdge_vtx_get (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphVtx **result = 0 ;
  
  if (!SWIG_check_num_args("CvGraphEdge_vtx_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphEdge_vtx_get" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  result = (CvGraphVtx **)(CvGraphVtx **) ((arg1)->vtx);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_CvGraphVtx, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvGraphEdge (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphEdge *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvGraphEdge",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvGraphEdge *)new CvGraphEdge(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphEdge, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvGraphEdge (const octave_value_list& args, int nargout) {
  CvGraphEdge *arg1 = (CvGraphEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvGraphEdge",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphEdge, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvGraphEdge" "', argument " "1"" of type '" "CvGraphEdge *""'"); 
  }
  arg1 = (CvGraphEdge *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvGraphEdge_members[] = {
{"flags",0,_wrap_CvGraphEdge_flags_get,_wrap_CvGraphEdge_flags_set,0,0},
{"weight",0,_wrap_CvGraphEdge_weight_get,_wrap_CvGraphEdge_weight_set,0,0},
{"next",0,_wrap_CvGraphEdge_next_get,_wrap_CvGraphEdge_next_set,0,0},
{"vtx",0,_wrap_CvGraphEdge_vtx_get,_wrap_CvGraphEdge_vtx_set,0,0},
{0,0,0,0}
};
static const char *swig_CvGraphEdge_base_names[] = {0};
static const swig_type_info *swig_CvGraphEdge_base[] = {0};
static swig_octave_class _wrap_class_CvGraphEdge = {"CvGraphEdge", &SWIGTYPE_p_CvGraphEdge,0,_wrap_new_CvGraphEdge,0,_wrap_delete_CvGraphEdge,swig_CvGraphEdge_members,swig_CvGraphEdge_base_names,swig_CvGraphEdge_base };

static octave_value_list _wrap_CvGraphVtx_flags_set (const octave_value_list& args, int nargout) {
  CvGraphVtx *arg1 = (CvGraphVtx *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphVtx_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphVtx_flags_set" "', argument " "1"" of type '" "CvGraphVtx *""'"); 
  }
  arg1 = (CvGraphVtx *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraphVtx_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphVtx_flags_get (const octave_value_list& args, int nargout) {
  CvGraphVtx *arg1 = (CvGraphVtx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraphVtx_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphVtx_flags_get" "', argument " "1"" of type '" "CvGraphVtx *""'"); 
  }
  arg1 = (CvGraphVtx *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphVtx_first_set (const octave_value_list& args, int nargout) {
  CvGraphVtx *arg1 = (CvGraphVtx *) 0 ;
  CvGraphEdge *arg2 = (CvGraphEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphVtx_first_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphVtx_first_set" "', argument " "1"" of type '" "CvGraphVtx *""'"); 
  }
  arg1 = (CvGraphVtx *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphEdge, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraphVtx_first_set" "', argument " "2"" of type '" "CvGraphEdge *""'"); 
  }
  arg2 = (CvGraphEdge *)(argp2);
  if (arg1) (arg1)->first = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphVtx_first_get (const octave_value_list& args, int nargout) {
  CvGraphVtx *arg1 = (CvGraphVtx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphEdge *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraphVtx_first_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphVtx_first_get" "', argument " "1"" of type '" "CvGraphVtx *""'"); 
  }
  arg1 = (CvGraphVtx *)(argp1);
  result = (CvGraphEdge *) ((arg1)->first);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvGraphVtx (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphVtx *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvGraphVtx",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvGraphVtx *)new CvGraphVtx(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphVtx, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvGraphVtx (const octave_value_list& args, int nargout) {
  CvGraphVtx *arg1 = (CvGraphVtx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvGraphVtx",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvGraphVtx" "', argument " "1"" of type '" "CvGraphVtx *""'"); 
  }
  arg1 = (CvGraphVtx *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvGraphVtx_members[] = {
{"flags",0,_wrap_CvGraphVtx_flags_get,_wrap_CvGraphVtx_flags_set,0,0},
{"first",0,_wrap_CvGraphVtx_first_get,_wrap_CvGraphVtx_first_set,0,0},
{0,0,0,0}
};
static const char *swig_CvGraphVtx_base_names[] = {0};
static const swig_type_info *swig_CvGraphVtx_base[] = {0};
static swig_octave_class _wrap_class_CvGraphVtx = {"CvGraphVtx", &SWIGTYPE_p_CvGraphVtx,0,_wrap_new_CvGraphVtx,0,_wrap_delete_CvGraphVtx,swig_CvGraphVtx_members,swig_CvGraphVtx_base_names,swig_CvGraphVtx_base };

static octave_value_list _wrap_CvGraphVtx2D_flags_set (const octave_value_list& args, int nargout) {
  CvGraphVtx2D *arg1 = (CvGraphVtx2D *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphVtx2D_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphVtx2D_flags_set" "', argument " "1"" of type '" "CvGraphVtx2D *""'"); 
  }
  arg1 = (CvGraphVtx2D *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraphVtx2D_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphVtx2D_flags_get (const octave_value_list& args, int nargout) {
  CvGraphVtx2D *arg1 = (CvGraphVtx2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraphVtx2D_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphVtx2D_flags_get" "', argument " "1"" of type '" "CvGraphVtx2D *""'"); 
  }
  arg1 = (CvGraphVtx2D *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphVtx2D_first_set (const octave_value_list& args, int nargout) {
  CvGraphVtx2D *arg1 = (CvGraphVtx2D *) 0 ;
  CvGraphEdge *arg2 = (CvGraphEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphVtx2D_first_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphVtx2D_first_set" "', argument " "1"" of type '" "CvGraphVtx2D *""'"); 
  }
  arg1 = (CvGraphVtx2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphEdge, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraphVtx2D_first_set" "', argument " "2"" of type '" "CvGraphEdge *""'"); 
  }
  arg2 = (CvGraphEdge *)(argp2);
  if (arg1) (arg1)->first = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphVtx2D_first_get (const octave_value_list& args, int nargout) {
  CvGraphVtx2D *arg1 = (CvGraphVtx2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphEdge *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraphVtx2D_first_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphVtx2D_first_get" "', argument " "1"" of type '" "CvGraphVtx2D *""'"); 
  }
  arg1 = (CvGraphVtx2D *)(argp1);
  result = (CvGraphEdge *) ((arg1)->first);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphVtx2D_ptr_set (const octave_value_list& args, int nargout) {
  CvGraphVtx2D *arg1 = (CvGraphVtx2D *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphVtx2D_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphVtx2D_ptr_set" "', argument " "1"" of type '" "CvGraphVtx2D *""'"); 
  }
  arg1 = (CvGraphVtx2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint2D32f, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraphVtx2D_ptr_set" "', argument " "2"" of type '" "CvPoint2D32f *""'"); 
  }
  arg2 = (CvPoint2D32f *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphVtx2D_ptr_get (const octave_value_list& args, int nargout) {
  CvGraphVtx2D *arg1 = (CvGraphVtx2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraphVtx2D_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphVtx2D_ptr_get" "', argument " "1"" of type '" "CvGraphVtx2D *""'"); 
  }
  arg1 = (CvGraphVtx2D *)(argp1);
  result = (CvPoint2D32f *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvGraphVtx2D (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphVtx2D *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvGraphVtx2D",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvGraphVtx2D *)new CvGraphVtx2D(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphVtx2D, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvGraphVtx2D (const octave_value_list& args, int nargout) {
  CvGraphVtx2D *arg1 = (CvGraphVtx2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvGraphVtx2D",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphVtx2D, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvGraphVtx2D" "', argument " "1"" of type '" "CvGraphVtx2D *""'"); 
  }
  arg1 = (CvGraphVtx2D *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvGraphVtx2D_members[] = {
{"flags",0,_wrap_CvGraphVtx2D_flags_get,_wrap_CvGraphVtx2D_flags_set,0,0},
{"first",0,_wrap_CvGraphVtx2D_first_get,_wrap_CvGraphVtx2D_first_set,0,0},
{"ptr",0,_wrap_CvGraphVtx2D_ptr_get,_wrap_CvGraphVtx2D_ptr_set,0,0},
{0,0,0,0}
};
static const char *swig_CvGraphVtx2D_base_names[] = {0};
static const swig_type_info *swig_CvGraphVtx2D_base[] = {0};
static swig_octave_class _wrap_class_CvGraphVtx2D = {"CvGraphVtx2D", &SWIGTYPE_p_CvGraphVtx2D,0,_wrap_new_CvGraphVtx2D,0,_wrap_delete_CvGraphVtx2D,swig_CvGraphVtx2D_members,swig_CvGraphVtx2D_base_names,swig_CvGraphVtx2D_base };

static octave_value_list _wrap_CvGraph_flags_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraph_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_flags_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraph_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_header_size_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraph_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_header_size_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraph_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_h_prev_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_h_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_h_prev_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_h_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (CvSeq *) ((arg1)->h_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_h_next_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_h_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_h_next_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_h_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (CvSeq *) ((arg1)->h_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_v_prev_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_v_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_v_prev_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_v_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (CvSeq *) ((arg1)->v_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_v_next_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_v_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_v_next_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_v_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (CvSeq *) ((arg1)->v_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_total_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_total_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraph_total_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->total = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_total_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraph_total_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (int) ((arg1)->total);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_elem_size_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_elem_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraph_elem_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->elem_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_elem_size_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraph_elem_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (int) ((arg1)->elem_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_block_max_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_block_max_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraph_block_max_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_max = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_block_max_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_block_max_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (schar *) ((arg1)->block_max);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_ptr_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraph_ptr_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_ptr_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (schar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_delta_elems_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_delta_elems_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraph_delta_elems_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->delta_elems = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_delta_elems_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraph_delta_elems_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (int) ((arg1)->delta_elems);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_storage_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_storage_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraph_storage_set" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (arg1) (arg1)->storage = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_storage_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStorage *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_storage_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (CvMemStorage *) ((arg1)->storage);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_free_blocks_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_free_blocks_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraph_free_blocks_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->free_blocks = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_free_blocks_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_free_blocks_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (CvSeqBlock *) ((arg1)->free_blocks);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_first_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_first_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraph_first_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->first = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_first_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_first_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (CvSeqBlock *) ((arg1)->first);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_free_elems_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvSetElem *arg2 = (CvSetElem *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_free_elems_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSetElem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraph_free_elems_set" "', argument " "2"" of type '" "CvSetElem *""'"); 
  }
  arg2 = (CvSetElem *)(argp2);
  if (arg1) (arg1)->free_elems = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_free_elems_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSetElem *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_free_elems_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (CvSetElem *) ((arg1)->free_elems);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSetElem, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_active_count_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_active_count_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraph_active_count_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->active_count = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_active_count_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraph_active_count_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (int) ((arg1)->active_count);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_edges_set (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvSet *arg2 = (CvSet *) 0 ;
  void *ptr1 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraph_edges_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg2 = (CvSet *)ptr2;
  }
  if (arg1) (arg1)->edges = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraph_edges_get (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSet *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraph_edges_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  result = (CvSet *) ((arg1)->edges);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSet, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvGraph (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraph *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvGraph",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvGraph *)new CvGraph(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraph, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvGraph (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvGraph",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvGraph_members[] = {
{"flags",0,_wrap_CvGraph_flags_get,_wrap_CvGraph_flags_set,0,0},
{"header_size",0,_wrap_CvGraph_header_size_get,_wrap_CvGraph_header_size_set,0,0},
{"h_prev",0,_wrap_CvGraph_h_prev_get,_wrap_CvGraph_h_prev_set,0,0},
{"h_next",0,_wrap_CvGraph_h_next_get,_wrap_CvGraph_h_next_set,0,0},
{"v_prev",0,_wrap_CvGraph_v_prev_get,_wrap_CvGraph_v_prev_set,0,0},
{"v_next",0,_wrap_CvGraph_v_next_get,_wrap_CvGraph_v_next_set,0,0},
{"total",0,_wrap_CvGraph_total_get,_wrap_CvGraph_total_set,0,0},
{"elem_size",0,_wrap_CvGraph_elem_size_get,_wrap_CvGraph_elem_size_set,0,0},
{"block_max",0,_wrap_CvGraph_block_max_get,_wrap_CvGraph_block_max_set,0,0},
{"ptr",0,_wrap_CvGraph_ptr_get,_wrap_CvGraph_ptr_set,0,0},
{"delta_elems",0,_wrap_CvGraph_delta_elems_get,_wrap_CvGraph_delta_elems_set,0,0},
{"storage",0,_wrap_CvGraph_storage_get,_wrap_CvGraph_storage_set,0,0},
{"free_blocks",0,_wrap_CvGraph_free_blocks_get,_wrap_CvGraph_free_blocks_set,0,0},
{"first",0,_wrap_CvGraph_first_get,_wrap_CvGraph_first_set,0,0},
{"free_elems",0,_wrap_CvGraph_free_elems_get,_wrap_CvGraph_free_elems_set,0,0},
{"active_count",0,_wrap_CvGraph_active_count_get,_wrap_CvGraph_active_count_set,0,0},
{"edges",0,_wrap_CvGraph_edges_get,_wrap_CvGraph_edges_set,0,0},
{0,0,0,0}
};
static const char *swig_CvGraph_base_names[] = {0};
static const swig_type_info *swig_CvGraph_base[] = {0};
static swig_octave_class _wrap_class_CvGraph = {"CvGraph", &SWIGTYPE_p_CvGraph,0,_wrap_new_CvGraph,0,_wrap_delete_CvGraph,swig_CvGraph_members,swig_CvGraph_base_names,swig_CvGraph_base };

static octave_value_list _wrap_CvChain_flags_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_flags_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvChain_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_flags_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvChain_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_flags_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_header_size_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_header_size_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvChain_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_header_size_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvChain_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_header_size_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_h_prev_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_h_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_h_prev_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_h_prev_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvChain_h_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_h_prev_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (CvSeq *) ((arg1)->h_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_h_next_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_h_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_h_next_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_h_next_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvChain_h_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_h_next_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (CvSeq *) ((arg1)->h_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_v_prev_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_v_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_v_prev_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_v_prev_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvChain_v_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_v_prev_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (CvSeq *) ((arg1)->v_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_v_next_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_v_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_v_next_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_v_next_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvChain_v_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_v_next_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (CvSeq *) ((arg1)->v_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_total_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_total_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_total_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvChain_total_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->total = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_total_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvChain_total_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_total_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (int) ((arg1)->total);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_elem_size_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_elem_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_elem_size_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvChain_elem_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->elem_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_elem_size_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvChain_elem_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_elem_size_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (int) ((arg1)->elem_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_block_max_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_block_max_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_block_max_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChain_block_max_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_max = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_block_max_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvChain_block_max_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_block_max_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (schar *) ((arg1)->block_max);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_ptr_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_ptr_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChain_ptr_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_ptr_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvChain_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_ptr_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (schar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_delta_elems_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_delta_elems_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_delta_elems_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvChain_delta_elems_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->delta_elems = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_delta_elems_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvChain_delta_elems_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_delta_elems_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (int) ((arg1)->delta_elems);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_storage_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_storage_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_storage_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChain_storage_set" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (arg1) (arg1)->storage = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_storage_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStorage *result = 0 ;
  
  if (!SWIG_check_num_args("CvChain_storage_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_storage_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (CvMemStorage *) ((arg1)->storage);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_free_blocks_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_free_blocks_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_free_blocks_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChain_free_blocks_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->free_blocks = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_free_blocks_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvChain_free_blocks_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_free_blocks_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (CvSeqBlock *) ((arg1)->free_blocks);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_first_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_first_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_first_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChain_first_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->first = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_first_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvChain_first_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_first_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (CvSeqBlock *) ((arg1)->first);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_origin_set (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChain_origin_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_origin_set" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChain_origin_set" "', argument " "2"" of type '" "CvPoint *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  if (arg1) (arg1)->origin = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChain_origin_get (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvChain_origin_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChain_origin_get" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  result = (CvPoint *)& ((arg1)->origin);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvChain (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvChain *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvChain",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvChain *)new CvChain(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvChain, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvChain (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvChain",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvChain" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvChain_members[] = {
{"flags",0,_wrap_CvChain_flags_get,_wrap_CvChain_flags_set,0,0},
{"header_size",0,_wrap_CvChain_header_size_get,_wrap_CvChain_header_size_set,0,0},
{"h_prev",0,_wrap_CvChain_h_prev_get,_wrap_CvChain_h_prev_set,0,0},
{"h_next",0,_wrap_CvChain_h_next_get,_wrap_CvChain_h_next_set,0,0},
{"v_prev",0,_wrap_CvChain_v_prev_get,_wrap_CvChain_v_prev_set,0,0},
{"v_next",0,_wrap_CvChain_v_next_get,_wrap_CvChain_v_next_set,0,0},
{"total",0,_wrap_CvChain_total_get,_wrap_CvChain_total_set,0,0},
{"elem_size",0,_wrap_CvChain_elem_size_get,_wrap_CvChain_elem_size_set,0,0},
{"block_max",0,_wrap_CvChain_block_max_get,_wrap_CvChain_block_max_set,0,0},
{"ptr",0,_wrap_CvChain_ptr_get,_wrap_CvChain_ptr_set,0,0},
{"delta_elems",0,_wrap_CvChain_delta_elems_get,_wrap_CvChain_delta_elems_set,0,0},
{"storage",0,_wrap_CvChain_storage_get,_wrap_CvChain_storage_set,0,0},
{"free_blocks",0,_wrap_CvChain_free_blocks_get,_wrap_CvChain_free_blocks_set,0,0},
{"first",0,_wrap_CvChain_first_get,_wrap_CvChain_first_set,0,0},
{"origin",0,_wrap_CvChain_origin_get,_wrap_CvChain_origin_set,0,0},
{0,0,0,0}
};
static const char *swig_CvChain_base_names[] = {0};
static const swig_type_info *swig_CvChain_base[] = {0};
static swig_octave_class _wrap_class_CvChain = {"CvChain", &SWIGTYPE_p_CvChain,0,_wrap_new_CvChain,0,_wrap_delete_CvChain,swig_CvChain_members,swig_CvChain_base_names,swig_CvChain_base };

static octave_value_list _wrap_CvContour_flags_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_flags_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContour_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_flags_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContour_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_flags_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_header_size_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_header_size_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContour_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_header_size_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContour_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_header_size_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_h_prev_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_h_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_h_prev_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_h_prev_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_h_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_h_prev_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (CvSeq *) ((arg1)->h_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_h_next_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_h_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_h_next_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_h_next_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_h_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_h_next_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (CvSeq *) ((arg1)->h_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_v_prev_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_v_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_v_prev_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_v_prev_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_v_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_v_prev_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (CvSeq *) ((arg1)->v_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_v_next_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_v_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_v_next_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_v_next_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_v_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_v_next_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (CvSeq *) ((arg1)->v_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_total_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_total_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_total_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContour_total_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->total = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_total_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContour_total_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_total_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (int) ((arg1)->total);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_elem_size_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_elem_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_elem_size_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContour_elem_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->elem_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_elem_size_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContour_elem_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_elem_size_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (int) ((arg1)->elem_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_block_max_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_block_max_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_block_max_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContour_block_max_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_max = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_block_max_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_block_max_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_block_max_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (schar *) ((arg1)->block_max);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_ptr_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_ptr_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContour_ptr_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_ptr_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_ptr_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (schar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_delta_elems_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_delta_elems_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_delta_elems_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContour_delta_elems_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->delta_elems = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_delta_elems_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContour_delta_elems_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_delta_elems_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (int) ((arg1)->delta_elems);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_storage_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_storage_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_storage_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContour_storage_set" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (arg1) (arg1)->storage = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_storage_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStorage *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_storage_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_storage_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (CvMemStorage *) ((arg1)->storage);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_free_blocks_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_free_blocks_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_free_blocks_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContour_free_blocks_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->free_blocks = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_free_blocks_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_free_blocks_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_free_blocks_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (CvSeqBlock *) ((arg1)->free_blocks);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_first_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_first_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_first_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContour_first_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->first = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_first_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_first_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_first_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (CvSeqBlock *) ((arg1)->first);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_rect_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  CvRect *arg2 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_rect_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_rect_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContour_rect_set" "', argument " "2"" of type '" "CvRect *""'"); 
  }
  arg2 = (CvRect *)(argp2);
  if (arg1) (arg1)->rect = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_rect_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_rect_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_rect_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (CvRect *)& ((arg1)->rect);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvRect, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_color_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_color_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_color_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContour_color_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->color = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_color_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContour_color_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_color_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (int) ((arg1)->color);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_reserved_set (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  int *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContour_reserved_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_reserved_set" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContour_reserved_set" "', argument " "2"" of type '" "int [3]""'"); 
  } 
  arg2 = (int *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)3; ++ii) arg1->reserved[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""reserved""' of type '""int [3]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContour_reserved_get (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvContour_reserved_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContour_reserved_get" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  result = (int *)(int *) ((arg1)->reserved);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvContour (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvContour *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvContour",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvContour *)new CvContour(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvContour, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvContour (const octave_value_list& args, int nargout) {
  CvContour *arg1 = (CvContour *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvContour",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContour, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvContour" "', argument " "1"" of type '" "CvContour *""'"); 
  }
  arg1 = (CvContour *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvContour_members[] = {
{"flags",0,_wrap_CvContour_flags_get,_wrap_CvContour_flags_set,0,0},
{"header_size",0,_wrap_CvContour_header_size_get,_wrap_CvContour_header_size_set,0,0},
{"h_prev",0,_wrap_CvContour_h_prev_get,_wrap_CvContour_h_prev_set,0,0},
{"h_next",0,_wrap_CvContour_h_next_get,_wrap_CvContour_h_next_set,0,0},
{"v_prev",0,_wrap_CvContour_v_prev_get,_wrap_CvContour_v_prev_set,0,0},
{"v_next",0,_wrap_CvContour_v_next_get,_wrap_CvContour_v_next_set,0,0},
{"total",0,_wrap_CvContour_total_get,_wrap_CvContour_total_set,0,0},
{"elem_size",0,_wrap_CvContour_elem_size_get,_wrap_CvContour_elem_size_set,0,0},
{"block_max",0,_wrap_CvContour_block_max_get,_wrap_CvContour_block_max_set,0,0},
{"ptr",0,_wrap_CvContour_ptr_get,_wrap_CvContour_ptr_set,0,0},
{"delta_elems",0,_wrap_CvContour_delta_elems_get,_wrap_CvContour_delta_elems_set,0,0},
{"storage",0,_wrap_CvContour_storage_get,_wrap_CvContour_storage_set,0,0},
{"free_blocks",0,_wrap_CvContour_free_blocks_get,_wrap_CvContour_free_blocks_set,0,0},
{"first",0,_wrap_CvContour_first_get,_wrap_CvContour_first_set,0,0},
{"rect",0,_wrap_CvContour_rect_get,_wrap_CvContour_rect_set,0,0},
{"color",0,_wrap_CvContour_color_get,_wrap_CvContour_color_set,0,0},
{"reserved",0,_wrap_CvContour_reserved_get,_wrap_CvContour_reserved_set,0,0},
{0,0,0,0}
};
static const char *swig_CvContour_base_names[] = {0};
static const swig_type_info *swig_CvContour_base[] = {0};
static swig_octave_class _wrap_class_CvContour = {"CvContour", &SWIGTYPE_p_CvContour,0,_wrap_new_CvContour,0,_wrap_delete_CvContour,swig_CvContour_members,swig_CvContour_base_names,swig_CvContour_base };

static octave_value_list _wrap_CvSeqWriter_header_size_set (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqWriter_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_header_size_set" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeqWriter_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_header_size_get (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSeqWriter_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_header_size_get" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_seq_set (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqWriter_seq_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_seq_set" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->seq = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_seq_get (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqWriter_seq_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_seq_get" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  result = (CvSeq *) ((arg1)->seq);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_block_set (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqWriter_block_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_block_set" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqWriter_block_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->block = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_block_get (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqWriter_block_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_block_get" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  result = (CvSeqBlock *) ((arg1)->block);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_ptr_set (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqWriter_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_ptr_set" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqWriter_ptr_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_ptr_get (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqWriter_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_ptr_get" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  result = (schar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_block_min_set (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqWriter_block_min_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_block_min_set" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqWriter_block_min_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_min = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_block_min_get (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqWriter_block_min_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_block_min_get" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  result = (schar *) ((arg1)->block_min);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_block_max_set (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqWriter_block_max_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_block_max_set" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqWriter_block_max_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_max = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqWriter_block_max_get (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqWriter_block_max_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqWriter_block_max_get" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  result = (schar *) ((arg1)->block_max);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeqWriter (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqWriter *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeqWriter",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSeqWriter *)new CvSeqWriter(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqWriter, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeqWriter (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeqWriter",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeqWriter" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeqWriter_members[] = {
{"header_size",0,_wrap_CvSeqWriter_header_size_get,_wrap_CvSeqWriter_header_size_set,0,0},
{"seq",0,_wrap_CvSeqWriter_seq_get,_wrap_CvSeqWriter_seq_set,0,0},
{"block",0,_wrap_CvSeqWriter_block_get,_wrap_CvSeqWriter_block_set,0,0},
{"ptr",0,_wrap_CvSeqWriter_ptr_get,_wrap_CvSeqWriter_ptr_set,0,0},
{"block_min",0,_wrap_CvSeqWriter_block_min_get,_wrap_CvSeqWriter_block_min_set,0,0},
{"block_max",0,_wrap_CvSeqWriter_block_max_get,_wrap_CvSeqWriter_block_max_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSeqWriter_base_names[] = {0};
static const swig_type_info *swig_CvSeqWriter_base[] = {0};
static swig_octave_class _wrap_class_CvSeqWriter = {"CvSeqWriter", &SWIGTYPE_p_CvSeqWriter,0,_wrap_new_CvSeqWriter,0,_wrap_delete_CvSeqWriter,swig_CvSeqWriter_members,swig_CvSeqWriter_base_names,swig_CvSeqWriter_base };

static octave_value_list _wrap_CvSeqReader_header_size_set (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqReader_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_header_size_set" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeqReader_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_header_size_get (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSeqReader_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_header_size_get" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_seq_set (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqReader_seq_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_seq_set" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->seq = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_seq_get (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqReader_seq_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_seq_get" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  result = (CvSeq *) ((arg1)->seq);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_block_set (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqReader_block_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_block_set" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqReader_block_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->block = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_block_get (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqReader_block_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_block_get" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  result = (CvSeqBlock *) ((arg1)->block);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_ptr_set (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqReader_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_ptr_set" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqReader_ptr_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_ptr_get (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqReader_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_ptr_get" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  result = (schar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_block_min_set (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqReader_block_min_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_block_min_set" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqReader_block_min_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_min = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_block_min_get (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqReader_block_min_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_block_min_get" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  result = (schar *) ((arg1)->block_min);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_block_max_set (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqReader_block_max_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_block_max_set" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqReader_block_max_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_max = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_block_max_get (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqReader_block_max_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_block_max_get" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  result = (schar *) ((arg1)->block_max);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_delta_index_set (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqReader_delta_index_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_delta_index_set" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeqReader_delta_index_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->delta_index = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_delta_index_get (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSeqReader_delta_index_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_delta_index_get" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  result = (int) ((arg1)->delta_index);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_prev_elem_set (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeqReader_prev_elem_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_prev_elem_set" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeqReader_prev_elem_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->prev_elem = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeqReader_prev_elem_get (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeqReader_prev_elem_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeqReader_prev_elem_get" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  result = (schar *) ((arg1)->prev_elem);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeqReader (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqReader *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeqReader",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSeqReader *)new CvSeqReader(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqReader, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeqReader (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeqReader",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeqReader" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeqReader_members[] = {
{"header_size",0,_wrap_CvSeqReader_header_size_get,_wrap_CvSeqReader_header_size_set,0,0},
{"seq",0,_wrap_CvSeqReader_seq_get,_wrap_CvSeqReader_seq_set,0,0},
{"block",0,_wrap_CvSeqReader_block_get,_wrap_CvSeqReader_block_set,0,0},
{"ptr",0,_wrap_CvSeqReader_ptr_get,_wrap_CvSeqReader_ptr_set,0,0},
{"block_min",0,_wrap_CvSeqReader_block_min_get,_wrap_CvSeqReader_block_min_set,0,0},
{"block_max",0,_wrap_CvSeqReader_block_max_get,_wrap_CvSeqReader_block_max_set,0,0},
{"delta_index",0,_wrap_CvSeqReader_delta_index_get,_wrap_CvSeqReader_delta_index_set,0,0},
{"prev_elem",0,_wrap_CvSeqReader_prev_elem_get,_wrap_CvSeqReader_prev_elem_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSeqReader_base_names[] = {0};
static const swig_type_info *swig_CvSeqReader_base[] = {0};
static swig_octave_class _wrap_class_CvSeqReader = {"CvSeqReader", &SWIGTYPE_p_CvSeqReader,0,_wrap_new_CvSeqReader,0,_wrap_delete_CvSeqReader,swig_CvSeqReader_members,swig_CvSeqReader_base_names,swig_CvSeqReader_base };

static octave_value_list _wrap_CvAttrList_attr_set (const octave_value_list& args, int nargout) {
  CvAttrList *arg1 = (CvAttrList *) 0 ;
  char **arg2 = (char **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *vptr2 ;
  char *buffer2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvAttrList_attr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAttrList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvAttrList_attr_set" "', argument " "1"" of type '" "CvAttrList *""'"); 
  }
  arg1 = (CvAttrList *)(argp1);
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_char, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (char *) vptr2;
    arg2=&buffer2;
  }
  if (arg1) (arg1)->attr = (char const **)arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvAttrList_attr_get (const octave_value_list& args, int nargout) {
  CvAttrList *arg1 = (CvAttrList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char **result = 0 ;
  
  if (!SWIG_check_num_args("CvAttrList_attr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAttrList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvAttrList_attr_get" "', argument " "1"" of type '" "CvAttrList *""'"); 
  }
  arg1 = (CvAttrList *)(argp1);
  result = (char **) ((arg1)->attr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvAttrList_next_set (const octave_value_list& args, int nargout) {
  CvAttrList *arg1 = (CvAttrList *) 0 ;
  CvAttrList *arg2 = (CvAttrList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvAttrList_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAttrList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvAttrList_next_set" "', argument " "1"" of type '" "CvAttrList *""'"); 
  }
  arg1 = (CvAttrList *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvAttrList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvAttrList_next_set" "', argument " "2"" of type '" "CvAttrList *""'"); 
  }
  arg2 = (CvAttrList *)(argp2);
  if (arg1) (arg1)->next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvAttrList_next_get (const octave_value_list& args, int nargout) {
  CvAttrList *arg1 = (CvAttrList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvAttrList *result = 0 ;
  
  if (!SWIG_check_num_args("CvAttrList_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAttrList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvAttrList_next_get" "', argument " "1"" of type '" "CvAttrList *""'"); 
  }
  arg1 = (CvAttrList *)(argp1);
  result = (CvAttrList *) ((arg1)->next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvAttrList, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvAttrList (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvAttrList *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvAttrList",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvAttrList *)new CvAttrList(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvAttrList, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvAttrList (const octave_value_list& args, int nargout) {
  CvAttrList *arg1 = (CvAttrList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvAttrList",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAttrList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvAttrList" "', argument " "1"" of type '" "CvAttrList *""'"); 
  }
  arg1 = (CvAttrList *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvAttrList_members[] = {
{"attr",0,_wrap_CvAttrList_attr_get,_wrap_CvAttrList_attr_set,0,0},
{"next",0,_wrap_CvAttrList_next_get,_wrap_CvAttrList_next_set,0,0},
{0,0,0,0}
};
static const char *swig_CvAttrList_base_names[] = {0};
static const swig_type_info *swig_CvAttrList_base[] = {0};
static swig_octave_class _wrap_class_CvAttrList = {"CvAttrList", &SWIGTYPE_p_CvAttrList,0,_wrap_new_CvAttrList,0,_wrap_delete_CvAttrList,swig_CvAttrList_members,swig_CvAttrList_base_names,swig_CvAttrList_base };

static octave_value_list _wrap_cvAttrList__SWIG_0 (const octave_value_list& args, int nargout) {
  char **arg1 = (char **) 0 ;
  CvAttrList *arg2 = (CvAttrList *) 0 ;
  void *vptr1 ;
  char *buffer1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvAttrList result;
  
  if (!SWIG_check_num_args("cvAttrList",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_char, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (char *) vptr1;
    arg1=&buffer1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvAttrList, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvAttrList" "', argument " "2"" of type '" "CvAttrList *""'"); 
  }
  arg2 = (CvAttrList *)(argp2);
  {
    try {
      result = cvAttrList((char const **)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvAttrList((const CvAttrList&)(result))), SWIGTYPE_p_CvAttrList, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvAttrList__SWIG_1 (const octave_value_list& args, int nargout) {
  char **arg1 = (char **) 0 ;
  void *vptr1 ;
  char *buffer1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvAttrList result;
  
  if (!SWIG_check_num_args("cvAttrList",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_char, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (char *) vptr1;
    arg1=&buffer1;
  }
  {
    try {
      result = cvAttrList((char const **)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvAttrList((const CvAttrList&)(result))), SWIGTYPE_p_CvAttrList, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvAttrList__SWIG_2 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvAttrList result;
  
  if (!SWIG_check_num_args("cvAttrList",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = cvAttrList(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvAttrList((const CvAttrList&)(result))), SWIGTYPE_p_CvAttrList, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvAttrList (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 0) {
    return _wrap_cvAttrList__SWIG_2(args, nargout);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_p_char, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_cvAttrList__SWIG_1(args, nargout);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_p_char, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvAttrList, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_cvAttrList__SWIG_0(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvString_len_set (const octave_value_list& args, int nargout) {
  CvString *arg1 = (CvString *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvString_len_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvString, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvString_len_set" "', argument " "1"" of type '" "CvString *""'"); 
  }
  arg1 = (CvString *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvString_len_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->len = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvString_len_get (const octave_value_list& args, int nargout) {
  CvString *arg1 = (CvString *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvString_len_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvString, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvString_len_get" "', argument " "1"" of type '" "CvString *""'"); 
  }
  arg1 = (CvString *)(argp1);
  result = (int) ((arg1)->len);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvString_ptr_set (const octave_value_list& args, int nargout) {
  CvString *arg1 = (CvString *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvString_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvString, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvString_ptr_set" "', argument " "1"" of type '" "CvString *""'"); 
  }
  arg1 = (CvString *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvString_ptr_set" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = (char *)(buf2);
  if (arg1->ptr) delete[] arg1->ptr;
  if (arg2) {
    size_t size = strlen((const char *)(arg2)) + 1;
    arg1->ptr = (char *)(char*)(memcpy((new char[size]), (const char *)(arg2), sizeof(char)*(size)));
  } else {
    arg1->ptr = 0;
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_CvString_ptr_get (const octave_value_list& args, int nargout) {
  CvString *arg1 = (CvString *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvString_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvString, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvString_ptr_get" "', argument " "1"" of type '" "CvString *""'"); 
  }
  arg1 = (CvString *)(argp1);
  result = (char *) ((arg1)->ptr);
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvString (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvString *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvString",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvString *)new CvString(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvString, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvString (const octave_value_list& args, int nargout) {
  CvString *arg1 = (CvString *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvString",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvString, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvString" "', argument " "1"" of type '" "CvString *""'"); 
  }
  arg1 = (CvString *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvString_members[] = {
{"len",0,_wrap_CvString_len_get,_wrap_CvString_len_set,0,0},
{"ptr",0,_wrap_CvString_ptr_get,_wrap_CvString_ptr_set,0,0},
{0,0,0,0}
};
static const char *swig_CvString_base_names[] = {0};
static const swig_type_info *swig_CvString_base[] = {0};
static swig_octave_class _wrap_class_CvString = {"CvString", &SWIGTYPE_p_CvString,0,_wrap_new_CvString,0,_wrap_delete_CvString,swig_CvString_members,swig_CvString_base_names,swig_CvString_base };

static octave_value_list _wrap_CvStringHashNode_hashval_set (const octave_value_list& args, int nargout) {
  CvStringHashNode *arg1 = (CvStringHashNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStringHashNode_hashval_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStringHashNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStringHashNode_hashval_set" "', argument " "1"" of type '" "CvStringHashNode *""'"); 
  }
  arg1 = (CvStringHashNode *)(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStringHashNode_hashval_set" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = (unsigned int)(val2);
  if (arg1) (arg1)->hashval = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStringHashNode_hashval_get (const octave_value_list& args, int nargout) {
  CvStringHashNode *arg1 = (CvStringHashNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  unsigned int result;
  
  if (!SWIG_check_num_args("CvStringHashNode_hashval_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStringHashNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStringHashNode_hashval_get" "', argument " "1"" of type '" "CvStringHashNode *""'"); 
  }
  arg1 = (CvStringHashNode *)(argp1);
  result = (unsigned int) ((arg1)->hashval);
  _outv = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStringHashNode_str_set (const octave_value_list& args, int nargout) {
  CvStringHashNode *arg1 = (CvStringHashNode *) 0 ;
  CvString *arg2 = (CvString *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStringHashNode_str_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStringHashNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStringHashNode_str_set" "', argument " "1"" of type '" "CvStringHashNode *""'"); 
  }
  arg1 = (CvStringHashNode *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvString, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStringHashNode_str_set" "', argument " "2"" of type '" "CvString *""'"); 
  }
  arg2 = (CvString *)(argp2);
  if (arg1) (arg1)->str = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStringHashNode_str_get (const octave_value_list& args, int nargout) {
  CvStringHashNode *arg1 = (CvStringHashNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvString *result = 0 ;
  
  if (!SWIG_check_num_args("CvStringHashNode_str_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStringHashNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStringHashNode_str_get" "', argument " "1"" of type '" "CvStringHashNode *""'"); 
  }
  arg1 = (CvStringHashNode *)(argp1);
  result = (CvString *)& ((arg1)->str);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvString, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStringHashNode_next_set (const octave_value_list& args, int nargout) {
  CvStringHashNode *arg1 = (CvStringHashNode *) 0 ;
  CvStringHashNode *arg2 = (CvStringHashNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStringHashNode_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStringHashNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStringHashNode_next_set" "', argument " "1"" of type '" "CvStringHashNode *""'"); 
  }
  arg1 = (CvStringHashNode *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvStringHashNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStringHashNode_next_set" "', argument " "2"" of type '" "CvStringHashNode *""'"); 
  }
  arg2 = (CvStringHashNode *)(argp2);
  if (arg1) (arg1)->next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStringHashNode_next_get (const octave_value_list& args, int nargout) {
  CvStringHashNode *arg1 = (CvStringHashNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStringHashNode *result = 0 ;
  
  if (!SWIG_check_num_args("CvStringHashNode_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStringHashNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStringHashNode_next_get" "', argument " "1"" of type '" "CvStringHashNode *""'"); 
  }
  arg1 = (CvStringHashNode *)(argp1);
  result = (CvStringHashNode *) ((arg1)->next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvStringHashNode, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvStringHashNode (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStringHashNode *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvStringHashNode",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvStringHashNode *)new CvStringHashNode(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvStringHashNode, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvStringHashNode (const octave_value_list& args, int nargout) {
  CvStringHashNode *arg1 = (CvStringHashNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvStringHashNode",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStringHashNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvStringHashNode" "', argument " "1"" of type '" "CvStringHashNode *""'"); 
  }
  arg1 = (CvStringHashNode *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvStringHashNode_members[] = {
{"hashval",0,_wrap_CvStringHashNode_hashval_get,_wrap_CvStringHashNode_hashval_set,0,0},
{"str",0,_wrap_CvStringHashNode_str_get,_wrap_CvStringHashNode_str_set,0,0},
{"next",0,_wrap_CvStringHashNode_next_get,_wrap_CvStringHashNode_next_set,0,0},
{0,0,0,0}
};
static const char *swig_CvStringHashNode_base_names[] = {0};
static const swig_type_info *swig_CvStringHashNode_base[] = {0};
static swig_octave_class _wrap_class_CvStringHashNode = {"CvStringHashNode", &SWIGTYPE_p_CvStringHashNode,0,_wrap_new_CvStringHashNode,0,_wrap_delete_CvStringHashNode,swig_CvStringHashNode_members,swig_CvStringHashNode_base_names,swig_CvStringHashNode_base };

static octave_value_list _wrap_CvFileNode_tag_set (const octave_value_list& args, int nargout) {
  CvFileNode *arg1 = (CvFileNode *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFileNode_tag_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_tag_set" "', argument " "1"" of type '" "CvFileNode *""'"); 
  }
  arg1 = (CvFileNode *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvFileNode_tag_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->tag = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_tag_get (const octave_value_list& args, int nargout) {
  CvFileNode *arg1 = (CvFileNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvFileNode_tag_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_tag_get" "', argument " "1"" of type '" "CvFileNode *""'"); 
  }
  arg1 = (CvFileNode *)(argp1);
  result = (int) ((arg1)->tag);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_info_set (const octave_value_list& args, int nargout) {
  CvFileNode *arg1 = (CvFileNode *) 0 ;
  CvTypeInfo *arg2 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFileNode_info_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_info_set" "', argument " "1"" of type '" "CvFileNode *""'"); 
  }
  arg1 = (CvFileNode *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvTypeInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvFileNode_info_set" "', argument " "2"" of type '" "CvTypeInfo *""'"); 
  }
  arg2 = (CvTypeInfo *)(argp2);
  if (arg1) (arg1)->info = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_info_get (const octave_value_list& args, int nargout) {
  CvFileNode *arg1 = (CvFileNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypeInfo *result = 0 ;
  
  if (!SWIG_check_num_args("CvFileNode_info_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_info_get" "', argument " "1"" of type '" "CvFileNode *""'"); 
  }
  arg1 = (CvFileNode *)(argp1);
  result = (CvTypeInfo *) ((arg1)->info);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_data_get (const octave_value_list& args, int nargout) {
  CvFileNode *arg1 = (CvFileNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFileNode_data *result = 0 ;
  
  if (!SWIG_check_num_args("CvFileNode_data_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_get" "', argument " "1"" of type '" "CvFileNode *""'"); 
  }
  arg1 = (CvFileNode *)(argp1);
  result = (CvFileNode_data *)& ((arg1)->data);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvFileNode (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFileNode *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvFileNode",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvFileNode *)new CvFileNode(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvFileNode, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvFileNode (const octave_value_list& args, int nargout) {
  CvFileNode *arg1 = (CvFileNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvFileNode",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvFileNode" "', argument " "1"" of type '" "CvFileNode *""'"); 
  }
  arg1 = (CvFileNode *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvFileNode_members[] = {
{"tag",0,_wrap_CvFileNode_tag_get,_wrap_CvFileNode_tag_set,0,0},
{"info",0,_wrap_CvFileNode_info_get,_wrap_CvFileNode_info_set,0,0},
{"data",0,_wrap_CvFileNode_data_get,octave_set_immutable,0,0},
{0,0,0,0}
};
static const char *swig_CvFileNode_base_names[] = {0};
static const swig_type_info *swig_CvFileNode_base[] = {0};
static swig_octave_class _wrap_class_CvFileNode = {"CvFileNode", &SWIGTYPE_p_CvFileNode,0,_wrap_new_CvFileNode,0,_wrap_delete_CvFileNode,swig_CvFileNode_members,swig_CvFileNode_base_names,swig_CvFileNode_base };

static octave_value_list _wrap_CvFileNode_data_f_set (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFileNode_data_f_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_f_set" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvFileNode_data_f_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->f = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_data_f_get (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvFileNode_data_f_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_f_get" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  result = (double) ((arg1)->f);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_data_i_set (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFileNode_data_i_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_i_set" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvFileNode_data_i_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->i = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_data_i_get (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvFileNode_data_i_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_i_get" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  result = (int) ((arg1)->i);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_data_str_set (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  CvString *arg2 = (CvString *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFileNode_data_str_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_str_set" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvString, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvFileNode_data_str_set" "', argument " "2"" of type '" "CvString *""'"); 
  }
  arg2 = (CvString *)(argp2);
  if (arg1) (arg1)->str = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_data_str_get (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvString *result = 0 ;
  
  if (!SWIG_check_num_args("CvFileNode_data_str_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_str_get" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  result = (CvString *)& ((arg1)->str);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvString, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_data_seq_set (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFileNode_data_seq_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_seq_set" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->seq = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_data_seq_get (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvFileNode_data_seq_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_seq_get" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  result = (CvSeq *) ((arg1)->seq);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_data_map_set (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  CvFileNodeHash *arg2 = (CvFileNodeHash *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFileNode_data_map_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_map_set" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGenericHash, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvFileNode_data_map_set" "', argument " "2"" of type '" "CvFileNodeHash *""'"); 
  }
  arg2 = (CvFileNodeHash *)(argp2);
  if (arg1) (arg1)->map = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFileNode_data_map_get (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFileNodeHash *result = 0 ;
  
  if (!SWIG_check_num_args("CvFileNode_data_map_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFileNode_data_map_get" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  result = (CvFileNodeHash *) ((arg1)->map);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGenericHash, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvFileNode_data (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFileNode_data *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvFileNode_data",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvFileNode_data *)new CvFileNode_data(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvFileNode_data, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvFileNode_data (const octave_value_list& args, int nargout) {
  CvFileNode_data *arg1 = (CvFileNode_data *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvFileNode_data",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode_data, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvFileNode_data" "', argument " "1"" of type '" "CvFileNode_data *""'"); 
  }
  arg1 = (CvFileNode_data *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvFileNode_data_members[] = {
{"f",0,_wrap_CvFileNode_data_f_get,_wrap_CvFileNode_data_f_set,0,0},
{"i",0,_wrap_CvFileNode_data_i_get,_wrap_CvFileNode_data_i_set,0,0},
{"str",0,_wrap_CvFileNode_data_str_get,_wrap_CvFileNode_data_str_set,0,0},
{"seq",0,_wrap_CvFileNode_data_seq_get,_wrap_CvFileNode_data_seq_set,0,0},
{"map",0,_wrap_CvFileNode_data_map_get,_wrap_CvFileNode_data_map_set,0,0},
{0,0,0,0}
};
static const char *swig_CvFileNode_data_base_names[] = {0};
static const swig_type_info *swig_CvFileNode_data_base[] = {0};
static swig_octave_class _wrap_class_CvFileNode_data = {"CvFileNode_data", &SWIGTYPE_p_CvFileNode_data,0,_wrap_new_CvFileNode_data,0,_wrap_delete_CvFileNode_data,swig_CvFileNode_data_members,swig_CvFileNode_data_base_names,swig_CvFileNode_data_base };

static octave_value_list _wrap_CvTypeInfo_flags_set (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTypeInfo_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_flags_set" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTypeInfo_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_flags_get (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvTypeInfo_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_flags_get" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_header_size_set (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTypeInfo_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_header_size_set" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTypeInfo_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_header_size_get (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvTypeInfo_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_header_size_get" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_prev_set (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  CvTypeInfo *arg2 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTypeInfo_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_prev_set" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvTypeInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvTypeInfo_prev_set" "', argument " "2"" of type '" "CvTypeInfo *""'"); 
  }
  arg2 = (CvTypeInfo *)(argp2);
  if (arg1) (arg1)->prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_prev_get (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypeInfo *result = 0 ;
  
  if (!SWIG_check_num_args("CvTypeInfo_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_prev_get" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  result = (CvTypeInfo *) ((arg1)->prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_next_set (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  CvTypeInfo *arg2 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTypeInfo_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_next_set" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvTypeInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvTypeInfo_next_set" "', argument " "2"" of type '" "CvTypeInfo *""'"); 
  }
  arg2 = (CvTypeInfo *)(argp2);
  if (arg1) (arg1)->next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_next_get (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypeInfo *result = 0 ;
  
  if (!SWIG_check_num_args("CvTypeInfo_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_next_get" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  result = (CvTypeInfo *) ((arg1)->next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_type_name_set (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTypeInfo_type_name_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_type_name_set" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvTypeInfo_type_name_set" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (arg2) {
    size_t size = strlen((const char *)((const char *)(arg2))) + 1;
    arg1->type_name = (char const *)(char*)(memcpy((new char[size]), arg2, sizeof(char)*(size)));
  } else {
    arg1->type_name = 0;
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_type_name_get (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvTypeInfo_type_name_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_type_name_get" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  result = (char *) ((arg1)->type_name);
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_is_instance_set (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  CvIsInstanceFunc arg2 = (CvIsInstanceFunc) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTypeInfo_is_instance_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_is_instance_set" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__void__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "CvTypeInfo_is_instance_set" "', argument " "2"" of type '" "CvIsInstanceFunc""'"); 
    }
  }
  if (arg1) (arg1)->is_instance = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_is_instance_get (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvIsInstanceFunc result;
  
  if (!SWIG_check_num_args("CvTypeInfo_is_instance_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_is_instance_get" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  result = (CvIsInstanceFunc) ((arg1)->is_instance);
  _outv = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_q_const__void__int);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_release_set (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  CvReleaseFunc arg2 = (CvReleaseFunc) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTypeInfo_release_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_release_set" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_p_void__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "CvTypeInfo_release_set" "', argument " "2"" of type '" "CvReleaseFunc""'"); 
    }
  }
  if (arg1) (arg1)->release = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_release_get (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvReleaseFunc result;
  
  if (!SWIG_check_num_args("CvTypeInfo_release_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_release_get" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  result = (CvReleaseFunc) ((arg1)->release);
  _outv = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_p_void__void);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_read_set (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  CvReadFunc arg2 = (CvReadFunc) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTypeInfo_read_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_read_set" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_CvFileStorage_p_CvFileNode__p_void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "CvTypeInfo_read_set" "', argument " "2"" of type '" "CvReadFunc""'"); 
    }
  }
  if (arg1) (arg1)->read = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_read_get (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvReadFunc result;
  
  if (!SWIG_check_num_args("CvTypeInfo_read_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_read_get" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  result = (CvReadFunc) ((arg1)->read);
  _outv = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_CvFileStorage_p_CvFileNode__p_void);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_write_set (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  CvWriteFunc arg2 = (CvWriteFunc) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTypeInfo_write_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_write_set" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "CvTypeInfo_write_set" "', argument " "2"" of type '" "CvWriteFunc""'"); 
    }
  }
  if (arg1) (arg1)->write = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_write_get (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvWriteFunc result;
  
  if (!SWIG_check_num_args("CvTypeInfo_write_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_write_get" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  result = (CvWriteFunc) ((arg1)->write);
  _outv = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_clone_set (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  CvCloneFunc arg2 = (CvCloneFunc) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTypeInfo_clone_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_clone_set" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__void__p_void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "CvTypeInfo_clone_set" "', argument " "2"" of type '" "CvCloneFunc""'"); 
    }
  }
  if (arg1) (arg1)->clone = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTypeInfo_clone_get (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvCloneFunc result;
  
  if (!SWIG_check_num_args("CvTypeInfo_clone_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTypeInfo_clone_get" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  result = (CvCloneFunc) ((arg1)->clone);
  _outv = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_p_q_const__void__p_void);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvTypeInfo (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypeInfo *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvTypeInfo",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypeInfo *)new CvTypeInfo(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypeInfo, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvTypeInfo (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvTypeInfo",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvTypeInfo" "', argument " "1"" of type '" "CvTypeInfo *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvTypeInfo_members[] = {
{"flags",0,_wrap_CvTypeInfo_flags_get,_wrap_CvTypeInfo_flags_set,0,0},
{"header_size",0,_wrap_CvTypeInfo_header_size_get,_wrap_CvTypeInfo_header_size_set,0,0},
{"prev",0,_wrap_CvTypeInfo_prev_get,_wrap_CvTypeInfo_prev_set,0,0},
{"next",0,_wrap_CvTypeInfo_next_get,_wrap_CvTypeInfo_next_set,0,0},
{"type_name",0,_wrap_CvTypeInfo_type_name_get,_wrap_CvTypeInfo_type_name_set,0,0},
{"is_instance",0,_wrap_CvTypeInfo_is_instance_get,_wrap_CvTypeInfo_is_instance_set,0,0},
{"release",0,_wrap_CvTypeInfo_release_get,_wrap_CvTypeInfo_release_set,0,0},
{"read",0,_wrap_CvTypeInfo_read_get,_wrap_CvTypeInfo_read_set,0,0},
{"write",0,_wrap_CvTypeInfo_write_get,_wrap_CvTypeInfo_write_set,0,0},
{"clone",0,_wrap_CvTypeInfo_clone_get,_wrap_CvTypeInfo_clone_set,0,0},
{0,0,0,0}
};
static const char *swig_CvTypeInfo_base_names[] = {0};
static const swig_type_info *swig_CvTypeInfo_base[] = {0};
static swig_octave_class _wrap_class_CvTypeInfo = {"CvTypeInfo", &SWIGTYPE_p_CvTypeInfo,0,_wrap_new_CvTypeInfo,0,_wrap_delete_CvTypeInfo,swig_CvTypeInfo_members,swig_CvTypeInfo_base_names,swig_CvTypeInfo_base };

static octave_value_list _wrap_CvPluginFuncInfo_func_addr_set (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  void **arg2 = (void **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *vptr2 ;
  void *buffer2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPluginFuncInfo_func_addr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPluginFuncInfo_func_addr_set" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_void, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (void *) vptr2;
    arg2=&buffer2;
  }
  if (arg1) (arg1)->func_addr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPluginFuncInfo_func_addr_get (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void **result = 0 ;
  
  if (!SWIG_check_num_args("CvPluginFuncInfo_func_addr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPluginFuncInfo_func_addr_get" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  result = (void **) ((arg1)->func_addr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPluginFuncInfo_default_func_addr_set (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPluginFuncInfo_default_func_addr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPluginFuncInfo_default_func_addr_set" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvPluginFuncInfo_default_func_addr_set" "', argument " "2"" of type '" "void *""'"); 
  }
  if (arg1) (arg1)->default_func_addr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPluginFuncInfo_default_func_addr_get (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("CvPluginFuncInfo_default_func_addr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPluginFuncInfo_default_func_addr_get" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  result = (void *) ((arg1)->default_func_addr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPluginFuncInfo_func_names_set (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPluginFuncInfo_func_names_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPluginFuncInfo_func_names_set" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvPluginFuncInfo_func_names_set" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (arg2) {
    size_t size = strlen((const char *)((const char *)(arg2))) + 1;
    arg1->func_names = (char const *)(char*)(memcpy((new char[size]), arg2, sizeof(char)*(size)));
  } else {
    arg1->func_names = 0;
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_CvPluginFuncInfo_func_names_get (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvPluginFuncInfo_func_names_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPluginFuncInfo_func_names_get" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  result = (char *) ((arg1)->func_names);
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPluginFuncInfo_search_modules_set (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPluginFuncInfo_search_modules_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPluginFuncInfo_search_modules_set" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPluginFuncInfo_search_modules_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->search_modules = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPluginFuncInfo_search_modules_get (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvPluginFuncInfo_search_modules_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPluginFuncInfo_search_modules_get" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  result = (int) ((arg1)->search_modules);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPluginFuncInfo_loaded_from_set (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvPluginFuncInfo_loaded_from_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPluginFuncInfo_loaded_from_set" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvPluginFuncInfo_loaded_from_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->loaded_from = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvPluginFuncInfo_loaded_from_get (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvPluginFuncInfo_loaded_from_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvPluginFuncInfo_loaded_from_get" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  result = (int) ((arg1)->loaded_from);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvPluginFuncInfo (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPluginFuncInfo *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvPluginFuncInfo",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvPluginFuncInfo *)new CvPluginFuncInfo(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPluginFuncInfo, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvPluginFuncInfo (const octave_value_list& args, int nargout) {
  CvPluginFuncInfo *arg1 = (CvPluginFuncInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvPluginFuncInfo",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPluginFuncInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvPluginFuncInfo" "', argument " "1"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg1 = (CvPluginFuncInfo *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvPluginFuncInfo_members[] = {
{"func_addr",0,_wrap_CvPluginFuncInfo_func_addr_get,_wrap_CvPluginFuncInfo_func_addr_set,0,0},
{"default_func_addr",0,_wrap_CvPluginFuncInfo_default_func_addr_get,_wrap_CvPluginFuncInfo_default_func_addr_set,0,0},
{"func_names",0,_wrap_CvPluginFuncInfo_func_names_get,_wrap_CvPluginFuncInfo_func_names_set,0,0},
{"search_modules",0,_wrap_CvPluginFuncInfo_search_modules_get,_wrap_CvPluginFuncInfo_search_modules_set,0,0},
{"loaded_from",0,_wrap_CvPluginFuncInfo_loaded_from_get,_wrap_CvPluginFuncInfo_loaded_from_set,0,0},
{0,0,0,0}
};
static const char *swig_CvPluginFuncInfo_base_names[] = {0};
static const swig_type_info *swig_CvPluginFuncInfo_base[] = {0};
static swig_octave_class _wrap_class_CvPluginFuncInfo = {"CvPluginFuncInfo", &SWIGTYPE_p_CvPluginFuncInfo,0,_wrap_new_CvPluginFuncInfo,0,_wrap_delete_CvPluginFuncInfo,swig_CvPluginFuncInfo_members,swig_CvPluginFuncInfo_base_names,swig_CvPluginFuncInfo_base };

static octave_value_list _wrap_CvModuleInfo_next_set (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  CvModuleInfo *arg2 = (CvModuleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvModuleInfo_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvModuleInfo_next_set" "', argument " "1"" of type '" "CvModuleInfo *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvModuleInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvModuleInfo_next_set" "', argument " "2"" of type '" "CvModuleInfo *""'"); 
  }
  arg2 = (CvModuleInfo *)(argp2);
  if (arg1) (arg1)->next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvModuleInfo_next_get (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvModuleInfo *result = 0 ;
  
  if (!SWIG_check_num_args("CvModuleInfo_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvModuleInfo_next_get" "', argument " "1"" of type '" "CvModuleInfo *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  result = (CvModuleInfo *) ((arg1)->next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvModuleInfo_name_set (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvModuleInfo_name_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvModuleInfo_name_set" "', argument " "1"" of type '" "CvModuleInfo *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvModuleInfo_name_set" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (arg2) {
    size_t size = strlen((const char *)((const char *)(arg2))) + 1;
    arg1->name = (char const *)(char*)(memcpy((new char[size]), arg2, sizeof(char)*(size)));
  } else {
    arg1->name = 0;
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_CvModuleInfo_name_get (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvModuleInfo_name_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvModuleInfo_name_get" "', argument " "1"" of type '" "CvModuleInfo *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  result = (char *) ((arg1)->name);
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvModuleInfo_version_set (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvModuleInfo_version_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvModuleInfo_version_set" "', argument " "1"" of type '" "CvModuleInfo *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvModuleInfo_version_set" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (arg2) {
    size_t size = strlen((const char *)((const char *)(arg2))) + 1;
    arg1->version = (char const *)(char*)(memcpy((new char[size]), arg2, sizeof(char)*(size)));
  } else {
    arg1->version = 0;
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_CvModuleInfo_version_get (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("CvModuleInfo_version_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvModuleInfo_version_get" "', argument " "1"" of type '" "CvModuleInfo *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  result = (char *) ((arg1)->version);
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvModuleInfo_func_tab_set (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  CvPluginFuncInfo *arg2 = (CvPluginFuncInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvModuleInfo_func_tab_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvModuleInfo_func_tab_set" "', argument " "1"" of type '" "CvModuleInfo *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPluginFuncInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvModuleInfo_func_tab_set" "', argument " "2"" of type '" "CvPluginFuncInfo *""'"); 
  }
  arg2 = (CvPluginFuncInfo *)(argp2);
  if (arg1) (arg1)->func_tab = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvModuleInfo_func_tab_get (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPluginFuncInfo *result = 0 ;
  
  if (!SWIG_check_num_args("CvModuleInfo_func_tab_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvModuleInfo_func_tab_get" "', argument " "1"" of type '" "CvModuleInfo *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  result = (CvPluginFuncInfo *) ((arg1)->func_tab);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPluginFuncInfo, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvModuleInfo (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvModuleInfo *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvModuleInfo",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvModuleInfo *)new CvModuleInfo(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvModuleInfo, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvModuleInfo (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvModuleInfo",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvModuleInfo" "', argument " "1"" of type '" "CvModuleInfo *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvModuleInfo_members[] = {
{"next",0,_wrap_CvModuleInfo_next_get,_wrap_CvModuleInfo_next_set,0,0},
{"name",0,_wrap_CvModuleInfo_name_get,_wrap_CvModuleInfo_name_set,0,0},
{"version",0,_wrap_CvModuleInfo_version_get,_wrap_CvModuleInfo_version_set,0,0},
{"func_tab",0,_wrap_CvModuleInfo_func_tab_get,_wrap_CvModuleInfo_func_tab_set,0,0},
{0,0,0,0}
};
static const char *swig_CvModuleInfo_base_names[] = {0};
static const swig_type_info *swig_CvModuleInfo_base[] = {0};
static swig_octave_class _wrap_class_CvModuleInfo = {"CvModuleInfo", &SWIGTYPE_p_CvModuleInfo,0,_wrap_new_CvModuleInfo,0,_wrap_delete_CvModuleInfo,swig_CvModuleInfo_members,swig_CvModuleInfo_base_names,swig_CvModuleInfo_base };

static octave_value_list _wrap_cvAlloc (const octave_value_list& args, int nargout) {
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("cvAlloc",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_size_t(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvAlloc" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = (size_t)(val1);
  {
    try {
      result = (void *)cvAlloc(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFree_ (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  int res1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFree_",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFree_" "', argument " "1"" of type '" "void *""'"); 
  }
  {
    try {
      cvFree_(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseImageHeader (const octave_value_list& args, int nargout) {
  IplImage **arg1 = (IplImage **) 0 ;
  void *vptr1 ;
  IplImage *buffer1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseImageHeader",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p__IplImage, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (IplImage *) vptr1;
    arg1=&buffer1;
  }
  {
    try {
      cvReleaseImageHeader(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseImage (const octave_value_list& args, int nargout) {
  IplImage **arg1 = (IplImage **) 0 ;
  void *vptr1 ;
  IplImage *buffer1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseImage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p__IplImage, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (IplImage *) vptr1;
    arg1=&buffer1;
  }
  {
    try {
      cvReleaseImage(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvResetImageROI (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvResetImageROI",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    try {
      cvResetImageROI(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateMatHeader (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateMatHeader",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateMatHeader" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateMatHeader" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateMatHeader" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvMat *)cvCreateMatHeader(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvInitMatHeader (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *arg5 = (void *) NULL ;
  int arg6 = (int) 0x7fffffff ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvInitMatHeader",args.length(),6,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvInitMatHeader" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvInitMatHeader" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvInitMatHeader" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvInitMatHeader" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  if (4<args.length()) {
    res5 = SWIG_ConvertPtr(args(4),SWIG_as_voidptrptr(&arg5), 0, 0);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvInitMatHeader" "', argument " "5"" of type '" "void *""'"); 
    }
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvInitMatHeader" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      result = (CvMat *)cvInitMatHeader(arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateMat (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateMat",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateMat" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateMat" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateMat" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvMat *)cvCreateMat(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseMat (const octave_value_list& args, int nargout) {
  CvMat **arg1 = (CvMat **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseMat",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseMat" "', argument " "1"" of type '" "CvMat **""'"); 
  }
  arg1 = (CvMat **)(argp1);
  {
    try {
      cvReleaseMat(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvDecRefData (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvDecRefData",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      cvDecRefData(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvIncRefData (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvIncRefData",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      result = (int)cvIncRefData(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCloneMat (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvCloneMat",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCloneMat" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (CvMat *)cvCloneMat((CvMat const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetSubRect (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvRect arg3 ;
  bool freearg1 = false ;
  CvMat *header2 ;
  void *argp3 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  {
    header2 = (CvMat *)cvAlloc(sizeof(CvMat));
    arg2 = header2;
  }
  if (!SWIG_check_num_args("cvGetSubRect",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    res3 = SWIG_ConvertPtr(args(1), &argp3, SWIGTYPE_p_CvRect,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGetSubRect" "', argument " "3"" of type '" "CvRect""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvGetSubRect" "', argument " "3"" of type '" "CvRect""'");
    } else {
      arg3 = *((CvRect *)(argp3));
    }
  }
  {
    try {
      result = (CvMat *)cvGetSubRect((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    arg2->hdr_refcount = ((CvMat *)arg1)->hdr_refcount;
    arg2->refcount = ((CvMat *)arg1)->refcount;
    cvIncRefData(arg2);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetRows (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 = (int) 1 ;
  bool freearg1 = false ;
  CvMat *header2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  {
    header2 = (CvMat *)cvAlloc(sizeof(CvMat));
    arg2 = header2;
  }
  if (!SWIG_check_num_args("cvGetRows",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode3 = SWIG_AsVal_int(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetRows" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(2), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvGetRows" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  if (3<args.length()) {
    ecode5 = SWIG_AsVal_int(args(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvGetRows" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      result = (CvMat *)cvGetRows((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    arg2->hdr_refcount = ((CvMat *)arg1)->hdr_refcount;
    arg2->refcount = ((CvMat *)arg1)->refcount;
    cvIncRefData(arg2);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetRow (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  int arg3 ;
  bool freearg1 = false ;
  CvMat *header2 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  {
    header2 = (CvMat *)cvAlloc(sizeof(CvMat));
    arg2 = header2;
  }
  if (!SWIG_check_num_args("cvGetRow",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode3 = SWIG_AsVal_int(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetRow" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvMat *)cvGetRow((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    arg2->hdr_refcount = ((CvMat *)arg1)->hdr_refcount;
    arg2->refcount = ((CvMat *)arg1)->refcount;
    cvIncRefData(arg2);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetCols (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  int arg3 ;
  int arg4 ;
  bool freearg1 = false ;
  CvMat *header2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  {
    header2 = (CvMat *)cvAlloc(sizeof(CvMat));
    arg2 = header2;
  }
  if (!SWIG_check_num_args("cvGetCols",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode3 = SWIG_AsVal_int(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetCols" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(2), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvGetCols" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      result = (CvMat *)cvGetCols((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    arg2->hdr_refcount = ((CvMat *)arg1)->hdr_refcount;
    arg2->refcount = ((CvMat *)arg1)->refcount;
    cvIncRefData(arg2);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetCol (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  int arg3 ;
  bool freearg1 = false ;
  CvMat *header2 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  {
    header2 = (CvMat *)cvAlloc(sizeof(CvMat));
    arg2 = header2;
  }
  if (!SWIG_check_num_args("cvGetCol",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode3 = SWIG_AsVal_int(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetCol" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvMat *)cvGetCol((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    arg2->hdr_refcount = ((CvMat *)arg1)->hdr_refcount;
    arg2->refcount = ((CvMat *)arg1)->refcount;
    cvIncRefData(arg2);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetDiag (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  int arg3 = (int) 0 ;
  bool freearg1 = false ;
  CvMat *header2 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  {
    header2 = (CvMat *)cvAlloc(sizeof(CvMat));
    arg2 = header2;
  }
  if (!SWIG_check_num_args("cvGetDiag",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    ecode3 = SWIG_AsVal_int(args(1), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetDiag" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      result = (CvMat *)cvGetDiag((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    arg2->hdr_refcount = ((CvMat *)arg1)->hdr_refcount;
    arg2->refcount = ((CvMat *)arg1)->refcount;
    cvIncRefData(arg2);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvScalarToRawData (const octave_value_list& args, int nargout) {
  CvScalar *arg1 = (CvScalar *) 0 ;
  void *arg2 = (void *) 0 ;
  int arg3 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvScalarToRawData",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvScalarToRawData" "', argument " "1"" of type '" "CvScalar const *""'"); 
  }
  arg1 = (CvScalar *)(argp1);
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvScalarToRawData" "', argument " "2"" of type '" "void *""'"); 
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvScalarToRawData" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvScalarToRawData" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvScalarToRawData((CvScalar const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRawDataToScalar (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  int arg2 ;
  CvScalar *arg3 = (CvScalar *) 0 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRawDataToScalar",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRawDataToScalar" "', argument " "1"" of type '" "void const *""'"); 
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvRawDataToScalar" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvRawDataToScalar" "', argument " "3"" of type '" "CvScalar *""'"); 
  }
  arg3 = (CvScalar *)(argp3);
  {
    try {
      cvRawDataToScalar((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateMatNDHeader (const octave_value_list& args, int nargout) {
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int arg3 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatND *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateMatNDHeader",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    int i;
    
    // get the size of the dimention array
    arg1 = OctList_Size (args(0));
    
    // allocate the needed memory
    arg2 = (int *)malloc (arg1 * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < arg1; i++) {
      octave_value item = OctList_GetItem (args(0), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  ecode3 = SWIG_AsVal_int(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateMatNDHeader" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvMatND *)cvCreateMatNDHeader(arg1,(int const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatND, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateMatND (const octave_value_list& args, int nargout) {
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int arg3 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatND *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateMatND",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    int i;
    
    // get the size of the dimention array
    arg1 = OctList_Size (args(0));
    
    // allocate the needed memory
    arg2 = (int *)malloc (arg1 * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < arg1; i++) {
      octave_value item = OctList_GetItem (args(0), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  ecode3 = SWIG_AsVal_int(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateMatND" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvMatND *)cvCreateMatND(arg1,(int const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatND, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvInitMatNDHeader (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  int arg4 ;
  void *arg5 = (void *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int res5 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatND *result = 0 ;
  
  if (!SWIG_check_num_args("cvInitMatNDHeader",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvInitMatNDHeader" "', argument " "1"" of type '" "CvMatND *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  {
    int i;
    
    // get the size of the dimention array
    arg2 = OctList_Size (args(1));
    
    // allocate the needed memory
    arg3 = (int *)malloc (arg2 * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < arg2; i++) {
      octave_value item = OctList_GetItem (args(1), i);
      arg3 [i] = (int)OctInt_AsLong (item);
    }
  }
  ecode4 = SWIG_AsVal_int(args(2), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvInitMatNDHeader" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  if (3<args.length()) {
    res5 = SWIG_ConvertPtr(args(3),SWIG_as_voidptrptr(&arg5), 0, 0);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvInitMatNDHeader" "', argument " "5"" of type '" "void *""'"); 
    }
  }
  {
    try {
      result = (CvMatND *)cvInitMatNDHeader(arg1,arg2,(int const *)arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatND, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseMatND (const octave_value_list& args, int nargout) {
  CvMatND **arg1 = (CvMatND **) 0 ;
  void *vptr1 ;
  CvMatND *buffer1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseMatND",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvMatND, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (CvMatND *) vptr1;
    arg1=&buffer1;
  }
  {
    try {
      cvReleaseMatND(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCloneMatND (const octave_value_list& args, int nargout) {
  CvMatND *arg1 = (CvMatND *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatND *result = 0 ;
  
  if (!SWIG_check_num_args("cvCloneMatND",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCloneMatND" "', argument " "1"" of type '" "CvMatND const *""'"); 
  }
  arg1 = (CvMatND *)(argp1);
  {
    try {
      result = (CvMatND *)cvCloneMatND((CvMatND const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatND, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateSparseMat (const octave_value_list& args, int nargout) {
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int arg3 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSparseMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateSparseMat",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    int i;
    
    // get the size of the dimention array
    arg1 = OctList_Size (args(0));
    
    // allocate the needed memory
    arg2 = (int *)malloc (arg1 * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < arg1; i++) {
      octave_value item = OctList_GetItem (args(0), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  ecode3 = SWIG_AsVal_int(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateSparseMat" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvSparseMat *)cvCreateSparseMat(arg1,(int const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSparseMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseSparseMat (const octave_value_list& args, int nargout) {
  CvSparseMat **arg1 = (CvSparseMat **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseSparseMat",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseSparseMat" "', argument " "1"" of type '" "CvSparseMat **""'"); 
  }
  arg1 = (CvSparseMat **)(argp1);
  {
    try {
      cvReleaseSparseMat(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCloneSparseMat (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSparseMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvCloneSparseMat",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCloneSparseMat" "', argument " "1"" of type '" "CvSparseMat const *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  {
    try {
      result = (CvSparseMat *)cvCloneSparseMat((CvSparseMat const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSparseMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvInitSparseMatIterator (const octave_value_list& args, int nargout) {
  CvSparseMat *arg1 = (CvSparseMat *) 0 ;
  CvSparseMatIterator *arg2 = (CvSparseMatIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSparseNode *result = 0 ;
  
  if (!SWIG_check_num_args("cvInitSparseMatIterator",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvInitSparseMatIterator" "', argument " "1"" of type '" "CvSparseMat const *""'"); 
  }
  arg1 = (CvSparseMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSparseMatIterator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvInitSparseMatIterator" "', argument " "2"" of type '" "CvSparseMatIterator *""'"); 
  }
  arg2 = (CvSparseMatIterator *)(argp2);
  {
    try {
      result = (CvSparseNode *)cvInitSparseMatIterator((CvSparseMat const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSparseNode, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetNextSparseNode (const octave_value_list& args, int nargout) {
  CvSparseMatIterator *arg1 = (CvSparseMatIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSparseNode *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetNextSparseNode",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSparseMatIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetNextSparseNode" "', argument " "1"" of type '" "CvSparseMatIterator *""'"); 
  }
  arg1 = (CvSparseMatIterator *)(argp1);
  {
    try {
      result = (CvSparseNode *)cvGetNextSparseNode(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSparseNode, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_count_set (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvNArrayIterator_count_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_count_set" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvNArrayIterator_count_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->count = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_count_get (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvNArrayIterator_count_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_count_get" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  result = (int) ((arg1)->count);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_dims_set (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvNArrayIterator_dims_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_dims_set" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvNArrayIterator_dims_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->dims = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_dims_get (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvNArrayIterator_dims_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_dims_get" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  result = (int) ((arg1)->dims);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_size_set (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  CvSize *arg2 = (CvSize *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvNArrayIterator_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_size_set" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSize, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvNArrayIterator_size_set" "', argument " "2"" of type '" "CvSize *""'"); 
  }
  arg2 = (CvSize *)(argp2);
  if (arg1) (arg1)->size = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_size_get (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize *result = 0 ;
  
  if (!SWIG_check_num_args("CvNArrayIterator_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_size_get" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  result = (CvSize *)& ((arg1)->size);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSize, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_ptr_set (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  uchar **arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvNArrayIterator_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_ptr_set" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvNArrayIterator_ptr_set" "', argument " "2"" of type '" "uchar *[10]""'"); 
  } 
  arg2 = (uchar **)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)10; ++ii) arg1->ptr[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""ptr""' of type '""uchar *[10]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_ptr_get (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar **result = 0 ;
  
  if (!SWIG_check_num_args("CvNArrayIterator_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_ptr_get" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  result = (uchar **)(uchar **) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_stack_set (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  int *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvNArrayIterator_stack_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_stack_set" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvNArrayIterator_stack_set" "', argument " "2"" of type '" "int [32]""'"); 
  } 
  arg2 = (int *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)32; ++ii) arg1->stack[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""stack""' of type '""int [32]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_stack_get (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvNArrayIterator_stack_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_stack_get" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  result = (int *)(int *) ((arg1)->stack);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_hdr_set (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  CvMatND **arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvNArrayIterator_hdr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_hdr_set" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvNArrayIterator_hdr_set" "', argument " "2"" of type '" "CvMatND *[10]""'"); 
  } 
  arg2 = (CvMatND **)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)10; ++ii) arg1->hdr[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""hdr""' of type '""CvMatND *[10]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvNArrayIterator_hdr_get (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatND **result = 0 ;
  
  if (!SWIG_check_num_args("CvNArrayIterator_hdr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvNArrayIterator_hdr_get" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  result = (CvMatND **)(CvMatND **) ((arg1)->hdr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_CvMatND, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvNArrayIterator (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvNArrayIterator *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvNArrayIterator",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvNArrayIterator *)new CvNArrayIterator(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvNArrayIterator, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvNArrayIterator (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvNArrayIterator",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvNArrayIterator" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvNArrayIterator_members[] = {
{"count",0,_wrap_CvNArrayIterator_count_get,_wrap_CvNArrayIterator_count_set,0,0},
{"dims",0,_wrap_CvNArrayIterator_dims_get,_wrap_CvNArrayIterator_dims_set,0,0},
{"size",0,_wrap_CvNArrayIterator_size_get,_wrap_CvNArrayIterator_size_set,0,0},
{"ptr",0,_wrap_CvNArrayIterator_ptr_get,_wrap_CvNArrayIterator_ptr_set,0,0},
{"stack",0,_wrap_CvNArrayIterator_stack_get,_wrap_CvNArrayIterator_stack_set,0,0},
{"hdr",0,_wrap_CvNArrayIterator_hdr_get,_wrap_CvNArrayIterator_hdr_set,0,0},
{0,0,0,0}
};
static const char *swig_CvNArrayIterator_base_names[] = {0};
static const swig_type_info *swig_CvNArrayIterator_base[] = {0};
static swig_octave_class _wrap_class_CvNArrayIterator = {"CvNArrayIterator", &SWIGTYPE_p_CvNArrayIterator,0,_wrap_new_CvNArrayIterator,0,_wrap_delete_CvNArrayIterator,swig_CvNArrayIterator_members,swig_CvNArrayIterator_base_names,swig_CvNArrayIterator_base };

static octave_value_list _wrap_cvInitNArrayIterator (const octave_value_list& args, int nargout) {
  int arg1 ;
  CvArr **arg2 = (CvArr **) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvMatND *arg4 = (CvMatND *) 0 ;
  CvNArrayIterator *arg5 = (CvNArrayIterator *) 0 ;
  int arg6 = (int) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  void *vptr2 ;
  CvArr *buffer2 ;
  bool freearg3 = false ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvInitNArrayIterator",args.length(),6,5,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvInitNArrayIterator" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_void, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (CvArr *) vptr2;
    arg2=&buffer2;
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMatND, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvInitNArrayIterator" "', argument " "4"" of type '" "CvMatND *""'"); 
  }
  arg4 = (CvMatND *)(argp4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvInitNArrayIterator" "', argument " "5"" of type '" "CvNArrayIterator *""'"); 
  }
  arg5 = (CvNArrayIterator *)(argp5);
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvInitNArrayIterator" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      result = (int)cvInitNArrayIterator(arg1,arg2,(void const *)arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvNextNArraySlice (const octave_value_list& args, int nargout) {
  CvNArrayIterator *arg1 = (CvNArrayIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvNextNArraySlice",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvNArrayIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvNextNArraySlice" "', argument " "1"" of type '" "CvNArrayIterator *""'"); 
  }
  arg1 = (CvNArrayIterator *)(argp1);
  {
    try {
      result = (int)cvNextNArraySlice(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetElemType (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGetElemType",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      result = (int)cvGetElemType((void const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetDims (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int *arg2 = (int *) NULL ;
  void *myarr1 ;
  int mysizes1[CV_MAX_DIM] ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGetDims",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    SWIG_Octave_ConvertPtr(args(0), &myarr1, 0, SWIG_POINTER_EXCEPTION);
    arg1=(CvArr *)myarr1;
    arg2=mysizes1;
  }
  {
    try {
      result = (int)cvGetDims((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    int len = OctInt_AsLong( _outp );
    octave_value obj = OctTuple_FromIntArray( arg2, len );
    _outp = SWIG_Octave_AppendOutput(_outp, obj);
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetDimSize (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGetDimSize",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetDimSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (int)cvGetDimSize((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPtr1D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int *arg3 = (int *) NULL ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("cvPtr1D",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvPtr1D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_int, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvPtr1D" "', argument " "3"" of type '" "int *""'"); 
    }
    arg3 = (int *)(argp3);
  }
  {
    try {
      result = (uchar *)cvPtr1D((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPtr2D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  int *arg4 = (int *) NULL ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("cvPtr2D",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvPtr2D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPtr2D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_int, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvPtr2D" "', argument " "4"" of type '" "int *""'"); 
    }
    arg4 = (int *)(argp4);
  }
  {
    try {
      result = (uchar *)cvPtr2D((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPtr3D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int *arg5 = (int *) NULL ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("cvPtr3D",args.length(),5,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvPtr3D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPtr3D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvPtr3D" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  if (4<args.length()) {
    res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_int, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvPtr3D" "', argument " "5"" of type '" "int *""'"); 
    }
    arg5 = (int *)(argp5);
  }
  {
    try {
      result = (uchar *)cvPtr3D((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPtrND (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) NULL ;
  int arg4 = (int) 1 ;
  unsigned int *arg5 = (unsigned int *) NULL ;
  bool freearg1 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("cvPtrND",args.length(),5,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    int i;
    int size;
    
    // get the size of the dimention array
    size = OctList_Size (args(1));
    
    // allocate the needed memory
    arg2 = (int *)malloc (size * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < size; i++) {
      octave_value item = OctList_GetItem (args(1), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_int, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvPtrND" "', argument " "3"" of type '" "int *""'"); 
    }
    arg3 = (int *)(argp3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvPtrND" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_unsigned_int, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvPtrND" "', argument " "5"" of type '" "unsigned int *""'"); 
    }
    arg5 = (unsigned int *)(argp5);
  }
  {
    try {
      result = (uchar *)cvPtrND((void const *)arg1,(int const *)arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGet1D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvGet1D",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGet1D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = cvGet1D((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGet2D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvGet2D",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGet2D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGet2D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = cvGet2D((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGet3D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvGet3D",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGet3D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGet3D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvGet3D" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      result = cvGet3D((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetND (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int *arg2 = (int *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvGetND",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    int i;
    int size;
    
    // get the size of the dimention array
    size = OctList_Size (args(1));
    
    // allocate the needed memory
    arg2 = (int *)malloc (size * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < size; i++) {
      octave_value item = OctList_GetItem (args(1), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  {
    try {
      result = cvGetND((void const *)arg1,(int const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetReal1D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvGetReal1D",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetReal1D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (double)cvGetReal1D((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetReal2D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvGetReal2D",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetReal2D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetReal2D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (double)cvGetReal2D((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetReal3D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvGetReal3D",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetReal3D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetReal3D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvGetReal3D" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      result = (double)cvGetReal3D((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetRealND (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int *arg2 = (int *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvGetRealND",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    int i;
    int size;
    
    // get the size of the dimention array
    size = OctList_Size (args(1));
    
    // allocate the needed memory
    arg2 = (int *)malloc (size * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < size; i++) {
      octave_value item = OctList_GetItem (args(1), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  {
    try {
      result = (double)cvGetRealND((void const *)arg1,(int const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSet1D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  CvScalar arg3 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSet1D",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSet1D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    arg3 = OctObject_to_CvScalar( args(2) );
  }
  {
    try {
      cvSet1D(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSet2D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  CvScalar arg4 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSet2D",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSet2D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSet2D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    arg4 = OctObject_to_CvScalar( args(3) );
  }
  {
    try {
      cvSet2D(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSet3D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  CvScalar arg5 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSet3D",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSet3D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSet3D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSet3D" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    arg5 = OctObject_to_CvScalar( args(4) );
  }
  {
    try {
      cvSet3D(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSetND (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int *arg2 = (int *) 0 ;
  CvScalar arg3 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetND",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    int i;
    int size;
    
    // get the size of the dimention array
    size = OctList_Size (args(1));
    
    // allocate the needed memory
    arg2 = (int *)malloc (size * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < size; i++) {
      octave_value item = OctList_GetItem (args(1), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  {
    arg3 = OctObject_to_CvScalar( args(2) );
  }
  {
    try {
      cvSetND(arg1,(int const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSetReal1D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  double arg3 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetReal1D",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSetReal1D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSetReal1D" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      cvSetReal1D(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSetReal2D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  double arg4 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetReal2D",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSetReal2D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSetReal2D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSetReal2D" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    try {
      cvSetReal2D(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSetReal3D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  double arg5 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetReal3D",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSetReal3D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSetReal3D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSetReal3D" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvSetReal3D" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  {
    try {
      cvSetReal3D(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSetRealND (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int *arg2 = (int *) 0 ;
  double arg3 ;
  bool freearg1 = false ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetRealND",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    int i;
    int size;
    
    // get the size of the dimention array
    size = OctList_Size (args(1));
    
    // allocate the needed memory
    arg2 = (int *)malloc (size * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < size; i++) {
      octave_value item = OctList_GetItem (args(1), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSetRealND" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      cvSetRealND(arg1,(int const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvClearND (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int *arg2 = (int *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvClearND",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    int i;
    int size;
    
    // get the size of the dimention array
    size = OctList_Size (args(1));
    
    // allocate the needed memory
    arg2 = (int *)malloc (size * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < size; i++) {
      octave_value item = OctList_GetItem (args(1), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  {
    try {
      cvClearND(arg1,(int const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetMat (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  int *arg3 = (int *) NULL ;
  int arg4 = (int) 0 ;
  bool freearg1 = false ;
  CvMat *header2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  {
    header2 = (CvMat *)cvAlloc(sizeof(CvMat));
    arg2 = header2;
  }
  if (!SWIG_check_num_args("cvGetMat",args.length(),3,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    res3 = SWIG_ConvertPtr(args(1), &argp3,SWIGTYPE_p_int, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGetMat" "', argument " "3"" of type '" "int *""'"); 
    }
    arg3 = (int *)(argp3);
  }
  if (2<args.length()) {
    ecode4 = SWIG_AsVal_int(args(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvGetMat" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      result = (CvMat *)cvGetMat((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    arg2->hdr_refcount = ((CvMat *)arg1)->hdr_refcount;
    arg2->refcount = ((CvMat *)arg1)->refcount;
    cvIncRefData(arg2);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvReshapeMatND (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  int arg4 ;
  int arg5 ;
  int *arg6 = (int *) 0 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  bool freearg3 = false ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("cvReshapeMatND",args.length(),6,6,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvReshapeMatND" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvReshapeMatND" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvReshapeMatND" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvReshapeMatND" "', argument " "6"" of type '" "int *""'"); 
  }
  arg6 = (int *)(argp6);
  {
    try {
      result = (CvArr *)cvReshapeMatND((void const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvReshape (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  int arg3 ;
  int arg4 = (int) 0 ;
  bool freearg1 = false ;
  CvMat *header2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  {
    header2 = (CvMat *)cvAlloc(sizeof(CvMat));
    arg2 = header2;
  }
  if (!SWIG_check_num_args("cvReshape",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode3 = SWIG_AsVal_int(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvReshape" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (2<args.length()) {
    ecode4 = SWIG_AsVal_int(args(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvReshape" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      result = (CvMat *)cvReshape((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    arg2->hdr_refcount = ((CvMat *)arg1)->hdr_refcount;
    arg2->refcount = ((CvMat *)arg1)->refcount;
    cvIncRefData(arg2);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvRepeat (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRepeat",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      cvRepeat((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateData (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCreateData",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      cvCreateData(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseData (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseData",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      cvReleaseData(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSetData (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  void *arg2 = (void *) 0 ;
  int arg3 ;
  bool freearg1 = false ;
  int res2 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetData",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSetData" "', argument " "2"" of type '" "void *""'"); 
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSetData" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      cvSetData(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetRawData (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  uchar **arg2 = (uchar **) 0 ;
  int *arg3 = (int *) NULL ;
  CvSize *arg4 = (CvSize *) NULL ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvGetRawData",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_p_unsigned_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGetRawData" "', argument " "2"" of type '" "uchar **""'"); 
  }
  arg2 = (uchar **)(argp2);
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_int, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGetRawData" "', argument " "3"" of type '" "int *""'"); 
    }
    arg3 = (int *)(argp3);
  }
  if (3<args.length()) {
    res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvSize, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvGetRawData" "', argument " "4"" of type '" "CvSize *""'"); 
    }
    arg4 = (CvSize *)(argp4);
  }
  {
    try {
      cvGetRawData((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetSize (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize result;
  
  if (!SWIG_check_num_args("cvGetSize",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      result = cvGetSize((void const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvSize((const CvSize&)(result))), SWIGTYPE_p_CvSize, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCopy (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCopy",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    {
      arg3 = OctObject_to_CvArr(args(2), &freearg3);
    }
  }
  {
    try {
      cvCopy((void const *)arg1,arg2,(void const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSet (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar arg2 ;
  CvArr *arg3 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSet",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  if (2<args.length()) {
    {
      arg3 = OctObject_to_CvArr(args(2), &freearg3);
    }
  }
  {
    try {
      cvSet(arg1,arg2,(void const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSetZero (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetZero",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      cvSetZero(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSplit (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  CvArr *arg5 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  bool freearg5 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSplit",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    arg5 = OctObject_to_CvArr(args(4), &freearg5);
  }
  {
    try {
      cvSplit((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
  {
    if(arg5!=NULL && freearg5){
      cvReleaseData( arg5 );
      cvFree(&(arg5));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMerge (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  CvArr *arg5 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  bool freearg5 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMerge",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    arg5 = OctObject_to_CvArr(args(4), &freearg5);
  }
  {
    try {
      cvMerge((void const *)arg1,(void const *)arg2,(void const *)arg3,(void const *)arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
  {
    if(arg5!=NULL && freearg5){
      cvReleaseData( arg5 );
      cvFree(&(arg5));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMixChannels (const octave_value_list& args, int nargout) {
  CvArr **arg1 = (CvArr **) 0 ;
  int arg2 ;
  CvArr **arg3 = (CvArr **) 0 ;
  int arg4 ;
  int *arg5 = (int *) 0 ;
  int arg6 ;
  void *vptr1 ;
  CvArr *buffer1 ;
  int val2 ;
  int ecode2 = 0 ;
  void *vptr3 ;
  CvArr *buffer3 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMixChannels",args.length(),6,6,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_void, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (CvArr *) vptr1;
    arg1=&buffer1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvMixChannels" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_void, 1)) == -1){
      SWIG_fail;
    }
    buffer3 = (CvArr *) vptr3;
    arg3=&buffer3;
  }
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvMixChannels" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvMixChannels" "', argument " "5"" of type '" "int const *""'"); 
  }
  arg5 = (int *)(argp5);
  ecode6 = SWIG_AsVal_int(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvMixChannels" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  {
    try {
      cvMixChannels((void const **)arg1,arg2,arg3,arg4,(int const *)arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvConvertScale (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 = (double) 1 ;
  double arg4 = (double) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvConvertScale",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_double(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvConvertScale" "', argument " "3"" of type '" "double""'");
    } 
    arg3 = (double)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvConvertScale" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  {
    try {
      cvConvertScale((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvConvertScaleAbs (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 = (double) 1 ;
  double arg4 = (double) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvConvertScaleAbs",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_double(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvConvertScaleAbs" "', argument " "3"" of type '" "double""'");
    } 
    arg3 = (double)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvConvertScaleAbs" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  {
    try {
      cvConvertScaleAbs((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCheckTermCriteria (const octave_value_list& args, int nargout) {
  CvTermCriteria arg1 ;
  double arg2 ;
  int arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTermCriteria result;
  
  if (!SWIG_check_num_args("cvCheckTermCriteria",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCheckTermCriteria" "', argument " "1"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCheckTermCriteria" "', argument " "1"" of type '" "CvTermCriteria""'");
    } else {
      arg1 = *((CvTermCriteria *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCheckTermCriteria" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCheckTermCriteria" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = cvCheckTermCriteria(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvTermCriteria((const CvTermCriteria&)(result))), SWIGTYPE_p_CvTermCriteria, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvAdd (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAdd",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvAdd((void const *)arg1,(void const *)arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAddS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAddS",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvAddS((void const *)arg1,arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSub (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSub",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvSub((void const *)arg1,(void const *)arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSubS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSubS",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvSubS((void const *)arg1,arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSubRS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSubRS",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvSubRS((void const *)arg1,arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMul (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  double arg4 = (double) 1 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMul",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvMul" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  {
    try {
      cvMul((void const *)arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvDiv (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  double arg4 = (double) 1 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvDiv",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvDiv" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  {
    try {
      cvDiv((void const *)arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvScaleAdd (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvScaleAdd",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    try {
      cvScaleAdd((void const *)arg1,arg2,(void const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAddWeighted (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  double arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  double arg4 ;
  double arg5 ;
  CvArr *arg6 = (CvArr *) 0 ;
  bool freearg1 = false ;
  double val2 ;
  int ecode2 = 0 ;
  bool freearg3 = false ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  bool freearg6 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAddWeighted",args.length(),6,6,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvAddWeighted" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvAddWeighted" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvAddWeighted" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  {
    arg6 = OctObject_to_CvArr(args(5), &freearg6);
  }
  {
    try {
      cvAddWeighted((void const *)arg1,arg2,(void const *)arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg6!=NULL && freearg6){
      cvReleaseData( arg6 );
      cvFree(&(arg6));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvDotProduct (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvDotProduct",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      result = (double)cvDotProduct((void const *)arg1,(void const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAnd (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAnd",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvAnd((void const *)arg1,(void const *)arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAndS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAndS",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvAndS((void const *)arg1,arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvOr (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvOr",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvOr((void const *)arg1,(void const *)arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvOrS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvOrS",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvOrS((void const *)arg1,arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvXor (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvXor",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvXor((void const *)arg1,(void const *)arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvXorS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvXorS",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvXorS((void const *)arg1,arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvNot (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvNot",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      cvNot((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvInRange (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInRange",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    try {
      cvInRange((void const *)arg1,(void const *)arg2,(void const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvInRangeS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar arg2 ;
  CvScalar arg3 ;
  CvArr *arg4 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInRangeS",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvScalar( args(1) );
  }
  {
    arg3 = OctObject_to_CvScalar( args(2) );
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    try {
      cvInRangeS((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCmp (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  int arg4 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCmp",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCmp" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      cvCmp((void const *)arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCmpS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  double arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  int arg4 ;
  bool freearg1 = false ;
  double val2 ;
  int ecode2 = 0 ;
  bool freearg3 = false ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCmpS",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCmpS" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCmpS" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      cvCmpS((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMin (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMin",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      cvMin((void const *)arg1,(void const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMax (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMax",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      cvMax((void const *)arg1,(void const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMinS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  double arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  bool freearg1 = false ;
  double val2 ;
  int ecode2 = 0 ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMinS",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvMinS" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      cvMinS((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMaxS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  double arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  bool freearg1 = false ;
  double val2 ;
  int ecode2 = 0 ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMaxS",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvMaxS" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      cvMaxS((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAbsDiff (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAbsDiff",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      cvAbsDiff((void const *)arg1,(void const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAbsDiffS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvScalar arg3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAbsDiffS",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvScalar( args(2) );
  }
  {
    try {
      cvAbsDiffS((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCartToPolar (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  int arg5 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCartToPolar",args.length(),5,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCartToPolar" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      cvCartToPolar((void const *)arg1,(void const *)arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPolarToCart (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  int arg5 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvPolarToCart",args.length(),5,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvPolarToCart" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      cvPolarToCart((void const *)arg1,(void const *)arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPow (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvPow",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPow" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      cvPow((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvExp (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvExp",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      cvExp((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvLog (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvLog",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      cvLog((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFastArctan (const octave_value_list& args, int nargout) {
  float arg1 ;
  float arg2 ;
  float val1 ;
  int ecode1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("cvFastArctan",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_float(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvFastArctan" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = (float)(val1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvFastArctan" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  {
    try {
      result = (float)cvFastArctan(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCbrt (const octave_value_list& args, int nargout) {
  float arg1 ;
  float val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("cvCbrt",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_float(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCbrt" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = (float)(val1);
  {
    try {
      result = (float)cvCbrt(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCheckArr (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 = (int) 0 ;
  double arg3 = (double) 0 ;
  double arg4 = (double) 0 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvCheckArr",args.length(),4,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCheckArr" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_double(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCheckArr" "', argument " "3"" of type '" "double""'");
    } 
    arg3 = (double)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCheckArr" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  {
    try {
      result = (int)cvCheckArr((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvRandArr (const octave_value_list& args, int nargout) {
  CvRNG *arg1 = (CvRNG *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  CvScalar arg4 ;
  CvScalar arg5 ;
  void *vptr1 ;
  CvRNG_Wrapper *wrapper1 ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRandArr",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    if(SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvRNG_Wrapper, 0)==-1){
      SWIG_exception( SWIG_TypeError, "could not convert Octave object to C value");
      SWIG_fail;
    }
    wrapper1 = (CvRNG_Wrapper *) vptr1;
    arg1 = wrapper1->ptr();
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvRandArr" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    arg4 = OctObject_to_CvScalar( args(3) );
  }
  {
    arg5 = OctObject_to_CvScalar( args(4) );
  }
  {
    try {
      cvRandArr(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvRandShuffle (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvRNG *arg2 = (CvRNG *) 0 ;
  double arg3 = (double) 1. ;
  bool freearg1 = false ;
  void *vptr2 ;
  CvRNG_Wrapper *wrapper2 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRandShuffle",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    if(SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_CvRNG_Wrapper, 0)==-1){
      SWIG_exception( SWIG_TypeError, "could not convert Octave object to C value");
      SWIG_fail;
    }
    wrapper2 = (CvRNG_Wrapper *) vptr2;
    arg2 = wrapper2->ptr();
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_double(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvRandShuffle" "', argument " "3"" of type '" "double""'");
    } 
    arg3 = (double)(val3);
  }
  {
    try {
      cvRandShuffle(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSort (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) NULL ;
  CvArr *arg3 = (CvArr *) NULL ;
  int arg4 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSort",args.length(),4,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    {
      arg2 = OctObject_to_CvArr(args(1), &freearg2);
    }
  }
  if (2<args.length()) {
    {
      arg3 = OctObject_to_CvArr(args(2), &freearg3);
    }
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSort" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvSort((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSolveCubic (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvSolveCubic",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSolveCubic" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSolveCubic" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  {
    try {
      result = (int)cvSolveCubic((CvMat const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSolvePoly (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  int arg3 = (int) 20 ;
  int arg4 = (int) 100 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSolvePoly",args.length(),4,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSolvePoly" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSolvePoly" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSolvePoly" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSolvePoly" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvSolvePoly((CvMat const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCrossProduct (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCrossProduct",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      cvCrossProduct((void const *)arg1,(void const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGEMM (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 ;
  CvArr *arg4 = (CvArr *) 0 ;
  double arg5 ;
  CvArr *arg6 = (CvArr *) 0 ;
  int arg7 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  bool freearg4 = false ;
  double val5 ;
  int ecode5 = 0 ;
  bool freearg6 = false ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvGEMM",args.length(),7,6,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGEMM" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvGEMM" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  {
    arg6 = OctObject_to_CvArr(args(5), &freearg6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvGEMM" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    try {
      cvGEMM((void const *)arg1,(void const *)arg2,arg3,(void const *)arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
  {
    if(arg6!=NULL && freearg6){
      cvReleaseData( arg6 );
      cvFree(&(arg6));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvTransform (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvTransform",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvTransform" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  if (3<args.length()) {
    res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvTransform" "', argument " "4"" of type '" "CvMat const *""'"); 
    }
    arg4 = (CvMat *)(argp4);
  }
  {
    try {
      cvTransform((void const *)arg1,arg2,(CvMat const *)arg3,(CvMat const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPerspectiveTransform (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvPerspectiveTransform",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvPerspectiveTransform" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  {
    try {
      cvPerspectiveTransform((void const *)arg1,arg2,(CvMat const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMulTransposed (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  CvArr *arg4 = (CvArr *) NULL ;
  double arg5 = (double) 1. ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  bool freearg4 = false ;
  double val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMulTransposed",args.length(),5,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvMulTransposed" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_double(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvMulTransposed" "', argument " "5"" of type '" "double""'");
    } 
    arg5 = (double)(val5);
  }
  {
    try {
      cvMulTransposed((void const *)arg1,arg2,arg3,(void const *)arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvTranspose (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvTranspose",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      cvTranspose((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCompleteSymm (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCompleteSymm",args.length(),2,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCompleteSymm" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCompleteSymm" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    try {
      cvCompleteSymm(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFlip (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) NULL ;
  int arg3 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFlip",args.length(),3,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    {
      arg2 = OctObject_to_CvArr(args(1), &freearg2);
    }
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvFlip" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      cvFlip((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSVD (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) NULL ;
  CvArr *arg4 = (CvArr *) NULL ;
  int arg5 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSVD",args.length(),5,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    {
      arg3 = OctObject_to_CvArr(args(2), &freearg3);
    }
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvSVD" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      cvSVD(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSVBkSb (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  CvArr *arg5 = (CvArr *) 0 ;
  int arg6 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  bool freearg5 = false ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSVBkSb",args.length(),6,6,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    arg5 = OctObject_to_CvArr(args(4), &freearg5);
  }
  ecode6 = SWIG_AsVal_int(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvSVBkSb" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  {
    try {
      cvSVBkSb((void const *)arg1,(void const *)arg2,(void const *)arg3,(void const *)arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
  {
    if(arg5!=NULL && freearg5){
      cvReleaseData( arg5 );
      cvFree(&(arg5));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvInvert (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvInvert",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvInvert" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      result = (double)cvInvert((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSolve (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  int arg4 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvSolve",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSolve" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      result = (int)cvSolve((void const *)arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvDet (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvDet",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      result = (double)cvDet((void const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvTrace (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvTrace",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      result = cvTrace((void const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvEigenVV (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  double arg4 = (double) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) -1 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvEigenVV",args.length(),6,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvEigenVV" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvEigenVV" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvEigenVV" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      cvEigenVV(arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSetIdentity (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar arg2 = (CvScalar) cvRealScalar(1) ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetIdentity",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    {
      arg2 = OctObject_to_CvScalar( args(1) );
    }
  }
  {
    try {
      cvSetIdentity(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvRange (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  double arg2 ;
  double arg3 ;
  bool freearg1 = false ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvArr *result = 0 ;
  
  if (!SWIG_check_num_args("cvRange",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvRange" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvRange" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      result = (CvArr *)cvRange(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcCovarMatrix (const octave_value_list& args, int nargout) {
  CvArr **arg1 = (CvArr **) 0 ;
  int arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  int arg5 ;
  CvArr *one_image1 = NULL ;
  bool free_one_arg1 = false ;
  CvArr **many_images1 = NULL ;
  bool *free_many_args1 = NULL ;
  int nimages1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcCovarMatrix",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    // first, check if this is a tuple
    if (OctTuple_Check (args(0))) {
      // This is a tuple, so we need to test each element and pass
      // them to the called function
      
      int i;
      
      // get the size of the tuple
      nimages1 = OctTuple_Size (args(0));
      
      // allocate the necessary place
      many_images1 = (CvArr **)malloc (nimages1 * sizeof (CvArr *));
      free_many_args1 = (bool *)malloc(nimages1 * sizeof(bool));
      
      for (i = 0; i < nimages1; i++) {
        // convert the current tuple element to a CvArr *, and
        // store to many_images1 [i]
        many_images1[i] = OctObject_to_CvArr (OctTuple_GetItem (args(0), i),
          free_many_args1+i);
        
        // check that the current item is a correct type
        if(!many_images1[i]) {
          // incorrect !
          SWIG_fail;
        }
      }
      
      // what to give to the called function
      arg1 = many_images1;
      
    } else if((one_image1 = OctObject_to_CvArr( args(0), &free_one_arg1 ))){
      // this is just one CvArr *, so one_image1 will receive it
      arg1 = &one_image1;
      
    } else {
      // not a CvArr *, not a tuple, this is wrong
      SWIG_fail;
    }
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCalcCovarMatrix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCalcCovarMatrix" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    try {
      cvCalcCovarMatrix((void const **)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(free_one_arg1){
      cvFree(&(one_image1));
    }
    else if(free_many_args1){
      int i;
      for (i=0; i<nimages1; i++){
        if(free_many_args1[i]){
          cvReleaseData(many_images1[i]);
          cvFree(many_images1+i);
        }
      }
      free(many_images1);
      free(free_many_args1);
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcPCA (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  int arg5 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcPCA",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCalcPCA" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    try {
      cvCalcPCA((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvProjectPCA (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvProjectPCA",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    try {
      cvProjectPCA((void const *)arg1,(void const *)arg2,(void const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvBackProjectPCA (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvBackProjectPCA",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    try {
      cvBackProjectPCA((void const *)arg1,(void const *)arg2,(void const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMahalanobis (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvMahalanobis",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      result = (double)cvMahalanobis((void const *)arg1,(void const *)arg2,(void const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSum (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvSum",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      result = cvSum((void const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCountNonZero (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvCountNonZero",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      result = (int)cvCountNonZero((void const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAvg (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvAvg",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    {
      arg2 = OctObject_to_CvArr(args(1), &freearg2);
    }
  }
  {
    try {
      result = cvAvg((void const *)arg1,(void const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAvgSdv (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvScalar *arg2 = (CvScalar *) 0 ;
  CvScalar *arg3 = (CvScalar *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAvgSdv",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvAvgSdv" "', argument " "2"" of type '" "CvScalar *""'"); 
  }
  arg2 = (CvScalar *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvAvgSdv" "', argument " "3"" of type '" "CvScalar *""'"); 
  }
  arg3 = (CvScalar *)(argp3);
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvAvgSdv((void const *)arg1,arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMinMaxLoc (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  CvPoint *arg4 = (CvPoint *) NULL ;
  CvPoint *arg5 = (CvPoint *) NULL ;
  CvArr *arg6 = (CvArr *) NULL ;
  bool freearg1 = false ;
  double temp2 ;
  int res2 = SWIG_TMPOBJ ;
  double temp3 ;
  int res3 = SWIG_TMPOBJ ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool freearg6 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  arg2 = &temp2;
  arg3 = &temp3;
  if (!SWIG_check_num_args("cvMinMaxLoc",args.length(),4,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    res4 = SWIG_ConvertPtr(args(1), &argp4,SWIGTYPE_p_CvPoint, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvMinMaxLoc" "', argument " "4"" of type '" "CvPoint *""'"); 
    }
    arg4 = (CvPoint *)(argp4);
  }
  if (2<args.length()) {
    res5 = SWIG_ConvertPtr(args(2), &argp5,SWIGTYPE_p_CvPoint, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvMinMaxLoc" "', argument " "5"" of type '" "CvPoint *""'"); 
    }
    arg5 = (CvPoint *)(argp5);
  }
  if (3<args.length()) {
    {
      arg6 = OctObject_to_CvArr(args(3), &freearg6);
    }
  }
  {
    try {
      cvMinMaxLoc((void const *)arg1,arg2,arg3,arg4,arg5,(void const *)arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (SWIG_IsTmpObj(res2)) {
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_From_double((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_double, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_From_double((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_double, new_flags));
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg6!=NULL && freearg6){
      cvReleaseData( arg6 );
      cvFree(&(arg6));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvNorm (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) NULL ;
  int arg3 = (int) 4 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvNorm",args.length(),4,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    {
      arg2 = OctObject_to_CvArr(args(1), &freearg2);
    }
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvNorm" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      result = (double)cvNorm((void const *)arg1,(void const *)arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvNormalize (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 = (double) 1. ;
  double arg4 = (double) 0. ;
  int arg5 = (int) 4 ;
  CvArr *arg6 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool freearg6 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvNormalize",args.length(),6,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_double(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvNormalize" "', argument " "3"" of type '" "double""'");
    } 
    arg3 = (double)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvNormalize" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvNormalize" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    {
      arg6 = OctObject_to_CvArr(args(5), &freearg6);
    }
  }
  {
    try {
      cvNormalize((void const *)arg1,arg2,arg3,arg4,arg5,(void const *)arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg6!=NULL && freearg6){
      cvReleaseData( arg6 );
      cvFree(&(arg6));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvReduce (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReduce",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvReduce" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvReduce" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvReduce((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvDFT (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  int arg4 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvDFT",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvDFT" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvDFT" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvDFT((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMulSpectrums (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  int arg4 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMulSpectrums",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvMulSpectrums" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      cvMulSpectrums((void const *)arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetOptimalDFTSize (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGetOptimalDFTSize",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvGetOptimalDFTSize" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    try {
      result = (int)cvGetOptimalDFTSize(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvDCT (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvDCT",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvDCT" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      cvDCT((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSliceLength (const octave_value_list& args, int nargout) {
  CvSlice arg1 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvSliceLength",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvSlice,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSliceLength" "', argument " "1"" of type '" "CvSlice""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvSliceLength" "', argument " "1"" of type '" "CvSlice""'");
    } else {
      arg1 = *((CvSlice *)(argp1));
    }
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  {
    try {
      result = (int)cvSliceLength(arg1,(CvSeq const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateMemStorage (const octave_value_list& args, int nargout) {
  int arg1 = (int) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStorage *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateMemStorage",args.length(),1,0,0)) {
    SWIG_fail;
  }
  if (0<args.length()) {
    ecode1 = SWIG_AsVal_int(args(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateMemStorage" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = (int)(val1);
  }
  {
    try {
      result = (CvMemStorage *)cvCreateMemStorage(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStorage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateChildMemStorage (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStorage *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateChildMemStorage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCreateChildMemStorage" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  {
    try {
      result = (CvMemStorage *)cvCreateChildMemStorage(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStorage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseMemStorage (const octave_value_list& args, int nargout) {
  CvMemStorage **arg1 = (CvMemStorage **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseMemStorage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseMemStorage" "', argument " "1"" of type '" "CvMemStorage **""'"); 
  }
  arg1 = (CvMemStorage **)(argp1);
  {
    try {
      cvReleaseMemStorage(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvClearMemStorage (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvClearMemStorage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvClearMemStorage" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  {
    try {
      cvClearMemStorage(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSaveMemStoragePos (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  CvMemStoragePos *arg2 = (CvMemStoragePos *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSaveMemStoragePos",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSaveMemStoragePos" "', argument " "1"" of type '" "CvMemStorage const *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStoragePos, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSaveMemStoragePos" "', argument " "2"" of type '" "CvMemStoragePos *""'"); 
  }
  arg2 = (CvMemStoragePos *)(argp2);
  {
    try {
      cvSaveMemStoragePos((CvMemStorage const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRestoreMemStoragePos (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  CvMemStoragePos *arg2 = (CvMemStoragePos *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRestoreMemStoragePos",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRestoreMemStoragePos" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStoragePos, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvRestoreMemStoragePos" "', argument " "2"" of type '" "CvMemStoragePos *""'"); 
  }
  arg2 = (CvMemStoragePos *)(argp2);
  {
    try {
      cvRestoreMemStoragePos(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvMemStorageAlloc (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("cvMemStorageAlloc",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvMemStorageAlloc" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  ecode2 = SWIG_AsVal_size_t(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvMemStorageAlloc" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = (size_t)(val2);
  {
    try {
      result = (void *)cvMemStorageAlloc(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvMemStorageAllocString (const octave_value_list& args, int nargout) {
  CvMemStorage *arg1 = (CvMemStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvString result;
  
  if (!SWIG_check_num_args("cvMemStorageAllocString",args.length(),3,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvMemStorageAllocString" "', argument " "1"" of type '" "CvMemStorage *""'"); 
  }
  arg1 = (CvMemStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvMemStorageAllocString" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvMemStorageAllocString" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      result = cvMemStorageAllocString(arg1,(char const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvString((const CvString&)(result))), SWIGTYPE_p_CvString, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateSeq (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  CvMemStorage *arg4 = (CvMemStorage *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateSeq",args.length(),4,4,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateSeq" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateSeq" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateSeq" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCreateSeq" "', argument " "4"" of type '" "CvMemStorage *""'"); 
  }
  arg4 = (CvMemStorage *)(argp4);
  {
    try {
      result = (CvSeq *)cvCreateSeq(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetSeqBlockSize (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetSeqBlockSize",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSetSeqBlockSize" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      cvSetSeqBlockSize(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqPush (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *arg2 = (void *) NULL ;
  void *ptr1 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("cvSeqPush",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqPush" "', argument " "2"" of type '" "void const *""'"); 
    }
  }
  {
    try {
      result = (schar *)cvSeqPush(arg1,(void const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqPushFront (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *arg2 = (void *) NULL ;
  void *ptr1 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("cvSeqPushFront",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqPushFront" "', argument " "2"" of type '" "void const *""'"); 
    }
  }
  {
    try {
      result = (schar *)cvSeqPushFront(arg1,(void const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqPop (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *arg2 = (void *) NULL ;
  void *ptr1 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSeqPop",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqPop" "', argument " "2"" of type '" "void *""'"); 
    }
  }
  {
    try {
      cvSeqPop(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqPopFront (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *arg2 = (void *) NULL ;
  void *ptr1 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSeqPopFront",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqPopFront" "', argument " "2"" of type '" "void *""'"); 
    }
  }
  {
    try {
      cvSeqPopFront(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqPushMulti (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *arg2 = (void *) 0 ;
  int arg3 ;
  int arg4 = (int) 0 ;
  void *ptr1 ;
  int res2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSeqPushMulti",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqPushMulti" "', argument " "2"" of type '" "void const *""'"); 
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSeqPushMulti" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSeqPushMulti" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvSeqPushMulti(arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqPopMulti (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *arg2 = (void *) 0 ;
  int arg3 ;
  int arg4 = (int) 0 ;
  void *ptr1 ;
  int res2 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSeqPopMulti",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqPopMulti" "', argument " "2"" of type '" "void *""'"); 
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSeqPopMulti" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSeqPopMulti" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvSeqPopMulti(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqInsert (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  int arg2 ;
  void *arg3 = (void *) NULL ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("cvSeqInsert",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSeqInsert" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvSeqInsert" "', argument " "3"" of type '" "void const *""'"); 
    }
  }
  {
    try {
      result = (schar *)cvSeqInsert(arg1,arg2,(void const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqRemove (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSeqRemove",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSeqRemove" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      cvSeqRemove(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvClearSeq (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvClearSeq",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      cvClearSeq(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetSeqElem (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetSeqElem",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetSeqElem" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (schar *)cvGetSeqElem((CvSeq const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqElemIdx (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *arg2 = (void *) 0 ;
  CvSeqBlock **arg3 = (CvSeqBlock **) NULL ;
  void *ptr1 ;
  int res2 ;
  void *vptr3 ;
  CvSeqBlock *buffer3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvSeqElemIdx",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqElemIdx" "', argument " "2"" of type '" "void const *""'"); 
  }
  if (2<args.length()) {
    {
      if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_CvSeqBlock, 1)) == -1){
        SWIG_fail;
      }
      buffer3 = (CvSeqBlock *) vptr3;
      arg3=&buffer3;
    }
  }
  {
    try {
      result = (int)cvSeqElemIdx((CvSeq const *)arg1,(void const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvStartAppendToSeq (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSeqWriter *arg2 = (CvSeqWriter *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvStartAppendToSeq",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvStartAppendToSeq" "', argument " "2"" of type '" "CvSeqWriter *""'"); 
  }
  arg2 = (CvSeqWriter *)(argp2);
  {
    try {
      cvStartAppendToSeq(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvStartWriteSeq (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  CvMemStorage *arg4 = (CvMemStorage *) 0 ;
  CvSeqWriter *arg5 = (CvSeqWriter *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvStartWriteSeq",args.length(),5,5,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvStartWriteSeq" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvStartWriteSeq" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvStartWriteSeq" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvStartWriteSeq" "', argument " "4"" of type '" "CvMemStorage *""'"); 
  }
  arg4 = (CvMemStorage *)(argp4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvStartWriteSeq" "', argument " "5"" of type '" "CvSeqWriter *""'"); 
  }
  arg5 = (CvSeqWriter *)(argp5);
  {
    try {
      cvStartWriteSeq(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvEndWriteSeq (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvEndWriteSeq",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvEndWriteSeq" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  {
    try {
      result = (CvSeq *)cvEndWriteSeq(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFlushSeqWriter (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFlushSeqWriter",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFlushSeqWriter" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  {
    try {
      cvFlushSeqWriter(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvStartReadSeq (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSeqReader *arg2 = (CvSeqReader *) 0 ;
  int arg3 = (int) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvStartReadSeq",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvStartReadSeq" "', argument " "2"" of type '" "CvSeqReader *""'"); 
  }
  arg2 = (CvSeqReader *)(argp2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvStartReadSeq" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      cvStartReadSeq((CvSeq const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetSeqReaderPos (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGetSeqReaderPos",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetSeqReaderPos" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  {
    try {
      result = (int)cvGetSeqReaderPos(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetSeqReaderPos (const octave_value_list& args, int nargout) {
  CvSeqReader *arg1 = (CvSeqReader *) 0 ;
  int arg2 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetSeqReaderPos",args.length(),3,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSetSeqReaderPos" "', argument " "1"" of type '" "CvSeqReader *""'"); 
  }
  arg1 = (CvSeqReader *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSetSeqReaderPos" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSetSeqReaderPos" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      cvSetSeqReaderPos(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvMakeSeqHeaderForArray (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  void *arg4 = (void *) 0 ;
  int arg5 ;
  CvSeq *arg6 = (CvSeq *) 0 ;
  CvSeqBlock *arg7 = (CvSeqBlock *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  int val5 ;
  int ecode5 = 0 ;
  void *ptr6 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvMakeSeqHeaderForArray",args.length(),7,7,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvMakeSeqHeaderForArray" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvMakeSeqHeaderForArray" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvMakeSeqHeaderForArray" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3),SWIG_as_voidptrptr(&arg4), 0, 0);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvMakeSeqHeaderForArray" "', argument " "4"" of type '" "void *""'"); 
  }
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvMakeSeqHeaderForArray" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    if( SWIG_ConvertPtr(args(5), &ptr6, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(5), &ptr6, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(5), &ptr6, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(5), &ptr6, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(5), &ptr6, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(5), &ptr6, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(5), &ptr6, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg6 = (CvSeq *) ptr6;
  }
  res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvMakeSeqHeaderForArray" "', argument " "7"" of type '" "CvSeqBlock *""'"); 
  }
  arg7 = (CvSeqBlock *)(argp7);
  {
    try {
      result = (CvSeq *)cvMakeSeqHeaderForArray(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqSlice (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSlice arg2 ;
  CvMemStorage *arg3 = (CvMemStorage *) NULL ;
  int arg4 = (int) 0 ;
  void *ptr1 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvSeqSlice",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqSlice" "', argument " "2"" of type '" "CvSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvSeqSlice" "', argument " "2"" of type '" "CvSlice""'");
    } else {
      arg2 = *((CvSlice *)(argp2));
    }
  }
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvSeqSlice" "', argument " "3"" of type '" "CvMemStorage *""'"); 
    }
    arg3 = (CvMemStorage *)(argp3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSeqSlice" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      result = (CvSeq *)cvSeqSlice((CvSeq const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCloneSeq (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) NULL ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvCloneSeq",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCloneSeq" "', argument " "2"" of type '" "CvMemStorage *""'"); 
    }
    arg2 = (CvMemStorage *)(argp2);
  }
  {
    try {
      result = (CvSeq *)cvCloneSeq((CvSeq const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqRemoveSlice (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvSlice arg2 ;
  void *ptr1 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSeqRemoveSlice",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSlice,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqRemoveSlice" "', argument " "2"" of type '" "CvSlice""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvSeqRemoveSlice" "', argument " "2"" of type '" "CvSlice""'");
    } else {
      arg2 = *((CvSlice *)(argp2));
    }
  }
  {
    try {
      cvSeqRemoveSlice(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqInsertSlice (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  int arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSeqInsertSlice",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSeqInsertSlice" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      cvSeqInsertSlice(arg1,arg2,(void const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqSort (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvCmpFunc arg2 = (CvCmpFunc) 0 ;
  void *arg3 = (void *) NULL ;
  void *ptr1 ;
  int res3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSeqSort",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__void_p_q_const__void_p_void__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSeqSort" "', argument " "2"" of type '" "CvCmpFunc""'"); 
    }
  }
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvSeqSort" "', argument " "3"" of type '" "void *""'"); 
    }
  }
  {
    try {
      cvSeqSort(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqSearch (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *arg2 = (void *) 0 ;
  CvCmpFunc arg3 = (CvCmpFunc) 0 ;
  int arg4 ;
  int *arg5 = (int *) 0 ;
  void *arg6 = (void *) NULL ;
  void *ptr1 ;
  int res2 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int res6 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("cvSeqSearch",args.length(),6,5,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqSearch" "', argument " "2"" of type '" "void const *""'"); 
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(2), (void**)(&arg3), SWIGTYPE_p_f_p_q_const__void_p_q_const__void_p_void__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSeqSearch" "', argument " "3"" of type '" "CvCmpFunc""'"); 
    }
  }
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSeqSearch" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvSeqSearch" "', argument " "5"" of type '" "int *""'"); 
  }
  arg5 = (int *)(argp5);
  if (5<args.length()) {
    res6 = SWIG_ConvertPtr(args(5),SWIG_as_voidptrptr(&arg6), 0, 0);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvSeqSearch" "', argument " "6"" of type '" "void *""'"); 
    }
  }
  {
    try {
      result = (schar *)cvSeqSearch(arg1,(void const *)arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqInvert (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSeqInvert",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      cvSeqInvert(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSeqPartition (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  CvSeq **arg3 = (CvSeq **) 0 ;
  CvCmpFunc arg4 = (CvCmpFunc) 0 ;
  void *arg5 = (void *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *vptr3 ;
  CvSeq *buffer3 ;
  int res5 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvSeqPartition",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSeqPartition" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  {
    if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_CvSeq, 1)) == -1){
      SWIG_fail;
    }
    buffer3 = (CvSeq *) vptr3;
    arg3=&buffer3;
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(3), (void**)(&arg4), SWIGTYPE_p_f_p_q_const__void_p_q_const__void_p_void__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSeqPartition" "', argument " "4"" of type '" "CvCmpFunc""'"); 
    }
  }
  res5 = SWIG_ConvertPtr(args(4),SWIG_as_voidptrptr(&arg5), 0, 0);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvSeqPartition" "', argument " "5"" of type '" "void *""'"); 
  }
  {
    try {
      result = (int)cvSeqPartition((CvSeq const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvChangeSeqBlock (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  int arg2 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvChangeSeqBlock",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvChangeSeqBlock" "', argument " "1"" of type '" "void *""'"); 
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvChangeSeqBlock" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      cvChangeSeqBlock(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateSeqBlock (const octave_value_list& args, int nargout) {
  CvSeqWriter *arg1 = (CvSeqWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCreateSeqBlock",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSeqWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCreateSeqBlock" "', argument " "1"" of type '" "CvSeqWriter *""'"); 
  }
  arg1 = (CvSeqWriter *)(argp1);
  {
    try {
      cvCreateSeqBlock(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateSet (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  CvMemStorage *arg4 = (CvMemStorage *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSet *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateSet",args.length(),4,4,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateSet" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateSet" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateSet" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCreateSet" "', argument " "4"" of type '" "CvMemStorage *""'"); 
  }
  arg4 = (CvMemStorage *)(argp4);
  {
    try {
      result = (CvSet *)cvCreateSet(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSet, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetAdd (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  CvSetElem *arg2 = (CvSetElem *) NULL ;
  CvSetElem **arg3 = (CvSetElem **) NULL ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *vptr3 ;
  CvSetElem *buffer3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvSetAdd",args.length(),3,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSetElem, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSetAdd" "', argument " "2"" of type '" "CvSetElem *""'"); 
    }
    arg2 = (CvSetElem *)(argp2);
  }
  if (2<args.length()) {
    {
      if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_CvSetElem, 1)) == -1){
        SWIG_fail;
      }
      buffer3 = (CvSetElem *) vptr3;
      arg3=&buffer3;
    }
  }
  {
    try {
      result = (int)cvSetAdd(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetNew (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSetElem *result = 0 ;
  
  if (!SWIG_check_num_args("cvSetNew",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  {
    try {
      result = (CvSetElem *)cvSetNew(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSetElem, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetRemoveByPtr (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *arg2 = (void *) 0 ;
  void *ptr1 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetRemoveByPtr",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSetRemoveByPtr" "', argument " "2"" of type '" "void *""'"); 
  }
  {
    try {
      cvSetRemoveByPtr(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetRemove (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetRemove",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSetRemove" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      cvSetRemove(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetSetElem (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSetElem *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetSetElem",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetSetElem" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvSetElem *)cvGetSetElem((CvSet const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSetElem, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvClearSet (const octave_value_list& args, int nargout) {
  CvSet *arg1 = (CvSet *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvClearSet",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSet");
      SWIG_fail;
    }
    arg1 = (CvSet *)ptr1;
  }
  {
    try {
      cvClearSet(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateGraph (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  CvMemStorage *arg5 = (CvMemStorage *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraph *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateGraph",args.length(),5,5,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateGraph" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateGraph" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateGraph" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCreateGraph" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvCreateGraph" "', argument " "5"" of type '" "CvMemStorage *""'"); 
  }
  arg5 = (CvMemStorage *)(argp5);
  {
    try {
      result = (CvGraph *)cvCreateGraph(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraph, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphAddVtx (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) NULL ;
  CvGraphVtx **arg3 = (CvGraphVtx **) NULL ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *vptr3 ;
  CvGraphVtx *buffer3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphAddVtx",args.length(),3,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGraphAddVtx" "', argument " "2"" of type '" "CvGraphVtx const *""'"); 
    }
    arg2 = (CvGraphVtx *)(argp2);
  }
  if (2<args.length()) {
    {
      if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_CvGraphVtx, 1)) == -1){
        SWIG_fail;
      }
      buffer3 = (CvGraphVtx *) vptr3;
      arg3=&buffer3;
    }
  }
  {
    try {
      result = (int)cvGraphAddVtx(arg1,(CvGraphVtx const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphRemoveVtx (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphRemoveVtx",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGraphRemoveVtx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (int)cvGraphRemoveVtx(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphRemoveVtxByPtr (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphRemoveVtxByPtr",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGraphRemoveVtxByPtr" "', argument " "2"" of type '" "CvGraphVtx *""'"); 
  }
  arg2 = (CvGraphVtx *)(argp2);
  {
    try {
      result = (int)cvGraphRemoveVtxByPtr(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphAddEdge (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  int arg3 ;
  CvGraphEdge *arg4 = (CvGraphEdge *) NULL ;
  CvGraphEdge **arg5 = (CvGraphEdge **) NULL ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *vptr5 ;
  CvGraphEdge *buffer5 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphAddEdge",args.length(),5,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGraphAddEdge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGraphAddEdge" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvGraphAddEdge" "', argument " "4"" of type '" "CvGraphEdge const *""'"); 
    }
    arg4 = (CvGraphEdge *)(argp4);
  }
  if (4<args.length()) {
    {
      if ((SWIG_ConvertPtr(args(4), &vptr5, SWIGTYPE_p_CvGraphEdge, 1)) == -1){
        SWIG_fail;
      }
      buffer5 = (CvGraphEdge *) vptr5;
      arg5=&buffer5;
    }
  }
  {
    try {
      result = (int)cvGraphAddEdge(arg1,arg2,arg3,(CvGraphEdge const *)arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphAddEdgeByPtr (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) 0 ;
  CvGraphVtx *arg3 = (CvGraphVtx *) 0 ;
  CvGraphEdge *arg4 = (CvGraphEdge *) NULL ;
  CvGraphEdge **arg5 = (CvGraphEdge **) NULL ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *vptr5 ;
  CvGraphEdge *buffer5 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphAddEdgeByPtr",args.length(),5,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGraphAddEdgeByPtr" "', argument " "2"" of type '" "CvGraphVtx *""'"); 
  }
  arg2 = (CvGraphVtx *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGraphAddEdgeByPtr" "', argument " "3"" of type '" "CvGraphVtx *""'"); 
  }
  arg3 = (CvGraphVtx *)(argp3);
  if (3<args.length()) {
    res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvGraphEdge, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvGraphAddEdgeByPtr" "', argument " "4"" of type '" "CvGraphEdge const *""'"); 
    }
    arg4 = (CvGraphEdge *)(argp4);
  }
  if (4<args.length()) {
    {
      if ((SWIG_ConvertPtr(args(4), &vptr5, SWIGTYPE_p_CvGraphEdge, 1)) == -1){
        SWIG_fail;
      }
      buffer5 = (CvGraphEdge *) vptr5;
      arg5=&buffer5;
    }
  }
  {
    try {
      result = (int)cvGraphAddEdgeByPtr(arg1,arg2,arg3,(CvGraphEdge const *)arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphRemoveEdge (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  int arg3 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvGraphRemoveEdge",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGraphRemoveEdge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGraphRemoveEdge" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      cvGraphRemoveEdge(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphRemoveEdgeByPtr (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) 0 ;
  CvGraphVtx *arg3 = (CvGraphVtx *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvGraphRemoveEdgeByPtr",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGraphRemoveEdgeByPtr" "', argument " "2"" of type '" "CvGraphVtx *""'"); 
  }
  arg2 = (CvGraphVtx *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGraphRemoveEdgeByPtr" "', argument " "3"" of type '" "CvGraphVtx *""'"); 
  }
  arg3 = (CvGraphVtx *)(argp3);
  {
    try {
      cvGraphRemoveEdgeByPtr(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindGraphEdge (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  int arg3 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphEdge *result = 0 ;
  
  if (!SWIG_check_num_args("cvFindGraphEdge",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvFindGraphEdge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvFindGraphEdge" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvGraphEdge *)cvFindGraphEdge((CvGraph const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindGraphEdgeByPtr (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) 0 ;
  CvGraphVtx *arg3 = (CvGraphVtx *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphEdge *result = 0 ;
  
  if (!SWIG_check_num_args("cvFindGraphEdgeByPtr",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvFindGraphEdgeByPtr" "', argument " "2"" of type '" "CvGraphVtx const *""'"); 
  }
  arg2 = (CvGraphVtx *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvFindGraphEdgeByPtr" "', argument " "3"" of type '" "CvGraphVtx const *""'"); 
  }
  arg3 = (CvGraphVtx *)(argp3);
  {
    try {
      result = (CvGraphEdge *)cvFindGraphEdgeByPtr((CvGraph const *)arg1,(CvGraphVtx const *)arg2,(CvGraphVtx const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvClearGraph (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvClearGraph",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  {
    try {
      cvClearGraph(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphVtxDegree (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  int arg2 ;
  void *ptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphVtxDegree",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGraphVtxDegree" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (int)cvGraphVtxDegree((CvGraph const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGraphVtxDegreeByPtr (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGraphVtxDegreeByPtr",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGraphVtxDegreeByPtr" "', argument " "2"" of type '" "CvGraphVtx const *""'"); 
  }
  arg2 = (CvGraphVtx *)(argp2);
  {
    try {
      result = (int)cvGraphVtxDegreeByPtr((CvGraph const *)arg1,(CvGraphVtx const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_vtx_set (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphScanner_vtx_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_vtx_set" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraphScanner_vtx_set" "', argument " "2"" of type '" "CvGraphVtx *""'"); 
  }
  arg2 = (CvGraphVtx *)(argp2);
  if (arg1) (arg1)->vtx = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_vtx_get (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphVtx *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraphScanner_vtx_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_vtx_get" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  result = (CvGraphVtx *) ((arg1)->vtx);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_dst_set (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphScanner_dst_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_dst_set" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraphScanner_dst_set" "', argument " "2"" of type '" "CvGraphVtx *""'"); 
  }
  arg2 = (CvGraphVtx *)(argp2);
  if (arg1) (arg1)->dst = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_dst_get (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphVtx *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraphScanner_dst_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_dst_get" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  result = (CvGraphVtx *) ((arg1)->dst);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphVtx, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_edge_set (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  CvGraphEdge *arg2 = (CvGraphEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphScanner_edge_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_edge_set" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphEdge, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvGraphScanner_edge_set" "', argument " "2"" of type '" "CvGraphEdge *""'"); 
  }
  arg2 = (CvGraphEdge *)(argp2);
  if (arg1) (arg1)->edge = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_edge_get (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphEdge *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraphScanner_edge_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_edge_get" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  result = (CvGraphEdge *) ((arg1)->edge);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphEdge, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_graph_set (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  CvGraph *arg2 = (CvGraph *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphScanner_graph_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_graph_set" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg2 = (CvGraph *)ptr2;
  }
  if (arg1) (arg1)->graph = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_graph_get (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraph *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraphScanner_graph_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_graph_get" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  result = (CvGraph *) ((arg1)->graph);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraph, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_stack_set (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphScanner_stack_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_stack_set" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->stack = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_stack_get (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvGraphScanner_stack_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_stack_get" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  result = (CvSeq *) ((arg1)->stack);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_index_set (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphScanner_index_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_index_set" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraphScanner_index_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->index = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_index_get (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraphScanner_index_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_index_get" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  result = (int) ((arg1)->index);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_mask_set (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvGraphScanner_mask_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_mask_set" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvGraphScanner_mask_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->mask = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvGraphScanner_mask_get (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvGraphScanner_mask_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvGraphScanner_mask_get" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  result = (int) ((arg1)->mask);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvGraphScanner (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvGraphScanner",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvGraphScanner" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  {
    try {
      delete_CvGraphScanner(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvGraphScanner_members[] = {
{"vtx",0,_wrap_CvGraphScanner_vtx_get,_wrap_CvGraphScanner_vtx_set,0,0},
{"dst",0,_wrap_CvGraphScanner_dst_get,_wrap_CvGraphScanner_dst_set,0,0},
{"edge",0,_wrap_CvGraphScanner_edge_get,_wrap_CvGraphScanner_edge_set,0,0},
{"graph",0,_wrap_CvGraphScanner_graph_get,_wrap_CvGraphScanner_graph_set,0,0},
{"stack",0,_wrap_CvGraphScanner_stack_get,_wrap_CvGraphScanner_stack_set,0,0},
{"index",0,_wrap_CvGraphScanner_index_get,_wrap_CvGraphScanner_index_set,0,0},
{"mask",0,_wrap_CvGraphScanner_mask_get,_wrap_CvGraphScanner_mask_set,0,0},
{0,0,0,0}
};
static const char *swig_CvGraphScanner_base_names[] = {0};
static const swig_type_info *swig_CvGraphScanner_base[] = {0};
static swig_octave_class _wrap_class_CvGraphScanner = {"CvGraphScanner", &SWIGTYPE_p_CvGraphScanner,0,0,0,_wrap_delete_CvGraphScanner,swig_CvGraphScanner_members,swig_CvGraphScanner_base_names,swig_CvGraphScanner_base };

static octave_value_list _wrap_cvCreateGraphScanner (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvGraphVtx *arg2 = (CvGraphVtx *) NULL ;
  int arg3 = (int) -1 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraphScanner *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateGraphScanner",args.length(),3,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvGraphVtx, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCreateGraphScanner" "', argument " "2"" of type '" "CvGraphVtx *""'"); 
    }
    arg2 = (CvGraphVtx *)(argp2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateGraphScanner" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      result = (CvGraphScanner *)cvCreateGraphScanner(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraphScanner, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseGraphScanner (const octave_value_list& args, int nargout) {
  CvGraphScanner **arg1 = (CvGraphScanner **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseGraphScanner",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseGraphScanner" "', argument " "1"" of type '" "CvGraphScanner **""'"); 
  }
  arg1 = (CvGraphScanner **)(argp1);
  {
    try {
      cvReleaseGraphScanner(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvNextGraphItem (const octave_value_list& args, int nargout) {
  CvGraphScanner *arg1 = (CvGraphScanner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvNextGraphItem",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvGraphScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvNextGraphItem" "', argument " "1"" of type '" "CvGraphScanner *""'"); 
  }
  arg1 = (CvGraphScanner *)(argp1);
  {
    try {
      result = (int)cvNextGraphItem(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCloneGraph (const octave_value_list& args, int nargout) {
  CvGraph *arg1 = (CvGraph *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvGraph *result = 0 ;
  
  if (!SWIG_check_num_args("cvCloneGraph",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1) 
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvGraph");
      SWIG_fail;
    }
    arg1 = (CvGraph *)ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCloneGraph" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  {
    try {
      result = (CvGraph *)cvCloneGraph((CvGraph const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvGraph, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvLine (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint arg2 ;
  CvPoint arg3 ;
  CvScalar arg4 ;
  int arg5 = (int) 1 ;
  int arg6 = (int) 8 ;
  int arg7 = (int) 0 ;
  bool freearg1 = false ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvLine",args.length(),7,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvPoint(args(1));
  }
  {
    arg3 = OctObject_to_CvPoint(args(2));
  }
  {
    arg4 = OctObject_to_CvScalar( args(3) );
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvLine" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvLine" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvLine" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    try {
      cvLine(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvRectangle (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint arg2 ;
  CvPoint arg3 ;
  CvScalar arg4 ;
  int arg5 = (int) 1 ;
  int arg6 = (int) 8 ;
  int arg7 = (int) 0 ;
  bool freearg1 = false ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRectangle",args.length(),7,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvPoint(args(1));
  }
  {
    arg3 = OctObject_to_CvPoint(args(2));
  }
  {
    arg4 = OctObject_to_CvScalar( args(3) );
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvRectangle" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvRectangle" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvRectangle" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    try {
      cvRectangle(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCircle (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint arg2 ;
  int arg3 ;
  CvScalar arg4 ;
  int arg5 = (int) 1 ;
  int arg6 = (int) 8 ;
  int arg7 = (int) 0 ;
  bool freearg1 = false ;
  int val3 ;
  int ecode3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCircle",args.length(),7,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvPoint(args(1));
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCircle" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    arg4 = OctObject_to_CvScalar( args(3) );
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCircle" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvCircle" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvCircle" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    try {
      cvCircle(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvEllipse (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint arg2 ;
  CvSize arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 ;
  CvScalar arg7 ;
  int arg8 = (int) 1 ;
  int arg9 = (int) 8 ;
  int arg10 = (int) 0 ;
  bool freearg1 = false ;
  void *argp3 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvEllipse",args.length(),10,7,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvPoint(args(1));
  }
  {
    res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvEllipse" "', argument " "3"" of type '" "CvSize""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvEllipse" "', argument " "3"" of type '" "CvSize""'");
    } else {
      arg3 = *((CvSize *)(argp3));
    }
  }
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvEllipse" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvEllipse" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_double(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvEllipse" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  {
    arg7 = OctObject_to_CvScalar( args(6) );
  }
  if (7<args.length()) {
    ecode8 = SWIG_AsVal_int(args(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cvEllipse" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (8<args.length()) {
    ecode9 = SWIG_AsVal_int(args(8), &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cvEllipse" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  if (9<args.length()) {
    ecode10 = SWIG_AsVal_int(args(9), &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cvEllipse" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = (int)(val10);
  }
  {
    try {
      cvEllipse(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvEllipseBox (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvBox2D arg2 ;
  CvScalar arg3 ;
  int arg4 = (int) 1 ;
  int arg5 = (int) 8 ;
  int arg6 = (int) 0 ;
  bool freearg1 = false ;
  void *argp2 ;
  int res2 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvEllipseBox",args.length(),6,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvBox2D,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvEllipseBox" "', argument " "2"" of type '" "CvBox2D""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvEllipseBox" "', argument " "2"" of type '" "CvBox2D""'");
    } else {
      arg2 = *((CvBox2D *)(argp2));
    }
  }
  {
    arg3 = OctObject_to_CvScalar( args(2) );
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvEllipseBox" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvEllipseBox" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvEllipseBox" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      cvEllipseBox(arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFillConvexPoly (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  int arg3 ;
  CvScalar arg4 ;
  int arg5 = (int) 8 ;
  int arg6 = (int) 0 ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFillConvexPoly",args.length(),6,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvFillConvexPoly" "', argument " "2"" of type '" "CvPoint const *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvFillConvexPoly" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    arg4 = OctObject_to_CvScalar( args(3) );
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvFillConvexPoly" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvFillConvexPoly" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      cvFillConvexPoly(arg1,(CvPoint const *)arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFillPoly (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint **arg2 = (CvPoint **) 0 ;
  int *arg3 = (int *) 0 ;
  int arg4 ;
  CvScalar arg5 ;
  int arg6 = (int) 8 ;
  int arg7 = (int) 0 ;
  bool freearg1 = false ;
  void *vptr2 ;
  CvPoint *buffer2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFillPoly",args.length(),7,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_CvPoint, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (CvPoint *) vptr2;
    arg2=&buffer2;
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvFillPoly" "', argument " "3"" of type '" "int const *""'"); 
  }
  arg3 = (int *)(argp3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvFillPoly" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    arg5 = OctObject_to_CvScalar( args(4) );
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvFillPoly" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvFillPoly" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    try {
      cvFillPoly(arg1,arg2,(int const *)arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPolyLine (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint **arg2 = (CvPoint **) 0 ;
  int *arg3 = (int *) 0 ;
  int arg4 ;
  int arg5 ;
  CvScalar arg6 ;
  int arg7 = (int) 1 ;
  int arg8 = (int) 8 ;
  int arg9 = (int) 0 ;
  bool freearg1 = false ;
  void *vptr2 ;
  CvPoint *buffer2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvPolyLine",args.length(),9,6,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_CvPoint, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (CvPoint *) vptr2;
    arg2=&buffer2;
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvPolyLine" "', argument " "3"" of type '" "int const *""'"); 
  }
  arg3 = (int *)(argp3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvPolyLine" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvPolyLine" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    arg6 = OctObject_to_CvScalar( args(5) );
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvPolyLine" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (7<args.length()) {
    ecode8 = SWIG_AsVal_int(args(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cvPolyLine" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (8<args.length()) {
    ecode9 = SWIG_AsVal_int(args(8), &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cvPolyLine" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  {
    try {
      cvPolyLine(arg1,arg2,(int const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvClipLine (const octave_value_list& args, int nargout) {
  CvSize arg1 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  CvPoint *arg3 = (CvPoint *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvClipLine",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvClipLine" "', argument " "1"" of type '" "CvSize""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvClipLine" "', argument " "1"" of type '" "CvSize""'");
    } else {
      arg1 = *((CvSize *)(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvClipLine" "', argument " "2"" of type '" "CvPoint *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvClipLine" "', argument " "3"" of type '" "CvPoint *""'"); 
  }
  arg3 = (CvPoint *)(argp3);
  {
    try {
      result = (int)cvClipLine(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvInitLineIterator (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint arg2 ;
  CvPoint arg3 ;
  CvLineIterator *arg4 = (CvLineIterator *) 0 ;
  int arg5 = (int) 8 ;
  int arg6 = (int) 0 ;
  bool freearg1 = false ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvInitLineIterator",args.length(),6,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvPoint(args(1));
  }
  {
    arg3 = OctObject_to_CvPoint(args(2));
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvLineIterator, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvInitLineIterator" "', argument " "4"" of type '" "CvLineIterator *""'"); 
  }
  arg4 = (CvLineIterator *)(argp4);
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvInitLineIterator" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvInitLineIterator" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      result = (int)cvInitLineIterator((void const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_font_face_set (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFont_font_face_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_font_face_set" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvFont_font_face_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->font_face = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_font_face_get (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvFont_font_face_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_font_face_get" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  result = (int) ((arg1)->font_face);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_ascii_set (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFont_ascii_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_ascii_set" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvFont_ascii_set" "', argument " "2"" of type '" "int const *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->ascii = (int const *)arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_ascii_get (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvFont_ascii_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_ascii_get" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  result = (int *) ((arg1)->ascii);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_greek_set (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFont_greek_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_greek_set" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvFont_greek_set" "', argument " "2"" of type '" "int const *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->greek = (int const *)arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_greek_get (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvFont_greek_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_greek_get" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  result = (int *) ((arg1)->greek);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_cyrillic_set (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFont_cyrillic_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_cyrillic_set" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvFont_cyrillic_set" "', argument " "2"" of type '" "int const *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->cyrillic = (int const *)arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_cyrillic_get (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvFont_cyrillic_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_cyrillic_get" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  result = (int *) ((arg1)->cyrillic);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_hscale_set (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFont_hscale_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_hscale_set" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvFont_hscale_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->hscale = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_hscale_get (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvFont_hscale_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_hscale_get" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  result = (float) ((arg1)->hscale);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_vscale_set (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFont_vscale_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_vscale_set" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvFont_vscale_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->vscale = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_vscale_get (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvFont_vscale_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_vscale_get" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  result = (float) ((arg1)->vscale);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_shear_set (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFont_shear_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_shear_set" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvFont_shear_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->shear = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_shear_get (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvFont_shear_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_shear_get" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  result = (float) ((arg1)->shear);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_thickness_set (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFont_thickness_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_thickness_set" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvFont_thickness_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->thickness = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_thickness_get (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvFont_thickness_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_thickness_get" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  result = (int) ((arg1)->thickness);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_dx_set (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFont_dx_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_dx_set" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvFont_dx_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->dx = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_dx_get (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvFont_dx_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_dx_get" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  result = (float) ((arg1)->dx);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_line_type_set (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvFont_line_type_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_line_type_set" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvFont_line_type_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->line_type = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvFont_line_type_get (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvFont_line_type_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvFont_line_type_get" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  result = (int) ((arg1)->line_type);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvFont (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFont *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvFont",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvFont *)new CvFont(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvFont, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvFont (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvFont",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFont, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvFont" "', argument " "1"" of type '" "CvFont *""'"); 
  }
  arg1 = (CvFont *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvFont_members[] = {
{"font_face",0,_wrap_CvFont_font_face_get,_wrap_CvFont_font_face_set,0,0},
{"ascii",0,_wrap_CvFont_ascii_get,_wrap_CvFont_ascii_set,0,0},
{"greek",0,_wrap_CvFont_greek_get,_wrap_CvFont_greek_set,0,0},
{"cyrillic",0,_wrap_CvFont_cyrillic_get,_wrap_CvFont_cyrillic_set,0,0},
{"hscale",0,_wrap_CvFont_hscale_get,_wrap_CvFont_hscale_set,0,0},
{"vscale",0,_wrap_CvFont_vscale_get,_wrap_CvFont_vscale_set,0,0},
{"shear",0,_wrap_CvFont_shear_get,_wrap_CvFont_shear_set,0,0},
{"thickness",0,_wrap_CvFont_thickness_get,_wrap_CvFont_thickness_set,0,0},
{"dx",0,_wrap_CvFont_dx_get,_wrap_CvFont_dx_set,0,0},
{"line_type",0,_wrap_CvFont_line_type_get,_wrap_CvFont_line_type_set,0,0},
{0,0,0,0}
};
static const char *swig_CvFont_base_names[] = {0};
static const swig_type_info *swig_CvFont_base[] = {0};
static swig_octave_class _wrap_class_CvFont = {"CvFont", &SWIGTYPE_p_CvFont,0,_wrap_new_CvFont,0,_wrap_delete_CvFont,swig_CvFont_members,swig_CvFont_base_names,swig_CvFont_base };

static octave_value_list _wrap_cvInitFont (const octave_value_list& args, int nargout) {
  CvFont *arg1 = (CvFont *) 0 ;
  int arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 = (double) 0 ;
  int arg6 = (int) 1 ;
  int arg7 = (int) 8 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInitFont",args.length(),6,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = (CvFont *)malloc (sizeof (CvFont));
    arg2 = (int)OctInt_AsLong (args(0)); 
    if (SWIG_arg_fail(1)) SWIG_fail;
  }
  ecode3 = SWIG_AsVal_double(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvInitFont" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(args(2), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvInitFont" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  if (3<args.length()) {
    ecode5 = SWIG_AsVal_double(args(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvInitFont" "', argument " "5"" of type '" "double""'");
    } 
    arg5 = (double)(val5);
  }
  if (4<args.length()) {
    ecode6 = SWIG_AsVal_int(args(4), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvInitFont" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (5<args.length()) {
    ecode7 = SWIG_AsVal_int(args(5), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvInitFont" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    try {
      cvInitFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    octave_value to_add;
    
    // extract the pointer we want to add to the returned tuple
    to_add = SWIG_NewPointerObj (arg1, SWIGTYPE_p_CvFont, 0);
    
    _outp = SWIG_AppendResult(_outp, &to_add, 1);
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFont (const octave_value_list& args, int nargout) {
  double arg1 ;
  int arg2 = (int) 1 ;
  double val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFont result;
  
  if (!SWIG_check_num_args("cvFont",args.length(),2,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvFont" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvFont" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    try {
      result = cvFont(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvFont((const CvFont&)(result))), SWIGTYPE_p_CvFont, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvPutText (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  char *arg2 = (char *) 0 ;
  CvPoint arg3 ;
  CvFont *arg4 = (CvFont *) 0 ;
  CvScalar arg5 ;
  bool freearg1 = false ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvPutText",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvPutText" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    arg3 = OctObject_to_CvPoint(args(2));
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvPutText" "', argument " "4"" of type '" "CvFont const *""'"); 
  }
  arg4 = (CvFont *)(argp4);
  {
    arg5 = OctObject_to_CvScalar( args(4) );
  }
  {
    try {
      cvPutText(arg1,(char const *)arg2,arg3,(CvFont const *)arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_cvGetTextSize (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  CvFont *arg2 = (CvFont *) 0 ;
  CvSize *arg3 = (CvSize *) 0 ;
  int *arg4 = (int *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  {
    CvSize *size = (CvSize *)malloc (sizeof (CvSize));
    int *baseline = (int *)malloc (sizeof (int));
    arg3 = size;
    arg4 = baseline;
  }
  if (!SWIG_check_num_args("cvGetTextSize",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetTextSize" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFont, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGetTextSize" "', argument " "2"" of type '" "CvFont const *""'"); 
  }
  arg2 = (CvFont *)(argp2);
  {
    try {
      cvGetTextSize((char const *)arg1,(CvFont const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    octave_value to_add[2];
    
    // extract the pointers we want to add to the returned tuple
    to_add [0] = SWIG_NewPointerObj (arg3, SWIGTYPE_p_CvSize, 0);
    to_add [1] = OctInt_FromLong (*arg4);
    
    _outp = SWIG_AppendResult(_outp, to_add, 2);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_cvColorToScalar (const octave_value_list& args, int nargout) {
  double arg1 ;
  int arg2 ;
  double val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar result;
  
  if (!SWIG_check_num_args("cvColorToScalar",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvColorToScalar" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvColorToScalar" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = cvColorToScalar(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvScalar((const CvScalar&)(result))), SWIGTYPE_p_CvScalar, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvEllipse2Poly (const octave_value_list& args, int nargout) {
  CvPoint arg1 ;
  CvSize arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  CvPoint *arg6 = (CvPoint *) 0 ;
  int arg7 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvEllipse2Poly",args.length(),7,7,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint(args(0));
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvEllipse2Poly" "', argument " "2"" of type '" "CvSize""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvEllipse2Poly" "', argument " "2"" of type '" "CvSize""'");
    } else {
      arg2 = *((CvSize *)(argp2));
    }
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvEllipse2Poly" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvEllipse2Poly" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvEllipse2Poly" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvEllipse2Poly" "', argument " "6"" of type '" "CvPoint *""'"); 
  }
  arg6 = (CvPoint *)(argp6);
  ecode7 = SWIG_AsVal_int(args(6), &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvEllipse2Poly" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = (int)(val7);
  {
    try {
      result = (int)cvEllipse2Poly(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvDrawContours (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  CvScalar arg3 ;
  CvScalar arg4 ;
  int arg5 ;
  int arg6 = (int) 1 ;
  int arg7 = (int) 8 ;
  CvPoint arg8 = (CvPoint) cvPoint(0,0) ;
  bool freearg1 = false ;
  void *ptr2 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvDrawContours",args.length(),8,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  {
    arg3 = OctObject_to_CvScalar( args(2) );
  }
  {
    arg4 = OctObject_to_CvScalar( args(3) );
  }
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvDrawContours" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvDrawContours" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvDrawContours" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (7<args.length()) {
    {
      arg8 = OctObject_to_CvPoint(args(7));
    }
  }
  {
    try {
      cvDrawContours(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvLUT (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvLUT",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    try {
      cvLUT((void const *)arg1,arg2,(void const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvTreeNodeIterator_node_set (const octave_value_list& args, int nargout) {
  CvTreeNodeIterator *arg1 = (CvTreeNodeIterator *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTreeNodeIterator_node_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTreeNodeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTreeNodeIterator_node_set" "', argument " "1"" of type '" "CvTreeNodeIterator *""'"); 
  }
  arg1 = (CvTreeNodeIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, SWIG_POINTER_DISOWN);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvTreeNodeIterator_node_set" "', argument " "2"" of type '" "void const *""'"); 
  }
  if (arg1) (arg1)->node = (void const *)arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTreeNodeIterator_node_get (const octave_value_list& args, int nargout) {
  CvTreeNodeIterator *arg1 = (CvTreeNodeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("CvTreeNodeIterator_node_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTreeNodeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTreeNodeIterator_node_get" "', argument " "1"" of type '" "CvTreeNodeIterator *""'"); 
  }
  arg1 = (CvTreeNodeIterator *)(argp1);
  result = (void *) ((arg1)->node);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTreeNodeIterator_level_set (const octave_value_list& args, int nargout) {
  CvTreeNodeIterator *arg1 = (CvTreeNodeIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTreeNodeIterator_level_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTreeNodeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTreeNodeIterator_level_set" "', argument " "1"" of type '" "CvTreeNodeIterator *""'"); 
  }
  arg1 = (CvTreeNodeIterator *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTreeNodeIterator_level_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->level = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTreeNodeIterator_level_get (const octave_value_list& args, int nargout) {
  CvTreeNodeIterator *arg1 = (CvTreeNodeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvTreeNodeIterator_level_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTreeNodeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTreeNodeIterator_level_get" "', argument " "1"" of type '" "CvTreeNodeIterator *""'"); 
  }
  arg1 = (CvTreeNodeIterator *)(argp1);
  result = (int) ((arg1)->level);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTreeNodeIterator_max_level_set (const octave_value_list& args, int nargout) {
  CvTreeNodeIterator *arg1 = (CvTreeNodeIterator *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTreeNodeIterator_max_level_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTreeNodeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTreeNodeIterator_max_level_set" "', argument " "1"" of type '" "CvTreeNodeIterator *""'"); 
  }
  arg1 = (CvTreeNodeIterator *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTreeNodeIterator_max_level_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->max_level = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTreeNodeIterator_max_level_get (const octave_value_list& args, int nargout) {
  CvTreeNodeIterator *arg1 = (CvTreeNodeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvTreeNodeIterator_max_level_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTreeNodeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTreeNodeIterator_max_level_get" "', argument " "1"" of type '" "CvTreeNodeIterator *""'"); 
  }
  arg1 = (CvTreeNodeIterator *)(argp1);
  result = (int) ((arg1)->max_level);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvTreeNodeIterator (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTreeNodeIterator *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvTreeNodeIterator",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTreeNodeIterator *)new CvTreeNodeIterator(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTreeNodeIterator, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvTreeNodeIterator (const octave_value_list& args, int nargout) {
  CvTreeNodeIterator *arg1 = (CvTreeNodeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvTreeNodeIterator",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTreeNodeIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvTreeNodeIterator" "', argument " "1"" of type '" "CvTreeNodeIterator *""'"); 
  }
  arg1 = (CvTreeNodeIterator *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvTreeNodeIterator_members[] = {
{"node",0,_wrap_CvTreeNodeIterator_node_get,_wrap_CvTreeNodeIterator_node_set,0,0},
{"level",0,_wrap_CvTreeNodeIterator_level_get,_wrap_CvTreeNodeIterator_level_set,0,0},
{"max_level",0,_wrap_CvTreeNodeIterator_max_level_get,_wrap_CvTreeNodeIterator_max_level_set,0,0},
{0,0,0,0}
};
static const char *swig_CvTreeNodeIterator_base_names[] = {0};
static const swig_type_info *swig_CvTreeNodeIterator_base[] = {0};
static swig_octave_class _wrap_class_CvTreeNodeIterator = {"CvTreeNodeIterator", &SWIGTYPE_p_CvTreeNodeIterator,0,_wrap_new_CvTreeNodeIterator,0,_wrap_delete_CvTreeNodeIterator,swig_CvTreeNodeIterator_members,swig_CvTreeNodeIterator_base_names,swig_CvTreeNodeIterator_base };

static octave_value_list _wrap_cvInitTreeNodeIterator (const octave_value_list& args, int nargout) {
  CvTreeNodeIterator *arg1 = (CvTreeNodeIterator *) 0 ;
  void *arg2 = (void *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInitTreeNodeIterator",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTreeNodeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvInitTreeNodeIterator" "', argument " "1"" of type '" "CvTreeNodeIterator *""'"); 
  }
  arg1 = (CvTreeNodeIterator *)(argp1);
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvInitTreeNodeIterator" "', argument " "2"" of type '" "void const *""'"); 
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvInitTreeNodeIterator" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      cvInitTreeNodeIterator(arg1,(void const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvNextTreeNode (const octave_value_list& args, int nargout) {
  CvTreeNodeIterator *arg1 = (CvTreeNodeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("cvNextTreeNode",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTreeNodeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvNextTreeNode" "', argument " "1"" of type '" "CvTreeNodeIterator *""'"); 
  }
  arg1 = (CvTreeNodeIterator *)(argp1);
  {
    try {
      result = (void *)cvNextTreeNode(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvPrevTreeNode (const octave_value_list& args, int nargout) {
  CvTreeNodeIterator *arg1 = (CvTreeNodeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("cvPrevTreeNode",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTreeNodeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvPrevTreeNode" "', argument " "1"" of type '" "CvTreeNodeIterator *""'"); 
  }
  arg1 = (CvTreeNodeIterator *)(argp1);
  {
    try {
      result = (void *)cvPrevTreeNode(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvInsertNodeIntoTree (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  void *arg2 = (void *) 0 ;
  void *arg3 = (void *) 0 ;
  int res1 ;
  int res2 ;
  int res3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInsertNodeIntoTree",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvInsertNodeIntoTree" "', argument " "1"" of type '" "void *""'"); 
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvInsertNodeIntoTree" "', argument " "2"" of type '" "void *""'"); 
  }
  res3 = SWIG_ConvertPtr(args(2),SWIG_as_voidptrptr(&arg3), 0, 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvInsertNodeIntoTree" "', argument " "3"" of type '" "void *""'"); 
  }
  {
    try {
      cvInsertNodeIntoTree(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRemoveNodeFromTree (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  void *arg2 = (void *) 0 ;
  int res1 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRemoveNodeFromTree",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRemoveNodeFromTree" "', argument " "1"" of type '" "void *""'"); 
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvRemoveNodeFromTree" "', argument " "2"" of type '" "void *""'"); 
  }
  {
    try {
      cvRemoveNodeFromTree(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvTreeToNodeSeq (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  int arg2 ;
  CvMemStorage *arg3 = (CvMemStorage *) 0 ;
  int res1 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvTreeToNodeSeq",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvTreeToNodeSeq" "', argument " "1"" of type '" "void const *""'"); 
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvTreeToNodeSeq" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvTreeToNodeSeq" "', argument " "3"" of type '" "CvMemStorage *""'"); 
  }
  arg3 = (CvMemStorage *)(argp3);
  {
    try {
      result = (CvSeq *)cvTreeToNodeSeq((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvKMeans2 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvTermCriteria arg4 ;
  int arg5 = (int) 1 ;
  CvRNG *arg6 = (CvRNG *) 0 ;
  int arg7 = (int) 0 ;
  CvArr *arg8 = (CvArr *) 0 ;
  double *arg9 = (double *) 0 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  bool freearg3 = false ;
  void *argp4 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *vptr6 ;
  CvRNG_Wrapper *wrapper6 ;
  int val7 ;
  int ecode7 = 0 ;
  bool freearg8 = false ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvKMeans2",args.length(),9,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvKMeans2" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    res4 = SWIG_ConvertPtr(args(3), &argp4, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvKMeans2" "', argument " "4"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvKMeans2" "', argument " "4"" of type '" "CvTermCriteria""'");
    } else {
      arg4 = *((CvTermCriteria *)(argp4));
    }
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvKMeans2" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    {
      if(SWIG_ConvertPtr(args(5), &vptr6, SWIGTYPE_p_CvRNG_Wrapper, 0)==-1){
        SWIG_exception( SWIG_TypeError, "could not convert Octave object to C value");
        SWIG_fail;
      }
      wrapper6 = (CvRNG_Wrapper *) vptr6;
      arg6 = wrapper6->ptr();
    }
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvKMeans2" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (7<args.length()) {
    {
      arg8 = OctObject_to_CvArr(args(7), &freearg8);
    }
  }
  if (8<args.length()) {
    res9 = SWIG_ConvertPtr(args(8), &argp9,SWIGTYPE_p_double, 0 |  0 );
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cvKMeans2" "', argument " "9"" of type '" "double *""'"); 
    }
    arg9 = (double *)(argp9);
  }
  {
    try {
      result = (int)cvKMeans2((void const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg8!=NULL && freearg8){
      cvReleaseData( arg8 );
      cvFree(&(arg8));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvRegisterModule (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvRegisterModule",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRegisterModule" "', argument " "1"" of type '" "CvModuleInfo const *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  {
    try {
      result = (int)cvRegisterModule((CvModuleInfo const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvUseOptimized (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvUseOptimized",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvUseOptimized" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    try {
      result = (int)cvUseOptimized(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetModuleInfo (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  char **arg2 = (char **) 0 ;
  char **arg3 = (char **) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *vptr2 ;
  char *buffer2 ;
  void *vptr3 ;
  char *buffer3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvGetModuleInfo",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetModuleInfo" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_char, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (char *) vptr2;
    arg2=&buffer2;
  }
  {
    if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_char, 1)) == -1){
      SWIG_fail;
    }
    buffer3 = (char *) vptr3;
    arg3=&buffer3;
  }
  {
    try {
      cvGetModuleInfo((char const *)arg1,(char const **)arg2,(char const **)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_cvGetErrStatus (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGetErrStatus",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (int)cvGetErrStatus(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetErrStatus (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetErrStatus",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvSetErrStatus" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    try {
      cvSetErrStatus(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetErrMode (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGetErrMode",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (int)cvGetErrMode(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetErrMode (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvSetErrMode",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvSetErrMode" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    try {
      result = (int)cvSetErrMode(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvError (const octave_value_list& args, int nargout) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvError",args.length(),5,5,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvError" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvError" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvError" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvError" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    try {
      cvError(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_cvErrorStr (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("cvErrorStr",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvErrorStr" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    try {
      result = (char *)cvErrorStr(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetErrInfo (const octave_value_list& args, int nargout) {
  char **arg1 = (char **) 0 ;
  char **arg2 = (char **) 0 ;
  char **arg3 = (char **) 0 ;
  int *arg4 = (int *) 0 ;
  void *vptr1 ;
  char *buffer1 ;
  void *vptr2 ;
  char *buffer2 ;
  void *vptr3 ;
  char *buffer3 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGetErrInfo",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_char, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (char *) vptr1;
    arg1=&buffer1;
  }
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_char, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (char *) vptr2;
    arg2=&buffer2;
  }
  {
    if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_char, 1)) == -1){
      SWIG_fail;
    }
    buffer3 = (char *) vptr3;
    arg3=&buffer3;
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvGetErrInfo" "', argument " "4"" of type '" "int *""'"); 
  }
  arg4 = (int *)(argp4);
  {
    try {
      result = (int)cvGetErrInfo((char const **)arg1,(char const **)arg2,(char const **)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvErrorFromIppStatus (const octave_value_list& args, int nargout) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvErrorFromIppStatus",args.length(),1,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvErrorFromIppStatus" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    try {
      result = (int)cvErrorFromIppStatus(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRedirectError (const octave_value_list& args, int nargout) {
  CvErrorCallback arg1 = (CvErrorCallback) 0 ;
  void *arg2 = (void *) NULL ;
  void **arg3 = (void **) NULL ;
  int res2 ;
  void *vptr3 ;
  void *buffer3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvErrorCallback result;
  
  if (!SWIG_check_num_args("cvRedirectError",args.length(),3,1,0)) {
    SWIG_fail;
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(0), (void**)(&arg1), SWIGTYPE_p_f_int_p_q_const__char_p_q_const__char_p_q_const__char_int_p_void__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvRedirectError" "', argument " "1"" of type '" "CvErrorCallback""'"); 
    }
  }
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvRedirectError" "', argument " "2"" of type '" "void *""'"); 
    }
  }
  if (2<args.length()) {
    {
      if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_void, 1)) == -1){
        SWIG_fail;
      }
      buffer3 = (void *) vptr3;
      arg3=&buffer3;
    }
  }
  {
    try {
      result = (CvErrorCallback)cvRedirectError(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewFunctionPtrObj((void *)(result), SWIGTYPE_p_f_int_p_q_const__char_p_q_const__char_p_q_const__char_int_p_void__int);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvNulDevReport (const octave_value_list& args, int nargout) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  void *arg6 = (void *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int res6 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvNulDevReport",args.length(),6,6,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvNulDevReport" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvNulDevReport" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvNulDevReport" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvNulDevReport" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvNulDevReport" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  res6 = SWIG_ConvertPtr(args(5),SWIG_as_voidptrptr(&arg6), 0, 0);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvNulDevReport" "', argument " "6"" of type '" "void *""'"); 
  }
  {
    try {
      result = (int)cvNulDevReport(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_cvStdErrReport (const octave_value_list& args, int nargout) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  void *arg6 = (void *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int res6 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvStdErrReport",args.length(),6,6,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvStdErrReport" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvStdErrReport" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvStdErrReport" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvStdErrReport" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvStdErrReport" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  res6 = SWIG_ConvertPtr(args(5),SWIG_as_voidptrptr(&arg6), 0, 0);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvStdErrReport" "', argument " "6"" of type '" "void *""'"); 
  }
  {
    try {
      result = (int)cvStdErrReport(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_cvGuiBoxReport (const octave_value_list& args, int nargout) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  void *arg6 = (void *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int res6 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGuiBoxReport",args.length(),6,6,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvGuiBoxReport" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGuiBoxReport" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGuiBoxReport" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvGuiBoxReport" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = (char *)(buf4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvGuiBoxReport" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  res6 = SWIG_ConvertPtr(args(5),SWIG_as_voidptrptr(&arg6), 0, 0);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvGuiBoxReport" "', argument " "6"" of type '" "void *""'"); 
  }
  {
    try {
      result = (int)cvGuiBoxReport(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_cvSetMemoryManager (const octave_value_list& args, int nargout) {
  CvAllocFunc arg1 = (CvAllocFunc) NULL ;
  CvFreeFunc arg2 = (CvFreeFunc) NULL ;
  void *arg3 = (void *) NULL ;
  int res3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetMemoryManager",args.length(),3,0,0)) {
    SWIG_fail;
  }
  if (0<args.length()) {
    {
      int res = SWIG_ConvertFunctionPtr(args(0), (void**)(&arg1), SWIGTYPE_p_f_size_t_p_void__p_void);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetMemoryManager" "', argument " "1"" of type '" "CvAllocFunc""'"); 
      }
    }
  }
  if (1<args.length()) {
    {
      int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_void_p_void__int);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetMemoryManager" "', argument " "2"" of type '" "CvFreeFunc""'"); 
      }
    }
  }
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2),SWIG_as_voidptrptr(&arg3), 0, 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvSetMemoryManager" "', argument " "3"" of type '" "void *""'"); 
    }
  }
  {
    try {
      cvSetMemoryManager(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetIPLAllocators (const octave_value_list& args, int nargout) {
  Cv_iplCreateImageHeader arg1 = (Cv_iplCreateImageHeader) 0 ;
  Cv_iplAllocateImageData arg2 = (Cv_iplAllocateImageData) 0 ;
  Cv_iplDeallocate arg3 = (Cv_iplDeallocate) 0 ;
  Cv_iplCreateROI arg4 = (Cv_iplCreateROI) 0 ;
  Cv_iplCloneImage arg5 = (Cv_iplCloneImage) 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetIPLAllocators",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(0), (void**)(&arg1), SWIGTYPE_p_f_int_int_int_p_char_p_char_int_int_int_int_int_p_IplROI_p_IplImage_p_void_p_IplTileInfo__p__IplImage);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetIPLAllocators" "', argument " "1"" of type '" "Cv_iplCreateImageHeader""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p__IplImage_int_int__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetIPLAllocators" "', argument " "2"" of type '" "Cv_iplAllocateImageData""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(2), (void**)(&arg3), SWIGTYPE_p_f_p__IplImage_int__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetIPLAllocators" "', argument " "3"" of type '" "Cv_iplDeallocate""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(3), (void**)(&arg4), SWIGTYPE_p_f_int_int_int_int_int__p__IplROI);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetIPLAllocators" "', argument " "4"" of type '" "Cv_iplCreateROI""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(4), (void**)(&arg5), SWIGTYPE_p_f_p_q_const__IplImage__p__IplImage);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetIPLAllocators" "', argument " "5"" of type '" "Cv_iplCloneImage""'"); 
    }
  }
  {
    try {
      cvSetIPLAllocators(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvOpenFileStorage (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  int arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFileStorage *result = 0 ;
  
  if (!SWIG_check_num_args("cvOpenFileStorage",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvOpenFileStorage" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvOpenFileStorage" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvOpenFileStorage" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvFileStorage *)cvOpenFileStorage((char const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvFileStorage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseFileStorage (const octave_value_list& args, int nargout) {
  CvFileStorage **arg1 = (CvFileStorage **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseFileStorage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseFileStorage" "', argument " "1"" of type '" "CvFileStorage **""'"); 
  }
  arg1 = (CvFileStorage **)(argp1);
  {
    try {
      cvReleaseFileStorage(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvAttrValue (const octave_value_list& args, int nargout) {
  CvAttrList *arg1 = (CvAttrList *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("cvAttrValue",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAttrList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvAttrValue" "', argument " "1"" of type '" "CvAttrList const *""'"); 
  }
  arg1 = (CvAttrList *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvAttrValue" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    try {
      result = (char *)cvAttrValue((CvAttrList const *)arg1,(char const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_cvStartWriteStruct (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  char *arg4 = (char *) NULL ;
  CvAttrList arg5 = (CvAttrList) cvAttrList() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvStartWriteStruct",args.length(),5,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvStartWriteStruct" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvStartWriteStruct" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvStartWriteStruct" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvStartWriteStruct" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (4<args.length()) {
    {
      res5 = SWIG_ConvertPtr(args(4), &argp5, SWIGTYPE_p_CvAttrList,  0 );
      if (!SWIG_IsOK(res5)) {
        SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvStartWriteStruct" "', argument " "5"" of type '" "CvAttrList""'"); 
      }  
      if (!argp5) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvStartWriteStruct" "', argument " "5"" of type '" "CvAttrList""'");
      } else {
        arg5 = *((CvAttrList *)(argp5));
      }
    }
  }
  {
    try {
      cvStartWriteStruct(arg1,(char const *)arg2,arg3,(char const *)arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_cvEndWriteStruct (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvEndWriteStruct",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvEndWriteStruct" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  {
    try {
      cvEndWriteStruct(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvWriteInt (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvWriteInt",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvWriteInt" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvWriteInt" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvWriteInt" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      cvWriteInt(arg1,(char const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_cvWriteReal (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvWriteReal",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvWriteReal" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvWriteReal" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvWriteReal" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      cvWriteReal(arg1,(char const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_cvWriteString (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvWriteString",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvWriteString" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvWriteString" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvWriteString" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvWriteString" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvWriteString(arg1,(char const *)arg2,(char const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_cvWriteComment (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvWriteComment",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvWriteComment" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvWriteComment" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvWriteComment" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      cvWriteComment(arg1,(char const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_cvWrite (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  void *arg3 = (void *) 0 ;
  CvAttrList arg4 = (CvAttrList) cvAttrList() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  void *argp4 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvWrite",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvWrite" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvWrite" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_ConvertPtr(args(2),SWIG_as_voidptrptr(&arg3), 0, 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvWrite" "', argument " "3"" of type '" "void const *""'"); 
  }
  if (3<args.length()) {
    {
      res4 = SWIG_ConvertPtr(args(3), &argp4, SWIGTYPE_p_CvAttrList,  0 );
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvWrite" "', argument " "4"" of type '" "CvAttrList""'"); 
      }  
      if (!argp4) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvWrite" "', argument " "4"" of type '" "CvAttrList""'");
      } else {
        arg4 = *((CvAttrList *)(argp4));
      }
    }
  }
  {
    try {
      cvWrite(arg1,(char const *)arg2,(void const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_cvStartNextStream (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvStartNextStream",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvStartNextStream" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  {
    try {
      cvStartNextStream(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvWriteRawData (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  void *arg2 = (void *) 0 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvWriteRawData",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvWriteRawData" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvWriteRawData" "', argument " "2"" of type '" "void const *""'"); 
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvWriteRawData" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvWriteRawData" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = (char *)(buf4);
  {
    try {
      cvWriteRawData(arg1,(void const *)arg2,arg3,(char const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_cvGetHashedKey (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStringHashNode *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetHashedKey",args.length(),4,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetHashedKey" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGetHashedKey" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetHashedKey" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvGetHashedKey" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      result = (CvStringHashNode *)cvGetHashedKey(arg1,(char const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvStringHashNode, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_cvGetRootFileNode (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFileNode *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetRootFileNode",args.length(),2,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetRootFileNode" "', argument " "1"" of type '" "CvFileStorage const *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetRootFileNode" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    try {
      result = (CvFileNode *)cvGetRootFileNode((CvFileStorage const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetFileNode (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  CvFileNode *arg2 = (CvFileNode *) 0 ;
  CvStringHashNode *arg3 = (CvStringHashNode *) 0 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFileNode *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetFileNode",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetFileNode" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGetFileNode" "', argument " "2"" of type '" "CvFileNode *""'"); 
  }
  arg2 = (CvFileNode *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvStringHashNode, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGetFileNode" "', argument " "3"" of type '" "CvStringHashNode const *""'"); 
  }
  arg3 = (CvStringHashNode *)(argp3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvGetFileNode" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      result = (CvFileNode *)cvGetFileNode(arg1,arg2,(CvStringHashNode const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetFileNodeByName (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  CvFileNode *arg2 = (CvFileNode *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFileNode *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetFileNodeByName",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetFileNodeByName" "', argument " "1"" of type '" "CvFileStorage const *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGetFileNodeByName" "', argument " "2"" of type '" "CvFileNode const *""'"); 
  }
  arg2 = (CvFileNode *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGetFileNodeByName" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    try {
      result = (CvFileNode *)cvGetFileNodeByName((CvFileStorage const *)arg1,(CvFileNode const *)arg2,(char const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_cvReadInt (const octave_value_list& args, int nargout) {
  CvFileNode *arg1 = (CvFileNode *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvReadInt",args.length(),2,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReadInt" "', argument " "1"" of type '" "CvFileNode const *""'"); 
  }
  arg1 = (CvFileNode *)(argp1);
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvReadInt" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    try {
      result = (int)cvReadInt((CvFileNode const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReadIntByName (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  CvFileNode *arg2 = (CvFileNode *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvReadIntByName",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReadIntByName" "', argument " "1"" of type '" "CvFileStorage const *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvReadIntByName" "', argument " "2"" of type '" "CvFileNode const *""'"); 
  }
  arg2 = (CvFileNode *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvReadIntByName" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvReadIntByName" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      result = (int)cvReadIntByName((CvFileStorage const *)arg1,(CvFileNode const *)arg2,(char const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_cvReadReal (const octave_value_list& args, int nargout) {
  CvFileNode *arg1 = (CvFileNode *) 0 ;
  double arg2 = (double) 0. ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvReadReal",args.length(),2,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReadReal" "', argument " "1"" of type '" "CvFileNode const *""'"); 
  }
  arg1 = (CvFileNode *)(argp1);
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_double(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvReadReal" "', argument " "2"" of type '" "double""'");
    } 
    arg2 = (double)(val2);
  }
  {
    try {
      result = (double)cvReadReal((CvFileNode const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReadRealByName (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  CvFileNode *arg2 = (CvFileNode *) 0 ;
  char *arg3 = (char *) 0 ;
  double arg4 = (double) 0. ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvReadRealByName",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReadRealByName" "', argument " "1"" of type '" "CvFileStorage const *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvReadRealByName" "', argument " "2"" of type '" "CvFileNode const *""'"); 
  }
  arg2 = (CvFileNode *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvReadRealByName" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvReadRealByName" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  {
    try {
      result = (double)cvReadRealByName((CvFileStorage const *)arg1,(CvFileNode const *)arg2,(char const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_cvReadString (const octave_value_list& args, int nargout) {
  CvFileNode *arg1 = (CvFileNode *) 0 ;
  char *arg2 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("cvReadString",args.length(),2,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReadString" "', argument " "1"" of type '" "CvFileNode const *""'"); 
  }
  arg1 = (CvFileNode *)(argp1);
  if (1<args.length()) {
    res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvReadString" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = (char *)(buf2);
  }
  {
    try {
      result = (char *)cvReadString((CvFileNode const *)arg1,(char const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_cvReadStringByName (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  CvFileNode *arg2 = (CvFileNode *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("cvReadStringByName",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReadStringByName" "', argument " "1"" of type '" "CvFileStorage const *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvReadStringByName" "', argument " "2"" of type '" "CvFileNode const *""'"); 
  }
  arg2 = (CvFileNode *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvReadStringByName" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  if (3<args.length()) {
    res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvReadStringByName" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
  }
  {
    try {
      result = (char *)cvReadStringByName((CvFileStorage const *)arg1,(CvFileNode const *)arg2,(char const *)arg3,(char const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_cvRead (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  CvFileNode *arg2 = (CvFileNode *) 0 ;
  CvAttrList *arg3 = (CvAttrList *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("cvRead",args.length(),3,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRead" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvRead" "', argument " "2"" of type '" "CvFileNode *""'"); 
  }
  arg2 = (CvFileNode *)(argp2);
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvAttrList, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvRead" "', argument " "3"" of type '" "CvAttrList *""'"); 
    }
    arg3 = (CvAttrList *)(argp3);
  }
  {
    try {
      result = (void *)cvRead(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReadByName (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  CvFileNode *arg2 = (CvFileNode *) 0 ;
  char *arg3 = (char *) 0 ;
  CvAttrList *arg4 = (CvAttrList *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("cvReadByName",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReadByName" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvReadByName" "', argument " "2"" of type '" "CvFileNode const *""'"); 
  }
  arg2 = (CvFileNode *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvReadByName" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  if (3<args.length()) {
    res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvAttrList, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvReadByName" "', argument " "4"" of type '" "CvAttrList *""'"); 
    }
    arg4 = (CvAttrList *)(argp4);
  }
  {
    try {
      result = (void *)cvReadByName(arg1,(CvFileNode const *)arg2,(char const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_cvStartReadRawData (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  CvFileNode *arg2 = (CvFileNode *) 0 ;
  CvSeqReader *arg3 = (CvSeqReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvStartReadRawData",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvStartReadRawData" "', argument " "1"" of type '" "CvFileStorage const *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvStartReadRawData" "', argument " "2"" of type '" "CvFileNode const *""'"); 
  }
  arg2 = (CvFileNode *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvStartReadRawData" "', argument " "3"" of type '" "CvSeqReader *""'"); 
  }
  arg3 = (CvSeqReader *)(argp3);
  {
    try {
      cvStartReadRawData((CvFileStorage const *)arg1,(CvFileNode const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReadRawDataSlice (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  CvSeqReader *arg2 = (CvSeqReader *) 0 ;
  int arg3 ;
  void *arg4 = (void *) 0 ;
  char *arg5 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReadRawDataSlice",args.length(),5,5,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReadRawDataSlice" "', argument " "1"" of type '" "CvFileStorage const *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqReader, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvReadRawDataSlice" "', argument " "2"" of type '" "CvSeqReader *""'"); 
  }
  arg2 = (CvSeqReader *)(argp2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvReadRawDataSlice" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3),SWIG_as_voidptrptr(&arg4), 0, 0);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvReadRawDataSlice" "', argument " "4"" of type '" "void *""'"); 
  }
  res5 = SWIG_AsCharPtrAndSize(args(4), &buf5, NULL, &alloc5);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvReadRawDataSlice" "', argument " "5"" of type '" "char const *""'");
  }
  arg5 = (char *)(buf5);
  {
    try {
      cvReadRawDataSlice((CvFileStorage const *)arg1,arg2,arg3,arg4,(char const *)arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
fail:
  return _out;
}


static octave_value_list _wrap_cvReadRawData (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  CvFileNode *arg2 = (CvFileNode *) 0 ;
  void *arg3 = (void *) 0 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReadRawData",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReadRawData" "', argument " "1"" of type '" "CvFileStorage const *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvReadRawData" "', argument " "2"" of type '" "CvFileNode const *""'"); 
  }
  arg2 = (CvFileNode *)(argp2);
  res3 = SWIG_ConvertPtr(args(2),SWIG_as_voidptrptr(&arg3), 0, 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvReadRawData" "', argument " "3"" of type '" "void *""'"); 
  }
  res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvReadRawData" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = (char *)(buf4);
  {
    try {
      cvReadRawData((CvFileStorage const *)arg1,(CvFileNode const *)arg2,arg3,(char const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_cvWriteFileNode (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  CvFileNode *arg3 = (CvFileNode *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvWriteFileNode",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvWriteFileNode" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvWriteFileNode" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvWriteFileNode" "', argument " "3"" of type '" "CvFileNode const *""'"); 
  }
  arg3 = (CvFileNode *)(argp3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvWriteFileNode" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      cvWriteFileNode(arg1,(char const *)arg2,(CvFileNode const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_cvGetFileNodeName (const octave_value_list& args, int nargout) {
  CvFileNode *arg1 = (CvFileNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetFileNodeName",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetFileNodeName" "', argument " "1"" of type '" "CvFileNode const *""'"); 
  }
  arg1 = (CvFileNode *)(argp1);
  {
    try {
      result = (char *)cvGetFileNodeName((CvFileNode const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_FromCharPtr((const char *)result);
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRegisterType (const octave_value_list& args, int nargout) {
  CvTypeInfo *arg1 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRegisterType",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRegisterType" "', argument " "1"" of type '" "CvTypeInfo const *""'"); 
  }
  arg1 = (CvTypeInfo *)(argp1);
  {
    try {
      cvRegisterType((CvTypeInfo const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvUnregisterType (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvUnregisterType",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvUnregisterType" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    try {
      cvUnregisterType((char const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_cvFirstType (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypeInfo *result = 0 ;
  
  if (!SWIG_check_num_args("cvFirstType",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypeInfo *)cvFirstType(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindType (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypeInfo *result = 0 ;
  
  if (!SWIG_check_num_args("cvFindType",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFindType" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    try {
      result = (CvTypeInfo *)cvFindType((char const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_cvTypeOf (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  int res1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypeInfo *result = 0 ;
  
  if (!SWIG_check_num_args("cvTypeOf",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvTypeOf" "', argument " "1"" of type '" "void const *""'"); 
  }
  {
    try {
      result = (CvTypeInfo *)cvTypeOf((void const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRelease (const octave_value_list& args, int nargout) {
  void **arg1 = (void **) 0 ;
  void *vptr1 ;
  void *buffer1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRelease",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_void, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (void *) vptr1;
    arg1=&buffer1;
  }
  {
    try {
      cvRelease(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvClone (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  int res1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("cvClone",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvClone" "', argument " "1"" of type '" "void const *""'"); 
  }
  {
    try {
      result = (void *)cvClone((void const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSave (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  void *arg2 = (void *) 0 ;
  char *arg3 = (char *) NULL ;
  char *arg4 = (char *) NULL ;
  CvAttrList arg5 = (CvAttrList) cvAttrList() ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSave",args.length(),5,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSave" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvSave" "', argument " "2"" of type '" "void const *""'"); 
  }
  if (2<args.length()) {
    res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvSave" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (3<args.length()) {
    res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvSave" "', argument " "4"" of type '" "char const *""'");
    }
    arg4 = (char *)(buf4);
  }
  if (4<args.length()) {
    {
      res5 = SWIG_ConvertPtr(args(4), &argp5, SWIGTYPE_p_CvAttrList,  0 );
      if (!SWIG_IsOK(res5)) {
        SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvSave" "', argument " "5"" of type '" "CvAttrList""'"); 
      }  
      if (!argp5) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvSave" "', argument " "5"" of type '" "CvAttrList""'");
      } else {
        arg5 = *((CvAttrList *)(argp5));
      }
    }
  }
  {
    try {
      cvSave((char const *)arg1,(void const *)arg2,(char const *)arg3,(char const *)arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_cvLoad (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) NULL ;
  char *arg3 = (char *) NULL ;
  char **arg4 = (char **) NULL ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *vptr4 ;
  char *buffer4 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  void *result = 0 ;
  
  if (!SWIG_check_num_args("cvLoad",args.length(),4,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvLoad" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvLoad" "', argument " "2"" of type '" "CvMemStorage *""'"); 
    }
    arg2 = (CvMemStorage *)(argp2);
  }
  if (2<args.length()) {
    res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvLoad" "', argument " "3"" of type '" "char const *""'");
    }
    arg3 = (char *)(buf3);
  }
  if (3<args.length()) {
    {
      if ((SWIG_ConvertPtr(args(3), &vptr4, SWIGTYPE_p_char, 1)) == -1){
        SWIG_fail;
      }
      buffer4 = (char *) vptr4;
      arg4=&buffer4;
    }
  }
  {
    try {
      result = (void *)cvLoad((char const *)arg1,arg2,(char const *)arg3,(char const **)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_void, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_cvGetTickCount (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int64 result;
  
  if (!SWIG_check_num_args("cvGetTickCount",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = cvGetTickCount(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new int64((const int64&)(result))), SWIGTYPE_p_int64_t, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetTickFrequency (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvGetTickFrequency",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (double)cvGetTickFrequency(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetNumThreads (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGetNumThreads",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (int)cvGetNumThreads(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetNumThreads (const octave_value_list& args, int nargout) {
  int arg1 = (int) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetNumThreads",args.length(),1,0,0)) {
    SWIG_fail;
  }
  if (0<args.length()) {
    ecode1 = SWIG_AsVal_int(args(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvSetNumThreads" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = (int)(val1);
  }
  {
    try {
      cvSetNumThreads(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetThreadNum (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvGetThreadNum",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (int)cvGetThreadNum(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetImageIOFunctions (const octave_value_list& args, int nargout) {
  CvLoadImageFunc arg1 = (CvLoadImageFunc) 0 ;
  CvLoadImageMFunc arg2 = (CvLoadImageMFunc) 0 ;
  CvSaveImageFunc arg3 = (CvSaveImageFunc) 0 ;
  CvShowImageFunc arg4 = (CvShowImageFunc) 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvSetImageIOFunctions",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(0), (void**)(&arg1), SWIGTYPE_p_f_p_q_const__char_int__p__IplImage);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetImageIOFunctions" "', argument " "1"" of type '" "CvLoadImageFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__char_int__p_CvMat);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetImageIOFunctions" "', argument " "2"" of type '" "CvLoadImageMFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(2), (void**)(&arg3), SWIGTYPE_p_f_p_q_const__char_p_q_const__void_p_q_const__int__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetImageIOFunctions" "', argument " "3"" of type '" "CvSaveImageFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(3), (void**)(&arg4), SWIGTYPE_p_f_p_q_const__char_p_q_const__void__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvSetImageIOFunctions" "', argument " "4"" of type '" "CvShowImageFunc""'"); 
    }
  }
  {
    try {
      result = (int)cvSetImageIOFunctions(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvImage__SWIG_0 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvImage *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvImage",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvImage *)new CvImage(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvImage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvImage__SWIG_1 (const octave_value_list& args, int nargout) {
  CvSize arg1 ;
  int arg2 ;
  int arg3 ;
  void *argp1 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvImage *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvImage",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvImage" "', argument " "1"" of type '" "CvSize""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CvImage" "', argument " "1"" of type '" "CvSize""'");
    } else {
      arg1 = *((CvSize *)(argp1));
    }
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CvImage" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvImage" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvImage *)new CvImage(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvImage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvImage__SWIG_2 (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage header1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvImage *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvImage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    try {
      result = (CvImage *)new CvImage(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvImage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvImage__SWIG_3 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvImage *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvImage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvImage,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvImage" "', argument " "1"" of type '" "CvImage const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CvImage" "', argument " "1"" of type '" "CvImage const &""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (CvImage *)new CvImage((CvImage const &)*arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvImage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvImage__SWIG_4 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvImage *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvImage",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvImage" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CvImage" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvImage" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvImage *)new CvImage((char const *)arg1,(char const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvImage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvImage__SWIG_5 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvImage *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvImage",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvImage" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CvImage" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    try {
      result = (CvImage *)new CvImage((char const *)arg1,(char const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvImage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvImage__SWIG_6 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvImage *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvImage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvImage" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    try {
      result = (CvImage *)new CvImage((char const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvImage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvImage__SWIG_7 (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvImage *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvImage",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvImage" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CvImage" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_CvImage" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    try {
      result = (CvImage *)new CvImage(arg1,(char const *)arg2,(char const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvImage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvImage__SWIG_8 (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvImage *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvImage",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvImage" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CvImage" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvImage" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvImage *)new CvImage(arg1,(char const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvImage, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvImage (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 0) {
    return _wrap_new_CvImage__SWIG_0(args, nargout);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p__IplImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CvImage__SWIG_2(args, nargout);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CvImage__SWIG_3(args, nargout);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CvImage__SWIG_6(args, nargout);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_CvImage__SWIG_5(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvSize, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_CvImage__SWIG_1(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvFileStorage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_CvImage__SWIG_8(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvFileStorage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_CvImage__SWIG_7(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_CvImage__SWIG_4(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_delete_CvImage (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvImage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvImage" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_clone (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvImage result;
  
  if (!SWIG_check_num_args("CvImage_clone",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_clone" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (arg1)->clone(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvImage((const CvImage&)(result))), SWIGTYPE_p_CvImage, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_create (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  CvSize arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_create",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_create" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_create" "', argument " "2"" of type '" "CvSize""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvImage_create" "', argument " "2"" of type '" "CvSize""'");
    } else {
      arg2 = *((CvSize *)(argp2));
    }
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CvImage_create" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CvImage_create" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      (arg1)->create(arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_release (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_release",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_release" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      (arg1)->release(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_clear (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_clear",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_clear" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      (arg1)->clear(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_attach__SWIG_0 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  IplImage *arg2 = (IplImage *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IplImage header2 ;
  bool val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_attach",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_attach" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(1), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg2 = cvGetImage((CvMat *)vptr, &header2);
  }
  ecode3 = SWIG_AsVal_bool(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CvImage_attach" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = (bool)(val3);
  {
    try {
      (arg1)->attach(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_attach__SWIG_1 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  IplImage *arg2 = (IplImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  IplImage header2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_attach",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_attach" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(1), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg2 = cvGetImage((CvMat *)vptr, &header2);
  }
  {
    try {
      (arg1)->attach(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_attach (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p__IplImage, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvImage_attach__SWIG_1(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p__IplImage, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_CvImage_attach__SWIG_0(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvImage_detach (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_detach",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_detach" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      (arg1)->detach(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_load__SWIG_0 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvImage_load",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_load" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_load" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvImage_load" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CvImage_load" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      result = (bool)(arg1)->load((char const *)arg2,(char const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_load__SWIG_1 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvImage_load",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_load" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_load" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvImage_load" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    try {
      result = (bool)(arg1)->load((char const *)arg2,(char const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_load__SWIG_2 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvImage_load",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_load" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_load" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    try {
      result = (bool)(arg1)->load((char const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_load (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[4]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvImage_load__SWIG_2(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_CvImage_load__SWIG_1(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_CvImage_load__SWIG_0(args, nargout);
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvImage_read__SWIG_0 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  CvFileStorage *arg2 = (CvFileStorage *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvImage_read",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_read" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_read" "', argument " "2"" of type '" "CvFileStorage *""'"); 
  }
  arg2 = (CvFileStorage *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvImage_read" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CvImage_read" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = (char *)(buf4);
  {
    try {
      result = (bool)(arg1)->read(arg2,(char const *)arg3,(char const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_read__SWIG_1 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  CvFileStorage *arg2 = (CvFileStorage *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvImage_read",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_read" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_read" "', argument " "2"" of type '" "CvFileStorage *""'"); 
  }
  arg2 = (CvFileStorage *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvImage_read" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CvImage_read" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      result = (bool)(arg1)->read(arg2,(char const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_read (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[4]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3)
  };
  
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvFileStorage, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_CvImage_read__SWIG_1(args, nargout);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvFileStorage, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_CvImage_read__SWIG_0(args, nargout);
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvImage_save__SWIG_0 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int *arg4 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_save",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_save" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_save" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvImage_save" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CvImage_save" "', argument " "4"" of type '" "int const *""'"); 
  }
  arg4 = (int *)(argp4);
  {
    try {
      (arg1)->save((char const *)arg2,(char const *)arg3,(int const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_save__SWIG_1 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_save",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_save" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_save" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvImage_save" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    try {
      (arg1)->save((char const *)arg2,(char const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_save (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[4]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3)
  };
  
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_CvImage_save__SWIG_1(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_int, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_CvImage_save__SWIG_0(args, nargout);
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvImage_write (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  CvFileStorage *arg2 = (CvFileStorage *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_write",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_write" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_write" "', argument " "2"" of type '" "CvFileStorage *""'"); 
  }
  arg2 = (CvFileStorage *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvImage_write" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    try {
      (arg1)->write(arg2,(char const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_show (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_show",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_show" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_show" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    try {
      (arg1)->show((char const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_is_valid (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvImage_is_valid",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_is_valid" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (bool)(arg1)->is_valid(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_width (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvImage_width",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_width" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (int)((CvImage const *)arg1)->width(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_height (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvImage_height",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_height" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (int)((CvImage const *)arg1)->height(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_size (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize result;
  
  if (!SWIG_check_num_args("CvImage_size",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_size" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = ((CvImage const *)arg1)->size(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvSize((const CvSize&)(result))), SWIGTYPE_p_CvSize, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_roi_size (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize result;
  
  if (!SWIG_check_num_args("CvImage_roi_size",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_roi_size" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = ((CvImage const *)arg1)->roi_size(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvSize((const CvSize&)(result))), SWIGTYPE_p_CvSize, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_roi (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect result;
  
  if (!SWIG_check_num_args("CvImage_roi",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_roi" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = ((CvImage const *)arg1)->roi(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvRect((const CvRect&)(result))), SWIGTYPE_p_CvRect, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_coi (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvImage_coi",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_coi" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (int)((CvImage const *)arg1)->coi(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_set_roi (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  CvRect arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_set_roi",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_set_roi" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvRect,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvImage_set_roi" "', argument " "2"" of type '" "CvRect""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CvImage_set_roi" "', argument " "2"" of type '" "CvRect""'");
    } else {
      arg2 = *((CvRect *)(argp2));
    }
  }
  {
    try {
      (arg1)->set_roi(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_reset_roi (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_reset_roi",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_reset_roi" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      (arg1)->reset_roi(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_set_coi (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvImage_set_coi",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_set_coi" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvImage_set_coi" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      (arg1)->set_coi(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_depth (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvImage_depth",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_depth" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (int)((CvImage const *)arg1)->depth(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_channels (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvImage_channels",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_channels" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (int)((CvImage const *)arg1)->channels(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_pix_size (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvImage_pix_size",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_pix_size" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (int)((CvImage const *)arg1)->pix_size(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_data__SWIG_0 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvImage_data",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_data" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (uchar *)(arg1)->data(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_data__SWIG_1 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvImage_data",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_data" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (uchar *)((CvImage const *)arg1)->data(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_data (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[1]={
    octave_value_ref(args,0)
  };
  
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_CvImage_data__SWIG_0(args, nargout);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_CvImage_data__SWIG_1(args, nargout);
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvImage_step (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvImage_step",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_step" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (int)((CvImage const *)arg1)->step(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_origin (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvImage_origin",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_origin" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (int)((CvImage const *)arg1)->origin(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_roi_row__SWIG_0 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvImage_roi_row",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_roi_row" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvImage_roi_row" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (uchar *)(arg1)->roi_row(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_roi_row__SWIG_1 (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvImage_roi_row",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_roi_row" "', argument " "1"" of type '" "CvImage const *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvImage_roi_row" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (uchar *)((CvImage const *)arg1)->roi_row(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvImage_roi_row (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvImage_roi_row__SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvImage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvImage_roi_row__SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvImage_asIplImage (const octave_value_list& args, int nargout) {
  CvImage *arg1 = (CvImage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplImage *result = 0 ;
  
  if (!SWIG_check_num_args("CvImage_asIplImage",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvImage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvImage_asIplImage" "', argument " "1"" of type '" "CvImage *""'"); 
  }
  arg1 = (CvImage *)(argp1);
  {
    try {
      result = (IplImage *)(arg1)->operator IplImage*(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    SWIG_exception( SWIG_TypeError, "IplImage * return type is deprecated. Please file a bug report at www.sourceforge.net/opencvlibrary if you see this error message.");
    SWIG_fail;
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvImage_members[] = {
{"clone",_wrap_CvImage_clone,0,0,0,0},
{"create",_wrap_CvImage_create,0,0,0,0},
{"release",_wrap_CvImage_release,0,0,0,0},
{"clear",_wrap_CvImage_clear,0,0,0,0},
{"attach",_wrap_CvImage_attach,0,0,0,0},
{"detach",_wrap_CvImage_detach,0,0,0,0},
{"load",_wrap_CvImage_load,0,0,0,0},
{"read",_wrap_CvImage_read,0,0,0,0},
{"save",_wrap_CvImage_save,0,0,0,0},
{"write",_wrap_CvImage_write,0,0,0,0},
{"show",_wrap_CvImage_show,0,0,0,0},
{"is_valid",_wrap_CvImage_is_valid,0,0,0,0},
{"width",_wrap_CvImage_width,0,0,0,0},
{"height",_wrap_CvImage_height,0,0,0,0},
{"size",_wrap_CvImage_size,0,0,0,0},
{"roi_size",_wrap_CvImage_roi_size,0,0,0,0},
{"roi",_wrap_CvImage_roi,0,0,0,0},
{"coi",_wrap_CvImage_coi,0,0,0,0},
{"set_roi",_wrap_CvImage_set_roi,0,0,0,0},
{"reset_roi",_wrap_CvImage_reset_roi,0,0,0,0},
{"set_coi",_wrap_CvImage_set_coi,0,0,0,0},
{"depth",_wrap_CvImage_depth,0,0,0,0},
{"channels",_wrap_CvImage_channels,0,0,0,0},
{"pix_size",_wrap_CvImage_pix_size,0,0,0,0},
{"data",_wrap_CvImage_data,0,0,0,0},
{"step",_wrap_CvImage_step,0,0,0,0},
{"origin",_wrap_CvImage_origin,0,0,0,0},
{"roi_row",_wrap_CvImage_roi_row,0,0,0,0},
{"asIplImage",_wrap_CvImage_asIplImage,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvImage_base_names[] = {0};
static const swig_type_info *swig_CvImage_base[] = {0};
static swig_octave_class _wrap_class_CvImage = {"CvImage", &SWIGTYPE_p_CvImage,0,_wrap_new_CvImage,0,_wrap_delete_CvImage,swig_CvImage_members,swig_CvImage_base_names,swig_CvImage_base };

static octave_value_list _wrap_new_CvMatrix__SWIG_0 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvMatrix *)new CvMatrix(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_1 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_2 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  CvMat *arg4 = (CvMat *) 0 ;
  void *arg5 = (void *) 0 ;
  int arg6 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int res5 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),6,6,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_CvMatrix" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  res5 = SWIG_ConvertPtr(args(4),SWIG_as_voidptrptr(&arg5), 0, 0);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_CvMatrix" "', argument " "5"" of type '" "void *""'"); 
  }
  ecode6 = SWIG_AsVal_int(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_CvMatrix" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_3 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  CvMat *arg4 = (CvMat *) 0 ;
  void *arg5 = (void *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int res5 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),5,5,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_CvMatrix" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  res5 = SWIG_ConvertPtr(args(4),SWIG_as_voidptrptr(&arg5), 0, 0);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_CvMatrix" "', argument " "5"" of type '" "void *""'"); 
  }
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_4 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  CvMat *arg4 = (CvMat *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),4,4,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_CvMatrix" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_5 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  CvMemStorage *arg4 = (CvMemStorage *) 0 ;
  bool arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),5,5,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_CvMatrix" "', argument " "4"" of type '" "CvMemStorage *""'"); 
  }
  arg4 = (CvMemStorage *)(argp4);
  ecode5 = SWIG_AsVal_bool(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_CvMatrix" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = (bool)(val5);
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_6 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  CvMemStorage *arg4 = (CvMemStorage *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),4,4,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_CvMatrix" "', argument " "4"" of type '" "CvMemStorage *""'"); 
  }
  arg4 = (CvMemStorage *)(argp4);
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_7 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  void *arg4 = (void *) 0 ;
  int arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),5,5,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3),SWIG_as_voidptrptr(&arg4), 0, 0);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_CvMatrix" "', argument " "4"" of type '" "void *""'"); 
  }
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_CvMatrix" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_8 (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  void *arg4 = (void *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),4,4,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  res4 = SWIG_ConvertPtr(args(3),SWIG_as_voidptrptr(&arg4), 0, 0);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_CvMatrix" "', argument " "4"" of type '" "void *""'"); 
  }
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_9 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_10 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = 0 ;
  void *argp1 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvMatrix,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "CvMatrix const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CvMatrix" "', argument " "1"" of type '" "CvMatrix const &""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (CvMatrix *)new CvMatrix((CvMatrix const &)*arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_11 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvMatrix *)new CvMatrix((char const *)arg1,(char const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_12 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    try {
      result = (CvMatrix *)new CvMatrix((char const *)arg1,(char const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_13 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    try {
      result = (CvMatrix *)new CvMatrix((char const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_14 (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1,(char const *)arg2,(char const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix__SWIG_15 (const octave_value_list& args, int nargout) {
  CvFileStorage *arg1 = (CvFileStorage *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvMatrix" "', argument " "1"" of type '" "CvFileStorage *""'"); 
  }
  arg1 = (CvFileStorage *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CvMatrix" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CvMatrix" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvMatrix *)new CvMatrix(arg1,(char const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[6]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3),octave_value_ref(args,4),octave_value_ref(args,5)
  };
  
  if (argc == 0) {
    return _wrap_new_CvMatrix__SWIG_0(args, nargout);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMat, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CvMatrix__SWIG_9(args, nargout);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CvMatrix__SWIG_10(args, nargout);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CvMatrix__SWIG_13(args, nargout);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_CvMatrix__SWIG_12(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvFileStorage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_CvMatrix__SWIG_15(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvFileStorage, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_CvMatrix__SWIG_14(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_CvMatrix__SWIG_1(args, nargout);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_CvMatrix__SWIG_11(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_CvMemStorage, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_CvMatrix__SWIG_6(args, nargout);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_CvMat, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_CvMatrix__SWIG_4(args, nargout);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *ptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &ptr, 0, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_CvMatrix__SWIG_8(args, nargout);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_CvMemStorage, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_bool(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_CvMatrix__SWIG_5(args, nargout);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_CvMat, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *ptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &ptr, 0, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_CvMatrix__SWIG_3(args, nargout);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *ptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &ptr, 0, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_CvMatrix__SWIG_7(args, nargout);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_CvMat, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *ptr = 0;
            int res = SWIG_ConvertPtr(argv[4], &ptr, 0, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              {
                int res = SWIG_AsVal_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_CvMatrix__SWIG_2(args, nargout);
              }
            }
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_delete_CvMatrix (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMatrix",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMatrix" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_clone (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix result;
  
  if (!SWIG_check_num_args("CvMatrix_clone",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_clone" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (arg1)->clone(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvMatrix((const CvMatrix&)(result))), SWIGTYPE_p_CvMatrix, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_set (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_set",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_set" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  ecode3 = SWIG_AsVal_bool(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CvMatrix_set" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = (bool)(val3);
  {
    try {
      (arg1)->set(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_create (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_create",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_create" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMatrix_create" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CvMatrix_create" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CvMatrix_create" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      (arg1)->create(arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_addref (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_addref",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_addref" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      ((CvMatrix const *)arg1)->addref(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_release (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_release",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_release" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      (arg1)->release(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_clear (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_clear",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_clear" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      (arg1)->clear(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_load__SWIG_0 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvMatrix_load",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_load" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_load" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvMatrix_load" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CvMatrix_load" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      result = (bool)(arg1)->load((char const *)arg2,(char const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_load__SWIG_1 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvMatrix_load",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_load" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_load" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvMatrix_load" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    try {
      result = (bool)(arg1)->load((char const *)arg2,(char const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_load__SWIG_2 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvMatrix_load",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_load" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_load" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    try {
      result = (bool)(arg1)->load((char const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_load (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[4]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvMatrix_load__SWIG_2(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_CvMatrix_load__SWIG_1(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_CvMatrix_load__SWIG_0(args, nargout);
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMatrix_read__SWIG_0 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  CvFileStorage *arg2 = (CvFileStorage *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvMatrix_read",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_read" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_read" "', argument " "2"" of type '" "CvFileStorage *""'"); 
  }
  arg2 = (CvFileStorage *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvMatrix_read" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_AsCharPtrAndSize(args(3), &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CvMatrix_read" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = (char *)(buf4);
  {
    try {
      result = (bool)(arg1)->read(arg2,(char const *)arg3,(char const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_read__SWIG_1 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  CvFileStorage *arg2 = (CvFileStorage *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvMatrix_read",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_read" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_read" "', argument " "2"" of type '" "CvFileStorage *""'"); 
  }
  arg2 = (CvFileStorage *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvMatrix_read" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CvMatrix_read" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      result = (bool)(arg1)->read(arg2,(char const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_read (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[4]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3)
  };
  
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvFileStorage, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_CvMatrix_read__SWIG_1(args, nargout);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CvFileStorage, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_CvMatrix_read__SWIG_0(args, nargout);
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMatrix_save__SWIG_0 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int *arg4 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_save",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_save" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_save" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvMatrix_save" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CvMatrix_save" "', argument " "4"" of type '" "int const *""'"); 
  }
  arg4 = (int *)(argp4);
  {
    try {
      (arg1)->save((char const *)arg2,(char const *)arg3,(int const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_save__SWIG_1 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_save",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_save" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_save" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvMatrix_save" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    try {
      (arg1)->save((char const *)arg2,(char const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_save (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[4]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3)
  };
  
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_CvMatrix_save__SWIG_1(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_int, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_CvMatrix_save__SWIG_0(args, nargout);
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMatrix_write (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  CvFileStorage *arg2 = (CvFileStorage *) 0 ;
  char *arg3 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_write",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_write" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvFileStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_write" "', argument " "2"" of type '" "CvFileStorage *""'"); 
  }
  arg2 = (CvFileStorage *)(argp2);
  res3 = SWIG_AsCharPtrAndSize(args(2), &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvMatrix_write" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = (char *)(buf3);
  {
    try {
      (arg1)->write(arg2,(char const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_show (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_show",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_show" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_AsCharPtrAndSize(args(1), &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_show" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = (char *)(buf2);
  {
    try {
      (arg1)->show((char const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_is_valid (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  bool result;
  
  if (!SWIG_check_num_args("CvMatrix_is_valid",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_is_valid" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (bool)(arg1)->is_valid(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_bool((bool)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_rows (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatrix_rows",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_rows" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (int)((CvMatrix const *)arg1)->rows(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_cols (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatrix_cols",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_cols" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (int)((CvMatrix const *)arg1)->cols(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_size (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize result;
  
  if (!SWIG_check_num_args("CvMatrix_size",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_size" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = ((CvMatrix const *)arg1)->size(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvSize((const CvSize&)(result))), SWIGTYPE_p_CvSize, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_type (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatrix_type",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_type" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (int)((CvMatrix const *)arg1)->type(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_depth (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatrix_depth",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_depth" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (int)((CvMatrix const *)arg1)->depth(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_channels (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatrix_channels",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_channels" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (int)((CvMatrix const *)arg1)->channels(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_pix_size (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatrix_pix_size",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_pix_size" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (int)((CvMatrix const *)arg1)->pix_size(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_data__SWIG_0 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatrix_data",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_data" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (uchar *)(arg1)->data(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_data__SWIG_1 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatrix_data",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_data" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (uchar *)((CvMatrix const *)arg1)->data(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_data (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[1]={
    octave_value_ref(args,0)
  };
  
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_CvMatrix_data__SWIG_0(args, nargout);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_CvMatrix_data__SWIG_1(args, nargout);
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMatrix_step (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMatrix_step",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_step" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (int)((CvMatrix const *)arg1)->step(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_set_data__SWIG_0 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *arg2 = (void *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_set_data",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_set_data" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_set_data" "', argument " "2"" of type '" "void *""'"); 
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CvMatrix_set_data" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      (arg1)->set_data(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_set_data__SWIG_1 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *arg2 = (void *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix_set_data",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_set_data" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix_set_data" "', argument " "2"" of type '" "void *""'"); 
  }
  {
    try {
      (arg1)->set_data(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_set_data (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[3]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *ptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &ptr, 0, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_CvMatrix_set_data__SWIG_1(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *ptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &ptr, 0, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_CvMatrix_set_data__SWIG_0(args, nargout);
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMatrix_row__SWIG_0 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatrix_row",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_row" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMatrix_row" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (uchar *)(arg1)->row(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_row__SWIG_1 (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  uchar *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatrix_row",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_row" "', argument " "1"" of type '" "CvMatrix const *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMatrix_row" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (uchar *)((CvMatrix const *)arg1)->row(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_unsigned_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix_row (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[2]={
    octave_value_ref(args,0),octave_value_ref(args,1)
  };
  
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMatrix_row__SWIG_0(args, nargout);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CvMatrix, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_CvMatrix_row__SWIG_1(args, nargout);
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_CvMatrix_asCvMat (const octave_value_list& args, int nargout) {
  CvMatrix *arg1 = (CvMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvMatrix_asCvMat",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix_asCvMat" "', argument " "1"" of type '" "CvMatrix *""'"); 
  }
  arg1 = (CvMatrix *)(argp1);
  {
    try {
      result = (CvMat *)(arg1)->operator CvMat*(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMatrix_members[] = {
{"clone",_wrap_CvMatrix_clone,0,0,0,0},
{"set",_wrap_CvMatrix_set,0,0,0,0},
{"create",_wrap_CvMatrix_create,0,0,0,0},
{"addref",_wrap_CvMatrix_addref,0,0,0,0},
{"release",_wrap_CvMatrix_release,0,0,0,0},
{"clear",_wrap_CvMatrix_clear,0,0,0,0},
{"load",_wrap_CvMatrix_load,0,0,0,0},
{"read",_wrap_CvMatrix_read,0,0,0,0},
{"save",_wrap_CvMatrix_save,0,0,0,0},
{"write",_wrap_CvMatrix_write,0,0,0,0},
{"show",_wrap_CvMatrix_show,0,0,0,0},
{"is_valid",_wrap_CvMatrix_is_valid,0,0,0,0},
{"rows",_wrap_CvMatrix_rows,0,0,0,0},
{"cols",_wrap_CvMatrix_cols,0,0,0,0},
{"size",_wrap_CvMatrix_size,0,0,0,0},
{"type",_wrap_CvMatrix_type,0,0,0,0},
{"depth",_wrap_CvMatrix_depth,0,0,0,0},
{"channels",_wrap_CvMatrix_channels,0,0,0,0},
{"pix_size",_wrap_CvMatrix_pix_size,0,0,0,0},
{"data",_wrap_CvMatrix_data,0,0,0,0},
{"step",_wrap_CvMatrix_step,0,0,0,0},
{"set_data",_wrap_CvMatrix_set_data,0,0,0,0},
{"row",_wrap_CvMatrix_row,0,0,0,0},
{"asCvMat",_wrap_CvMatrix_asCvMat,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvMatrix_base_names[] = {0};
static const swig_type_info *swig_CvMatrix_base[] = {0};
static swig_octave_class _wrap_class_CvMatrix = {"CvMatrix", &SWIGTYPE_p_CvMatrix,0,_wrap_new_CvMatrix,0,_wrap_delete_CvMatrix,swig_CvMatrix_members,swig_CvMatrix_base_names,swig_CvMatrix_base };

static octave_value_list _wrap_new_CvModule (const octave_value_list& args, int nargout) {
  CvModuleInfo *arg1 = (CvModuleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvModule *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvModule",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvModule" "', argument " "1"" of type '" "CvModuleInfo *""'"); 
  }
  arg1 = (CvModuleInfo *)(argp1);
  {
    try {
      result = (CvModule *)new CvModule(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvModule, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvModule (const octave_value_list& args, int nargout) {
  CvModule *arg1 = (CvModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvModule",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvModule" "', argument " "1"" of type '" "CvModule *""'"); 
  }
  arg1 = (CvModule *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvModule_info_set (const octave_value_list& args, int nargout) {
  CvModule *arg1 = (CvModule *) 0 ;
  CvModuleInfo *arg2 = (CvModuleInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvModule_info_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvModule_info_set" "', argument " "1"" of type '" "CvModule *""'"); 
  }
  arg1 = (CvModule *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvModuleInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvModule_info_set" "', argument " "2"" of type '" "CvModuleInfo *""'"); 
  }
  arg2 = (CvModuleInfo *)(argp2);
  if (arg1) (arg1)->info = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvModule_info_get (const octave_value_list& args, int nargout) {
  CvModule *arg1 = (CvModule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvModuleInfo *result = 0 ;
  
  if (!SWIG_check_num_args("CvModule_info_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvModule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvModule_info_get" "', argument " "1"" of type '" "CvModule *""'"); 
  }
  arg1 = (CvModule *)(argp1);
  result = (CvModuleInfo *) ((arg1)->info);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvModuleInfo, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvModule_first_set(const octave_value_list& args,int nargout) {
  if (!SWIG_check_num_args("CvModule_first_set",args.length(),1,1,0)) return octave_value_list();
  
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(args(0), &argp, SWIGTYPE_p_CvModuleInfo,  0 );  
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""CvModule::first""' of type '""CvModuleInfo *""'");
    }
    CvModule::first = (CvModuleInfo *)(argp);
  }
fail:
  return octave_value_list();
}


static octave_value_list _wrap_CvModule_first_get(const octave_value_list& args,int nargout) {
  octave_value obj;
  
  obj = SWIG_NewPointerObj(SWIG_as_voidptr(CvModule::first), SWIGTYPE_p_CvModuleInfo,  0 );
  return obj;
}


static octave_value_list _wrap_CvModule_last_set(const octave_value_list& args,int nargout) {
  if (!SWIG_check_num_args("CvModule_last_set",args.length(),1,1,0)) return octave_value_list();
  
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(args(0), &argp, SWIGTYPE_p_CvModuleInfo,  0 );  
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""CvModule::last""' of type '""CvModuleInfo *""'");
    }
    CvModule::last = (CvModuleInfo *)(argp);
  }
fail:
  return octave_value_list();
}


static octave_value_list _wrap_CvModule_last_get(const octave_value_list& args,int nargout) {
  octave_value obj;
  
  obj = SWIG_NewPointerObj(SWIG_as_voidptr(CvModule::last), SWIGTYPE_p_CvModuleInfo,  0 );
  return obj;
}


static swig_octave_member swig_CvModule_members[] = {
{"info",0,_wrap_CvModule_info_get,_wrap_CvModule_info_set,0,0},
{"first",0,_wrap_CvModule_first_get,_wrap_CvModule_first_set,1,0},
{"last",0,_wrap_CvModule_last_get,_wrap_CvModule_last_set,1,0},
{0,0,0,0}
};
static const char *swig_CvModule_base_names[] = {0};
static const swig_type_info *swig_CvModule_base[] = {0};
static swig_octave_class _wrap_class_CvModule = {"CvModule", &SWIGTYPE_p_CvModule,0,_wrap_new_CvModule,0,_wrap_delete_CvModule,swig_CvModule_members,swig_CvModule_base_names,swig_CvModule_base };

static octave_value_list _wrap_new_CvType__SWIG_0 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  CvIsInstanceFunc arg2 = (CvIsInstanceFunc) 0 ;
  CvReleaseFunc arg3 = (CvReleaseFunc) 0 ;
  CvReadFunc arg4 = (CvReadFunc) 0 ;
  CvWriteFunc arg5 = (CvWriteFunc) 0 ;
  CvCloneFunc arg6 = (CvCloneFunc) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvType *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvType",args.length(),6,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvType" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__void__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "2"" of type '" "CvIsInstanceFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(2), (void**)(&arg3), SWIGTYPE_p_f_p_p_void__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "3"" of type '" "CvReleaseFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(3), (void**)(&arg4), SWIGTYPE_p_f_p_CvFileStorage_p_CvFileNode__p_void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "4"" of type '" "CvReadFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(4), (void**)(&arg5), SWIGTYPE_p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "5"" of type '" "CvWriteFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(5), (void**)(&arg6), SWIGTYPE_p_f_p_q_const__void__p_void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "6"" of type '" "CvCloneFunc""'"); 
    }
  }
  {
    try {
      result = (CvType *)new CvType((char const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvType, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvType__SWIG_1 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  CvIsInstanceFunc arg2 = (CvIsInstanceFunc) 0 ;
  CvReleaseFunc arg3 = (CvReleaseFunc) 0 ;
  CvReadFunc arg4 = (CvReadFunc) 0 ;
  CvWriteFunc arg5 = (CvWriteFunc) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvType *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvType",args.length(),5,5,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvType" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__void__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "2"" of type '" "CvIsInstanceFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(2), (void**)(&arg3), SWIGTYPE_p_f_p_p_void__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "3"" of type '" "CvReleaseFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(3), (void**)(&arg4), SWIGTYPE_p_f_p_CvFileStorage_p_CvFileNode__p_void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "4"" of type '" "CvReadFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(4), (void**)(&arg5), SWIGTYPE_p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "5"" of type '" "CvWriteFunc""'"); 
    }
  }
  {
    try {
      result = (CvType *)new CvType((char const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvType, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvType__SWIG_2 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  CvIsInstanceFunc arg2 = (CvIsInstanceFunc) 0 ;
  CvReleaseFunc arg3 = (CvReleaseFunc) 0 ;
  CvReadFunc arg4 = (CvReadFunc) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvType *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvType",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvType" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__void__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "2"" of type '" "CvIsInstanceFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(2), (void**)(&arg3), SWIGTYPE_p_f_p_p_void__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "3"" of type '" "CvReleaseFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(3), (void**)(&arg4), SWIGTYPE_p_f_p_CvFileStorage_p_CvFileNode__p_void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "4"" of type '" "CvReadFunc""'"); 
    }
  }
  {
    try {
      result = (CvType *)new CvType((char const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvType, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvType__SWIG_3 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  CvIsInstanceFunc arg2 = (CvIsInstanceFunc) 0 ;
  CvReleaseFunc arg3 = (CvReleaseFunc) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvType *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvType",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvType" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__void__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "2"" of type '" "CvIsInstanceFunc""'"); 
    }
  }
  {
    int res = SWIG_ConvertFunctionPtr(args(2), (void**)(&arg3), SWIGTYPE_p_f_p_p_void__void);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "3"" of type '" "CvReleaseFunc""'"); 
    }
  }
  {
    try {
      result = (CvType *)new CvType((char const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvType, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvType__SWIG_4 (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  CvIsInstanceFunc arg2 = (CvIsInstanceFunc) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvType *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvType",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CvType" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    int res = SWIG_ConvertFunctionPtr(args(1), (void**)(&arg2), SWIGTYPE_p_f_p_q_const__void__int);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "new_CvType" "', argument " "2"" of type '" "CvIsInstanceFunc""'"); 
    }
  }
  {
    try {
      result = (CvType *)new CvType((char const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvType, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_new_CvType (const octave_value_list& args, int nargout) {
  int argc = args.length();
  octave_value_ref argv[6]={
    octave_value_ref(args,0),octave_value_ref(args,1),octave_value_ref(args,2),octave_value_ref(args,3),octave_value_ref(args,4),octave_value_ref(args,5)
  };
  
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *ptr = 0;
      int res = SWIG_ConvertFunctionPtr(argv[1], &ptr, SWIGTYPE_p_f_p_q_const__void__int);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_CvType__SWIG_4(args, nargout);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *ptr = 0;
      int res = SWIG_ConvertFunctionPtr(argv[1], &ptr, SWIGTYPE_p_f_p_q_const__void__int);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *ptr = 0;
        int res = SWIG_ConvertFunctionPtr(argv[2], &ptr, SWIGTYPE_p_f_p_p_void__void);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_CvType__SWIG_3(args, nargout);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *ptr = 0;
      int res = SWIG_ConvertFunctionPtr(argv[1], &ptr, SWIGTYPE_p_f_p_q_const__void__int);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *ptr = 0;
        int res = SWIG_ConvertFunctionPtr(argv[2], &ptr, SWIGTYPE_p_f_p_p_void__void);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *ptr = 0;
          int res = SWIG_ConvertFunctionPtr(argv[3], &ptr, SWIGTYPE_p_f_p_CvFileStorage_p_CvFileNode__p_void);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_CvType__SWIG_2(args, nargout);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *ptr = 0;
      int res = SWIG_ConvertFunctionPtr(argv[1], &ptr, SWIGTYPE_p_f_p_q_const__void__int);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *ptr = 0;
        int res = SWIG_ConvertFunctionPtr(argv[2], &ptr, SWIGTYPE_p_f_p_p_void__void);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *ptr = 0;
          int res = SWIG_ConvertFunctionPtr(argv[3], &ptr, SWIGTYPE_p_f_p_CvFileStorage_p_CvFileNode__p_void);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *ptr = 0;
            int res = SWIG_ConvertFunctionPtr(argv[4], &ptr, SWIGTYPE_p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_CvType__SWIG_1(args, nargout);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *ptr = 0;
      int res = SWIG_ConvertFunctionPtr(argv[1], &ptr, SWIGTYPE_p_f_p_q_const__void__int);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *ptr = 0;
        int res = SWIG_ConvertFunctionPtr(argv[2], &ptr, SWIGTYPE_p_f_p_p_void__void);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *ptr = 0;
          int res = SWIG_ConvertFunctionPtr(argv[3], &ptr, SWIGTYPE_p_f_p_CvFileStorage_p_CvFileNode__p_void);
          _v = SWIG_CheckState(res);
          if (_v) {
            void *ptr = 0;
            int res = SWIG_ConvertFunctionPtr(argv[4], &ptr, SWIGTYPE_p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void);
            _v = SWIG_CheckState(res);
            if (_v) {
              void *ptr = 0;
              int res = SWIG_ConvertFunctionPtr(argv[5], &ptr, SWIGTYPE_p_f_p_q_const__void__p_void);
              _v = SWIG_CheckState(res);
              if (_v) {
                return _wrap_new_CvType__SWIG_0(args, nargout);
              }
            }
          }
        }
      }
    }
  }
  
  error("No matching function for overload");
  return octave_value_list();
}


static octave_value_list _wrap_delete_CvType (const octave_value_list& args, int nargout) {
  CvType *arg1 = (CvType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvType",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvType, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvType" "', argument " "1"" of type '" "CvType *""'"); 
  }
  arg1 = (CvType *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvType_info_set (const octave_value_list& args, int nargout) {
  CvType *arg1 = (CvType *) 0 ;
  CvTypeInfo *arg2 = (CvTypeInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvType_info_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvType_info_set" "', argument " "1"" of type '" "CvType *""'"); 
  }
  arg1 = (CvType *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvTypeInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvType_info_set" "', argument " "2"" of type '" "CvTypeInfo *""'"); 
  }
  arg2 = (CvTypeInfo *)(argp2);
  if (arg1) (arg1)->info = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvType_info_get (const octave_value_list& args, int nargout) {
  CvType *arg1 = (CvType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypeInfo *result = 0 ;
  
  if (!SWIG_check_num_args("CvType_info_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvType_info_get" "', argument " "1"" of type '" "CvType *""'"); 
  }
  arg1 = (CvType *)(argp1);
  result = (CvTypeInfo *) ((arg1)->info);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypeInfo, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvType_first_set(const octave_value_list& args,int nargout) {
  if (!SWIG_check_num_args("CvType_first_set",args.length(),1,1,0)) return octave_value_list();
  
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(args(0), &argp, SWIGTYPE_p_CvTypeInfo,  0 );  
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""CvType::first""' of type '""CvTypeInfo *""'");
    }
    CvType::first = (CvTypeInfo *)(argp);
  }
fail:
  return octave_value_list();
}


static octave_value_list _wrap_CvType_first_get(const octave_value_list& args,int nargout) {
  octave_value obj;
  
  obj = SWIG_NewPointerObj(SWIG_as_voidptr(CvType::first), SWIGTYPE_p_CvTypeInfo,  0 );
  return obj;
}


static octave_value_list _wrap_CvType_last_set(const octave_value_list& args,int nargout) {
  if (!SWIG_check_num_args("CvType_last_set",args.length(),1,1,0)) return octave_value_list();
  
  {
    void *argp = 0;
    int res = SWIG_ConvertPtr(args(0), &argp, SWIGTYPE_p_CvTypeInfo,  0 );  
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""CvType::last""' of type '""CvTypeInfo *""'");
    }
    CvType::last = (CvTypeInfo *)(argp);
  }
fail:
  return octave_value_list();
}


static octave_value_list _wrap_CvType_last_get(const octave_value_list& args,int nargout) {
  octave_value obj;
  
  obj = SWIG_NewPointerObj(SWIG_as_voidptr(CvType::last), SWIGTYPE_p_CvTypeInfo,  0 );
  return obj;
}


static swig_octave_member swig_CvType_members[] = {
{"info",0,_wrap_CvType_info_get,_wrap_CvType_info_set,0,0},
{"first",0,_wrap_CvType_first_get,_wrap_CvType_first_set,1,0},
{"last",0,_wrap_CvType_last_get,_wrap_CvType_last_set,1,0},
{0,0,0,0}
};
static const char *swig_CvType_base_names[] = {0};
static const swig_type_info *swig_CvType_base[] = {0};
static swig_octave_class _wrap_class_CvType = {"CvType", &SWIGTYPE_p_CvType,0,_wrap_new_CvType,0,_wrap_delete_CvType,swig_CvType_members,swig_CvType_base_names,swig_CvType_base };

static octave_value_list _wrap_CvMoments_m00_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_m00_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m00_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_m00_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->m00 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m00_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_m00_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m00_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->m00);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m10_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_m10_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m10_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_m10_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->m10 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m10_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_m10_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m10_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->m10);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m01_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_m01_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m01_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_m01_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->m01 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m01_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_m01_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m01_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->m01);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m20_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_m20_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m20_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_m20_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->m20 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m20_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_m20_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m20_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->m20);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m11_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_m11_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m11_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_m11_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->m11 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m11_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_m11_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m11_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->m11);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m02_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_m02_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m02_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_m02_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->m02 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m02_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_m02_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m02_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->m02);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m30_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_m30_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m30_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_m30_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->m30 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m30_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_m30_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m30_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->m30);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m21_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_m21_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m21_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_m21_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->m21 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m21_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_m21_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m21_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->m21);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m12_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_m12_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m12_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_m12_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->m12 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m12_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_m12_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m12_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->m12);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m03_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_m03_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m03_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_m03_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->m03 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_m03_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_m03_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_m03_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->m03);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu20_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_mu20_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu20_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_mu20_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->mu20 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu20_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_mu20_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu20_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->mu20);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu11_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_mu11_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu11_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_mu11_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->mu11 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu11_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_mu11_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu11_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->mu11);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu02_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_mu02_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu02_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_mu02_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->mu02 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu02_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_mu02_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu02_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->mu02);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu30_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_mu30_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu30_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_mu30_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->mu30 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu30_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_mu30_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu30_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->mu30);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu21_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_mu21_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu21_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_mu21_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->mu21 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu21_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_mu21_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu21_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->mu21);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu12_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_mu12_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu12_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_mu12_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->mu12 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu12_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_mu12_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu12_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->mu12);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu03_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_mu03_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu03_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_mu03_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->mu03 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_mu03_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_mu03_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_mu03_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->mu03);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_inv_sqrt_m00_set (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMoments_inv_sqrt_m00_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_inv_sqrt_m00_set" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMoments_inv_sqrt_m00_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->inv_sqrt_m00 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMoments_inv_sqrt_m00_get (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMoments_inv_sqrt_m00_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMoments_inv_sqrt_m00_get" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  result = (double) ((arg1)->inv_sqrt_m00);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMoments (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMoments *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMoments",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvMoments *)new CvMoments(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMoments, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMoments (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMoments",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMoments" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMoments_members[] = {
{"m00",0,_wrap_CvMoments_m00_get,_wrap_CvMoments_m00_set,0,0},
{"m10",0,_wrap_CvMoments_m10_get,_wrap_CvMoments_m10_set,0,0},
{"m01",0,_wrap_CvMoments_m01_get,_wrap_CvMoments_m01_set,0,0},
{"m20",0,_wrap_CvMoments_m20_get,_wrap_CvMoments_m20_set,0,0},
{"m11",0,_wrap_CvMoments_m11_get,_wrap_CvMoments_m11_set,0,0},
{"m02",0,_wrap_CvMoments_m02_get,_wrap_CvMoments_m02_set,0,0},
{"m30",0,_wrap_CvMoments_m30_get,_wrap_CvMoments_m30_set,0,0},
{"m21",0,_wrap_CvMoments_m21_get,_wrap_CvMoments_m21_set,0,0},
{"m12",0,_wrap_CvMoments_m12_get,_wrap_CvMoments_m12_set,0,0},
{"m03",0,_wrap_CvMoments_m03_get,_wrap_CvMoments_m03_set,0,0},
{"mu20",0,_wrap_CvMoments_mu20_get,_wrap_CvMoments_mu20_set,0,0},
{"mu11",0,_wrap_CvMoments_mu11_get,_wrap_CvMoments_mu11_set,0,0},
{"mu02",0,_wrap_CvMoments_mu02_get,_wrap_CvMoments_mu02_set,0,0},
{"mu30",0,_wrap_CvMoments_mu30_get,_wrap_CvMoments_mu30_set,0,0},
{"mu21",0,_wrap_CvMoments_mu21_get,_wrap_CvMoments_mu21_set,0,0},
{"mu12",0,_wrap_CvMoments_mu12_get,_wrap_CvMoments_mu12_set,0,0},
{"mu03",0,_wrap_CvMoments_mu03_get,_wrap_CvMoments_mu03_set,0,0},
{"inv_sqrt_m00",0,_wrap_CvMoments_inv_sqrt_m00_get,_wrap_CvMoments_inv_sqrt_m00_set,0,0},
{0,0,0,0}
};
static const char *swig_CvMoments_base_names[] = {0};
static const swig_type_info *swig_CvMoments_base[] = {0};
static swig_octave_class _wrap_class_CvMoments = {"CvMoments", &SWIGTYPE_p_CvMoments,0,_wrap_new_CvMoments,0,_wrap_delete_CvMoments,swig_CvMoments_members,swig_CvMoments_base_names,swig_CvMoments_base };

static octave_value_list _wrap_CvHuMoments_hu1_set (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHuMoments_hu1_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu1_set" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHuMoments_hu1_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->hu1 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu1_get (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvHuMoments_hu1_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu1_get" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  result = (double) ((arg1)->hu1);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu2_set (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHuMoments_hu2_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu2_set" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHuMoments_hu2_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->hu2 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu2_get (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvHuMoments_hu2_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu2_get" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  result = (double) ((arg1)->hu2);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu3_set (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHuMoments_hu3_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu3_set" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHuMoments_hu3_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->hu3 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu3_get (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvHuMoments_hu3_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu3_get" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  result = (double) ((arg1)->hu3);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu4_set (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHuMoments_hu4_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu4_set" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHuMoments_hu4_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->hu4 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu4_get (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvHuMoments_hu4_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu4_get" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  result = (double) ((arg1)->hu4);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu5_set (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHuMoments_hu5_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu5_set" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHuMoments_hu5_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->hu5 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu5_get (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvHuMoments_hu5_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu5_get" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  result = (double) ((arg1)->hu5);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu6_set (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHuMoments_hu6_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu6_set" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHuMoments_hu6_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->hu6 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu6_get (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvHuMoments_hu6_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu6_get" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  result = (double) ((arg1)->hu6);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu7_set (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHuMoments_hu7_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu7_set" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHuMoments_hu7_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->hu7 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHuMoments_hu7_get (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvHuMoments_hu7_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHuMoments_hu7_get" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  result = (double) ((arg1)->hu7);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvHuMoments (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHuMoments *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvHuMoments",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvHuMoments *)new CvHuMoments(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHuMoments, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvHuMoments (const octave_value_list& args, int nargout) {
  CvHuMoments *arg1 = (CvHuMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvHuMoments",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHuMoments, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvHuMoments" "', argument " "1"" of type '" "CvHuMoments *""'"); 
  }
  arg1 = (CvHuMoments *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvHuMoments_members[] = {
{"hu1",0,_wrap_CvHuMoments_hu1_get,_wrap_CvHuMoments_hu1_set,0,0},
{"hu2",0,_wrap_CvHuMoments_hu2_get,_wrap_CvHuMoments_hu2_set,0,0},
{"hu3",0,_wrap_CvHuMoments_hu3_get,_wrap_CvHuMoments_hu3_set,0,0},
{"hu4",0,_wrap_CvHuMoments_hu4_get,_wrap_CvHuMoments_hu4_set,0,0},
{"hu5",0,_wrap_CvHuMoments_hu5_get,_wrap_CvHuMoments_hu5_set,0,0},
{"hu6",0,_wrap_CvHuMoments_hu6_get,_wrap_CvHuMoments_hu6_set,0,0},
{"hu7",0,_wrap_CvHuMoments_hu7_get,_wrap_CvHuMoments_hu7_set,0,0},
{0,0,0,0}
};
static const char *swig_CvHuMoments_base_names[] = {0};
static const swig_type_info *swig_CvHuMoments_base[] = {0};
static swig_octave_class _wrap_class_CvHuMoments = {"CvHuMoments", &SWIGTYPE_p_CvHuMoments,0,_wrap_new_CvHuMoments,0,_wrap_delete_CvHuMoments,swig_CvHuMoments_members,swig_CvHuMoments_base_names,swig_CvHuMoments_base };

static octave_value_list _wrap_CvConnectedComp_area_set (const octave_value_list& args, int nargout) {
  CvConnectedComp *arg1 = (CvConnectedComp *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConnectedComp_area_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConnectedComp_area_set" "', argument " "1"" of type '" "CvConnectedComp *""'"); 
  }
  arg1 = (CvConnectedComp *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvConnectedComp_area_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->area = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConnectedComp_area_get (const octave_value_list& args, int nargout) {
  CvConnectedComp *arg1 = (CvConnectedComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvConnectedComp_area_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConnectedComp_area_get" "', argument " "1"" of type '" "CvConnectedComp *""'"); 
  }
  arg1 = (CvConnectedComp *)(argp1);
  result = (double) ((arg1)->area);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConnectedComp_value_set (const octave_value_list& args, int nargout) {
  CvConnectedComp *arg1 = (CvConnectedComp *) 0 ;
  CvScalar *arg2 = (CvScalar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConnectedComp_value_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConnectedComp_value_set" "', argument " "1"" of type '" "CvConnectedComp *""'"); 
  }
  arg1 = (CvConnectedComp *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvScalar, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConnectedComp_value_set" "', argument " "2"" of type '" "CvScalar *""'"); 
  }
  arg2 = (CvScalar *)(argp2);
  if (arg1) (arg1)->value = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConnectedComp_value_get (const octave_value_list& args, int nargout) {
  CvConnectedComp *arg1 = (CvConnectedComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvScalar *result = 0 ;
  
  if (!SWIG_check_num_args("CvConnectedComp_value_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConnectedComp_value_get" "', argument " "1"" of type '" "CvConnectedComp *""'"); 
  }
  arg1 = (CvConnectedComp *)(argp1);
  result = (CvScalar *)& ((arg1)->value);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvScalar, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConnectedComp_rect_set (const octave_value_list& args, int nargout) {
  CvConnectedComp *arg1 = (CvConnectedComp *) 0 ;
  CvRect *arg2 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConnectedComp_rect_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConnectedComp_rect_set" "', argument " "1"" of type '" "CvConnectedComp *""'"); 
  }
  arg1 = (CvConnectedComp *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConnectedComp_rect_set" "', argument " "2"" of type '" "CvRect *""'"); 
  }
  arg2 = (CvRect *)(argp2);
  if (arg1) (arg1)->rect = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConnectedComp_rect_get (const octave_value_list& args, int nargout) {
  CvConnectedComp *arg1 = (CvConnectedComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect *result = 0 ;
  
  if (!SWIG_check_num_args("CvConnectedComp_rect_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConnectedComp_rect_get" "', argument " "1"" of type '" "CvConnectedComp *""'"); 
  }
  arg1 = (CvConnectedComp *)(argp1);
  result = (CvRect *)& ((arg1)->rect);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvRect, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConnectedComp_contour_set (const octave_value_list& args, int nargout) {
  CvConnectedComp *arg1 = (CvConnectedComp *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConnectedComp_contour_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConnectedComp_contour_set" "', argument " "1"" of type '" "CvConnectedComp *""'"); 
  }
  arg1 = (CvConnectedComp *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->contour = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConnectedComp_contour_get (const octave_value_list& args, int nargout) {
  CvConnectedComp *arg1 = (CvConnectedComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvConnectedComp_contour_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConnectedComp_contour_get" "', argument " "1"" of type '" "CvConnectedComp *""'"); 
  }
  arg1 = (CvConnectedComp *)(argp1);
  result = (CvSeq *) ((arg1)->contour);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvConnectedComp (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvConnectedComp *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvConnectedComp",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvConnectedComp *)new CvConnectedComp(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvConnectedComp, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvConnectedComp (const octave_value_list& args, int nargout) {
  CvConnectedComp *arg1 = (CvConnectedComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvConnectedComp",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConnectedComp, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvConnectedComp" "', argument " "1"" of type '" "CvConnectedComp *""'"); 
  }
  arg1 = (CvConnectedComp *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvConnectedComp_members[] = {
{"area",0,_wrap_CvConnectedComp_area_get,_wrap_CvConnectedComp_area_set,0,0},
{"value",0,_wrap_CvConnectedComp_value_get,_wrap_CvConnectedComp_value_set,0,0},
{"rect",0,_wrap_CvConnectedComp_rect_get,_wrap_CvConnectedComp_rect_set,0,0},
{"contour",0,_wrap_CvConnectedComp_contour_get,_wrap_CvConnectedComp_contour_set,0,0},
{0,0,0,0}
};
static const char *swig_CvConnectedComp_base_names[] = {0};
static const swig_type_info *swig_CvConnectedComp_base[] = {0};
static swig_octave_class _wrap_class_CvConnectedComp = {"CvConnectedComp", &SWIGTYPE_p_CvConnectedComp,0,_wrap_new_CvConnectedComp,0,_wrap_delete_CvConnectedComp,swig_CvConnectedComp_members,swig_CvConnectedComp_base_names,swig_CvConnectedComp_base };

static octave_value_list _wrap_CvChainPtReader_header_size_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_header_size_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvChainPtReader_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_header_size_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvChainPtReader_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_header_size_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_seq_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_seq_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_seq_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->seq = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_seq_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvChainPtReader_seq_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_seq_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (CvSeq *) ((arg1)->seq);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_block_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_block_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_block_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChainPtReader_block_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->block = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_block_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvChainPtReader_block_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_block_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (CvSeqBlock *) ((arg1)->block);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_ptr_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_ptr_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChainPtReader_ptr_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_ptr_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvChainPtReader_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_ptr_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (schar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_block_min_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_block_min_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_block_min_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChainPtReader_block_min_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_min = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_block_min_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvChainPtReader_block_min_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_block_min_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (schar *) ((arg1)->block_min);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_block_max_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_block_max_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_block_max_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChainPtReader_block_max_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_max = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_block_max_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvChainPtReader_block_max_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_block_max_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (schar *) ((arg1)->block_max);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_delta_index_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_delta_index_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_delta_index_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvChainPtReader_delta_index_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->delta_index = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_delta_index_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvChainPtReader_delta_index_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_delta_index_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (int) ((arg1)->delta_index);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_prev_elem_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_prev_elem_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_prev_elem_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChainPtReader_prev_elem_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->prev_elem = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_prev_elem_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvChainPtReader_prev_elem_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_prev_elem_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (schar *) ((arg1)->prev_elem);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_code_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_code_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_code_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  ecode2 = SWIG_AsVal_char(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvChainPtReader_code_set" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = (char)(val2);
  if (arg1) (arg1)->code = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_code_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  char result;
  
  if (!SWIG_check_num_args("CvChainPtReader_code_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_code_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (char) ((arg1)->code);
  _outv = SWIG_From_char((char)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_pt_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_pt_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_pt_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChainPtReader_pt_set" "', argument " "2"" of type '" "CvPoint *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  if (arg1) (arg1)->pt = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_pt_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvChainPtReader_pt_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_pt_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (CvPoint *)& ((arg1)->pt);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_deltas_set (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  schar (*arg2)[2] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvChainPtReader_deltas_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_deltas_set" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_a_2__signed_char, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvChainPtReader_deltas_set" "', argument " "2"" of type '" "schar [8][2]""'"); 
  } 
  arg2 = (schar (*)[2])(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)8; ++ii) {
        if (arg2[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)2; ++jj) arg1->deltas[ii][jj] = arg2[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""deltas""' of type '""schar [8][2]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""deltas""' of type '""schar [8][2]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvChainPtReader_deltas_get (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar (*result)[2] = 0 ;
  
  if (!SWIG_check_num_args("CvChainPtReader_deltas_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvChainPtReader_deltas_get" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  result = (schar (*)[2])(schar (*)[2]) ((arg1)->deltas);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_a_2__signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvChainPtReader (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvChainPtReader *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvChainPtReader",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvChainPtReader *)new CvChainPtReader(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvChainPtReader, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvChainPtReader (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvChainPtReader",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvChainPtReader" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvChainPtReader_members[] = {
{"header_size",0,_wrap_CvChainPtReader_header_size_get,_wrap_CvChainPtReader_header_size_set,0,0},
{"seq",0,_wrap_CvChainPtReader_seq_get,_wrap_CvChainPtReader_seq_set,0,0},
{"block",0,_wrap_CvChainPtReader_block_get,_wrap_CvChainPtReader_block_set,0,0},
{"ptr",0,_wrap_CvChainPtReader_ptr_get,_wrap_CvChainPtReader_ptr_set,0,0},
{"block_min",0,_wrap_CvChainPtReader_block_min_get,_wrap_CvChainPtReader_block_min_set,0,0},
{"block_max",0,_wrap_CvChainPtReader_block_max_get,_wrap_CvChainPtReader_block_max_set,0,0},
{"delta_index",0,_wrap_CvChainPtReader_delta_index_get,_wrap_CvChainPtReader_delta_index_set,0,0},
{"prev_elem",0,_wrap_CvChainPtReader_prev_elem_get,_wrap_CvChainPtReader_prev_elem_set,0,0},
{"code",0,_wrap_CvChainPtReader_code_get,_wrap_CvChainPtReader_code_set,0,0},
{"pt",0,_wrap_CvChainPtReader_pt_get,_wrap_CvChainPtReader_pt_set,0,0},
{"deltas",0,_wrap_CvChainPtReader_deltas_get,_wrap_CvChainPtReader_deltas_set,0,0},
{0,0,0,0}
};
static const char *swig_CvChainPtReader_base_names[] = {0};
static const swig_type_info *swig_CvChainPtReader_base[] = {0};
static swig_octave_class _wrap_class_CvChainPtReader = {"CvChainPtReader", &SWIGTYPE_p_CvChainPtReader,0,_wrap_new_CvChainPtReader,0,_wrap_delete_CvChainPtReader,swig_CvChainPtReader_members,swig_CvChainPtReader_base_names,swig_CvChainPtReader_base };

static octave_value_list _wrap_CvContourTree_flags_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_flags_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContourTree_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_flags_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContourTree_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_flags_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_header_size_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_header_size_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContourTree_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_header_size_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContourTree_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_header_size_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_h_prev_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_h_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_h_prev_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_h_prev_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_h_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_h_prev_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (CvSeq *) ((arg1)->h_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_h_next_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_h_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_h_next_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_h_next_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_h_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_h_next_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (CvSeq *) ((arg1)->h_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_v_prev_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_v_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_v_prev_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_v_prev_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_v_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_v_prev_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (CvSeq *) ((arg1)->v_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_v_next_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_v_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_v_next_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_v_next_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_v_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_v_next_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (CvSeq *) ((arg1)->v_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_total_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_total_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_total_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContourTree_total_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->total = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_total_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContourTree_total_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_total_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (int) ((arg1)->total);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_elem_size_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_elem_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_elem_size_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContourTree_elem_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->elem_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_elem_size_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContourTree_elem_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_elem_size_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (int) ((arg1)->elem_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_block_max_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_block_max_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_block_max_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContourTree_block_max_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_max = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_block_max_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_block_max_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_block_max_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (schar *) ((arg1)->block_max);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_ptr_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_ptr_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContourTree_ptr_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_ptr_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_ptr_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (schar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_delta_elems_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_delta_elems_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_delta_elems_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvContourTree_delta_elems_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->delta_elems = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_delta_elems_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvContourTree_delta_elems_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_delta_elems_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (int) ((arg1)->delta_elems);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_storage_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_storage_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_storage_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContourTree_storage_set" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (arg1) (arg1)->storage = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_storage_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStorage *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_storage_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_storage_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (CvMemStorage *) ((arg1)->storage);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_free_blocks_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_free_blocks_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_free_blocks_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContourTree_free_blocks_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->free_blocks = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_free_blocks_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_free_blocks_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_free_blocks_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (CvSeqBlock *) ((arg1)->free_blocks);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_first_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_first_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_first_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContourTree_first_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->first = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_first_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_first_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_first_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (CvSeqBlock *) ((arg1)->first);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_p1_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_p1_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_p1_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContourTree_p1_set" "', argument " "2"" of type '" "CvPoint *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  if (arg1) (arg1)->p1 = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_p1_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_p1_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_p1_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (CvPoint *)& ((arg1)->p1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_p2_set (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvContourTree_p2_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_p2_set" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvContourTree_p2_set" "', argument " "2"" of type '" "CvPoint *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  if (arg1) (arg1)->p2 = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvContourTree_p2_get (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvContourTree_p2_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvContourTree_p2_get" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  result = (CvPoint *)& ((arg1)->p2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvContourTree (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvContourTree *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvContourTree",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvContourTree *)new CvContourTree(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvContourTree, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvContourTree (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvContourTree",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvContourTree" "', argument " "1"" of type '" "CvContourTree *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvContourTree_members[] = {
{"flags",0,_wrap_CvContourTree_flags_get,_wrap_CvContourTree_flags_set,0,0},
{"header_size",0,_wrap_CvContourTree_header_size_get,_wrap_CvContourTree_header_size_set,0,0},
{"h_prev",0,_wrap_CvContourTree_h_prev_get,_wrap_CvContourTree_h_prev_set,0,0},
{"h_next",0,_wrap_CvContourTree_h_next_get,_wrap_CvContourTree_h_next_set,0,0},
{"v_prev",0,_wrap_CvContourTree_v_prev_get,_wrap_CvContourTree_v_prev_set,0,0},
{"v_next",0,_wrap_CvContourTree_v_next_get,_wrap_CvContourTree_v_next_set,0,0},
{"total",0,_wrap_CvContourTree_total_get,_wrap_CvContourTree_total_set,0,0},
{"elem_size",0,_wrap_CvContourTree_elem_size_get,_wrap_CvContourTree_elem_size_set,0,0},
{"block_max",0,_wrap_CvContourTree_block_max_get,_wrap_CvContourTree_block_max_set,0,0},
{"ptr",0,_wrap_CvContourTree_ptr_get,_wrap_CvContourTree_ptr_set,0,0},
{"delta_elems",0,_wrap_CvContourTree_delta_elems_get,_wrap_CvContourTree_delta_elems_set,0,0},
{"storage",0,_wrap_CvContourTree_storage_get,_wrap_CvContourTree_storage_set,0,0},
{"free_blocks",0,_wrap_CvContourTree_free_blocks_get,_wrap_CvContourTree_free_blocks_set,0,0},
{"first",0,_wrap_CvContourTree_first_get,_wrap_CvContourTree_first_set,0,0},
{"p1",0,_wrap_CvContourTree_p1_get,_wrap_CvContourTree_p1_set,0,0},
{"p2",0,_wrap_CvContourTree_p2_get,_wrap_CvContourTree_p2_set,0,0},
{0,0,0,0}
};
static const char *swig_CvContourTree_base_names[] = {0};
static const swig_type_info *swig_CvContourTree_base[] = {0};
static swig_octave_class _wrap_class_CvContourTree = {"CvContourTree", &SWIGTYPE_p_CvContourTree,0,_wrap_new_CvContourTree,0,_wrap_delete_CvContourTree,swig_CvContourTree_members,swig_CvContourTree_base_names,swig_CvContourTree_base };

static octave_value_list _wrap_CvConvexityDefect_start_set (const octave_value_list& args, int nargout) {
  CvConvexityDefect *arg1 = (CvConvexityDefect *) 0 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConvexityDefect_start_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConvexityDefect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConvexityDefect_start_set" "', argument " "1"" of type '" "CvConvexityDefect *""'"); 
  }
  arg1 = (CvConvexityDefect *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConvexityDefect_start_set" "', argument " "2"" of type '" "CvPoint *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  if (arg1) (arg1)->start = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConvexityDefect_start_get (const octave_value_list& args, int nargout) {
  CvConvexityDefect *arg1 = (CvConvexityDefect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvConvexityDefect_start_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConvexityDefect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConvexityDefect_start_get" "', argument " "1"" of type '" "CvConvexityDefect *""'"); 
  }
  arg1 = (CvConvexityDefect *)(argp1);
  result = (CvPoint *) ((arg1)->start);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConvexityDefect_end_set (const octave_value_list& args, int nargout) {
  CvConvexityDefect *arg1 = (CvConvexityDefect *) 0 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConvexityDefect_end_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConvexityDefect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConvexityDefect_end_set" "', argument " "1"" of type '" "CvConvexityDefect *""'"); 
  }
  arg1 = (CvConvexityDefect *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConvexityDefect_end_set" "', argument " "2"" of type '" "CvPoint *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  if (arg1) (arg1)->end = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConvexityDefect_end_get (const octave_value_list& args, int nargout) {
  CvConvexityDefect *arg1 = (CvConvexityDefect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvConvexityDefect_end_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConvexityDefect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConvexityDefect_end_get" "', argument " "1"" of type '" "CvConvexityDefect *""'"); 
  }
  arg1 = (CvConvexityDefect *)(argp1);
  result = (CvPoint *) ((arg1)->end);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConvexityDefect_depth_point_set (const octave_value_list& args, int nargout) {
  CvConvexityDefect *arg1 = (CvConvexityDefect *) 0 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConvexityDefect_depth_point_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConvexityDefect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConvexityDefect_depth_point_set" "', argument " "1"" of type '" "CvConvexityDefect *""'"); 
  }
  arg1 = (CvConvexityDefect *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConvexityDefect_depth_point_set" "', argument " "2"" of type '" "CvPoint *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  if (arg1) (arg1)->depth_point = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConvexityDefect_depth_point_get (const octave_value_list& args, int nargout) {
  CvConvexityDefect *arg1 = (CvConvexityDefect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvConvexityDefect_depth_point_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConvexityDefect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConvexityDefect_depth_point_get" "', argument " "1"" of type '" "CvConvexityDefect *""'"); 
  }
  arg1 = (CvConvexityDefect *)(argp1);
  result = (CvPoint *) ((arg1)->depth_point);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConvexityDefect_depth_set (const octave_value_list& args, int nargout) {
  CvConvexityDefect *arg1 = (CvConvexityDefect *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConvexityDefect_depth_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConvexityDefect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConvexityDefect_depth_set" "', argument " "1"" of type '" "CvConvexityDefect *""'"); 
  }
  arg1 = (CvConvexityDefect *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvConvexityDefect_depth_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->depth = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConvexityDefect_depth_get (const octave_value_list& args, int nargout) {
  CvConvexityDefect *arg1 = (CvConvexityDefect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvConvexityDefect_depth_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConvexityDefect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConvexityDefect_depth_get" "', argument " "1"" of type '" "CvConvexityDefect *""'"); 
  }
  arg1 = (CvConvexityDefect *)(argp1);
  result = (float) ((arg1)->depth);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvConvexityDefect (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvConvexityDefect *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvConvexityDefect",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvConvexityDefect *)new CvConvexityDefect(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvConvexityDefect, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvConvexityDefect (const octave_value_list& args, int nargout) {
  CvConvexityDefect *arg1 = (CvConvexityDefect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvConvexityDefect",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConvexityDefect, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvConvexityDefect" "', argument " "1"" of type '" "CvConvexityDefect *""'"); 
  }
  arg1 = (CvConvexityDefect *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvConvexityDefect_members[] = {
{"start",0,_wrap_CvConvexityDefect_start_get,_wrap_CvConvexityDefect_start_set,0,0},
{"end",0,_wrap_CvConvexityDefect_end_get,_wrap_CvConvexityDefect_end_set,0,0},
{"depth_point",0,_wrap_CvConvexityDefect_depth_point_get,_wrap_CvConvexityDefect_depth_point_set,0,0},
{"depth",0,_wrap_CvConvexityDefect_depth_get,_wrap_CvConvexityDefect_depth_set,0,0},
{0,0,0,0}
};
static const char *swig_CvConvexityDefect_base_names[] = {0};
static const swig_type_info *swig_CvConvexityDefect_base[] = {0};
static swig_octave_class _wrap_class_CvConvexityDefect = {"CvConvexityDefect", &SWIGTYPE_p_CvConvexityDefect,0,_wrap_new_CvConvexityDefect,0,_wrap_delete_CvConvexityDefect,swig_CvConvexityDefect_members,swig_CvConvexityDefect_base_names,swig_CvConvexityDefect_base };

static octave_value_list _wrap_CvQuadEdge2D_flags_set (const octave_value_list& args, int nargout) {
  CvQuadEdge2D *arg1 = (CvQuadEdge2D *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvQuadEdge2D_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvQuadEdge2D_flags_set" "', argument " "1"" of type '" "CvQuadEdge2D *""'"); 
  }
  arg1 = (CvQuadEdge2D *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvQuadEdge2D_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvQuadEdge2D_flags_get (const octave_value_list& args, int nargout) {
  CvQuadEdge2D *arg1 = (CvQuadEdge2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvQuadEdge2D_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvQuadEdge2D_flags_get" "', argument " "1"" of type '" "CvQuadEdge2D *""'"); 
  }
  arg1 = (CvQuadEdge2D *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvQuadEdge2D_pt_set (const octave_value_list& args, int nargout) {
  CvQuadEdge2D *arg1 = (CvQuadEdge2D *) 0 ;
  CvSubdiv2DPoint **arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvQuadEdge2D_pt_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvQuadEdge2D_pt_set" "', argument " "1"" of type '" "CvQuadEdge2D *""'"); 
  }
  arg1 = (CvQuadEdge2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_p_CvSubdiv2DPoint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvQuadEdge2D_pt_set" "', argument " "2"" of type '" "CvSubdiv2DPoint *[4]""'"); 
  } 
  arg2 = (CvSubdiv2DPoint **)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)4; ++ii) arg1->pt[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""pt""' of type '""CvSubdiv2DPoint *[4]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvQuadEdge2D_pt_get (const octave_value_list& args, int nargout) {
  CvQuadEdge2D *arg1 = (CvQuadEdge2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DPoint **result = 0 ;
  
  if (!SWIG_check_num_args("CvQuadEdge2D_pt_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvQuadEdge2D_pt_get" "', argument " "1"" of type '" "CvQuadEdge2D *""'"); 
  }
  arg1 = (CvQuadEdge2D *)(argp1);
  result = (CvSubdiv2DPoint **)(CvSubdiv2DPoint **) ((arg1)->pt);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_CvSubdiv2DPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvQuadEdge2D_next_set (const octave_value_list& args, int nargout) {
  CvQuadEdge2D *arg1 = (CvQuadEdge2D *) 0 ;
  CvSubdiv2DEdge *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvQuadEdge2D_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvQuadEdge2D_next_set" "', argument " "1"" of type '" "CvQuadEdge2D *""'"); 
  }
  arg1 = (CvQuadEdge2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_size_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvQuadEdge2D_next_set" "', argument " "2"" of type '" "CvSubdiv2DEdge [4]""'"); 
  } 
  arg2 = (CvSubdiv2DEdge *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)4; ++ii) arg1->next[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""next""' of type '""CvSubdiv2DEdge [4]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvQuadEdge2D_next_get (const octave_value_list& args, int nargout) {
  CvQuadEdge2D *arg1 = (CvQuadEdge2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DEdge *result = 0 ;
  
  if (!SWIG_check_num_args("CvQuadEdge2D_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvQuadEdge2D_next_get" "', argument " "1"" of type '" "CvQuadEdge2D *""'"); 
  }
  arg1 = (CvQuadEdge2D *)(argp1);
  result = (CvSubdiv2DEdge *)(CvSubdiv2DEdge *) ((arg1)->next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_size_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvQuadEdge2D (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvQuadEdge2D *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvQuadEdge2D",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvQuadEdge2D *)new CvQuadEdge2D(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvQuadEdge2D, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvQuadEdge2D (const octave_value_list& args, int nargout) {
  CvQuadEdge2D *arg1 = (CvQuadEdge2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvQuadEdge2D",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvQuadEdge2D, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvQuadEdge2D" "', argument " "1"" of type '" "CvQuadEdge2D *""'"); 
  }
  arg1 = (CvQuadEdge2D *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvQuadEdge2D_members[] = {
{"flags",0,_wrap_CvQuadEdge2D_flags_get,_wrap_CvQuadEdge2D_flags_set,0,0},
{"pt",0,_wrap_CvQuadEdge2D_pt_get,_wrap_CvQuadEdge2D_pt_set,0,0},
{"next",0,_wrap_CvQuadEdge2D_next_get,_wrap_CvQuadEdge2D_next_set,0,0},
{0,0,0,0}
};
static const char *swig_CvQuadEdge2D_base_names[] = {0};
static const swig_type_info *swig_CvQuadEdge2D_base[] = {0};
static swig_octave_class _wrap_class_CvQuadEdge2D = {"CvQuadEdge2D", &SWIGTYPE_p_CvQuadEdge2D,0,_wrap_new_CvQuadEdge2D,0,_wrap_delete_CvQuadEdge2D,swig_CvQuadEdge2D_members,swig_CvQuadEdge2D_base_names,swig_CvQuadEdge2D_base };

static octave_value_list _wrap_CvSubdiv2DPoint_flags_set (const octave_value_list& args, int nargout) {
  CvSubdiv2DPoint *arg1 = (CvSubdiv2DPoint *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2DPoint_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2DPoint_flags_set" "', argument " "1"" of type '" "CvSubdiv2DPoint *""'"); 
  }
  arg1 = (CvSubdiv2DPoint *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSubdiv2DPoint_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2DPoint_flags_get (const octave_value_list& args, int nargout) {
  CvSubdiv2DPoint *arg1 = (CvSubdiv2DPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSubdiv2DPoint_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2DPoint_flags_get" "', argument " "1"" of type '" "CvSubdiv2DPoint *""'"); 
  }
  arg1 = (CvSubdiv2DPoint *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2DPoint_first_set (const octave_value_list& args, int nargout) {
  CvSubdiv2DPoint *arg1 = (CvSubdiv2DPoint *) 0 ;
  CvSubdiv2DEdge arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  CvSubdiv2DEdge_Wrapper *wrapper2 ;
  CvQuadEdge2D *qedge2 ;
  void *vptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2DPoint_first_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2DPoint_first_set" "', argument " "1"" of type '" "CvSubdiv2DPoint *""'"); 
  }
  arg1 = (CvSubdiv2DPoint *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0) != -1 ){
      wrapper2 = (CvSubdiv2DEdge_Wrapper *) vptr2;
      arg2 = wrapper2->ref();
    }
    else if( SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_CvQuadEdge2D, 0) != -1 ){
      qedge2 = (CvQuadEdge2D *) vptr2;
      arg2 = (CvSubdiv2DEdge)qedge2;
    }
    else{
      SWIG_exception( SWIG_TypeError, "could not convert to CvSubdiv2DEdge");
      SWIG_fail;
    }
  }
  if (arg1) (arg1)->first = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2DPoint_first_get (const octave_value_list& args, int nargout) {
  CvSubdiv2DPoint *arg1 = (CvSubdiv2DPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DEdge result;
  
  if (!SWIG_check_num_args("CvSubdiv2DPoint_first_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2DPoint_first_get" "', argument " "1"" of type '" "CvSubdiv2DPoint *""'"); 
  }
  arg1 = (CvSubdiv2DPoint *)(argp1);
  result =  ((arg1)->first);
  {
    CvSubdiv2DEdge_Wrapper * wrapper = new CvSubdiv2DEdge_Wrapper( result );
    _outv = SWIG_NewPointerObj( wrapper, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 1 );
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2DPoint_pt_set (const octave_value_list& args, int nargout) {
  CvSubdiv2DPoint *arg1 = (CvSubdiv2DPoint *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2DPoint_pt_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2DPoint_pt_set" "', argument " "1"" of type '" "CvSubdiv2DPoint *""'"); 
  }
  arg1 = (CvSubdiv2DPoint *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2DPoint_pt_set" "', argument " "2"" of type '" "CvPoint2D32f *""'"); 
  }
  arg2 = (CvPoint2D32f *)(argp2);
  if (arg1) (arg1)->pt = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2DPoint_pt_get (const octave_value_list& args, int nargout) {
  CvSubdiv2DPoint *arg1 = (CvSubdiv2DPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2DPoint_pt_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2DPoint_pt_get" "', argument " "1"" of type '" "CvSubdiv2DPoint *""'"); 
  }
  arg1 = (CvSubdiv2DPoint *)(argp1);
  result = (CvPoint2D32f *)& ((arg1)->pt);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSubdiv2DPoint (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DPoint *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSubdiv2DPoint",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSubdiv2DPoint *)new CvSubdiv2DPoint(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSubdiv2DPoint, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSubdiv2DPoint (const octave_value_list& args, int nargout) {
  CvSubdiv2DPoint *arg1 = (CvSubdiv2DPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSubdiv2DPoint",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2DPoint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSubdiv2DPoint" "', argument " "1"" of type '" "CvSubdiv2DPoint *""'"); 
  }
  arg1 = (CvSubdiv2DPoint *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSubdiv2DPoint_members[] = {
{"flags",0,_wrap_CvSubdiv2DPoint_flags_get,_wrap_CvSubdiv2DPoint_flags_set,0,0},
{"first",0,_wrap_CvSubdiv2DPoint_first_get,_wrap_CvSubdiv2DPoint_first_set,0,0},
{"pt",0,_wrap_CvSubdiv2DPoint_pt_get,_wrap_CvSubdiv2DPoint_pt_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSubdiv2DPoint_base_names[] = {0};
static const swig_type_info *swig_CvSubdiv2DPoint_base[] = {0};
static swig_octave_class _wrap_class_CvSubdiv2DPoint = {"CvSubdiv2DPoint", &SWIGTYPE_p_CvSubdiv2DPoint,0,_wrap_new_CvSubdiv2DPoint,0,_wrap_delete_CvSubdiv2DPoint,swig_CvSubdiv2DPoint_members,swig_CvSubdiv2DPoint_base_names,swig_CvSubdiv2DPoint_base };

static octave_value_list _wrap_CvSubdiv2D_flags_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_flags_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSubdiv2D_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_flags_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSubdiv2D_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_flags_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_header_size_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_header_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_header_size_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSubdiv2D_header_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->header_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_header_size_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSubdiv2D_header_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_header_size_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (int) ((arg1)->header_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_h_prev_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_h_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_h_prev_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_h_prev_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_h_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_h_prev_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (CvSeq *) ((arg1)->h_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_h_next_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_h_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_h_next_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->h_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_h_next_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_h_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_h_next_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (CvSeq *) ((arg1)->h_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_v_prev_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_v_prev_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_v_prev_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_prev = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_v_prev_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_v_prev_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_v_prev_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (CvSeq *) ((arg1)->v_prev);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_v_next_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_v_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_v_next_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  if (arg1) (arg1)->v_next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_v_next_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_v_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_v_next_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (CvSeq *) ((arg1)->v_next);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_total_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_total_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_total_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSubdiv2D_total_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->total = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_total_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSubdiv2D_total_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_total_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (int) ((arg1)->total);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_elem_size_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_elem_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_elem_size_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSubdiv2D_elem_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->elem_size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_elem_size_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSubdiv2D_elem_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_elem_size_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (int) ((arg1)->elem_size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_block_max_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_block_max_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_block_max_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2D_block_max_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->block_max = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_block_max_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_block_max_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_block_max_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (schar *) ((arg1)->block_max);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_ptr_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  schar *arg2 = (schar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_ptr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_ptr_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_signed_char, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2D_ptr_set" "', argument " "2"" of type '" "schar *""'"); 
  }
  arg2 = (schar *)(argp2);
  if (arg1) (arg1)->ptr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_ptr_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  schar *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_ptr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_ptr_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (schar *) ((arg1)->ptr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_signed_char, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_delta_elems_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_delta_elems_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_delta_elems_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSubdiv2D_delta_elems_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->delta_elems = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_delta_elems_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSubdiv2D_delta_elems_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_delta_elems_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (int) ((arg1)->delta_elems);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_storage_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_storage_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_storage_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2D_storage_set" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (arg1) (arg1)->storage = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_storage_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMemStorage *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_storage_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_storage_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (CvMemStorage *) ((arg1)->storage);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_free_blocks_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_free_blocks_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_free_blocks_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2D_free_blocks_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->free_blocks = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_free_blocks_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_free_blocks_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_free_blocks_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (CvSeqBlock *) ((arg1)->free_blocks);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_first_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvSeqBlock *arg2 = (CvSeqBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_first_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_first_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSeqBlock, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2D_first_set" "', argument " "2"" of type '" "CvSeqBlock *""'"); 
  }
  arg2 = (CvSeqBlock *)(argp2);
  if (arg1) (arg1)->first = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_first_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeqBlock *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_first_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_first_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (CvSeqBlock *) ((arg1)->first);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_free_elems_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvSetElem *arg2 = (CvSetElem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_free_elems_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_free_elems_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSetElem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2D_free_elems_set" "', argument " "2"" of type '" "CvSetElem *""'"); 
  }
  arg2 = (CvSetElem *)(argp2);
  if (arg1) (arg1)->free_elems = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_free_elems_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSetElem *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_free_elems_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_free_elems_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (CvSetElem *) ((arg1)->free_elems);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSetElem, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_active_count_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_active_count_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_active_count_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSubdiv2D_active_count_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->active_count = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_active_count_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSubdiv2D_active_count_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_active_count_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (int) ((arg1)->active_count);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_quad_edges_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_quad_edges_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_quad_edges_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSubdiv2D_quad_edges_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->quad_edges = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_quad_edges_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSubdiv2D_quad_edges_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_quad_edges_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (int) ((arg1)->quad_edges);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_is_geometry_valid_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_is_geometry_valid_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_is_geometry_valid_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSubdiv2D_is_geometry_valid_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->is_geometry_valid = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_is_geometry_valid_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSubdiv2D_is_geometry_valid_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_is_geometry_valid_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (int) ((arg1)->is_geometry_valid);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_recent_edge_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvSubdiv2DEdge arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  CvSubdiv2DEdge_Wrapper *wrapper2 ;
  CvQuadEdge2D *qedge2 ;
  void *vptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_recent_edge_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_recent_edge_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0) != -1 ){
      wrapper2 = (CvSubdiv2DEdge_Wrapper *) vptr2;
      arg2 = wrapper2->ref();
    }
    else if( SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_CvQuadEdge2D, 0) != -1 ){
      qedge2 = (CvQuadEdge2D *) vptr2;
      arg2 = (CvSubdiv2DEdge)qedge2;
    }
    else{
      SWIG_exception( SWIG_TypeError, "could not convert to CvSubdiv2DEdge");
      SWIG_fail;
    }
  }
  if (arg1) (arg1)->recent_edge = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_recent_edge_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DEdge result;
  
  if (!SWIG_check_num_args("CvSubdiv2D_recent_edge_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_recent_edge_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result =  ((arg1)->recent_edge);
  {
    CvSubdiv2DEdge_Wrapper * wrapper = new CvSubdiv2DEdge_Wrapper( result );
    _outv = SWIG_NewPointerObj( wrapper, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 1 );
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_topleft_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_topleft_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_topleft_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2D_topleft_set" "', argument " "2"" of type '" "CvPoint2D32f *""'"); 
  }
  arg2 = (CvPoint2D32f *)(argp2);
  if (arg1) (arg1)->topleft = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_topleft_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_topleft_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_topleft_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (CvPoint2D32f *)& ((arg1)->topleft);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_bottomright_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_bottomright_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_bottomright_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2D_bottomright_set" "', argument " "2"" of type '" "CvPoint2D32f *""'"); 
  }
  arg2 = (CvPoint2D32f *)(argp2);
  if (arg1) (arg1)->bottomright = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_bottomright_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_bottomright_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_bottomright_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  result = (CvPoint2D32f *)& ((arg1)->bottomright);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_edges_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvTypedSeq< CvQuadEdge2D > *arg2 = (CvTypedSeq< CvQuadEdge2D > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_edges_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_edges_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2D_edges_set" "', argument " "2"" of type '" "CvTypedSeq< CvQuadEdge2D > *""'"); 
  }
  arg2 = (CvTypedSeq< CvQuadEdge2D > *)(argp2);
  {
    try {
      CvSubdiv2D_typed_edges_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_edges_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvQuadEdge2D > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_edges_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_edges_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    try {
      result = (CvTypedSeq< CvQuadEdge2D > *)CvSubdiv2D_typed_edges_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_typed_edges_get (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvQuadEdge2D > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSubdiv2D_typed_edges_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_typed_edges_get" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    try {
      result = (CvTypedSeq< CvQuadEdge2D > *)CvSubdiv2D_typed_edges_get(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSubdiv2D_typed_edges_set (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvTypedSeq< CvQuadEdge2D > *arg2 = (CvTypedSeq< CvQuadEdge2D > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSubdiv2D_typed_edges_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSubdiv2D_typed_edges_set" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSubdiv2D_typed_edges_set" "', argument " "2"" of type '" "CvTypedSeq< CvQuadEdge2D > *""'"); 
  }
  arg2 = (CvTypedSeq< CvQuadEdge2D > *)(argp2);
  {
    try {
      CvSubdiv2D_typed_edges_set(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSubdiv2D (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2D *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSubdiv2D",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSubdiv2D *)new CvSubdiv2D(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSubdiv2D, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSubdiv2D (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSubdiv2D",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSubdiv2D" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSubdiv2D_members[] = {
{"flags",0,_wrap_CvSubdiv2D_flags_get,_wrap_CvSubdiv2D_flags_set,0,0},
{"header_size",0,_wrap_CvSubdiv2D_header_size_get,_wrap_CvSubdiv2D_header_size_set,0,0},
{"h_prev",0,_wrap_CvSubdiv2D_h_prev_get,_wrap_CvSubdiv2D_h_prev_set,0,0},
{"h_next",0,_wrap_CvSubdiv2D_h_next_get,_wrap_CvSubdiv2D_h_next_set,0,0},
{"v_prev",0,_wrap_CvSubdiv2D_v_prev_get,_wrap_CvSubdiv2D_v_prev_set,0,0},
{"v_next",0,_wrap_CvSubdiv2D_v_next_get,_wrap_CvSubdiv2D_v_next_set,0,0},
{"total",0,_wrap_CvSubdiv2D_total_get,_wrap_CvSubdiv2D_total_set,0,0},
{"elem_size",0,_wrap_CvSubdiv2D_elem_size_get,_wrap_CvSubdiv2D_elem_size_set,0,0},
{"block_max",0,_wrap_CvSubdiv2D_block_max_get,_wrap_CvSubdiv2D_block_max_set,0,0},
{"ptr",0,_wrap_CvSubdiv2D_ptr_get,_wrap_CvSubdiv2D_ptr_set,0,0},
{"delta_elems",0,_wrap_CvSubdiv2D_delta_elems_get,_wrap_CvSubdiv2D_delta_elems_set,0,0},
{"storage",0,_wrap_CvSubdiv2D_storage_get,_wrap_CvSubdiv2D_storage_set,0,0},
{"free_blocks",0,_wrap_CvSubdiv2D_free_blocks_get,_wrap_CvSubdiv2D_free_blocks_set,0,0},
{"first",0,_wrap_CvSubdiv2D_first_get,_wrap_CvSubdiv2D_first_set,0,0},
{"free_elems",0,_wrap_CvSubdiv2D_free_elems_get,_wrap_CvSubdiv2D_free_elems_set,0,0},
{"active_count",0,_wrap_CvSubdiv2D_active_count_get,_wrap_CvSubdiv2D_active_count_set,0,0},
{"quad_edges",0,_wrap_CvSubdiv2D_quad_edges_get,_wrap_CvSubdiv2D_quad_edges_set,0,0},
{"is_geometry_valid",0,_wrap_CvSubdiv2D_is_geometry_valid_get,_wrap_CvSubdiv2D_is_geometry_valid_set,0,0},
{"recent_edge",0,_wrap_CvSubdiv2D_recent_edge_get,_wrap_CvSubdiv2D_recent_edge_set,0,0},
{"topleft",0,_wrap_CvSubdiv2D_topleft_get,_wrap_CvSubdiv2D_topleft_set,0,0},
{"bottomright",0,_wrap_CvSubdiv2D_bottomright_get,_wrap_CvSubdiv2D_bottomright_set,0,0},
{"edges",0,_wrap_CvSubdiv2D_edges_get,_wrap_CvSubdiv2D_edges_set,0,0},
{"typed_edges_get",_wrap_CvSubdiv2D_typed_edges_get,0,0,0,0},
{"typed_edges_set",_wrap_CvSubdiv2D_typed_edges_set,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSubdiv2D_base_names[] = {0};
static const swig_type_info *swig_CvSubdiv2D_base[] = {0};
static swig_octave_class _wrap_class_CvSubdiv2D = {"CvSubdiv2D", &SWIGTYPE_p_CvSubdiv2D,0,_wrap_new_CvSubdiv2D,0,_wrap_delete_CvSubdiv2D,swig_CvSubdiv2D_members,swig_CvSubdiv2D_base_names,swig_CvSubdiv2D_base };

static octave_value_list _wrap_CvMatrix3_m_set (const octave_value_list& args, int nargout) {
  CvMatrix3 *arg1 = (CvMatrix3 *) 0 ;
  float (*arg2)[3] ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMatrix3_m_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix3_m_set" "', argument " "1"" of type '" "CvMatrix3 *""'"); 
  }
  arg1 = (CvMatrix3 *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_a_3__float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvMatrix3_m_set" "', argument " "2"" of type '" "float [3][3]""'"); 
  } 
  arg2 = (float (*)[3])(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)3; ++ii) {
        if (arg2[ii]) {
          size_t jj = 0;
          for (; jj < (size_t)3; ++jj) arg1->m[ii][jj] = arg2[ii][jj];
        } else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""m""' of type '""float [3][3]""'");
        }
      }
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""m""' of type '""float [3][3]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMatrix3_m_get (const octave_value_list& args, int nargout) {
  CvMatrix3 *arg1 = (CvMatrix3 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float (*result)[3] = 0 ;
  
  if (!SWIG_check_num_args("CvMatrix3_m_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix3, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMatrix3_m_get" "', argument " "1"" of type '" "CvMatrix3 *""'"); 
  }
  arg1 = (CvMatrix3 *)(argp1);
  result = (float (*)[3])(float (*)[3]) ((arg1)->m);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_a_3__float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMatrix3 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMatrix3 *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMatrix3",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvMatrix3 *)new CvMatrix3(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMatrix3, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMatrix3 (const octave_value_list& args, int nargout) {
  CvMatrix3 *arg1 = (CvMatrix3 *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMatrix3",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMatrix3, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMatrix3" "', argument " "1"" of type '" "CvMatrix3 *""'"); 
  }
  arg1 = (CvMatrix3 *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMatrix3_members[] = {
{"m",0,_wrap_CvMatrix3_m_get,_wrap_CvMatrix3_m_set,0,0},
{0,0,0,0}
};
static const char *swig_CvMatrix3_base_names[] = {0};
static const swig_type_info *swig_CvMatrix3_base[] = {0};
static swig_octave_class _wrap_class_CvMatrix3 = {"CvMatrix3", &SWIGTYPE_p_CvMatrix3,0,_wrap_new_CvMatrix3,0,_wrap_delete_CvMatrix3,swig_CvMatrix3_members,swig_CvMatrix3_base_names,swig_CvMatrix3_base };

static octave_value_list _wrap_CvConDensation_MP_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_MP_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_MP_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvConDensation_MP_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->MP = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_MP_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvConDensation_MP_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_MP_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (int) ((arg1)->MP);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_DP_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_DP_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_DP_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvConDensation_DP_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->DP = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_DP_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvConDensation_DP_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_DP_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (int) ((arg1)->DP);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_DynamMatr_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_DynamMatr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_DynamMatr_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConDensation_DynamMatr_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->DynamMatr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_DynamMatr_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvConDensation_DynamMatr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_DynamMatr_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (float *) ((arg1)->DynamMatr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_State_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_State_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_State_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConDensation_State_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->State = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_State_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvConDensation_State_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_State_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (float *) ((arg1)->State);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_SamplesNum_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_SamplesNum_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_SamplesNum_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvConDensation_SamplesNum_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->SamplesNum = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_SamplesNum_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvConDensation_SamplesNum_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_SamplesNum_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (int) ((arg1)->SamplesNum);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_flSamples_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  float **arg2 = (float **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *vptr2 ;
  float *buffer2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_flSamples_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_flSamples_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_float, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (float *) vptr2;
    arg2=&buffer2;
  }
  if (arg1) (arg1)->flSamples = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_flSamples_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float **result = 0 ;
  
  if (!SWIG_check_num_args("CvConDensation_flSamples_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_flSamples_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (float **) ((arg1)->flSamples);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_flNewSamples_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  float **arg2 = (float **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *vptr2 ;
  float *buffer2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_flNewSamples_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_flNewSamples_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_float, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (float *) vptr2;
    arg2=&buffer2;
  }
  if (arg1) (arg1)->flNewSamples = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_flNewSamples_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float **result = 0 ;
  
  if (!SWIG_check_num_args("CvConDensation_flNewSamples_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_flNewSamples_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (float **) ((arg1)->flNewSamples);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_flConfidence_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_flConfidence_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_flConfidence_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConDensation_flConfidence_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->flConfidence = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_flConfidence_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvConDensation_flConfidence_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_flConfidence_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (float *) ((arg1)->flConfidence);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_flCumulative_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_flCumulative_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_flCumulative_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConDensation_flCumulative_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->flCumulative = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_flCumulative_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvConDensation_flCumulative_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_flCumulative_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (float *) ((arg1)->flCumulative);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_Temp_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_Temp_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_Temp_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConDensation_Temp_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->Temp = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_Temp_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvConDensation_Temp_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_Temp_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (float *) ((arg1)->Temp);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_RandomSample_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_RandomSample_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_RandomSample_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConDensation_RandomSample_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->RandomSample = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_RandomSample_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvConDensation_RandomSample_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_RandomSample_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (float *) ((arg1)->RandomSample);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_RandS_set (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  CvRandState *arg2 = (CvRandState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvConDensation_RandS_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_RandS_set" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvRandState, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvConDensation_RandS_set" "', argument " "2"" of type '" "CvRandState *""'"); 
  }
  arg2 = (CvRandState *)(argp2);
  if (arg1) (arg1)->RandS = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvConDensation_RandS_get (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRandState *result = 0 ;
  
  if (!SWIG_check_num_args("CvConDensation_RandS_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvConDensation_RandS_get" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  result = (CvRandState *) ((arg1)->RandS);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvRandState, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvConDensation (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvConDensation",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvConDensation" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  {
    try {
      delete_CvConDensation(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvConDensation_members[] = {
{"MP",0,_wrap_CvConDensation_MP_get,_wrap_CvConDensation_MP_set,0,0},
{"DP",0,_wrap_CvConDensation_DP_get,_wrap_CvConDensation_DP_set,0,0},
{"DynamMatr",0,_wrap_CvConDensation_DynamMatr_get,_wrap_CvConDensation_DynamMatr_set,0,0},
{"State",0,_wrap_CvConDensation_State_get,_wrap_CvConDensation_State_set,0,0},
{"SamplesNum",0,_wrap_CvConDensation_SamplesNum_get,_wrap_CvConDensation_SamplesNum_set,0,0},
{"flSamples",0,_wrap_CvConDensation_flSamples_get,_wrap_CvConDensation_flSamples_set,0,0},
{"flNewSamples",0,_wrap_CvConDensation_flNewSamples_get,_wrap_CvConDensation_flNewSamples_set,0,0},
{"flConfidence",0,_wrap_CvConDensation_flConfidence_get,_wrap_CvConDensation_flConfidence_set,0,0},
{"flCumulative",0,_wrap_CvConDensation_flCumulative_get,_wrap_CvConDensation_flCumulative_set,0,0},
{"Temp",0,_wrap_CvConDensation_Temp_get,_wrap_CvConDensation_Temp_set,0,0},
{"RandomSample",0,_wrap_CvConDensation_RandomSample_get,_wrap_CvConDensation_RandomSample_set,0,0},
{"RandS",0,_wrap_CvConDensation_RandS_get,_wrap_CvConDensation_RandS_set,0,0},
{0,0,0,0}
};
static const char *swig_CvConDensation_base_names[] = {0};
static const swig_type_info *swig_CvConDensation_base[] = {0};
static swig_octave_class _wrap_class_CvConDensation = {"CvConDensation", &SWIGTYPE_p_CvConDensation,0,0,0,_wrap_delete_CvConDensation,swig_CvConDensation_members,swig_CvConDensation_base_names,swig_CvConDensation_base };

static octave_value_list _wrap_CvKalman_MP_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_MP_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_MP_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvKalman_MP_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->MP = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_MP_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvKalman_MP_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_MP_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (int) ((arg1)->MP);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_DP_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_DP_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_DP_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvKalman_DP_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->DP = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_DP_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvKalman_DP_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_DP_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (int) ((arg1)->DP);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_CP_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_CP_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_CP_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvKalman_CP_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->CP = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_CP_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvKalman_CP_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_CP_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (int) ((arg1)->CP);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_PosterState_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_PosterState_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_PosterState_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_PosterState_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->PosterState = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_PosterState_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_PosterState_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_PosterState_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->PosterState);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_PriorState_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_PriorState_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_PriorState_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_PriorState_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->PriorState = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_PriorState_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_PriorState_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_PriorState_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->PriorState);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_DynamMatr_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_DynamMatr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_DynamMatr_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_DynamMatr_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->DynamMatr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_DynamMatr_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_DynamMatr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_DynamMatr_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->DynamMatr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_MeasurementMatr_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_MeasurementMatr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_MeasurementMatr_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_MeasurementMatr_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->MeasurementMatr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_MeasurementMatr_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_MeasurementMatr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_MeasurementMatr_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->MeasurementMatr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_MNCovariance_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_MNCovariance_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_MNCovariance_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_MNCovariance_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->MNCovariance = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_MNCovariance_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_MNCovariance_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_MNCovariance_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->MNCovariance);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_PNCovariance_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_PNCovariance_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_PNCovariance_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_PNCovariance_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->PNCovariance = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_PNCovariance_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_PNCovariance_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_PNCovariance_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->PNCovariance);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_KalmGainMatr_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_KalmGainMatr_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_KalmGainMatr_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_KalmGainMatr_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->KalmGainMatr = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_KalmGainMatr_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_KalmGainMatr_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_KalmGainMatr_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->KalmGainMatr);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_PriorErrorCovariance_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_PriorErrorCovariance_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_PriorErrorCovariance_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_PriorErrorCovariance_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->PriorErrorCovariance = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_PriorErrorCovariance_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_PriorErrorCovariance_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_PriorErrorCovariance_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->PriorErrorCovariance);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_PosterErrorCovariance_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_PosterErrorCovariance_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_PosterErrorCovariance_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_PosterErrorCovariance_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->PosterErrorCovariance = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_PosterErrorCovariance_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_PosterErrorCovariance_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_PosterErrorCovariance_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->PosterErrorCovariance);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_Temp1_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_Temp1_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_Temp1_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_Temp1_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->Temp1 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_Temp1_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_Temp1_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_Temp1_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->Temp1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_Temp2_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_Temp2_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_Temp2_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_Temp2_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->Temp2 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_Temp2_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_Temp2_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_Temp2_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (float *) ((arg1)->Temp2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_state_pre_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_state_pre_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_state_pre_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_state_pre_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->state_pre = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_state_pre_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_state_pre_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_state_pre_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->state_pre);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_state_post_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_state_post_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_state_post_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_state_post_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->state_post = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_state_post_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_state_post_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_state_post_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->state_post);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_transition_matrix_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_transition_matrix_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_transition_matrix_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_transition_matrix_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->transition_matrix = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_transition_matrix_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_transition_matrix_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_transition_matrix_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->transition_matrix);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_control_matrix_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_control_matrix_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_control_matrix_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_control_matrix_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->control_matrix = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_control_matrix_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_control_matrix_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_control_matrix_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->control_matrix);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_measurement_matrix_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_measurement_matrix_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_measurement_matrix_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_measurement_matrix_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->measurement_matrix = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_measurement_matrix_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_measurement_matrix_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_measurement_matrix_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->measurement_matrix);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_process_noise_cov_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_process_noise_cov_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_process_noise_cov_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_process_noise_cov_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->process_noise_cov = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_process_noise_cov_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_process_noise_cov_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_process_noise_cov_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->process_noise_cov);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_measurement_noise_cov_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_measurement_noise_cov_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_measurement_noise_cov_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_measurement_noise_cov_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->measurement_noise_cov = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_measurement_noise_cov_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_measurement_noise_cov_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_measurement_noise_cov_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->measurement_noise_cov);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_error_cov_pre_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_error_cov_pre_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_error_cov_pre_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_error_cov_pre_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->error_cov_pre = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_error_cov_pre_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_error_cov_pre_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_error_cov_pre_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->error_cov_pre);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_gain_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_gain_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_gain_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_gain_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->gain = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_gain_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_gain_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_gain_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->gain);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_error_cov_post_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_error_cov_post_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_error_cov_post_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_error_cov_post_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->error_cov_post = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_error_cov_post_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_error_cov_post_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_error_cov_post_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->error_cov_post);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_temp1_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_temp1_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_temp1_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_temp1_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->temp1 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_temp1_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_temp1_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_temp1_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->temp1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_temp2_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_temp2_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_temp2_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_temp2_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->temp2 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_temp2_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_temp2_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_temp2_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->temp2);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_temp3_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_temp3_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_temp3_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_temp3_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->temp3 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_temp3_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_temp3_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_temp3_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->temp3);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_temp4_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_temp4_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_temp4_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_temp4_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->temp4 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_temp4_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_temp4_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_temp4_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->temp4);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_temp5_set (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvKalman_temp5_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_temp5_set" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvKalman_temp5_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->temp5 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvKalman_temp5_get (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvKalman_temp5_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvKalman_temp5_get" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  result = (CvMat *) ((arg1)->temp5);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvKalman (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvKalman",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvKalman" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  {
    try {
      delete_CvKalman(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvKalman_members[] = {
{"MP",0,_wrap_CvKalman_MP_get,_wrap_CvKalman_MP_set,0,0},
{"DP",0,_wrap_CvKalman_DP_get,_wrap_CvKalman_DP_set,0,0},
{"CP",0,_wrap_CvKalman_CP_get,_wrap_CvKalman_CP_set,0,0},
{"PosterState",0,_wrap_CvKalman_PosterState_get,_wrap_CvKalman_PosterState_set,0,0},
{"PriorState",0,_wrap_CvKalman_PriorState_get,_wrap_CvKalman_PriorState_set,0,0},
{"DynamMatr",0,_wrap_CvKalman_DynamMatr_get,_wrap_CvKalman_DynamMatr_set,0,0},
{"MeasurementMatr",0,_wrap_CvKalman_MeasurementMatr_get,_wrap_CvKalman_MeasurementMatr_set,0,0},
{"MNCovariance",0,_wrap_CvKalman_MNCovariance_get,_wrap_CvKalman_MNCovariance_set,0,0},
{"PNCovariance",0,_wrap_CvKalman_PNCovariance_get,_wrap_CvKalman_PNCovariance_set,0,0},
{"KalmGainMatr",0,_wrap_CvKalman_KalmGainMatr_get,_wrap_CvKalman_KalmGainMatr_set,0,0},
{"PriorErrorCovariance",0,_wrap_CvKalman_PriorErrorCovariance_get,_wrap_CvKalman_PriorErrorCovariance_set,0,0},
{"PosterErrorCovariance",0,_wrap_CvKalman_PosterErrorCovariance_get,_wrap_CvKalman_PosterErrorCovariance_set,0,0},
{"Temp1",0,_wrap_CvKalman_Temp1_get,_wrap_CvKalman_Temp1_set,0,0},
{"Temp2",0,_wrap_CvKalman_Temp2_get,_wrap_CvKalman_Temp2_set,0,0},
{"state_pre",0,_wrap_CvKalman_state_pre_get,_wrap_CvKalman_state_pre_set,0,0},
{"state_post",0,_wrap_CvKalman_state_post_get,_wrap_CvKalman_state_post_set,0,0},
{"transition_matrix",0,_wrap_CvKalman_transition_matrix_get,_wrap_CvKalman_transition_matrix_set,0,0},
{"control_matrix",0,_wrap_CvKalman_control_matrix_get,_wrap_CvKalman_control_matrix_set,0,0},
{"measurement_matrix",0,_wrap_CvKalman_measurement_matrix_get,_wrap_CvKalman_measurement_matrix_set,0,0},
{"process_noise_cov",0,_wrap_CvKalman_process_noise_cov_get,_wrap_CvKalman_process_noise_cov_set,0,0},
{"measurement_noise_cov",0,_wrap_CvKalman_measurement_noise_cov_get,_wrap_CvKalman_measurement_noise_cov_set,0,0},
{"error_cov_pre",0,_wrap_CvKalman_error_cov_pre_get,_wrap_CvKalman_error_cov_pre_set,0,0},
{"gain",0,_wrap_CvKalman_gain_get,_wrap_CvKalman_gain_set,0,0},
{"error_cov_post",0,_wrap_CvKalman_error_cov_post_get,_wrap_CvKalman_error_cov_post_set,0,0},
{"temp1",0,_wrap_CvKalman_temp1_get,_wrap_CvKalman_temp1_set,0,0},
{"temp2",0,_wrap_CvKalman_temp2_get,_wrap_CvKalman_temp2_set,0,0},
{"temp3",0,_wrap_CvKalman_temp3_get,_wrap_CvKalman_temp3_set,0,0},
{"temp4",0,_wrap_CvKalman_temp4_get,_wrap_CvKalman_temp4_set,0,0},
{"temp5",0,_wrap_CvKalman_temp5_get,_wrap_CvKalman_temp5_set,0,0},
{0,0,0,0}
};
static const char *swig_CvKalman_base_names[] = {0};
static const swig_type_info *swig_CvKalman_base[] = {0};
static swig_octave_class _wrap_class_CvKalman = {"CvKalman", &SWIGTYPE_p_CvKalman,0,0,0,_wrap_delete_CvKalman,swig_CvKalman_members,swig_CvKalman_base_names,swig_CvKalman_base };

static octave_value_list _wrap_CvHaarFeature_tilted_set (const octave_value_list& args, int nargout) {
  CvHaarFeature *arg1 = (CvHaarFeature *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarFeature_tilted_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarFeature, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarFeature_tilted_set" "', argument " "1"" of type '" "CvHaarFeature *""'"); 
  }
  arg1 = (CvHaarFeature *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarFeature_tilted_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->tilted = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarFeature_tilted_get (const octave_value_list& args, int nargout) {
  CvHaarFeature *arg1 = (CvHaarFeature *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvHaarFeature_tilted_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarFeature, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarFeature_tilted_get" "', argument " "1"" of type '" "CvHaarFeature *""'"); 
  }
  arg1 = (CvHaarFeature *)(argp1);
  result = (int) ((arg1)->tilted);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarFeature_rect_get (const octave_value_list& args, int nargout) {
  CvHaarFeature *arg1 = (CvHaarFeature *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHaarFeature_rect *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarFeature_rect_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarFeature, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarFeature_rect_get" "', argument " "1"" of type '" "CvHaarFeature *""'"); 
  }
  arg1 = (CvHaarFeature *)(argp1);
  result = (CvHaarFeature_rect *)(CvHaarFeature_rect *) ((arg1)->rect);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHaarFeature_rect, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvHaarFeature (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHaarFeature *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvHaarFeature",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvHaarFeature *)new CvHaarFeature(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHaarFeature, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvHaarFeature (const octave_value_list& args, int nargout) {
  CvHaarFeature *arg1 = (CvHaarFeature *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvHaarFeature",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarFeature, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvHaarFeature" "', argument " "1"" of type '" "CvHaarFeature *""'"); 
  }
  arg1 = (CvHaarFeature *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvHaarFeature_members[] = {
{"tilted",0,_wrap_CvHaarFeature_tilted_get,_wrap_CvHaarFeature_tilted_set,0,0},
{"rect",0,_wrap_CvHaarFeature_rect_get,octave_set_immutable,0,0},
{0,0,0,0}
};
static const char *swig_CvHaarFeature_base_names[] = {0};
static const swig_type_info *swig_CvHaarFeature_base[] = {0};
static swig_octave_class _wrap_class_CvHaarFeature = {"CvHaarFeature", &SWIGTYPE_p_CvHaarFeature,0,_wrap_new_CvHaarFeature,0,_wrap_delete_CvHaarFeature,swig_CvHaarFeature_members,swig_CvHaarFeature_base_names,swig_CvHaarFeature_base };

static octave_value_list _wrap_CvHaarFeature_rect_r_set (const octave_value_list& args, int nargout) {
  CvHaarFeature_rect *arg1 = (CvHaarFeature_rect *) 0 ;
  CvRect *arg2 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarFeature_rect_r_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarFeature_rect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarFeature_rect_r_set" "', argument " "1"" of type '" "CvHaarFeature_rect *""'"); 
  }
  arg1 = (CvHaarFeature_rect *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarFeature_rect_r_set" "', argument " "2"" of type '" "CvRect *""'"); 
  }
  arg2 = (CvRect *)(argp2);
  if (arg1) (arg1)->r = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarFeature_rect_r_get (const octave_value_list& args, int nargout) {
  CvHaarFeature_rect *arg1 = (CvHaarFeature_rect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarFeature_rect_r_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarFeature_rect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarFeature_rect_r_get" "', argument " "1"" of type '" "CvHaarFeature_rect *""'"); 
  }
  arg1 = (CvHaarFeature_rect *)(argp1);
  result = (CvRect *)& ((arg1)->r);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvRect, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarFeature_rect_weight_set (const octave_value_list& args, int nargout) {
  CvHaarFeature_rect *arg1 = (CvHaarFeature_rect *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarFeature_rect_weight_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarFeature_rect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarFeature_rect_weight_set" "', argument " "1"" of type '" "CvHaarFeature_rect *""'"); 
  }
  arg1 = (CvHaarFeature_rect *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarFeature_rect_weight_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->weight = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarFeature_rect_weight_get (const octave_value_list& args, int nargout) {
  CvHaarFeature_rect *arg1 = (CvHaarFeature_rect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvHaarFeature_rect_weight_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarFeature_rect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarFeature_rect_weight_get" "', argument " "1"" of type '" "CvHaarFeature_rect *""'"); 
  }
  arg1 = (CvHaarFeature_rect *)(argp1);
  result = (float) ((arg1)->weight);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvHaarFeature_rect (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHaarFeature_rect *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvHaarFeature_rect",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvHaarFeature_rect *)new CvHaarFeature_rect(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHaarFeature_rect, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvHaarFeature_rect (const octave_value_list& args, int nargout) {
  CvHaarFeature_rect *arg1 = (CvHaarFeature_rect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvHaarFeature_rect",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarFeature_rect, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvHaarFeature_rect" "', argument " "1"" of type '" "CvHaarFeature_rect *""'"); 
  }
  arg1 = (CvHaarFeature_rect *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvHaarFeature_rect_members[] = {
{"r",0,_wrap_CvHaarFeature_rect_r_get,_wrap_CvHaarFeature_rect_r_set,0,0},
{"weight",0,_wrap_CvHaarFeature_rect_weight_get,_wrap_CvHaarFeature_rect_weight_set,0,0},
{0,0,0,0}
};
static const char *swig_CvHaarFeature_rect_base_names[] = {0};
static const swig_type_info *swig_CvHaarFeature_rect_base[] = {0};
static swig_octave_class _wrap_class_CvHaarFeature_rect = {"CvHaarFeature_rect", &SWIGTYPE_p_CvHaarFeature_rect,0,_wrap_new_CvHaarFeature_rect,0,_wrap_delete_CvHaarFeature_rect,swig_CvHaarFeature_rect_members,swig_CvHaarFeature_rect_base_names,swig_CvHaarFeature_rect_base };

static octave_value_list _wrap_CvHaarClassifier_count_set (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifier_count_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_count_set" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarClassifier_count_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->count = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_count_get (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvHaarClassifier_count_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_count_get" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  result = (int) ((arg1)->count);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_haar_feature_set (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  CvHaarFeature *arg2 = (CvHaarFeature *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifier_haar_feature_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_haar_feature_set" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHaarFeature, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarClassifier_haar_feature_set" "', argument " "2"" of type '" "CvHaarFeature *""'"); 
  }
  arg2 = (CvHaarFeature *)(argp2);
  if (arg1) (arg1)->haar_feature = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_haar_feature_get (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHaarFeature *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarClassifier_haar_feature_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_haar_feature_get" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  result = (CvHaarFeature *) ((arg1)->haar_feature);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHaarFeature, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_threshold_set (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifier_threshold_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_threshold_set" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarClassifier_threshold_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->threshold = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_threshold_get (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarClassifier_threshold_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_threshold_get" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  result = (float *) ((arg1)->threshold);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_left_set (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifier_left_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_left_set" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarClassifier_left_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->left = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_left_get (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarClassifier_left_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_left_get" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  result = (int *) ((arg1)->left);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_right_set (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  int *arg2 = (int *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifier_right_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_right_set" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_int, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarClassifier_right_set" "', argument " "2"" of type '" "int *""'"); 
  }
  arg2 = (int *)(argp2);
  if (arg1) (arg1)->right = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_right_get (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarClassifier_right_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_right_get" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  result = (int *) ((arg1)->right);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_int, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_alpha_set (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  float *arg2 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifier_alpha_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_alpha_set" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarClassifier_alpha_set" "', argument " "2"" of type '" "float *""'"); 
  }
  arg2 = (float *)(argp2);
  if (arg1) (arg1)->alpha = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifier_alpha_get (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarClassifier_alpha_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifier_alpha_get" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  result = (float *) ((arg1)->alpha);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvHaarClassifier (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHaarClassifier *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvHaarClassifier",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvHaarClassifier *)new CvHaarClassifier(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHaarClassifier, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvHaarClassifier (const octave_value_list& args, int nargout) {
  CvHaarClassifier *arg1 = (CvHaarClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvHaarClassifier",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifier, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvHaarClassifier" "', argument " "1"" of type '" "CvHaarClassifier *""'"); 
  }
  arg1 = (CvHaarClassifier *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvHaarClassifier_members[] = {
{"count",0,_wrap_CvHaarClassifier_count_get,_wrap_CvHaarClassifier_count_set,0,0},
{"haar_feature",0,_wrap_CvHaarClassifier_haar_feature_get,_wrap_CvHaarClassifier_haar_feature_set,0,0},
{"threshold",0,_wrap_CvHaarClassifier_threshold_get,_wrap_CvHaarClassifier_threshold_set,0,0},
{"left",0,_wrap_CvHaarClassifier_left_get,_wrap_CvHaarClassifier_left_set,0,0},
{"right",0,_wrap_CvHaarClassifier_right_get,_wrap_CvHaarClassifier_right_set,0,0},
{"alpha",0,_wrap_CvHaarClassifier_alpha_get,_wrap_CvHaarClassifier_alpha_set,0,0},
{0,0,0,0}
};
static const char *swig_CvHaarClassifier_base_names[] = {0};
static const swig_type_info *swig_CvHaarClassifier_base[] = {0};
static swig_octave_class _wrap_class_CvHaarClassifier = {"CvHaarClassifier", &SWIGTYPE_p_CvHaarClassifier,0,_wrap_new_CvHaarClassifier,0,_wrap_delete_CvHaarClassifier,swig_CvHaarClassifier_members,swig_CvHaarClassifier_base_names,swig_CvHaarClassifier_base };

static octave_value_list _wrap_CvHaarStageClassifier_count_set (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_count_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_count_set" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarStageClassifier_count_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->count = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_count_get (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_count_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_count_get" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  result = (int) ((arg1)->count);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_threshold_set (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_threshold_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_threshold_set" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarStageClassifier_threshold_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->threshold = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_threshold_get (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_threshold_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_threshold_get" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  result = (float) ((arg1)->threshold);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_classifier_set (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  CvHaarClassifier *arg2 = (CvHaarClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_classifier_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_classifier_set" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHaarClassifier, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarStageClassifier_classifier_set" "', argument " "2"" of type '" "CvHaarClassifier *""'"); 
  }
  arg2 = (CvHaarClassifier *)(argp2);
  if (arg1) (arg1)->classifier = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_classifier_get (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHaarClassifier *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_classifier_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_classifier_get" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  result = (CvHaarClassifier *) ((arg1)->classifier);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHaarClassifier, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_next_set (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_next_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_next_set" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarStageClassifier_next_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->next = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_next_get (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_next_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_next_get" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  result = (int) ((arg1)->next);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_child_set (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_child_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_child_set" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarStageClassifier_child_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->child = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_child_get (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_child_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_child_get" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  result = (int) ((arg1)->child);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_parent_set (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_parent_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_parent_set" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarStageClassifier_parent_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->parent = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarStageClassifier_parent_get (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvHaarStageClassifier_parent_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarStageClassifier_parent_get" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  result = (int) ((arg1)->parent);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvHaarStageClassifier (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHaarStageClassifier *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvHaarStageClassifier",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvHaarStageClassifier *)new CvHaarStageClassifier(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHaarStageClassifier, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvHaarStageClassifier (const octave_value_list& args, int nargout) {
  CvHaarStageClassifier *arg1 = (CvHaarStageClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvHaarStageClassifier",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarStageClassifier, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvHaarStageClassifier" "', argument " "1"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg1 = (CvHaarStageClassifier *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvHaarStageClassifier_members[] = {
{"count",0,_wrap_CvHaarStageClassifier_count_get,_wrap_CvHaarStageClassifier_count_set,0,0},
{"threshold",0,_wrap_CvHaarStageClassifier_threshold_get,_wrap_CvHaarStageClassifier_threshold_set,0,0},
{"classifier",0,_wrap_CvHaarStageClassifier_classifier_get,_wrap_CvHaarStageClassifier_classifier_set,0,0},
{"next",0,_wrap_CvHaarStageClassifier_next_get,_wrap_CvHaarStageClassifier_next_set,0,0},
{"child",0,_wrap_CvHaarStageClassifier_child_get,_wrap_CvHaarStageClassifier_child_set,0,0},
{"parent",0,_wrap_CvHaarStageClassifier_parent_get,_wrap_CvHaarStageClassifier_parent_set,0,0},
{0,0,0,0}
};
static const char *swig_CvHaarStageClassifier_base_names[] = {0};
static const swig_type_info *swig_CvHaarStageClassifier_base[] = {0};
static swig_octave_class _wrap_class_CvHaarStageClassifier = {"CvHaarStageClassifier", &SWIGTYPE_p_CvHaarStageClassifier,0,_wrap_new_CvHaarStageClassifier,0,_wrap_delete_CvHaarStageClassifier,swig_CvHaarStageClassifier_members,swig_CvHaarStageClassifier_base_names,swig_CvHaarStageClassifier_base };

static octave_value_list _wrap_CvHaarClassifierCascade_flags_set (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_flags_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_flags_set" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarClassifierCascade_flags_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->flags = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_flags_get (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_flags_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_flags_get" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  result = (int) ((arg1)->flags);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_count_set (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_count_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_count_set" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarClassifierCascade_count_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->count = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_count_get (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_count_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_count_get" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  result = (int) ((arg1)->count);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_orig_window_size_set (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  CvSize *arg2 = (CvSize *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_orig_window_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_orig_window_size_set" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSize, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarClassifierCascade_orig_window_size_set" "', argument " "2"" of type '" "CvSize *""'"); 
  }
  arg2 = (CvSize *)(argp2);
  if (arg1) (arg1)->orig_window_size = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_orig_window_size_get (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_orig_window_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_orig_window_size_get" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  result = (CvSize *)& ((arg1)->orig_window_size);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSize, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_real_window_size_set (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  CvSize *arg2 = (CvSize *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_real_window_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_real_window_size_set" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvSize, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarClassifierCascade_real_window_size_set" "', argument " "2"" of type '" "CvSize *""'"); 
  }
  arg2 = (CvSize *)(argp2);
  if (arg1) (arg1)->real_window_size = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_real_window_size_get (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSize *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_real_window_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_real_window_size_get" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  result = (CvSize *)& ((arg1)->real_window_size);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSize, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_scale_set (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_scale_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_scale_set" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvHaarClassifierCascade_scale_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->scale = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_scale_get (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_scale_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_scale_get" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  result = (double) ((arg1)->scale);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_stage_classifier_set (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  CvHaarStageClassifier *arg2 = (CvHaarStageClassifier *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_stage_classifier_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_stage_classifier_set" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHaarStageClassifier, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarClassifierCascade_stage_classifier_set" "', argument " "2"" of type '" "CvHaarStageClassifier *""'"); 
  }
  arg2 = (CvHaarStageClassifier *)(argp2);
  if (arg1) (arg1)->stage_classifier = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_stage_classifier_get (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHaarStageClassifier *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_stage_classifier_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_stage_classifier_get" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  result = (CvHaarStageClassifier *) ((arg1)->stage_classifier);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHaarStageClassifier, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_hid_cascade_set (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  CvHidHaarClassifierCascade *arg2 = (CvHidHaarClassifierCascade *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_hid_cascade_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_hid_cascade_set" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHidHaarClassifierCascade, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvHaarClassifierCascade_hid_cascade_set" "', argument " "2"" of type '" "CvHidHaarClassifierCascade *""'"); 
  }
  arg2 = (CvHidHaarClassifierCascade *)(argp2);
  if (arg1) (arg1)->hid_cascade = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvHaarClassifierCascade_hid_cascade_get (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHidHaarClassifierCascade *result = 0 ;
  
  if (!SWIG_check_num_args("CvHaarClassifierCascade_hid_cascade_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvHaarClassifierCascade_hid_cascade_get" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  result = (CvHidHaarClassifierCascade *) ((arg1)->hid_cascade);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHidHaarClassifierCascade, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvHaarClassifierCascade (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvHaarClassifierCascade",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvHaarClassifierCascade" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  {
    try {
      delete_CvHaarClassifierCascade(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvHaarClassifierCascade_members[] = {
{"flags",0,_wrap_CvHaarClassifierCascade_flags_get,_wrap_CvHaarClassifierCascade_flags_set,0,0},
{"count",0,_wrap_CvHaarClassifierCascade_count_get,_wrap_CvHaarClassifierCascade_count_set,0,0},
{"orig_window_size",0,_wrap_CvHaarClassifierCascade_orig_window_size_get,_wrap_CvHaarClassifierCascade_orig_window_size_set,0,0},
{"real_window_size",0,_wrap_CvHaarClassifierCascade_real_window_size_get,_wrap_CvHaarClassifierCascade_real_window_size_set,0,0},
{"scale",0,_wrap_CvHaarClassifierCascade_scale_get,_wrap_CvHaarClassifierCascade_scale_set,0,0},
{"stage_classifier",0,_wrap_CvHaarClassifierCascade_stage_classifier_get,_wrap_CvHaarClassifierCascade_stage_classifier_set,0,0},
{"hid_cascade",0,_wrap_CvHaarClassifierCascade_hid_cascade_get,_wrap_CvHaarClassifierCascade_hid_cascade_set,0,0},
{0,0,0,0}
};
static const char *swig_CvHaarClassifierCascade_base_names[] = {0};
static const swig_type_info *swig_CvHaarClassifierCascade_base[] = {0};
static swig_octave_class _wrap_class_CvHaarClassifierCascade = {"CvHaarClassifierCascade", &SWIGTYPE_p_CvHaarClassifierCascade,0,0,0,_wrap_delete_CvHaarClassifierCascade,swig_CvHaarClassifierCascade_members,swig_CvHaarClassifierCascade_base_names,swig_CvHaarClassifierCascade_base };

static octave_value_list _wrap_CvAvgComp_rect_set (const octave_value_list& args, int nargout) {
  CvAvgComp *arg1 = (CvAvgComp *) 0 ;
  CvRect *arg2 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvAvgComp_rect_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAvgComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvAvgComp_rect_set" "', argument " "1"" of type '" "CvAvgComp *""'"); 
  }
  arg1 = (CvAvgComp *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvAvgComp_rect_set" "', argument " "2"" of type '" "CvRect *""'"); 
  }
  arg2 = (CvRect *)(argp2);
  if (arg1) (arg1)->rect = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvAvgComp_rect_get (const octave_value_list& args, int nargout) {
  CvAvgComp *arg1 = (CvAvgComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect *result = 0 ;
  
  if (!SWIG_check_num_args("CvAvgComp_rect_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAvgComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvAvgComp_rect_get" "', argument " "1"" of type '" "CvAvgComp *""'"); 
  }
  arg1 = (CvAvgComp *)(argp1);
  result = (CvRect *)& ((arg1)->rect);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvRect, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvAvgComp_neighbors_set (const octave_value_list& args, int nargout) {
  CvAvgComp *arg1 = (CvAvgComp *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvAvgComp_neighbors_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAvgComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvAvgComp_neighbors_set" "', argument " "1"" of type '" "CvAvgComp *""'"); 
  }
  arg1 = (CvAvgComp *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvAvgComp_neighbors_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->neighbors = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvAvgComp_neighbors_get (const octave_value_list& args, int nargout) {
  CvAvgComp *arg1 = (CvAvgComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvAvgComp_neighbors_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAvgComp, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvAvgComp_neighbors_get" "', argument " "1"" of type '" "CvAvgComp *""'"); 
  }
  arg1 = (CvAvgComp *)(argp1);
  result = (int) ((arg1)->neighbors);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvAvgComp (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvAvgComp *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvAvgComp",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvAvgComp *)new CvAvgComp(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvAvgComp, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvAvgComp (const octave_value_list& args, int nargout) {
  CvAvgComp *arg1 = (CvAvgComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvAvgComp",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvAvgComp, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvAvgComp" "', argument " "1"" of type '" "CvAvgComp *""'"); 
  }
  arg1 = (CvAvgComp *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvAvgComp_members[] = {
{"rect",0,_wrap_CvAvgComp_rect_get,_wrap_CvAvgComp_rect_set,0,0},
{"neighbors",0,_wrap_CvAvgComp_neighbors_get,_wrap_CvAvgComp_neighbors_set,0,0},
{0,0,0,0}
};
static const char *swig_CvAvgComp_base_names[] = {0};
static const swig_type_info *swig_CvAvgComp_base[] = {0};
static swig_octave_class _wrap_class_CvAvgComp = {"CvAvgComp", &SWIGTYPE_p_CvAvgComp,0,_wrap_new_CvAvgComp,0,_wrap_delete_CvAvgComp,swig_CvAvgComp_members,swig_CvAvgComp_base_names,swig_CvAvgComp_base };

static octave_value_list _wrap_cvCopyMakeBorder (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvPoint arg3 ;
  int arg4 ;
  CvScalar arg5 = (CvScalar) cvScalarAll(0) ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCopyMakeBorder",args.length(),5,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvPoint(args(2));
  }
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCopyMakeBorder" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  if (4<args.length()) {
    {
      arg5 = OctObject_to_CvScalar( args(4) );
    }
  }
  {
    try {
      cvCopyMakeBorder((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSmooth (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 = (int) 2 ;
  int arg4 = (int) 3 ;
  int arg5 = (int) 0 ;
  double arg6 = (double) 0 ;
  double arg7 = (double) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSmooth",args.length(),7,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSmooth" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSmooth" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvSmooth" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_double(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvSmooth" "', argument " "6"" of type '" "double""'");
    } 
    arg6 = (double)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_double(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvSmooth" "', argument " "7"" of type '" "double""'");
    } 
    arg7 = (double)(val7);
  }
  {
    try {
      cvSmooth((void const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFilter2D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvPoint arg4 = (CvPoint) cvPoint(-1,-1) ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFilter2D",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvFilter2D" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvPoint(args(3));
    }
  }
  {
    try {
      cvFilter2D((void const *)arg1,arg2,(CvMat const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvIntegral (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) NULL ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvIntegral",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    {
      arg3 = OctObject_to_CvArr(args(2), &freearg3);
    }
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvIntegral((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPyrDown (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 = (int) CV_GAUSSIAN_5x5 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvPyrDown",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPyrDown" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      cvPyrDown((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPyrUp (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 = (int) CV_GAUSSIAN_5x5 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvPyrUp",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPyrUp" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      cvPyrUp((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCreatePyramid (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  double arg3 ;
  CvSize *arg4 = (CvSize *) 0 ;
  CvArr *arg5 = (CvArr *) 0 ;
  int arg6 = (int) 1 ;
  int arg7 = (int) CV_GAUSSIAN_5x5 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool freearg5 = false ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat **result = 0 ;
  
  if (!SWIG_check_num_args("cvCreatePyramid",args.length(),7,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreatePyramid" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreatePyramid" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  if (3<args.length()) {
    res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvSize, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCreatePyramid" "', argument " "4"" of type '" "CvSize const *""'"); 
    }
    arg4 = (CvSize *)(argp4);
  }
  if (4<args.length()) {
    {
      arg5 = OctObject_to_CvArr(args(4), &freearg5);
    }
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvCreatePyramid" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvCreatePyramid" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    try {
      result = (CvMat **)cvCreatePyramid((void const *)arg1,arg2,arg3,(CvSize const *)arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg5!=NULL && freearg5){
      cvReleaseData( arg5 );
      cvFree(&(arg5));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvReleasePyramid (const octave_value_list& args, int nargout) {
  CvMat ***arg1 = (CvMat ***) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleasePyramid",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleasePyramid" "', argument " "1"" of type '" "CvMat ***""'"); 
  }
  arg1 = (CvMat ***)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvReleasePyramid" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      cvReleasePyramid(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvPyrSegmentationUntyped (const octave_value_list& args, int nargout) {
  IplImage *arg1 = (IplImage *) 0 ;
  IplImage *arg2 = (IplImage *) 0 ;
  CvMemStorage *arg3 = (CvMemStorage *) 0 ;
  CvSeq **arg4 = (CvSeq **) 0 ;
  int arg5 ;
  double arg6 ;
  double arg7 ;
  IplImage header1 ;
  IplImage header2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  CvSeq *seq4 ;
  int val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  {
    arg4 = &seq4;
  }
  if (!SWIG_check_num_args("cvPyrSegmentationUntyped",args.length(),6,6,0)) {
    SWIG_fail;
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(0), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg1 = cvGetImage((CvMat *)vptr, &header1);
  }
  {
    void * vptr;
    int res = SWIG_ConvertPtr(args(1), (&vptr), SWIGTYPE_p_CvMat, 0);
    if ( res == -1 ){
      SWIG_exception( SWIG_TypeError, "%%typemap(in) IplImage * : could not convert to CvMat");
      SWIG_fail;
    }
    arg2 = cvGetImage((CvMat *)vptr, &header2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvPyrSegmentationUntyped" "', argument " "3"" of type '" "CvMemStorage *""'"); 
  }
  arg3 = (CvMemStorage *)(argp3);
  ecode5 = SWIG_AsVal_int(args(3), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvPyrSegmentationUntyped" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_double(args(4), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvPyrSegmentationUntyped" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  ecode7 = SWIG_AsVal_double(args(5), &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvPyrSegmentationUntyped" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  {
    try {
      cvPyrSegmentation(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    octave_value to_add;
    
    // extract the pointer we want to add to the returned tuple
    // sequence is allocated in CvMemStorage, so octave_ownership=0
    to_add = SWIG_NewPointerObj (*arg4, SWIGTYPE_p_CvSeq, 0); 
    
    _outp = SWIG_AppendResult(_outp, &to_add, 1);
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPyrMeanShiftFiltering (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 ;
  double arg4 ;
  int arg5 = (int) 1 ;
  CvTermCriteria arg6 = (CvTermCriteria) cvTermCriteria(1 +2,5,1) ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvPyrMeanShiftFiltering",args.length(),6,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPyrMeanShiftFiltering" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvPyrMeanShiftFiltering" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvPyrMeanShiftFiltering" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    {
      res6 = SWIG_ConvertPtr(args(5), &argp6, SWIGTYPE_p_CvTermCriteria,  0 );
      if (!SWIG_IsOK(res6)) {
        SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvPyrMeanShiftFiltering" "', argument " "6"" of type '" "CvTermCriteria""'"); 
      }  
      if (!argp6) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvPyrMeanShiftFiltering" "', argument " "6"" of type '" "CvTermCriteria""'");
      } else {
        arg6 = *((CvTermCriteria *)(argp6));
      }
    }
  }
  {
    try {
      cvPyrMeanShiftFiltering((void const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvWatershed (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvWatershed",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      cvWatershed((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvInpaint (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  double arg4 ;
  int arg5 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInpaint",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvInpaint" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvInpaint" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    try {
      cvInpaint((void const *)arg1,(void const *)arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSobel (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 = (int) 3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSobel",args.length(),5,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSobel" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSobel" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvSobel" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      cvSobel((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvLaplace (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 = (int) 3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvLaplace",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvLaplace" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      cvLaplace((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCvtColor (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCvtColor",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCvtColor" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      cvCvtColor((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvResize (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 = (int) 1 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvResize",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvResize" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      cvResize((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvWarpAffine (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  int arg4 = (int) 1+8 ;
  CvScalar arg5 = (CvScalar) cvScalarAll(0) ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvWarpAffine",args.length(),5,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvWarpAffine" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvWarpAffine" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    {
      arg5 = OctObject_to_CvScalar( args(4) );
    }
  }
  {
    try {
      cvWarpAffine((void const *)arg1,arg2,(CvMat const *)arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetAffineTransform (const octave_value_list& args, int nargout) {
  CvPoint2D32f *arg1 = (CvPoint2D32f *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetAffineTransform",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetAffineTransform" "', argument " "1"" of type '" "CvPoint2D32f const *""'"); 
  }
  arg1 = (CvPoint2D32f *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGetAffineTransform" "', argument " "2"" of type '" "CvPoint2D32f const *""'"); 
  }
  arg2 = (CvPoint2D32f *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGetAffineTransform" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  {
    try {
      result = (CvMat *)cvGetAffineTransform((CvPoint2D32f const *)arg1,(CvPoint2D32f const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cv2DRotationMatrix (const octave_value_list& args, int nargout) {
  CvPoint2D32f arg1 ;
  double arg2 ;
  double arg3 ;
  CvMat *arg4 = (CvMat *) 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cv2DRotationMatrix",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint2D32f(args(0));
  }
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cv2DRotationMatrix" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cv2DRotationMatrix" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cv2DRotationMatrix" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  {
    try {
      result = (CvMat *)cv2DRotationMatrix(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvWarpPerspective (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  int arg4 = (int) 1+8 ;
  CvScalar arg5 = (CvScalar) cvScalarAll(0) ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvWarpPerspective",args.length(),5,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvWarpPerspective" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvWarpPerspective" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    {
      arg5 = OctObject_to_CvScalar( args(4) );
    }
  }
  {
    try {
      cvWarpPerspective((void const *)arg1,arg2,(CvMat const *)arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetPerspectiveTransform (const octave_value_list& args, int nargout) {
  CvPoint2D32f *arg1 = (CvPoint2D32f *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetPerspectiveTransform",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetPerspectiveTransform" "', argument " "1"" of type '" "CvPoint2D32f const *""'"); 
  }
  arg1 = (CvPoint2D32f *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGetPerspectiveTransform" "', argument " "2"" of type '" "CvPoint2D32f const *""'"); 
  }
  arg2 = (CvPoint2D32f *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGetPerspectiveTransform" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  {
    try {
      result = (CvMat *)cvGetPerspectiveTransform((CvPoint2D32f const *)arg1,(CvPoint2D32f const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRemap (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  int arg5 = (int) 1+8 ;
  CvScalar arg6 = (CvScalar) cvScalarAll(0) ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRemap",args.length(),6,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvRemap" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    {
      arg6 = OctObject_to_CvScalar( args(5) );
    }
  }
  {
    try {
      cvRemap((void const *)arg1,arg2,(void const *)arg3,(void const *)arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvConvertMaps (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvConvertMaps",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    try {
      cvConvertMaps((void const *)arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvLogPolar (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvPoint2D32f arg3 ;
  double arg4 ;
  int arg5 = (int) 1+8 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvLogPolar",args.length(),5,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvPoint2D32f(args(2));
  }
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvLogPolar" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvLogPolar" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      cvLogPolar((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvLinearPolar (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvPoint2D32f arg3 ;
  double arg4 ;
  int arg5 = (int) 1+8 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvLinearPolar",args.length(),5,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvPoint2D32f(args(2));
  }
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvLinearPolar" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvLinearPolar" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      cvLinearPolar((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateStructuringElementEx (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int *arg6 = (int *) NULL ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  IplConvKernel *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateStructuringElementEx",args.length(),6,5,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateStructuringElementEx" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateStructuringElementEx" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateStructuringElementEx" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCreateStructuringElementEx" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCreateStructuringElementEx" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  if (5<args.length()) {
    res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_int, 0 |  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvCreateStructuringElementEx" "', argument " "6"" of type '" "int *""'"); 
    }
    arg6 = (int *)(argp6);
  }
  {
    try {
      result = (IplConvKernel *)cvCreateStructuringElementEx(arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseStructuringElement (const octave_value_list& args, int nargout) {
  IplConvKernel **arg1 = (IplConvKernel **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseStructuringElement",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseStructuringElement" "', argument " "1"" of type '" "IplConvKernel **""'"); 
  }
  arg1 = (IplConvKernel **)(argp1);
  {
    try {
      cvReleaseStructuringElement(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvErode (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplConvKernel *arg3 = (IplConvKernel *) NULL ;
  int arg4 = (int) 1 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvErode",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p__IplConvKernel, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvErode" "', argument " "3"" of type '" "IplConvKernel *""'"); 
    }
    arg3 = (IplConvKernel *)(argp3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvErode" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvErode((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvDilate (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  IplConvKernel *arg3 = (IplConvKernel *) NULL ;
  int arg4 = (int) 1 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvDilate",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p__IplConvKernel, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvDilate" "', argument " "3"" of type '" "IplConvKernel *""'"); 
    }
    arg3 = (IplConvKernel *)(argp3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvDilate" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvDilate((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMorphologyEx (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  IplConvKernel *arg4 = (IplConvKernel *) 0 ;
  int arg5 ;
  int arg6 = (int) 1 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMorphologyEx",args.length(),6,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p__IplConvKernel, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvMorphologyEx" "', argument " "4"" of type '" "IplConvKernel *""'"); 
  }
  arg4 = (IplConvKernel *)(argp4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvMorphologyEx" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvMorphologyEx" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      cvMorphologyEx((void const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMoments (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMoments *arg2 = (CvMoments *) 0 ;
  int arg3 = (int) 0 ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMoments",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvMoments" "', argument " "2"" of type '" "CvMoments *""'"); 
  }
  arg2 = (CvMoments *)(argp2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvMoments" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      cvMoments((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetSpatialMoment (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvGetSpatialMoment",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetSpatialMoment" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetSpatialMoment" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetSpatialMoment" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (double)cvGetSpatialMoment(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetCentralMoment (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvGetCentralMoment",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetCentralMoment" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetCentralMoment" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetCentralMoment" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (double)cvGetCentralMoment(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetNormalizedCentralMoment (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  int arg2 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvGetNormalizedCentralMoment",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetNormalizedCentralMoment" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvGetNormalizedCentralMoment" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvGetNormalizedCentralMoment" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (double)cvGetNormalizedCentralMoment(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetHuMoments (const octave_value_list& args, int nargout) {
  CvMoments *arg1 = (CvMoments *) 0 ;
  CvHuMoments *arg2 = (CvHuMoments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvGetHuMoments",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMoments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetHuMoments" "', argument " "1"" of type '" "CvMoments *""'"); 
  }
  arg1 = (CvMoments *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHuMoments, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGetHuMoments" "', argument " "2"" of type '" "CvHuMoments *""'"); 
  }
  arg2 = (CvHuMoments *)(argp2);
  {
    try {
      cvGetHuMoments(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSampleLine (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint arg2 ;
  CvPoint arg3 ;
  void *arg4 = (void *) 0 ;
  int arg5 = (int) 8 ;
  bool freearg1 = false ;
  int res4 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvSampleLine",args.length(),5,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvPoint(args(1));
  }
  {
    arg3 = OctObject_to_CvPoint(args(2));
  }
  res4 = SWIG_ConvertPtr(args(3),SWIG_as_voidptrptr(&arg4), 0, 0);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvSampleLine" "', argument " "4"" of type '" "void *""'"); 
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvSampleLine" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      result = (int)cvSampleLine((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetRectSubPix (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvPoint2D32f arg3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvGetRectSubPix",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvPoint2D32f(args(2));
  }
  {
    try {
      cvGetRectSubPix((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGetQuadrangleSubPix (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvGetQuadrangleSubPix",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGetQuadrangleSubPix" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  {
    try {
      cvGetQuadrangleSubPix((void const *)arg1,arg2,(CvMat const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMatchTemplate (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  int arg4 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMatchTemplate",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvMatchTemplate" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      cvMatchTemplate((void const *)arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcEMD2 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  CvDistanceFunction arg4 = (CvDistanceFunction) NULL ;
  CvArr *arg5 = (CvArr *) NULL ;
  CvArr *arg6 = (CvArr *) NULL ;
  float *arg7 = (float *) NULL ;
  void *arg8 = (void *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  bool freearg5 = false ;
  bool freearg6 = false ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  int res8 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("cvCalcEMD2",args.length(),8,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCalcEMD2" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    {
      int res = SWIG_ConvertFunctionPtr(args(3), (void**)(&arg4), SWIGTYPE_p_f_p_q_const__float_p_q_const__float_p_void__float);
      if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "cvCalcEMD2" "', argument " "4"" of type '" "CvDistanceFunction""'"); 
      }
    }
  }
  if (4<args.length()) {
    {
      arg5 = OctObject_to_CvArr(args(4), &freearg5);
    }
  }
  if (5<args.length()) {
    {
      arg6 = OctObject_to_CvArr(args(5), &freearg6);
    }
  }
  if (6<args.length()) {
    res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_float, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvCalcEMD2" "', argument " "7"" of type '" "float *""'"); 
    }
    arg7 = (float *)(argp7);
  }
  if (7<args.length()) {
    res8 = SWIG_ConvertPtr(args(7),SWIG_as_voidptrptr(&arg8), 0, 0);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cvCalcEMD2" "', argument " "8"" of type '" "void *""'"); 
    }
  }
  {
    try {
      result = (float)cvCalcEMD2((void const *)arg1,(void const *)arg2,arg3,arg4,(void const *)arg5,arg6,arg7,arg8); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg5!=NULL && freearg5){
      cvReleaseData( arg5 );
      cvFree(&(arg5));
    }
  }
  {
    if(arg6!=NULL && freearg6){
      cvReleaseData( arg6 );
      cvFree(&(arg6));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFindContoursUntyped (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  CvSeq **arg3 = (CvSeq **) 0 ;
  int arg4 = (int) sizeof(CvContour) ;
  int arg5 = (int) 1 ;
  int arg6 = (int) 2 ;
  CvPoint arg7 = (CvPoint) cvPoint(0,0) ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  CvSeq *seq3 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  {
    arg3 = &seq3;
  }
  if (!SWIG_check_num_args("cvFindContoursUntyped",args.length(),6,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvFindContoursUntyped" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (2<args.length()) {
    ecode4 = SWIG_AsVal_int(args(2), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvFindContoursUntyped" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (3<args.length()) {
    ecode5 = SWIG_AsVal_int(args(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvFindContoursUntyped" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (4<args.length()) {
    ecode6 = SWIG_AsVal_int(args(4), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvFindContoursUntyped" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (5<args.length()) {
    {
      arg7 = OctObject_to_CvPoint(args(5));
    }
  }
  {
    try {
      result = (int)cvFindContours(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    octave_value to_add;
    
    // extract the pointer we want to add to the returned tuple
    // sequence is allocated in CvMemStorage, so octave_ownership=0
    to_add = SWIG_NewPointerObj (*arg3, SWIGTYPE_p_CvSeq, 0); 
    
    _outp = SWIG_AppendResult(_outp, &to_add, 1);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvStartFindContours (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  int arg3 = (int) sizeof(CvContour) ;
  int arg4 = (int) 1 ;
  int arg5 = (int) 2 ;
  CvPoint arg6 = (CvPoint) cvPoint(0,0) ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvContourScanner result;
  
  if (!SWIG_check_num_args("cvStartFindContours",args.length(),6,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvStartFindContours" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvStartFindContours" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvStartFindContours" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvStartFindContours" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    {
      arg6 = OctObject_to_CvPoint(args(5));
    }
  }
  {
    try {
      result = (CvContourScanner)cvStartFindContours(arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p__CvContourScanner, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFindNextContour (const octave_value_list& args, int nargout) {
  CvContourScanner arg1 = (CvContourScanner) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvFindNextContour",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__CvContourScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFindNextContour" "', argument " "1"" of type '" "CvContourScanner""'"); 
  }
  arg1 = (CvContourScanner)(argp1);
  {
    try {
      result = (CvSeq *)cvFindNextContour(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSubstituteContour (const octave_value_list& args, int nargout) {
  CvContourScanner arg1 = (CvContourScanner) 0 ;
  CvSeq *arg2 = (CvSeq *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *ptr2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSubstituteContour",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p__CvContourScanner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSubstituteContour" "', argument " "1"" of type '" "CvContourScanner""'"); 
  }
  arg1 = (CvContourScanner)(argp1);
  {
    if( SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(1), &ptr2, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg2 = (CvSeq *) ptr2;
  }
  {
    try {
      cvSubstituteContour(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvEndFindContours (const octave_value_list& args, int nargout) {
  CvContourScanner *arg1 = (CvContourScanner *) 0 ;
  void *vptr1 ;
  CvContourScanner buffer1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvEndFindContours",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p__CvContourScanner, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (CvContourScanner) vptr1;
    arg1=&buffer1;
  }
  {
    try {
      result = (CvSeq *)cvEndFindContours(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvApproxChainsUntyped (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  int arg3 = (int) 2 ;
  double arg4 = (double) 0 ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvApproxChainsUntyped",args.length(),6,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvApproxChainsUntyped" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvApproxChainsUntyped" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvApproxChainsUntyped" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvApproxChainsUntyped" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvApproxChainsUntyped" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      result = (CvSeq *)cvApproxChains(arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvStartReadChainPoints (const octave_value_list& args, int nargout) {
  CvChain *arg1 = (CvChain *) 0 ;
  CvChainPtReader *arg2 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvStartReadChainPoints",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChain, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvStartReadChainPoints" "', argument " "1"" of type '" "CvChain *""'"); 
  }
  arg1 = (CvChain *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvStartReadChainPoints" "', argument " "2"" of type '" "CvChainPtReader *""'"); 
  }
  arg2 = (CvChainPtReader *)(argp2);
  {
    try {
      cvStartReadChainPoints(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReadChainPoint (const octave_value_list& args, int nargout) {
  CvChainPtReader *arg1 = (CvChainPtReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint result;
  
  if (!SWIG_check_num_args("cvReadChainPoint",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvChainPtReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReadChainPoint" "', argument " "1"" of type '" "CvChainPtReader *""'"); 
  }
  arg1 = (CvChainPtReader *)(argp1);
  {
    try {
      result = cvReadChainPoint(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvPoint((const CvPoint&)(result))), SWIGTYPE_p_CvPoint, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcOpticalFlowLK (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvSize arg3 ;
  CvArr *arg4 = (CvArr *) 0 ;
  CvArr *arg5 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 ;
  int res3 = 0 ;
  bool freearg4 = false ;
  bool freearg5 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcOpticalFlowLK",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCalcOpticalFlowLK" "', argument " "3"" of type '" "CvSize""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcOpticalFlowLK" "', argument " "3"" of type '" "CvSize""'");
    } else {
      arg3 = *((CvSize *)(argp3));
    }
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    arg5 = OctObject_to_CvArr(args(4), &freearg5);
  }
  {
    try {
      cvCalcOpticalFlowLK((void const *)arg1,(void const *)arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
  {
    if(arg5!=NULL && freearg5){
      cvReleaseData( arg5 );
      cvFree(&(arg5));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcOpticalFlowBM (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvSize arg3 ;
  CvSize arg4 ;
  CvSize arg5 ;
  int arg6 ;
  CvArr *arg7 = (CvArr *) 0 ;
  CvArr *arg8 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  bool freearg7 = false ;
  bool freearg8 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcOpticalFlowBM",args.length(),8,8,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCalcOpticalFlowBM" "', argument " "3"" of type '" "CvSize""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcOpticalFlowBM" "', argument " "3"" of type '" "CvSize""'");
    } else {
      arg3 = *((CvSize *)(argp3));
    }
  }
  {
    res4 = SWIG_ConvertPtr(args(3), &argp4, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCalcOpticalFlowBM" "', argument " "4"" of type '" "CvSize""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcOpticalFlowBM" "', argument " "4"" of type '" "CvSize""'");
    } else {
      arg4 = *((CvSize *)(argp4));
    }
  }
  {
    res5 = SWIG_ConvertPtr(args(4), &argp5, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvCalcOpticalFlowBM" "', argument " "5"" of type '" "CvSize""'"); 
    }  
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcOpticalFlowBM" "', argument " "5"" of type '" "CvSize""'");
    } else {
      arg5 = *((CvSize *)(argp5));
    }
  }
  ecode6 = SWIG_AsVal_int(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvCalcOpticalFlowBM" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  {
    arg7 = OctObject_to_CvArr(args(6), &freearg7);
  }
  {
    arg8 = OctObject_to_CvArr(args(7), &freearg8);
  }
  {
    try {
      cvCalcOpticalFlowBM((void const *)arg1,(void const *)arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg7!=NULL && freearg7){
      cvReleaseData( arg7 );
      cvFree(&(arg7));
    }
  }
  {
    if(arg8!=NULL && freearg8){
      cvReleaseData( arg8 );
      cvFree(&(arg8));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcOpticalFlowHS (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  CvArr *arg4 = (CvArr *) 0 ;
  CvArr *arg5 = (CvArr *) 0 ;
  double arg6 ;
  CvTermCriteria arg7 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  bool freearg4 = false ;
  bool freearg5 = false ;
  double val6 ;
  int ecode6 = 0 ;
  void *argp7 ;
  int res7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcOpticalFlowHS",args.length(),7,7,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCalcOpticalFlowHS" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    arg5 = OctObject_to_CvArr(args(4), &freearg5);
  }
  ecode6 = SWIG_AsVal_double(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvCalcOpticalFlowHS" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  {
    res7 = SWIG_ConvertPtr(args(6), &argp7, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvCalcOpticalFlowHS" "', argument " "7"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcOpticalFlowHS" "', argument " "7"" of type '" "CvTermCriteria""'");
    } else {
      arg7 = *((CvTermCriteria *)(argp7));
    }
  }
  {
    try {
      cvCalcOpticalFlowHS((void const *)arg1,(void const *)arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
  {
    if(arg5!=NULL && freearg5){
      cvReleaseData( arg5 );
      cvFree(&(arg5));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcOpticalFlowPyrLK (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  CvPoint2D32f *arg5 = (CvPoint2D32f *) 0 ;
  CvPoint2D32f *arg6 = (CvPoint2D32f *) 0 ;
  int arg7 ;
  CvSize arg8 ;
  int arg9 ;
  char *arg10 = (char *) 0 ;
  float *arg11 = (float *) 0 ;
  CvTermCriteria arg12 ;
  int arg13 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  int tmpCount6 ;
  void *argp8 ;
  int res8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int tmpCountStatus10 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 ;
  int res12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcOpticalFlowPyrLK",args.length(),12,12,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    int i;
    int size;
    
    // get the size of the input array
    size = OctList_Size (args(4));
    
    // allocate the needed memory
    arg5 = (CvPoint2D32f *)malloc (size * sizeof (CvPoint2D32f));
    
    // extract all the points values from the list
    for (i = 0; i < size; i++) {
      octave_value item = OctList_GetItem (args(4), i);
      
      void * vptr;
      SWIG_Octave_ConvertPtr (item, &vptr,
        SWIGTYPE_p_CvPoint2D32f,
        SWIG_POINTER_EXCEPTION);
      CvPoint2D32f *p = (CvPoint2D32f *)vptr;
      arg5 [i].x = p->x;
      arg5 [i].y = p->y;
    }
  }
  {
    // as input, we only need the size of the wanted features
    
    // memorize the size of the wanted features
    tmpCount6 = (int)OctInt_AsLong (args(5));
    
    // create the array for the C call
    arg6 = (CvPoint2D32f *) malloc(tmpCount6 * sizeof (CvPoint2D32f));
    
    // the size of the array for the C call
    arg7 = tmpCount6;
  }
  {
    res8 = SWIG_ConvertPtr(args(6), &argp8, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cvCalcOpticalFlowPyrLK" "', argument " "8"" of type '" "CvSize""'"); 
    }  
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcOpticalFlowPyrLK" "', argument " "8"" of type '" "CvSize""'");
    } else {
      arg8 = *((CvSize *)(argp8));
    }
  }
  ecode9 = SWIG_AsVal_int(args(7), &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cvCalcOpticalFlowPyrLK" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = (int)(val9);
  {
    // as input, we still need the size of the status array
    
    // memorize the size of the status array
    tmpCountStatus10 = (int)OctInt_AsLong (args(8));
    
    // create the status array for the C call
    arg10 = (char *)malloc (tmpCountStatus10 * sizeof (char));
  }
  res11 = SWIG_ConvertPtr(args(9), &argp11,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res11)) {
    SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "cvCalcOpticalFlowPyrLK" "', argument " "11"" of type '" "float *""'"); 
  }
  arg11 = (float *)(argp11);
  {
    res12 = SWIG_ConvertPtr(args(10), &argp12, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "cvCalcOpticalFlowPyrLK" "', argument " "12"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcOpticalFlowPyrLK" "', argument " "12"" of type '" "CvTermCriteria""'");
    } else {
      arg12 = *((CvTermCriteria *)(argp12));
    }
  }
  ecode13 = SWIG_AsVal_int(args(11), &val13);
  if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cvCalcOpticalFlowPyrLK" "', argument " "13"" of type '" "int""'");
  } 
  arg13 = (int)(val13);
  {
    try {
      cvCalcOpticalFlowPyrLK((void const *)arg1,(void const *)arg2,arg3,arg4,(CvPoint2D32f const *)arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    int i;
    octave_value to_add;
    
    // create the list to return
    to_add = OctList_New (tmpCount6);
    
    // extract all the points values of the result, and add it to the
    // final resulting list
    for (i = 0; i < tmpCount6; i++) {
      OctList_SetItem (to_add, i,
        SWIG_NewPointerObj (&(arg6 [i]),
          SWIGTYPE_p_CvPoint2D32f, 0));
    }
    
    _outp = SWIG_AppendResult(_outp, &to_add, 1);
  }
  {
    int i;
    octave_value to_add;
    
    // create the list to return
    to_add = OctList_New (tmpCountStatus10);
    
    // extract all the integer values of the result, and add it to the
    // final resulting list
    for (i = 0; i < tmpCountStatus10; i++) {
      OctList_SetItem (to_add, i, OctBool_FromLong (arg10 [i]));
    }
    
    _outp = SWIG_AppendResult(_outp, &to_add, 1); 
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcAffineFlowPyrLK (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  CvPoint2D32f *arg5 = (CvPoint2D32f *) 0 ;
  CvPoint2D32f *arg6 = (CvPoint2D32f *) 0 ;
  float *arg7 = (float *) 0 ;
  int arg8 ;
  CvSize arg9 ;
  int arg10 ;
  char *arg11 = (char *) 0 ;
  float *arg12 = (float *) 0 ;
  CvTermCriteria arg13 ;
  int arg14 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  void *argp9 ;
  int res9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int tmpCountStatus11 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 ;
  int res13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcAffineFlowPyrLK",args.length(),14,14,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    int i;
    int size;
    
    // get the size of the input array
    size = OctList_Size (args(4));
    
    // allocate the needed memory
    arg5 = (CvPoint2D32f *)malloc (size * sizeof (CvPoint2D32f));
    
    // extract all the points values from the list
    for (i = 0; i < size; i++) {
      octave_value item = OctList_GetItem (args(4), i);
      
      void * vptr;
      SWIG_Octave_ConvertPtr (item, &vptr,
        SWIGTYPE_p_CvPoint2D32f,
        SWIG_POINTER_EXCEPTION);
      CvPoint2D32f *p = (CvPoint2D32f *)vptr;
      arg5 [i].x = p->x;
      arg5 [i].y = p->y;
    }
  }
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvCalcAffineFlowPyrLK" "', argument " "6"" of type '" "CvPoint2D32f *""'"); 
  }
  arg6 = (CvPoint2D32f *)(argp6);
  res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvCalcAffineFlowPyrLK" "', argument " "7"" of type '" "float *""'"); 
  }
  arg7 = (float *)(argp7);
  ecode8 = SWIG_AsVal_int(args(7), &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cvCalcAffineFlowPyrLK" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = (int)(val8);
  {
    res9 = SWIG_ConvertPtr(args(8), &argp9, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cvCalcAffineFlowPyrLK" "', argument " "9"" of type '" "CvSize""'"); 
    }  
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcAffineFlowPyrLK" "', argument " "9"" of type '" "CvSize""'");
    } else {
      arg9 = *((CvSize *)(argp9));
    }
  }
  ecode10 = SWIG_AsVal_int(args(9), &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cvCalcAffineFlowPyrLK" "', argument " "10"" of type '" "int""'");
  } 
  arg10 = (int)(val10);
  {
    // as input, we still need the size of the status array
    
    // memorize the size of the status array
    tmpCountStatus11 = (int)OctInt_AsLong (args(10));
    
    // create the status array for the C call
    arg11 = (char *)malloc (tmpCountStatus11 * sizeof (char));
  }
  res12 = SWIG_ConvertPtr(args(11), &argp12,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res12)) {
    SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "cvCalcAffineFlowPyrLK" "', argument " "12"" of type '" "float *""'"); 
  }
  arg12 = (float *)(argp12);
  {
    res13 = SWIG_ConvertPtr(args(12), &argp13, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "cvCalcAffineFlowPyrLK" "', argument " "13"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcAffineFlowPyrLK" "', argument " "13"" of type '" "CvTermCriteria""'");
    } else {
      arg13 = *((CvTermCriteria *)(argp13));
    }
  }
  ecode14 = SWIG_AsVal_int(args(13), &val14);
  if (!SWIG_IsOK(ecode14)) {
    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "cvCalcAffineFlowPyrLK" "', argument " "14"" of type '" "int""'");
  } 
  arg14 = (int)(val14);
  {
    try {
      cvCalcAffineFlowPyrLK((void const *)arg1,(void const *)arg2,arg3,arg4,(CvPoint2D32f const *)arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    int i;
    octave_value to_add;
    
    // create the list to return
    to_add = OctList_New (tmpCountStatus11);
    
    // extract all the integer values of the result, and add it to the
    // final resulting list
    for (i = 0; i < tmpCountStatus11; i++) {
      OctList_SetItem (to_add, i, OctBool_FromLong (arg11 [i]));
    }
    
    _outp = SWIG_AppendResult(_outp, &to_add, 1); 
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvEstimateRigidTransform (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  int arg4 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvEstimateRigidTransform",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvEstimateRigidTransform" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvEstimateRigidTransform" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      result = (int)cvEstimateRigidTransform((void const *)arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvUpdateMotionHistory (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 ;
  double arg4 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvUpdateMotionHistory",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvUpdateMotionHistory" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvUpdateMotionHistory" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    try {
      cvUpdateMotionHistory((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcMotionGradient (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  double arg4 ;
  double arg5 ;
  int arg6 = (int) 3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcMotionGradient",args.length(),6,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCalcMotionGradient" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCalcMotionGradient" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvCalcMotionGradient" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      cvCalcMotionGradient((void const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcGlobalOrientation (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  double arg4 ;
  double arg5 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvCalcGlobalOrientation",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCalcGlobalOrientation" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCalcGlobalOrientation" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  {
    try {
      result = (double)cvCalcGlobalOrientation((void const *)arg1,(void const *)arg2,(void const *)arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAcc (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAcc",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    {
      arg3 = OctObject_to_CvArr(args(2), &freearg3);
    }
  }
  {
    try {
      cvAcc((void const *)arg1,arg2,(void const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvSquareAcc (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSquareAcc",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    {
      arg3 = OctObject_to_CvArr(args(2), &freearg3);
    }
  }
  {
    try {
      cvSquareAcc((void const *)arg1,arg2,(void const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMultiplyAcc (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvMultiplyAcc",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvMultiplyAcc((void const *)arg1,(void const *)arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvRunningAvg (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 ;
  CvArr *arg4 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRunningAvg",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvRunningAvg" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvRunningAvg((void const *)arg1,arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCamShift (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvRect arg2 ;
  CvTermCriteria arg3 ;
  CvConnectedComp *arg4 = (CvConnectedComp *) 0 ;
  CvBox2D *arg5 = (CvBox2D *) NULL ;
  bool freearg1 = false ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvCamShift",args.length(),5,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvRect,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCamShift" "', argument " "2"" of type '" "CvRect""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCamShift" "', argument " "2"" of type '" "CvRect""'");
    } else {
      arg2 = *((CvRect *)(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCamShift" "', argument " "3"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCamShift" "', argument " "3"" of type '" "CvTermCriteria""'");
    } else {
      arg3 = *((CvTermCriteria *)(argp3));
    }
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCamShift" "', argument " "4"" of type '" "CvConnectedComp *""'"); 
  }
  arg4 = (CvConnectedComp *)(argp4);
  if (4<args.length()) {
    res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvBox2D, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvCamShift" "', argument " "5"" of type '" "CvBox2D *""'"); 
    }
    arg5 = (CvBox2D *)(argp5);
  }
  {
    try {
      result = (int)cvCamShift((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMeanShift (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvRect arg2 ;
  CvTermCriteria arg3 ;
  CvConnectedComp *arg4 = (CvConnectedComp *) 0 ;
  bool freearg1 = false ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvMeanShift",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvRect,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvMeanShift" "', argument " "2"" of type '" "CvRect""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvMeanShift" "', argument " "2"" of type '" "CvRect""'");
    } else {
      arg2 = *((CvRect *)(argp2));
    }
  }
  {
    res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvMeanShift" "', argument " "3"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvMeanShift" "', argument " "3"" of type '" "CvTermCriteria""'");
    } else {
      arg3 = *((CvTermCriteria *)(argp3));
    }
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvMeanShift" "', argument " "4"" of type '" "CvConnectedComp *""'"); 
  }
  arg4 = (CvConnectedComp *)(argp4);
  {
    try {
      result = (int)cvMeanShift((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateConDensation (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvConDensation *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateConDensation",args.length(),3,3,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateConDensation" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateConDensation" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateConDensation" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (CvConDensation *)cvCreateConDensation(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvConDensation, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseConDensation (const octave_value_list& args, int nargout) {
  CvConDensation **arg1 = (CvConDensation **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseConDensation",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseConDensation" "', argument " "1"" of type '" "CvConDensation **""'"); 
  }
  arg1 = (CvConDensation **)(argp1);
  {
    try {
      cvReleaseConDensation(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvConDensUpdateByTime (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvConDensUpdateByTime",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvConDensUpdateByTime" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  {
    try {
      cvConDensUpdateByTime(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvConDensInitSampleSet (const octave_value_list& args, int nargout) {
  CvConDensation *arg1 = (CvConDensation *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvConDensInitSampleSet",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvConDensation, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvConDensInitSampleSet" "', argument " "1"" of type '" "CvConDensation *""'"); 
  }
  arg1 = (CvConDensation *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvConDensInitSampleSet" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvConDensInitSampleSet" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  {
    try {
      cvConDensInitSampleSet(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateKalman (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 = (int) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvKalman *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateKalman",args.length(),3,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateKalman" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateKalman" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateKalman" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      result = (CvKalman *)cvCreateKalman(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvKalman, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseKalman (const octave_value_list& args, int nargout) {
  CvKalman **arg1 = (CvKalman **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseKalman",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseKalman" "', argument " "1"" of type '" "CvKalman **""'"); 
  }
  arg1 = (CvKalman **)(argp1);
  {
    try {
      cvReleaseKalman(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvKalmanPredict (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvKalmanPredict",args.length(),2,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvKalmanPredict" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvKalmanPredict" "', argument " "2"" of type '" "CvMat const *""'"); 
    }
    arg2 = (CvMat *)(argp2);
  }
  {
    try {
      result = (CvMat *)cvKalmanPredict(arg1,(CvMat const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvKalmanCorrect (const octave_value_list& args, int nargout) {
  CvKalman *arg1 = (CvKalman *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("cvKalmanCorrect",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvKalman, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvKalmanCorrect" "', argument " "1"" of type '" "CvKalman *""'"); 
  }
  arg1 = (CvKalman *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvKalmanCorrect" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  {
    try {
      result = (CvMat *)cvKalmanCorrect(arg1,(CvMat const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvInitSubdivDelaunay2D (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvRect arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInitSubdivDelaunay2D",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvInitSubdivDelaunay2D" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvRect,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvInitSubdivDelaunay2D" "', argument " "2"" of type '" "CvRect""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvInitSubdivDelaunay2D" "', argument " "2"" of type '" "CvRect""'");
    } else {
      arg2 = *((CvRect *)(argp2));
    }
  }
  {
    try {
      cvInitSubdivDelaunay2D(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateSubdiv2D (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  CvMemStorage *arg5 = (CvMemStorage *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2D *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateSubdiv2D",args.length(),5,5,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateSubdiv2D" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateSubdiv2D" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateSubdiv2D" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCreateSubdiv2D" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvCreateSubdiv2D" "', argument " "5"" of type '" "CvMemStorage *""'"); 
  }
  arg5 = (CvMemStorage *)(argp5);
  {
    try {
      result = (CvSubdiv2D *)cvCreateSubdiv2D(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateSubdivDelaunay2D (const octave_value_list& args, int nargout) {
  CvRect arg1 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2D *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateSubdivDelaunay2D",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvRect,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCreateSubdivDelaunay2D" "', argument " "1"" of type '" "CvRect""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCreateSubdivDelaunay2D" "', argument " "1"" of type '" "CvRect""'");
    } else {
      arg1 = *((CvRect *)(argp1));
    }
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCreateSubdivDelaunay2D" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  {
    try {
      result = (CvSubdiv2D *)cvCreateSubdivDelaunay2D(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSubdivDelaunay2DInsert (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvPoint2D32f arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DPoint *result = 0 ;
  
  if (!SWIG_check_num_args("cvSubdivDelaunay2DInsert",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSubdivDelaunay2DInsert" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    arg2 = OctObject_to_CvPoint2D32f(args(1));
  }
  {
    try {
      result = (CvSubdiv2DPoint *)cvSubdivDelaunay2DInsert(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSubdiv2DPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSubdiv2DLocate (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvPoint2D32f arg2 ;
  CvSubdiv2DEdge *arg3 = (CvSubdiv2DEdge *) 0 ;
  CvSubdiv2DPoint **arg4 = (CvSubdiv2DPoint **) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  CvSubdiv2DEdge tmpEdge3 ;
  CvSubdiv2DPoint *tmpVertex3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DPointLocation result;
  
  {
    arg3 = &tmpEdge3;
    arg4 = &tmpVertex3;
  }
  if (!SWIG_check_num_args("cvSubdiv2DLocate",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSubdiv2DLocate" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    arg2 = OctObject_to_CvPoint2D32f(args(1));
  }
  {
    try {
      result = (CvSubdiv2DPointLocation)cvSubdiv2DLocate(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    octave_value to_add[2];
    if(result==CV_PTLOC_INSIDE || result==CV_PTLOC_ON_EDGE){
      CvSubdiv2DEdge_Wrapper * wrapper = new CvSubdiv2DEdge_Wrapper( tmpEdge3 );
      to_add[0] = SWIG_NewPointerObj( wrapper, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0);
      to_add[1] = octave_value();
    }
    if(result==CV_PTLOC_VERTEX){
      to_add[0] = octave_value();
      to_add[1] = SWIG_NewPointerObj( tmpVertex3, SWIGTYPE_p_CvSubdiv2DPoint, 0);
    }
    
    _outp = SWIG_AppendResult(_outp, to_add, 2);
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcSubdivVoronoi2D (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcSubdivVoronoi2D",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCalcSubdivVoronoi2D" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    try {
      cvCalcSubdivVoronoi2D(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvClearSubdivVoronoi2D (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvClearSubdivVoronoi2D",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvClearSubdivVoronoi2D" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    try {
      cvClearSubdivVoronoi2D(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindNearestPoint2D (const octave_value_list& args, int nargout) {
  CvSubdiv2D *arg1 = (CvSubdiv2D *) 0 ;
  CvPoint2D32f arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DPoint *result = 0 ;
  
  if (!SWIG_check_num_args("cvFindNearestPoint2D",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSubdiv2D, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFindNearestPoint2D" "', argument " "1"" of type '" "CvSubdiv2D *""'"); 
  }
  arg1 = (CvSubdiv2D *)(argp1);
  {
    arg2 = OctObject_to_CvPoint2D32f(args(1));
  }
  {
    try {
      result = (CvSubdiv2DPoint *)cvFindNearestPoint2D(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSubdiv2DPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSubdiv2DNextEdge (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge arg1 ;
  CvSubdiv2DEdge_Wrapper *wrapper1 ;
  CvQuadEdge2D *qedge1 ;
  void *vptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DEdge result;
  
  if (!SWIG_check_num_args("cvSubdiv2DNextEdge",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0) != -1 ){
      wrapper1 = (CvSubdiv2DEdge_Wrapper *) vptr1;
      arg1 = wrapper1->ref();
    }
    else if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvQuadEdge2D, 0) != -1 ){
      qedge1 = (CvQuadEdge2D *) vptr1;
      arg1 = (CvSubdiv2DEdge)qedge1;
    }
    else{
      SWIG_exception( SWIG_TypeError, "could not convert to CvSubdiv2DEdge");
      SWIG_fail;
    }
  }
  {
    try {
      result = cvSubdiv2DNextEdge(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    CvSubdiv2DEdge_Wrapper * wrapper = new CvSubdiv2DEdge_Wrapper( result );
    _outv = SWIG_NewPointerObj( wrapper, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 1 );
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSubdiv2DRotateEdge (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge arg1 ;
  int arg2 ;
  CvSubdiv2DEdge_Wrapper *wrapper1 ;
  CvQuadEdge2D *qedge1 ;
  void *vptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DEdge result;
  
  if (!SWIG_check_num_args("cvSubdiv2DRotateEdge",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0) != -1 ){
      wrapper1 = (CvSubdiv2DEdge_Wrapper *) vptr1;
      arg1 = wrapper1->ref();
    }
    else if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvQuadEdge2D, 0) != -1 ){
      qedge1 = (CvQuadEdge2D *) vptr1;
      arg1 = (CvSubdiv2DEdge)qedge1;
    }
    else{
      SWIG_exception( SWIG_TypeError, "could not convert to CvSubdiv2DEdge");
      SWIG_fail;
    }
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSubdiv2DRotateEdge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = cvSubdiv2DRotateEdge(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    CvSubdiv2DEdge_Wrapper * wrapper = new CvSubdiv2DEdge_Wrapper( result );
    _outv = SWIG_NewPointerObj( wrapper, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 1 );
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSubdiv2DSymEdge (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge arg1 ;
  CvSubdiv2DEdge_Wrapper *wrapper1 ;
  CvQuadEdge2D *qedge1 ;
  void *vptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DEdge result;
  
  if (!SWIG_check_num_args("cvSubdiv2DSymEdge",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0) != -1 ){
      wrapper1 = (CvSubdiv2DEdge_Wrapper *) vptr1;
      arg1 = wrapper1->ref();
    }
    else if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvQuadEdge2D, 0) != -1 ){
      qedge1 = (CvQuadEdge2D *) vptr1;
      arg1 = (CvSubdiv2DEdge)qedge1;
    }
    else{
      SWIG_exception( SWIG_TypeError, "could not convert to CvSubdiv2DEdge");
      SWIG_fail;
    }
  }
  {
    try {
      result = cvSubdiv2DSymEdge(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    CvSubdiv2DEdge_Wrapper * wrapper = new CvSubdiv2DEdge_Wrapper( result );
    _outv = SWIG_NewPointerObj( wrapper, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 1 );
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSubdiv2DGetEdge (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge arg1 ;
  CvNextEdgeType arg2 ;
  CvSubdiv2DEdge_Wrapper *wrapper1 ;
  CvQuadEdge2D *qedge1 ;
  void *vptr1 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DEdge result;
  
  if (!SWIG_check_num_args("cvSubdiv2DGetEdge",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0) != -1 ){
      wrapper1 = (CvSubdiv2DEdge_Wrapper *) vptr1;
      arg1 = wrapper1->ref();
    }
    else if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvQuadEdge2D, 0) != -1 ){
      qedge1 = (CvQuadEdge2D *) vptr1;
      arg1 = (CvSubdiv2DEdge)qedge1;
    }
    else{
      SWIG_exception( SWIG_TypeError, "could not convert to CvSubdiv2DEdge");
      SWIG_fail;
    }
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSubdiv2DGetEdge" "', argument " "2"" of type '" "CvNextEdgeType""'");
  } 
  arg2 = (CvNextEdgeType)(val2);
  {
    try {
      result = cvSubdiv2DGetEdge(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  {
    CvSubdiv2DEdge_Wrapper * wrapper = new CvSubdiv2DEdge_Wrapper( result );
    _outv = SWIG_NewPointerObj( wrapper, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 1 );
  }
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSubdiv2DEdgeOrg (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge arg1 ;
  CvSubdiv2DEdge_Wrapper *wrapper1 ;
  CvQuadEdge2D *qedge1 ;
  void *vptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DPoint *result = 0 ;
  
  if (!SWIG_check_num_args("cvSubdiv2DEdgeOrg",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0) != -1 ){
      wrapper1 = (CvSubdiv2DEdge_Wrapper *) vptr1;
      arg1 = wrapper1->ref();
    }
    else if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvQuadEdge2D, 0) != -1 ){
      qedge1 = (CvQuadEdge2D *) vptr1;
      arg1 = (CvSubdiv2DEdge)qedge1;
    }
    else{
      SWIG_exception( SWIG_TypeError, "could not convert to CvSubdiv2DEdge");
      SWIG_fail;
    }
  }
  {
    try {
      result = (CvSubdiv2DPoint *)cvSubdiv2DEdgeOrg(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSubdiv2DPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSubdiv2DEdgeDst (const octave_value_list& args, int nargout) {
  CvSubdiv2DEdge arg1 ;
  CvSubdiv2DEdge_Wrapper *wrapper1 ;
  CvQuadEdge2D *qedge1 ;
  void *vptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSubdiv2DPoint *result = 0 ;
  
  if (!SWIG_check_num_args("cvSubdiv2DEdgeDst",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvSubdiv2DEdge_Wrapper, 0) != -1 ){
      wrapper1 = (CvSubdiv2DEdge_Wrapper *) vptr1;
      arg1 = wrapper1->ref();
    }
    else if( SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvQuadEdge2D, 0) != -1 ){
      qedge1 = (CvQuadEdge2D *) vptr1;
      arg1 = (CvSubdiv2DEdge)qedge1;
    }
    else{
      SWIG_exception( SWIG_TypeError, "could not convert to CvSubdiv2DEdge");
      SWIG_fail;
    }
  }
  {
    try {
      result = (CvSubdiv2DPoint *)cvSubdiv2DEdgeDst(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSubdiv2DPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvTriangleArea (const octave_value_list& args, int nargout) {
  CvPoint2D32f arg1 ;
  CvPoint2D32f arg2 ;
  CvPoint2D32f arg3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvTriangleArea",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint2D32f(args(0));
  }
  {
    arg2 = OctObject_to_CvPoint2D32f(args(1));
  }
  {
    arg3 = OctObject_to_CvPoint2D32f(args(2));
  }
  {
    try {
      result = (double)cvTriangleArea(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindDominantPoints (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  int arg3 = (int) 1 ;
  double arg4 = (double) 0 ;
  double arg5 = (double) 0 ;
  double arg6 = (double) 0 ;
  double arg7 = (double) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvFindDominantPoints",args.length(),7,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvFindDominantPoints" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvFindDominantPoints" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvFindDominantPoints" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_double(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvFindDominantPoints" "', argument " "5"" of type '" "double""'");
    } 
    arg5 = (double)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_double(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvFindDominantPoints" "', argument " "6"" of type '" "double""'");
    } 
    arg6 = (double)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_double(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvFindDominantPoints" "', argument " "7"" of type '" "double""'");
    } 
    arg7 = (double)(val7);
  }
  {
    try {
      result = (CvSeq *)cvFindDominantPoints(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvBoundingRect (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 = (int) 0 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect result;
  
  if (!SWIG_check_num_args("cvBoundingRect",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvBoundingRect" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    try {
      result = cvBoundingRect(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvRect((const CvRect&)(result))), SWIGTYPE_p_CvRect, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvContourArea (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvSlice arg2 = (CvSlice) cvSlice(0, 0x3fffffff) ;
  bool freearg1 = false ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvContourArea",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    {
      res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSlice,  0 );
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvContourArea" "', argument " "2"" of type '" "CvSlice""'"); 
      }  
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvContourArea" "', argument " "2"" of type '" "CvSlice""'");
      } else {
        arg2 = *((CvSlice *)(argp2));
      }
    }
  }
  {
    try {
      result = (double)cvContourArea((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMinAreaRect2 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) NULL ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvBox2D result;
  
  if (!SWIG_check_num_args("cvMinAreaRect2",args.length(),2,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  if (1<args.length()) {
    res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvMinAreaRect2" "', argument " "2"" of type '" "CvMemStorage *""'"); 
    }
    arg2 = (CvMemStorage *)(argp2);
  }
  {
    try {
      result = cvMinAreaRect2((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvBox2D((const CvBox2D&)(result))), SWIGTYPE_p_CvBox2D, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMinEnclosingCircle (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  float *arg3 = (float *) 0 ;
  bool freearg1 = false ;
  CvPoint2D32f *tmp_center2 ;
  float tmp_radius2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  {
    tmp_center2 = (CvPoint2D32f *) malloc(sizeof(CvPoint2D32f));
    arg2 = tmp_center2;
    arg3 = &tmp_radius2;
  }
  if (!SWIG_check_num_args("cvMinEnclosingCircle",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      result = (int)cvMinEnclosingCircle((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    octave_value to_add[2];
    to_add[0] = SWIG_NewPointerObj( tmp_center2, SWIGTYPE_p_CvPoint2D32f, 1); 
    to_add[1] = OctFloat_FromDouble( tmp_radius2 );
    
    _outp = SWIG_AppendResult(_outp, to_add, 2);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMatchShapes (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  void *arg2 = (void *) 0 ;
  int arg3 ;
  double arg4 = (double) 0 ;
  int res1 ;
  int res2 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvMatchShapes",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvMatchShapes" "', argument " "1"" of type '" "void const *""'"); 
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvMatchShapes" "', argument " "2"" of type '" "void const *""'"); 
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvMatchShapes" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvMatchShapes" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  {
    try {
      result = (double)cvMatchShapes((void const *)arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateContourTree (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  double arg3 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvContourTree *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateContourTree",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCreateContourTree" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateContourTree" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    try {
      result = (CvContourTree *)cvCreateContourTree((CvSeq const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvContourFromContourTreeUntyped (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  CvTermCriteria arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvContourFromContourTreeUntyped",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvContourFromContourTreeUntyped" "', argument " "1"" of type '" "CvContourTree const *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvContourFromContourTreeUntyped" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  {
    res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvContourFromContourTreeUntyped" "', argument " "3"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvContourFromContourTreeUntyped" "', argument " "3"" of type '" "CvTermCriteria""'");
    } else {
      arg3 = *((CvTermCriteria *)(argp3));
    }
  }
  {
    try {
      result = (CvSeq *)cvContourFromContourTree((CvContourTree const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvMatchContourTrees (const octave_value_list& args, int nargout) {
  CvContourTree *arg1 = (CvContourTree *) 0 ;
  CvContourTree *arg2 = (CvContourTree *) 0 ;
  int arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvMatchContourTrees",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvMatchContourTrees" "', argument " "1"" of type '" "CvContourTree const *""'"); 
  }
  arg1 = (CvContourTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvContourTree, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvMatchContourTrees" "', argument " "2"" of type '" "CvContourTree const *""'"); 
  }
  arg2 = (CvContourTree *)(argp2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvMatchContourTrees" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvMatchContourTrees" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  {
    try {
      result = (double)cvMatchContourTrees((CvContourTree const *)arg1,(CvContourTree const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcPGH (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  CvHistogram *arg2 = (CvHistogram *) 0 ;
  void *ptr1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcPGH",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCalcPGH" "', argument " "2"" of type '" "CvHistogram *""'"); 
  }
  arg2 = (CvHistogram *)(argp2);
  {
    try {
      cvCalcPGH((CvSeq const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCheckContourConvexity (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvCheckContourConvexity",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      result = (int)cvCheckContourConvexity((void const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvConvexityDefectsUntyped (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMemStorage *arg3 = (CvMemStorage *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvConvexityDefectsUntyped",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMemStorage, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvConvexityDefectsUntyped" "', argument " "3"" of type '" "CvMemStorage *""'"); 
    }
    arg3 = (CvMemStorage *)(argp3);
  }
  {
    try {
      result = (CvSeq *)cvConvexityDefects((void const *)arg1,(void const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFitEllipse2 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  bool freearg1 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvBox2D result;
  
  if (!SWIG_check_num_args("cvFitEllipse2",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    try {
      result = cvFitEllipse2((void const *)arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvBox2D((const CvBox2D&)(result))), SWIGTYPE_p_CvBox2D, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvMaxRect (const octave_value_list& args, int nargout) {
  CvRect *arg1 = (CvRect *) 0 ;
  CvRect *arg2 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect result;
  
  if (!SWIG_check_num_args("cvMaxRect",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvMaxRect" "', argument " "1"" of type '" "CvRect const *""'"); 
  }
  arg1 = (CvRect *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvMaxRect" "', argument " "2"" of type '" "CvRect const *""'"); 
  }
  arg2 = (CvRect *)(argp2);
  {
    try {
      result = cvMaxRect((CvRect const *)arg1,(CvRect const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvRect((const CvRect&)(result))), SWIGTYPE_p_CvRect, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvBoxPoints (const octave_value_list& args, int nargout) {
  CvBox2D arg1 ;
  CvPoint2D32f *arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  CvPoint2D32f tmp_pts2[4] ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  {
    arg2 = tmp_pts2;
  }
  if (!SWIG_check_num_args("cvBoxPoints",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    res1 = SWIG_ConvertPtr(args(0), &argp1, SWIGTYPE_p_CvBox2D,  0 );
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvBoxPoints" "', argument " "1"" of type '" "CvBox2D""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvBoxPoints" "', argument " "1"" of type '" "CvBox2D""'");
    } else {
      arg1 = *((CvBox2D *)(argp1));
    }
  }
  {
    try {
      cvBoxPoints(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    octave_value to_add = OctList_New(4);
    int i;
    for(i=0; i<4; i++){
      CvPoint2D32f * p = new CvPoint2D32f;
      *p = tmp_pts2[i];
      OctList_SetItem(to_add, i, SWIG_NewPointerObj( p, SWIGTYPE_p_CvPoint2D32f, 1 ) );
    }
    _outp = SWIG_AppendResult(_outp, &to_add, 1);
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPointSeqFromMat (const octave_value_list& args, int nargout) {
  int arg1 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvContour *arg3 = (CvContour *) 0 ;
  CvSeqBlock *arg4 = (CvSeqBlock *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvPointSeqFromMat",args.length(),4,4,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvPointSeqFromMat" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvContour, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvPointSeqFromMat" "', argument " "3"" of type '" "CvContour *""'"); 
  }
  arg3 = (CvContour *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvSeqBlock, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvPointSeqFromMat" "', argument " "4"" of type '" "CvSeqBlock *""'"); 
  }
  arg4 = (CvSeqBlock *)(argp4);
  {
    try {
      result = (CvSeq *)cvPointSeqFromMat(arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPointPolygonTest (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint2D32f arg2 ;
  int arg3 ;
  bool freearg1 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvPointPolygonTest",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvPoint2D32f(args(1));
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPointPolygonTest" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (double)cvPointPolygonTest((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateHist (const octave_value_list& args, int nargout) {
  int arg1 ;
  int *arg2 = (int *) 0 ;
  int arg3 ;
  float **arg4 = (float **) NULL ;
  int arg5 = (int) 1 ;
  int val3 ;
  int ecode3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHistogram *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateHist",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    int i;
    
    // get the size of the dimention array
    arg1 = OctList_Size (args(0));
    
    // allocate the needed memory
    arg2 = (int *)malloc (arg1 * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < arg1; i++) {
      octave_value item = OctList_GetItem (args(0), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  ecode3 = SWIG_AsVal_int(args(1), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateHist" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (2<args.length()) {
    {
      int i1;
      int i2;
      int size1;
      int size2 = 0;
      
      // get the number of lines of the matrix
      size1 = OctList_Size (args(2));
      
      // allocate the correct number of lines for the destination matrix
      arg4 = (float **)malloc (size1 * sizeof (float *));
      
      for (i1 = 0; i1 < size1; i1++) {
        // extract all the lines of the matrix
        octave_value list = OctList_GetItem (args(2), i1);
        
        if (size2 == 0) {
          // size 2 wasn't computed before
          size2 = OctList_Size (list);
        } else if (size2 != OctList_Size (list)) {
          // the current line as a different size than the previous one
          // so, generate an exception
          SWIG_exception (SWIG_ValueError, "Lines must be the same size");
        }
        
        // allocate the correct number of rows for the current line
        arg4 [i1] = (float *)malloc (size2 * sizeof (float));
        
        // extract all the float values of this row
        for (i2 = 0; i2 < size2; i2++) {
          octave_value item = OctList_GetItem (list, i2);
          arg4 [i1][i2] = (float)OctFloat_AsDouble (item);
        }
      }
    }
  }
  if (3<args.length()) {
    ecode5 = SWIG_AsVal_int(args(3), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCreateHist" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      result = (CvHistogram *)cvCreateHist(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHistogram, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetHistBinRanges (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  float **arg2 = (float **) 0 ;
  int arg3 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetHistBinRanges",args.length(),3,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSetHistBinRanges" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  {
    int i1;
    int i2;
    int size1;
    int size2 = 0;
    
    // get the number of lines of the matrix
    size1 = OctList_Size (args(1));
    
    // allocate the correct number of lines for the destination matrix
    arg2 = (float **)malloc (size1 * sizeof (float *));
    
    for (i1 = 0; i1 < size1; i1++) {
      // extract all the lines of the matrix
      octave_value list = OctList_GetItem (args(1), i1);
      
      if (size2 == 0) {
        // size 2 wasn't computed before
        size2 = OctList_Size (list);
      } else if (size2 != OctList_Size (list)) {
        // the current line as a different size than the previous one
        // so, generate an exception
        SWIG_exception (SWIG_ValueError, "Lines must be the same size");
      }
      
      // allocate the correct number of rows for the current line
      arg2 [i1] = (float *)malloc (size2 * sizeof (float));
      
      // extract all the float values of this row
      for (i2 = 0; i2 < size2; i2++) {
        octave_value item = OctList_GetItem (list, i2);
        arg2 [i1][i2] = (float)OctFloat_AsDouble (item);
      }
    }
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSetHistBinRanges" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      cvSetHistBinRanges(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvMakeHistHeaderForArray (const octave_value_list& args, int nargout) {
  int arg1 ;
  int *arg2 = (int *) 0 ;
  CvHistogram *arg3 = (CvHistogram *) 0 ;
  float *arg4 = (float *) 0 ;
  float **arg5 = (float **) NULL ;
  int arg6 = (int) 1 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHistogram *result = 0 ;
  
  if (!SWIG_check_num_args("cvMakeHistHeaderForArray",args.length(),5,3,0)) {
    SWIG_fail;
  }
  {
    int i;
    
    // get the size of the dimention array
    arg1 = OctList_Size (args(0));
    
    // allocate the needed memory
    arg2 = (int *)malloc (arg1 * sizeof (int));
    
    // extract all the integer values from the list
    for (i = 0; i < arg1; i++) {
      octave_value item = OctList_GetItem (args(0), i);
      arg2 [i] = (int)OctInt_AsLong (item);
    }
  }
  res3 = SWIG_ConvertPtr(args(1), &argp3,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvMakeHistHeaderForArray" "', argument " "3"" of type '" "CvHistogram *""'"); 
  }
  arg3 = (CvHistogram *)(argp3);
  res4 = SWIG_ConvertPtr(args(2), &argp4,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvMakeHistHeaderForArray" "', argument " "4"" of type '" "float *""'"); 
  }
  arg4 = (float *)(argp4);
  if (3<args.length()) {
    {
      int i1;
      int i2;
      int size1;
      int size2 = 0;
      
      // get the number of lines of the matrix
      size1 = OctList_Size (args(3));
      
      // allocate the correct number of lines for the destination matrix
      arg5 = (float **)malloc (size1 * sizeof (float *));
      
      for (i1 = 0; i1 < size1; i1++) {
        // extract all the lines of the matrix
        octave_value list = OctList_GetItem (args(3), i1);
        
        if (size2 == 0) {
          // size 2 wasn't computed before
          size2 = OctList_Size (list);
        } else if (size2 != OctList_Size (list)) {
          // the current line as a different size than the previous one
          // so, generate an exception
          SWIG_exception (SWIG_ValueError, "Lines must be the same size");
        }
        
        // allocate the correct number of rows for the current line
        arg5 [i1] = (float *)malloc (size2 * sizeof (float));
        
        // extract all the float values of this row
        for (i2 = 0; i2 < size2; i2++) {
          octave_value item = OctList_GetItem (list, i2);
          arg5 [i1][i2] = (float)OctFloat_AsDouble (item);
        }
      }
    }
  }
  if (4<args.length()) {
    ecode6 = SWIG_AsVal_int(args(4), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvMakeHistHeaderForArray" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      result = (CvHistogram *)cvMakeHistHeaderForArray(arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseHist (const octave_value_list& args, int nargout) {
  CvHistogram **arg1 = (CvHistogram **) 0 ;
  void *vptr1 ;
  CvHistogram *buffer1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseHist",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvHistogram, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (CvHistogram *) vptr1;
    arg1=&buffer1;
  }
  {
    try {
      cvReleaseHist(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvClearHist (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvClearHist",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvClearHist" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  {
    try {
      cvClearHist(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetMinMaxHistValue (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  float *arg2 = (float *) 0 ;
  float *arg3 = (float *) 0 ;
  int *arg4 = (int *) NULL ;
  int *arg5 = (int *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float temp2 ;
  int res2 = SWIG_TMPOBJ ;
  float temp3 ;
  int res3 = SWIG_TMPOBJ ;
  int temp4 ;
  int res4 = SWIG_TMPOBJ ;
  int temp5 ;
  int res5 = SWIG_TMPOBJ ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  arg2 = &temp2;
  arg3 = &temp3;
  arg4 = &temp4;
  arg5 = &temp5;
  if (!SWIG_check_num_args("cvGetMinMaxHistValue",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvGetMinMaxHistValue" "', argument " "1"" of type '" "CvHistogram const *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  {
    try {
      cvGetMinMaxHistValue((CvHistogram const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (SWIG_IsTmpObj(res2)) {
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_From_float((*arg2)));
  } else {
    int new_flags = SWIG_IsNewObj(res2) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_NewPointerObj((void*)(arg2), SWIGTYPE_p_float, new_flags));
  }
  if (SWIG_IsTmpObj(res3)) {
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_From_float((*arg3)));
  } else {
    int new_flags = SWIG_IsNewObj(res3) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_NewPointerObj((void*)(arg3), SWIGTYPE_p_float, new_flags));
  }
  if (SWIG_IsTmpObj(res4)) {
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_From_int((*arg4)));
  } else {
    int new_flags = SWIG_IsNewObj(res4) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_NewPointerObj((void*)(arg4), SWIGTYPE_p_int, new_flags));
  }
  if (SWIG_IsTmpObj(res5)) {
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_From_int((*arg5)));
  } else {
    int new_flags = SWIG_IsNewObj(res5) ? (SWIG_POINTER_OWN |  0 ) :  0 ;
    _outp = SWIG_Octave_AppendOutput(_outp, SWIG_NewPointerObj((void*)(arg5), SWIGTYPE_p_int, new_flags));
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvNormalizeHist (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvNormalizeHist",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvNormalizeHist" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvNormalizeHist" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      cvNormalizeHist(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvThreshHist (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvThreshHist",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvThreshHist" "', argument " "1"" of type '" "CvHistogram *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvThreshHist" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  {
    try {
      cvThreshHist(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCompareHist (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  CvHistogram *arg2 = (CvHistogram *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvCompareHist",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCompareHist" "', argument " "1"" of type '" "CvHistogram const *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCompareHist" "', argument " "2"" of type '" "CvHistogram const *""'"); 
  }
  arg2 = (CvHistogram *)(argp2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCompareHist" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  {
    try {
      result = (double)cvCompareHist((CvHistogram const *)arg1,(CvHistogram const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCopyHist (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  CvHistogram **arg2 = (CvHistogram **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *vptr2 ;
  CvHistogram *buffer2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCopyHist",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCopyHist" "', argument " "1"" of type '" "CvHistogram const *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_CvHistogram, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (CvHistogram *) vptr2;
    arg2=&buffer2;
  }
  {
    try {
      cvCopyHist((CvHistogram const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcBayesianProb (const octave_value_list& args, int nargout) {
  CvHistogram **arg1 = (CvHistogram **) 0 ;
  int arg2 ;
  CvHistogram **arg3 = (CvHistogram **) 0 ;
  void *vptr1 ;
  CvHistogram *buffer1 ;
  int val2 ;
  int ecode2 = 0 ;
  void *vptr3 ;
  CvHistogram *buffer3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcBayesianProb",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p_CvHistogram, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (CvHistogram *) vptr1;
    arg1=&buffer1;
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCalcBayesianProb" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_CvHistogram, 1)) == -1){
      SWIG_fail;
    }
    buffer3 = (CvHistogram *) vptr3;
    arg3=&buffer3;
  }
  {
    try {
      cvCalcBayesianProb(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcArrHist (const octave_value_list& args, int nargout) {
  CvArr **arg1 = (CvArr **) 0 ;
  CvHistogram *arg2 = (CvHistogram *) 0 ;
  int arg3 = (int) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  CvArr *one_image1 = NULL ;
  bool free_one_arg1 = false ;
  CvArr **many_images1 = NULL ;
  bool *free_many_args1 = NULL ;
  int nimages1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcArrHist",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    // first, check if this is a tuple
    if (OctTuple_Check (args(0))) {
      // This is a tuple, so we need to test each element and pass
      // them to the called function
      
      int i;
      
      // get the size of the tuple
      nimages1 = OctTuple_Size (args(0));
      
      // allocate the necessary place
      many_images1 = (CvArr **)malloc (nimages1 * sizeof (CvArr *));
      free_many_args1 = (bool *)malloc(nimages1 * sizeof(bool));
      
      for (i = 0; i < nimages1; i++) {
        // convert the current tuple element to a CvArr *, and
        // store to many_images1 [i]
        many_images1[i] = OctObject_to_CvArr (OctTuple_GetItem (args(0), i),
          free_many_args1+i);
        
        // check that the current item is a correct type
        if(!many_images1[i]) {
          // incorrect !
          SWIG_fail;
        }
      }
      
      // what to give to the called function
      arg1 = many_images1;
      
    } else if((one_image1 = OctObject_to_CvArr( args(0), &free_one_arg1 ))){
      // this is just one CvArr *, so one_image1 will receive it
      arg1 = &one_image1;
      
    } else {
      // not a CvArr *, not a tuple, this is wrong
      SWIG_fail;
    }
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCalcArrHist" "', argument " "2"" of type '" "CvHistogram *""'"); 
  }
  arg2 = (CvHistogram *)(argp2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCalcArrHist" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvCalcArrHist(arg1,arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(free_one_arg1){
      cvFree(&(one_image1));
    }
    else if(free_many_args1){
      int i;
      for (i=0; i<nimages1; i++){
        if(free_many_args1[i]){
          cvReleaseData(many_images1[i]);
          cvFree(many_images1+i);
        }
      }
      free(many_images1);
      free(free_many_args1);
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcImageHist (const octave_value_list& args, int nargout) {
  IplImage **arg1 = (IplImage **) 0 ;
  CvHistogram *arg2 = (CvHistogram *) 0 ;
  int arg3 = (int) 0 ;
  CvArr *arg4 = (CvArr *) NULL ;
  void *vptr1 ;
  IplImage *buffer1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcImageHist",args.length(),4,2,0)) {
    SWIG_fail;
  }
  {
    if ((SWIG_ConvertPtr(args(0), &vptr1, SWIGTYPE_p__IplImage, 1)) == -1){
      SWIG_fail;
    }
    buffer1 = (IplImage *) vptr1;
    arg1=&buffer1;
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCalcImageHist" "', argument " "2"" of type '" "CvHistogram *""'"); 
  }
  arg2 = (CvHistogram *)(argp2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCalcImageHist" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvArr(args(3), &freearg4);
    }
  }
  {
    try {
      cvCalcHist(arg1,arg2,arg3,(void const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcArrBackProject (const octave_value_list& args, int nargout) {
  CvArr **arg1 = (CvArr **) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvHistogram *arg3 = (CvHistogram *) 0 ;
  CvArr *one_image1 = NULL ;
  bool free_one_arg1 = false ;
  CvArr **many_images1 = NULL ;
  bool *free_many_args1 = NULL ;
  int nimages1 = 0 ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcArrBackProject",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    // first, check if this is a tuple
    if (OctTuple_Check (args(0))) {
      // This is a tuple, so we need to test each element and pass
      // them to the called function
      
      int i;
      
      // get the size of the tuple
      nimages1 = OctTuple_Size (args(0));
      
      // allocate the necessary place
      many_images1 = (CvArr **)malloc (nimages1 * sizeof (CvArr *));
      free_many_args1 = (bool *)malloc(nimages1 * sizeof(bool));
      
      for (i = 0; i < nimages1; i++) {
        // convert the current tuple element to a CvArr *, and
        // store to many_images1 [i]
        many_images1[i] = OctObject_to_CvArr (OctTuple_GetItem (args(0), i),
          free_many_args1+i);
        
        // check that the current item is a correct type
        if(!many_images1[i]) {
          // incorrect !
          SWIG_fail;
        }
      }
      
      // what to give to the called function
      arg1 = many_images1;
      
    } else if((one_image1 = OctObject_to_CvArr( args(0), &free_one_arg1 ))){
      // this is just one CvArr *, so one_image1 will receive it
      arg1 = &one_image1;
      
    } else {
      // not a CvArr *, not a tuple, this is wrong
      SWIG_fail;
    }
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCalcArrBackProject" "', argument " "3"" of type '" "CvHistogram const *""'"); 
  }
  arg3 = (CvHistogram *)(argp3);
  {
    try {
      cvCalcArrBackProject(arg1,arg2,(CvHistogram const *)arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(free_one_arg1){
      cvFree(&(one_image1));
    }
    else if(free_many_args1){
      int i;
      for (i=0; i<nimages1; i++){
        if(free_many_args1[i]){
          cvReleaseData(many_images1[i]);
          cvFree(many_images1+i);
        }
      }
      free(many_images1);
      free(free_many_args1);
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcArrBackProjectPatch (const octave_value_list& args, int nargout) {
  CvArr **arg1 = (CvArr **) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvSize arg3 ;
  CvHistogram *arg4 = (CvHistogram *) 0 ;
  int arg5 ;
  double arg6 ;
  CvArr *one_image1 = NULL ;
  bool free_one_arg1 = false ;
  CvArr **many_images1 = NULL ;
  bool *free_many_args1 = NULL ;
  int nimages1 = 0 ;
  bool freearg2 = false ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcArrBackProjectPatch",args.length(),6,6,0)) {
    SWIG_fail;
  }
  {
    // first, check if this is a tuple
    if (OctTuple_Check (args(0))) {
      // This is a tuple, so we need to test each element and pass
      // them to the called function
      
      int i;
      
      // get the size of the tuple
      nimages1 = OctTuple_Size (args(0));
      
      // allocate the necessary place
      many_images1 = (CvArr **)malloc (nimages1 * sizeof (CvArr *));
      free_many_args1 = (bool *)malloc(nimages1 * sizeof(bool));
      
      for (i = 0; i < nimages1; i++) {
        // convert the current tuple element to a CvArr *, and
        // store to many_images1 [i]
        many_images1[i] = OctObject_to_CvArr (OctTuple_GetItem (args(0), i),
          free_many_args1+i);
        
        // check that the current item is a correct type
        if(!many_images1[i]) {
          // incorrect !
          SWIG_fail;
        }
      }
      
      // what to give to the called function
      arg1 = many_images1;
      
    } else if((one_image1 = OctObject_to_CvArr( args(0), &free_one_arg1 ))){
      // this is just one CvArr *, so one_image1 will receive it
      arg1 = &one_image1;
      
    } else {
      // not a CvArr *, not a tuple, this is wrong
      SWIG_fail;
    }
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCalcArrBackProjectPatch" "', argument " "3"" of type '" "CvSize""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalcArrBackProjectPatch" "', argument " "3"" of type '" "CvSize""'");
    } else {
      arg3 = *((CvSize *)(argp3));
    }
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCalcArrBackProjectPatch" "', argument " "4"" of type '" "CvHistogram *""'"); 
  }
  arg4 = (CvHistogram *)(argp4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCalcArrBackProjectPatch" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_double(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvCalcArrBackProjectPatch" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  {
    try {
      cvCalcArrBackProjectPatch(arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(free_one_arg1){
      cvFree(&(one_image1));
    }
    else if(free_many_args1){
      int i;
      for (i=0; i<nimages1; i++){
        if(free_many_args1[i]){
          cvReleaseData(many_images1[i]);
          cvFree(many_images1+i);
        }
      }
      free(many_images1);
      free(free_many_args1);
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcProbDensity (const octave_value_list& args, int nargout) {
  CvHistogram *arg1 = (CvHistogram *) 0 ;
  CvHistogram *arg2 = (CvHistogram *) 0 ;
  CvHistogram *arg3 = (CvHistogram *) 0 ;
  double arg4 = (double) 255 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcProbDensity",args.length(),4,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCalcProbDensity" "', argument " "1"" of type '" "CvHistogram const *""'"); 
  }
  arg1 = (CvHistogram *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCalcProbDensity" "', argument " "2"" of type '" "CvHistogram const *""'"); 
  }
  arg2 = (CvHistogram *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvHistogram, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCalcProbDensity" "', argument " "3"" of type '" "CvHistogram *""'"); 
  }
  arg3 = (CvHistogram *)(argp3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCalcProbDensity" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  {
    try {
      cvCalcProbDensity((CvHistogram const *)arg1,(CvHistogram const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvEqualizeHist (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvEqualizeHist",args.length(),2,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    try {
      cvEqualizeHist((void const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcImageHomography (const octave_value_list& args, int nargout) {
  float *arg1 = (float *) 0 ;
  CvPoint3D32f *arg2 = (CvPoint3D32f *) 0 ;
  float *arg3 = (float *) 0 ;
  float *arg4 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcImageHomography",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCalcImageHomography" "', argument " "1"" of type '" "float *""'"); 
  }
  arg1 = (float *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint3D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCalcImageHomography" "', argument " "2"" of type '" "CvPoint3D32f *""'"); 
  }
  arg2 = (CvPoint3D32f *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCalcImageHomography" "', argument " "3"" of type '" "float *""'"); 
  }
  arg3 = (float *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCalcImageHomography" "', argument " "4"" of type '" "float *""'"); 
  }
  arg4 = (float *)(argp4);
  {
    try {
      cvCalcImageHomography(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvDistTransform (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 = (int) 2 ;
  int arg4 = (int) 3 ;
  float *arg5 = (float *) NULL ;
  CvArr *arg6 = (CvArr *) NULL ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool freearg6 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvDistTransform",args.length(),6,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvDistTransform" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvDistTransform" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_float, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvDistTransform" "', argument " "5"" of type '" "float const *""'"); 
    }
    arg5 = (float *)(argp5);
  }
  if (5<args.length()) {
    {
      arg6 = OctObject_to_CvArr(args(5), &freearg6);
    }
  }
  {
    try {
      cvDistTransform((void const *)arg1,arg2,arg3,arg4,(float const *)arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg6!=NULL && freearg6){
      cvReleaseData( arg6 );
      cvFree(&(arg6));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvThreshold (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 ;
  double arg4 ;
  int arg5 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("cvThreshold",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvThreshold" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvThreshold" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvThreshold" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    try {
      result = (double)cvThreshold((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvAdaptiveThreshold (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 ;
  int arg4 = (int) 0 ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 3 ;
  double arg7 = (double) 5 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvAdaptiveThreshold",args.length(),7,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvAdaptiveThreshold" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvAdaptiveThreshold" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvAdaptiveThreshold" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvAdaptiveThreshold" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_double(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvAdaptiveThreshold" "', argument " "7"" of type '" "double""'");
    } 
    arg7 = (double)(val7);
  }
  {
    try {
      cvAdaptiveThreshold((void const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFloodFill (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint arg2 ;
  CvScalar arg3 ;
  CvScalar arg4 = (CvScalar) cvScalarAll(0) ;
  CvScalar arg5 = (CvScalar) cvScalarAll(0) ;
  CvConnectedComp *arg6 = (CvConnectedComp *) NULL ;
  int arg7 = (int) 4 ;
  CvArr *arg8 = (CvArr *) NULL ;
  bool freearg1 = false ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  bool freearg8 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFloodFill",args.length(),8,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvPoint(args(1));
  }
  {
    arg3 = OctObject_to_CvScalar( args(2) );
  }
  if (3<args.length()) {
    {
      arg4 = OctObject_to_CvScalar( args(3) );
    }
  }
  if (4<args.length()) {
    {
      arg5 = OctObject_to_CvScalar( args(4) );
    }
  }
  if (5<args.length()) {
    res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvFloodFill" "', argument " "6"" of type '" "CvConnectedComp *""'"); 
    }
    arg6 = (CvConnectedComp *)(argp6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvFloodFill" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  if (7<args.length()) {
    {
      arg8 = OctObject_to_CvArr(args(7), &freearg8);
    }
  }
  {
    try {
      cvFloodFill(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg8!=NULL && freearg8){
      cvReleaseData( arg8 );
      cvFree(&(arg8));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCanny (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  double arg3 ;
  double arg4 ;
  int arg5 = (int) 3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCanny",args.length(),5,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCanny" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCanny" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCanny" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      cvCanny((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvPreCornerDetect (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 = (int) 3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvPreCornerDetect",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPreCornerDetect" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      cvPreCornerDetect((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCornerEigenValsAndVecs (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  int arg4 = (int) 3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCornerEigenValsAndVecs",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCornerEigenValsAndVecs" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCornerEigenValsAndVecs" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvCornerEigenValsAndVecs((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCornerMinEigenVal (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  int arg4 = (int) 3 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCornerMinEigenVal",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCornerMinEigenVal" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCornerMinEigenVal" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvCornerMinEigenVal((void const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCornerHarris (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  int arg3 ;
  int arg4 = (int) 3 ;
  double arg5 = (double) 0.04 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCornerHarris",args.length(),5,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCornerHarris" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCornerHarris" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_double(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCornerHarris" "', argument " "5"" of type '" "double""'");
    } 
    arg5 = (double)(val5);
  }
  {
    try {
      cvCornerHarris((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFindCornerSubPix (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  int arg3 ;
  CvSize arg4 ;
  CvSize arg5 ;
  CvTermCriteria arg6 ;
  bool freearg1 = false ;
  int cornersCount2 ;
  CvPoint2D32f *corners2 ;
  void *argp4 ;
  int res4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFindCornerSubPix",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    int i;
    
    if(!OctList_Check(args(1))){
      error("Expected a list");
      SWIG_fail;
    }
    
    // get the size of the input array
    cornersCount2 = OctList_Size (args(1));
    arg3 = cornersCount2;
    
    // allocate the needed memory
    corners2 = (CvPoint2D32f *)malloc (arg3 * sizeof (CvPoint2D32f));
    arg2 = corners2;
    
    // the size of the array for the C call
    
    // extract all the points values from the list
    for (i = 0; i < arg3; i++) {
      octave_value item = OctList_GetItem (args(1), i);
      
      void *vptr;
      SWIG_Octave_ConvertPtr (item, &vptr,
        SWIGTYPE_p_CvPoint2D32f,
        SWIG_POINTER_EXCEPTION);
      CvPoint2D32f *p = (CvPoint2D32f *) vptr;;
      arg2 [i].x = p->x;
      arg2 [i].y = p->y;
    }
  }
  {
    res4 = SWIG_ConvertPtr(args(2), &argp4, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvFindCornerSubPix" "', argument " "4"" of type '" "CvSize""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvFindCornerSubPix" "', argument " "4"" of type '" "CvSize""'");
    } else {
      arg4 = *((CvSize *)(argp4));
    }
  }
  {
    res5 = SWIG_ConvertPtr(args(3), &argp5, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvFindCornerSubPix" "', argument " "5"" of type '" "CvSize""'"); 
    }  
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvFindCornerSubPix" "', argument " "5"" of type '" "CvSize""'");
    } else {
      arg5 = *((CvSize *)(argp5));
    }
  }
  {
    res6 = SWIG_ConvertPtr(args(4), &argp6, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvFindCornerSubPix" "', argument " "6"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvFindCornerSubPix" "', argument " "6"" of type '" "CvTermCriteria""'");
    } else {
      arg6 = *((CvTermCriteria *)(argp6));
    }
  }
  {
    try {
      cvFindCornerSubPix((void const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    int i;
    octave_value to_add;
    
    // create the list to return
    to_add = OctList_New (cornersCount2);
    
    // extract all the corner values of the result, and add it to the
    // final resulting list
    for (i = 0; i < cornersCount2; i++) {
      OctList_SetItem (to_add, i,
        SWIG_NewPointerObj (&(corners2 [i]),
          SWIGTYPE_p_CvPoint2D32f, 0));
    }
    
    _outp = SWIG_AppendResult( _outp, &to_add, 1);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvGoodFeaturesToTrack (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvPoint2D32f *arg4 = (CvPoint2D32f *) 0 ;
  int *arg5 = (int *) 0 ;
  double arg6 ;
  double arg7 ;
  CvArr *arg8 = (CvArr *) NULL ;
  int arg9 = (int) 3 ;
  int arg10 = (int) 0 ;
  double arg11 = (double) 0.04 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  int tmpCount4 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  bool freearg8 = false ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  double val11 ;
  int ecode11 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvGoodFeaturesToTrack",args.length(),10,6,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    // as input, we still need the size of the corners array
    
    // memorize the size of the status corners
    tmpCount4 = (int)OctInt_AsLong (args(3));
    
    // create the corners array for the C call
    arg4 = (CvPoint2D32f *)malloc (tmpCount4 * sizeof (CvPoint2D32f));
    
    // the size of the array for the C call
    arg5 = &tmpCount4;
  }
  ecode6 = SWIG_AsVal_double(args(4), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvGoodFeaturesToTrack" "', argument " "6"" of type '" "double""'");
  } 
  arg6 = (double)(val6);
  ecode7 = SWIG_AsVal_double(args(5), &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvGoodFeaturesToTrack" "', argument " "7"" of type '" "double""'");
  } 
  arg7 = (double)(val7);
  if (6<args.length()) {
    {
      arg8 = OctObject_to_CvArr(args(6), &freearg8);
    }
  }
  if (7<args.length()) {
    ecode9 = SWIG_AsVal_int(args(7), &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cvGoodFeaturesToTrack" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  if (8<args.length()) {
    ecode10 = SWIG_AsVal_int(args(8), &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "cvGoodFeaturesToTrack" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = (int)(val10);
  }
  if (9<args.length()) {
    ecode11 = SWIG_AsVal_double(args(9), &val11);
    if (!SWIG_IsOK(ecode11)) {
      SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "cvGoodFeaturesToTrack" "', argument " "11"" of type '" "double""'");
    } 
    arg11 = (double)(val11);
  }
  {
    try {
      cvGoodFeaturesToTrack((void const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,(void const *)arg8,arg9,arg10,arg11); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    int i;
    octave_value to_add;
    
    // create the list to return
    to_add = OctList_New (tmpCount4);
    
    // extract all the integer values of the result, and add it to the
    // final resulting list
    for (i = 0; i < tmpCount4; i++) {
      OctList_SetItem (to_add, i,
        SWIG_NewPointerObj (&(arg4 [i]),
          SWIGTYPE_p_CvPoint2D32f, 0));
    }
    
    _outp = SWIG_AppendResult(_outp, &to_add, 1);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg8!=NULL && freearg8){
      cvReleaseData( arg8 );
      cvFree(&(arg8));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvHoughLinesUntyped (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  void *arg2 = (void *) 0 ;
  int arg3 ;
  double arg4 ;
  double arg5 ;
  int arg6 ;
  double arg7 = (double) 0 ;
  double arg8 = (double) 0 ;
  bool freearg1 = false ;
  int res2 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvHoughLinesUntyped",args.length(),8,6,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvHoughLinesUntyped" "', argument " "2"" of type '" "void *""'"); 
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvHoughLinesUntyped" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvHoughLinesUntyped" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvHoughLinesUntyped" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  ecode6 = SWIG_AsVal_int(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvHoughLinesUntyped" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_double(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvHoughLinesUntyped" "', argument " "7"" of type '" "double""'");
    } 
    arg7 = (double)(val7);
  }
  if (7<args.length()) {
    ecode8 = SWIG_AsVal_double(args(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cvHoughLinesUntyped" "', argument " "8"" of type '" "double""'");
    } 
    arg8 = (double)(val8);
  }
  {
    try {
      result = (CvSeq *)cvHoughLines2(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvHoughCirclesUntyped (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  void *arg2 = (void *) 0 ;
  int arg3 ;
  double arg4 ;
  double arg5 ;
  double arg6 = (double) 100 ;
  double arg7 = (double) 100 ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 0 ;
  bool freearg1 = false ;
  int res2 ;
  int val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvHoughCirclesUntyped",args.length(),9,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1),SWIG_as_voidptrptr(&arg2), 0, 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvHoughCirclesUntyped" "', argument " "2"" of type '" "void *""'"); 
  }
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvHoughCirclesUntyped" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvHoughCirclesUntyped" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvHoughCirclesUntyped" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_double(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvHoughCirclesUntyped" "', argument " "6"" of type '" "double""'");
    } 
    arg6 = (double)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_double(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvHoughCirclesUntyped" "', argument " "7"" of type '" "double""'");
    } 
    arg7 = (double)(val7);
  }
  if (7<args.length()) {
    ecode8 = SWIG_AsVal_int(args(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cvHoughCirclesUntyped" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = (int)(val8);
  }
  if (8<args.length()) {
    ecode9 = SWIG_AsVal_int(args(8), &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cvHoughCirclesUntyped" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  {
    try {
      result = (CvSeq *)cvHoughCircles(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvFitLine (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  int arg2 ;
  double arg3 ;
  double arg4 ;
  double arg5 ;
  float *arg6 = (float *) 0 ;
  bool freearg1 = false ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFitLine",args.length(),6,6,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvFitLine" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvFitLine" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  ecode4 = SWIG_AsVal_double(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvFitLine" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = (double)(val4);
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvFitLine" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvFitLine" "', argument " "6"" of type '" "float *""'"); 
  }
  arg6 = (float *)(argp6);
  {
    try {
      cvFitLine((void const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateKDTree (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFeatureTree *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateKDTree",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCreateKDTree" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    try {
      result = (CvFeatureTree *)cvCreateKDTree(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvFeatureTree, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateSpillTree (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 = (int) (int)50 ;
  double arg3 = (double) (double).7 ;
  double arg4 = (double) (double).1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvFeatureTree *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateSpillTree",args.length(),4,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCreateSpillTree" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateSpillTree" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_double(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateSpillTree" "', argument " "3"" of type '" "double""'");
    } 
    arg3 = (double)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCreateSpillTree" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  {
    try {
      result = (CvFeatureTree *)cvCreateSpillTree((CvMat const *)arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvFeatureTree, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseFeatureTree (const octave_value_list& args, int nargout) {
  CvFeatureTree *arg1 = (CvFeatureTree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseFeatureTree",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFeatureTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseFeatureTree" "', argument " "1"" of type '" "CvFeatureTree *""'"); 
  }
  arg1 = (CvFeatureTree *)(argp1);
  {
    try {
      cvReleaseFeatureTree(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindFeatures (const octave_value_list& args, int nargout) {
  CvFeatureTree *arg1 = (CvFeatureTree *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  int arg5 ;
  int arg6 = (int) 20 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFindFeatures",args.length(),6,5,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFeatureTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFindFeatures" "', argument " "1"" of type '" "CvFeatureTree *""'"); 
  }
  arg1 = (CvFeatureTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvFindFeatures" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvFindFeatures" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvFindFeatures" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvFindFeatures" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvFindFeatures" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      cvFindFeatures(arg1,(CvMat const *)arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindFeaturesBoxed (const octave_value_list& args, int nargout) {
  CvFeatureTree *arg1 = (CvFeatureTree *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvFindFeaturesBoxed",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvFeatureTree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFindFeaturesBoxed" "', argument " "1"" of type '" "CvFeatureTree *""'"); 
  }
  arg1 = (CvFeatureTree *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvFindFeaturesBoxed" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvFindFeaturesBoxed" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvFindFeaturesBoxed" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  {
    try {
      result = (int)cvFindFeaturesBoxed(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateLSH (const octave_value_list& args, int nargout) {
  CvLSHOperations *arg1 = (CvLSHOperations *) 0 ;
  int arg2 ;
  int arg3 = (int) 10 ;
  int arg4 = (int) 10 ;
  int arg5 = (int) (((6) &((1 << 3) -1)) +(((1) -1) << 3)) ;
  double arg6 = (double) 4 ;
  int64 arg7 = (int64) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  void *argp7 ;
  int res7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvLSH *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateLSH",args.length(),7,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLSHOperations, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCreateLSH" "', argument " "1"" of type '" "CvLSHOperations *""'"); 
  }
  arg1 = (CvLSHOperations *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateLSH" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateLSH" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCreateLSH" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCreateLSH" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_double(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvCreateLSH" "', argument " "6"" of type '" "double""'");
    } 
    arg6 = (double)(val6);
  }
  if (6<args.length()) {
    {
      res7 = SWIG_ConvertPtr(args(6), &argp7, SWIGTYPE_p_int64_t,  0 );
      if (!SWIG_IsOK(res7)) {
        SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvCreateLSH" "', argument " "7"" of type '" "int64""'"); 
      }  
      if (!argp7) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCreateLSH" "', argument " "7"" of type '" "int64""'");
      } else {
        arg7 = *((int64 *)(argp7));
      }
    }
  }
  {
    try {
      result = (CvLSH *)cvCreateLSH(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvLSH, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreateMemoryLSH (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int arg3 = (int) 10 ;
  int arg4 = (int) 10 ;
  int arg5 = (int) (((6) &((1 << 3) -1)) +(((1) -1) << 3)) ;
  double arg6 = (double) 4 ;
  int64 arg7 = (int64) -1 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  void *argp7 ;
  int res7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvLSH *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateMemoryLSH",args.length(),7,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateMemoryLSH" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateMemoryLSH" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCreateMemoryLSH" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCreateMemoryLSH" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvCreateMemoryLSH" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_double(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvCreateMemoryLSH" "', argument " "6"" of type '" "double""'");
    } 
    arg6 = (double)(val6);
  }
  if (6<args.length()) {
    {
      res7 = SWIG_ConvertPtr(args(6), &argp7, SWIGTYPE_p_int64_t,  0 );
      if (!SWIG_IsOK(res7)) {
        SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvCreateMemoryLSH" "', argument " "7"" of type '" "int64""'"); 
      }  
      if (!argp7) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCreateMemoryLSH" "', argument " "7"" of type '" "int64""'");
      } else {
        arg7 = *((int64 *)(argp7));
      }
    }
  }
  {
    try {
      result = (CvLSH *)cvCreateMemoryLSH(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvLSH, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseLSH (const octave_value_list& args, int nargout) {
  CvLSH **arg1 = (CvLSH **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseLSH",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvLSH, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseLSH" "', argument " "1"" of type '" "CvLSH **""'"); 
  }
  arg1 = (CvLSH **)(argp1);
  {
    try {
      cvReleaseLSH(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_LSHSize (const octave_value_list& args, int nargout) {
  CvLSH *arg1 = (CvLSH *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  unsigned int result;
  
  if (!SWIG_check_num_args("LSHSize",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLSH, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LSHSize" "', argument " "1"" of type '" "CvLSH *""'"); 
  }
  arg1 = (CvLSH *)(argp1);
  {
    try {
      result = (unsigned int)LSHSize(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_unsigned_SS_int((unsigned int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvLSHAdd (const octave_value_list& args, int nargout) {
  CvLSH *arg1 = (CvLSH *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvLSHAdd",args.length(),3,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLSH, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvLSHAdd" "', argument " "1"" of type '" "CvLSH *""'"); 
  }
  arg1 = (CvLSH *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvLSHAdd" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvLSHAdd" "', argument " "3"" of type '" "CvMat *""'"); 
    }
    arg3 = (CvMat *)(argp3);
  }
  {
    try {
      cvLSHAdd(arg1,(CvMat const *)arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvLSHRemove (const octave_value_list& args, int nargout) {
  CvLSH *arg1 = (CvLSH *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvLSHRemove",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLSH, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvLSHRemove" "', argument " "1"" of type '" "CvLSH *""'"); 
  }
  arg1 = (CvLSH *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvLSHRemove" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  {
    try {
      cvLSHRemove(arg1,(CvMat const *)arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvLSHQuery (const octave_value_list& args, int nargout) {
  CvLSH *arg1 = (CvLSH *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  int arg5 ;
  int arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvLSHQuery",args.length(),6,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLSH, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvLSHQuery" "', argument " "1"" of type '" "CvLSH *""'"); 
  }
  arg1 = (CvLSH *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvLSHQuery" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvLSHQuery" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvLSHQuery" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  ecode5 = SWIG_AsVal_int(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvLSHQuery" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  ecode6 = SWIG_AsVal_int(args(5), &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvLSHQuery" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = (int)(val6);
  {
    try {
      cvLSHQuery(arg1,(CvMat const *)arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFPoint_pt_set (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSURFPoint_pt_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFPoint_pt_set" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSURFPoint_pt_set" "', argument " "2"" of type '" "CvPoint2D32f *""'"); 
  }
  arg2 = (CvPoint2D32f *)(argp2);
  if (arg1) (arg1)->pt = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFPoint_pt_get (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("CvSURFPoint_pt_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFPoint_pt_get" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  result = (CvPoint2D32f *)& ((arg1)->pt);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFPoint_laplacian_set (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSURFPoint_laplacian_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFPoint_laplacian_set" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSURFPoint_laplacian_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->laplacian = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFPoint_laplacian_get (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSURFPoint_laplacian_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFPoint_laplacian_get" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  result = (int) ((arg1)->laplacian);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFPoint_size_set (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSURFPoint_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFPoint_size_set" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSURFPoint_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFPoint_size_get (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSURFPoint_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFPoint_size_get" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  result = (int) ((arg1)->size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFPoint_dir_set (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSURFPoint_dir_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFPoint_dir_set" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSURFPoint_dir_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->dir = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFPoint_dir_get (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvSURFPoint_dir_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFPoint_dir_get" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  result = (float) ((arg1)->dir);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFPoint_hessian_set (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSURFPoint_hessian_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFPoint_hessian_set" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSURFPoint_hessian_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->hessian = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFPoint_hessian_get (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvSURFPoint_hessian_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFPoint_hessian_get" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  result = (float) ((arg1)->hessian);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSURFPoint (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSURFPoint *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSURFPoint",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSURFPoint *)new CvSURFPoint(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSURFPoint, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSURFPoint (const octave_value_list& args, int nargout) {
  CvSURFPoint *arg1 = (CvSURFPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSURFPoint",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFPoint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSURFPoint" "', argument " "1"" of type '" "CvSURFPoint *""'"); 
  }
  arg1 = (CvSURFPoint *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSURFPoint_members[] = {
{"pt",0,_wrap_CvSURFPoint_pt_get,_wrap_CvSURFPoint_pt_set,0,0},
{"laplacian",0,_wrap_CvSURFPoint_laplacian_get,_wrap_CvSURFPoint_laplacian_set,0,0},
{"size",0,_wrap_CvSURFPoint_size_get,_wrap_CvSURFPoint_size_set,0,0},
{"dir",0,_wrap_CvSURFPoint_dir_get,_wrap_CvSURFPoint_dir_set,0,0},
{"hessian",0,_wrap_CvSURFPoint_hessian_get,_wrap_CvSURFPoint_hessian_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSURFPoint_base_names[] = {0};
static const swig_type_info *swig_CvSURFPoint_base[] = {0};
static swig_octave_class _wrap_class_CvSURFPoint = {"CvSURFPoint", &SWIGTYPE_p_CvSURFPoint,0,_wrap_new_CvSURFPoint,0,_wrap_delete_CvSURFPoint,swig_CvSURFPoint_members,swig_CvSURFPoint_base_names,swig_CvSURFPoint_base };

static octave_value_list _wrap_cvSURFPoint (const octave_value_list& args, int nargout) {
  CvPoint2D32f arg1 ;
  int arg2 ;
  int arg3 ;
  float arg4 = (float) 0 ;
  float arg5 = (float) 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSURFPoint result;
  
  if (!SWIG_check_num_args("cvSURFPoint",args.length(),5,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint2D32f(args(0));
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSURFPoint" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvSURFPoint" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_float(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvSURFPoint" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_float(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvSURFPoint" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  {
    try {
      result = cvSURFPoint(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvSURFPoint((const CvSURFPoint&)(result))), SWIGTYPE_p_CvSURFPoint, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFParams_extended_set (const octave_value_list& args, int nargout) {
  CvSURFParams *arg1 = (CvSURFParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSURFParams_extended_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFParams_extended_set" "', argument " "1"" of type '" "CvSURFParams *""'"); 
  }
  arg1 = (CvSURFParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSURFParams_extended_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->extended = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFParams_extended_get (const octave_value_list& args, int nargout) {
  CvSURFParams *arg1 = (CvSURFParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSURFParams_extended_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFParams_extended_get" "', argument " "1"" of type '" "CvSURFParams *""'"); 
  }
  arg1 = (CvSURFParams *)(argp1);
  result = (int) ((arg1)->extended);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFParams_hessianThreshold_set (const octave_value_list& args, int nargout) {
  CvSURFParams *arg1 = (CvSURFParams *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSURFParams_hessianThreshold_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFParams_hessianThreshold_set" "', argument " "1"" of type '" "CvSURFParams *""'"); 
  }
  arg1 = (CvSURFParams *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSURFParams_hessianThreshold_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->hessianThreshold = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFParams_hessianThreshold_get (const octave_value_list& args, int nargout) {
  CvSURFParams *arg1 = (CvSURFParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvSURFParams_hessianThreshold_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFParams_hessianThreshold_get" "', argument " "1"" of type '" "CvSURFParams *""'"); 
  }
  arg1 = (CvSURFParams *)(argp1);
  result = (double) ((arg1)->hessianThreshold);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFParams_nOctaves_set (const octave_value_list& args, int nargout) {
  CvSURFParams *arg1 = (CvSURFParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSURFParams_nOctaves_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFParams_nOctaves_set" "', argument " "1"" of type '" "CvSURFParams *""'"); 
  }
  arg1 = (CvSURFParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSURFParams_nOctaves_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nOctaves = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFParams_nOctaves_get (const octave_value_list& args, int nargout) {
  CvSURFParams *arg1 = (CvSURFParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSURFParams_nOctaves_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFParams_nOctaves_get" "', argument " "1"" of type '" "CvSURFParams *""'"); 
  }
  arg1 = (CvSURFParams *)(argp1);
  result = (int) ((arg1)->nOctaves);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFParams_nOctaveLayers_set (const octave_value_list& args, int nargout) {
  CvSURFParams *arg1 = (CvSURFParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSURFParams_nOctaveLayers_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFParams_nOctaveLayers_set" "', argument " "1"" of type '" "CvSURFParams *""'"); 
  }
  arg1 = (CvSURFParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSURFParams_nOctaveLayers_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->nOctaveLayers = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSURFParams_nOctaveLayers_get (const octave_value_list& args, int nargout) {
  CvSURFParams *arg1 = (CvSURFParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvSURFParams_nOctaveLayers_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSURFParams_nOctaveLayers_get" "', argument " "1"" of type '" "CvSURFParams *""'"); 
  }
  arg1 = (CvSURFParams *)(argp1);
  result = (int) ((arg1)->nOctaveLayers);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSURFParams (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSURFParams *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSURFParams",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvSURFParams *)new CvSURFParams(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSURFParams, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSURFParams (const octave_value_list& args, int nargout) {
  CvSURFParams *arg1 = (CvSURFParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSURFParams",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvSURFParams, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSURFParams" "', argument " "1"" of type '" "CvSURFParams *""'"); 
  }
  arg1 = (CvSURFParams *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSURFParams_members[] = {
{"extended",0,_wrap_CvSURFParams_extended_get,_wrap_CvSURFParams_extended_set,0,0},
{"hessianThreshold",0,_wrap_CvSURFParams_hessianThreshold_get,_wrap_CvSURFParams_hessianThreshold_set,0,0},
{"nOctaves",0,_wrap_CvSURFParams_nOctaves_get,_wrap_CvSURFParams_nOctaves_set,0,0},
{"nOctaveLayers",0,_wrap_CvSURFParams_nOctaveLayers_get,_wrap_CvSURFParams_nOctaveLayers_set,0,0},
{0,0,0,0}
};
static const char *swig_CvSURFParams_base_names[] = {0};
static const swig_type_info *swig_CvSURFParams_base[] = {0};
static swig_octave_class _wrap_class_CvSURFParams = {"CvSURFParams", &SWIGTYPE_p_CvSURFParams,0,_wrap_new_CvSURFParams,0,_wrap_delete_CvSURFParams,swig_CvSURFParams_members,swig_CvSURFParams_base_names,swig_CvSURFParams_base };

static octave_value_list _wrap_cvSURFParams (const octave_value_list& args, int nargout) {
  double arg1 ;
  int arg2 = (int) 0 ;
  double val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSURFParams result;
  
  if (!SWIG_check_num_args("cvSURFParams",args.length(),2,1,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvSURFParams" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvSURFParams" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    try {
      result = cvSURFParams(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvSURFParams((const CvSURFParams&)(result))), SWIGTYPE_p_CvSURFParams, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvExtractSURF (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvSeq **arg3 = (CvSeq **) 0 ;
  CvSeq **arg4 = (CvSeq **) 0 ;
  CvMemStorage *arg5 = (CvMemStorage *) 0 ;
  CvSURFParams arg6 ;
  int arg7 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *vptr3 ;
  CvSeq *buffer3 ;
  void *vptr4 ;
  CvSeq *buffer4 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvExtractSURF",args.length(),7,6,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_CvSeq, 1)) == -1){
      SWIG_fail;
    }
    buffer3 = (CvSeq *) vptr3;
    arg3=&buffer3;
  }
  {
    if ((SWIG_ConvertPtr(args(3), &vptr4, SWIGTYPE_p_CvSeq, 1)) == -1){
      SWIG_fail;
    }
    buffer4 = (CvSeq *) vptr4;
    arg4=&buffer4;
  }
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvExtractSURF" "', argument " "5"" of type '" "CvMemStorage *""'"); 
  }
  arg5 = (CvMemStorage *)(argp5);
  {
    res6 = SWIG_ConvertPtr(args(5), &argp6, SWIGTYPE_p_CvSURFParams,  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvExtractSURF" "', argument " "6"" of type '" "CvSURFParams""'"); 
    }  
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvExtractSURF" "', argument " "6"" of type '" "CvSURFParams""'");
    } else {
      arg6 = *((CvSURFParams *)(argp6));
    }
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvExtractSURF" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    try {
      cvExtractSURF((void const *)arg1,(void const *)arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_delta_set (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMSERParams_delta_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_delta_set" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMSERParams_delta_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->delta = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_delta_get (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMSERParams_delta_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_delta_get" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  result = (int) ((arg1)->delta);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_maxArea_set (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMSERParams_maxArea_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_maxArea_set" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMSERParams_maxArea_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->maxArea = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_maxArea_get (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMSERParams_maxArea_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_maxArea_get" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  result = (int) ((arg1)->maxArea);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_minArea_set (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMSERParams_minArea_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_minArea_set" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMSERParams_minArea_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->minArea = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_minArea_get (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMSERParams_minArea_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_minArea_get" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  result = (int) ((arg1)->minArea);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_maxVariation_set (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMSERParams_maxVariation_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_maxVariation_set" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMSERParams_maxVariation_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->maxVariation = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_maxVariation_get (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvMSERParams_maxVariation_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_maxVariation_get" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  result = (float) ((arg1)->maxVariation);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_minDiversity_set (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMSERParams_minDiversity_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_minDiversity_set" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMSERParams_minDiversity_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->minDiversity = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_minDiversity_get (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvMSERParams_minDiversity_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_minDiversity_get" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  result = (float) ((arg1)->minDiversity);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_maxEvolution_set (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMSERParams_maxEvolution_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_maxEvolution_set" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMSERParams_maxEvolution_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->maxEvolution = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_maxEvolution_get (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMSERParams_maxEvolution_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_maxEvolution_get" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  result = (int) ((arg1)->maxEvolution);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_areaThreshold_set (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMSERParams_areaThreshold_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_areaThreshold_set" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMSERParams_areaThreshold_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->areaThreshold = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_areaThreshold_get (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMSERParams_areaThreshold_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_areaThreshold_get" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  result = (double) ((arg1)->areaThreshold);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_minMargin_set (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMSERParams_minMargin_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_minMargin_set" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMSERParams_minMargin_set" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  if (arg1) (arg1)->minMargin = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_minMargin_get (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  double result;
  
  if (!SWIG_check_num_args("CvMSERParams_minMargin_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_minMargin_get" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  result = (double) ((arg1)->minMargin);
  _outv = SWIG_From_double((double)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_edgeBlurSize_set (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvMSERParams_edgeBlurSize_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_edgeBlurSize_set" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvMSERParams_edgeBlurSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->edgeBlurSize = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvMSERParams_edgeBlurSize_get (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvMSERParams_edgeBlurSize_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvMSERParams_edgeBlurSize_get" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  result = (int) ((arg1)->edgeBlurSize);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvMSERParams (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMSERParams *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvMSERParams",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvMSERParams *)new CvMSERParams(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMSERParams, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvMSERParams (const octave_value_list& args, int nargout) {
  CvMSERParams *arg1 = (CvMSERParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvMSERParams",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMSERParams, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvMSERParams" "', argument " "1"" of type '" "CvMSERParams *""'"); 
  }
  arg1 = (CvMSERParams *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvMSERParams_members[] = {
{"delta",0,_wrap_CvMSERParams_delta_get,_wrap_CvMSERParams_delta_set,0,0},
{"maxArea",0,_wrap_CvMSERParams_maxArea_get,_wrap_CvMSERParams_maxArea_set,0,0},
{"minArea",0,_wrap_CvMSERParams_minArea_get,_wrap_CvMSERParams_minArea_set,0,0},
{"maxVariation",0,_wrap_CvMSERParams_maxVariation_get,_wrap_CvMSERParams_maxVariation_set,0,0},
{"minDiversity",0,_wrap_CvMSERParams_minDiversity_get,_wrap_CvMSERParams_minDiversity_set,0,0},
{"maxEvolution",0,_wrap_CvMSERParams_maxEvolution_get,_wrap_CvMSERParams_maxEvolution_set,0,0},
{"areaThreshold",0,_wrap_CvMSERParams_areaThreshold_get,_wrap_CvMSERParams_areaThreshold_set,0,0},
{"minMargin",0,_wrap_CvMSERParams_minMargin_get,_wrap_CvMSERParams_minMargin_set,0,0},
{"edgeBlurSize",0,_wrap_CvMSERParams_edgeBlurSize_get,_wrap_CvMSERParams_edgeBlurSize_set,0,0},
{0,0,0,0}
};
static const char *swig_CvMSERParams_base_names[] = {0};
static const swig_type_info *swig_CvMSERParams_base[] = {0};
static swig_octave_class _wrap_class_CvMSERParams = {"CvMSERParams", &SWIGTYPE_p_CvMSERParams,0,_wrap_new_CvMSERParams,0,_wrap_delete_CvMSERParams,swig_CvMSERParams_members,swig_CvMSERParams_base_names,swig_CvMSERParams_base };

static octave_value_list _wrap_cvMSERParams (const octave_value_list& args, int nargout) {
  int arg1 = (int) 5 ;
  int arg2 = (int) 60 ;
  int arg3 = (int) 14400 ;
  float arg4 = (float) .25 ;
  float arg5 = (float) .2 ;
  int arg6 = (int) 200 ;
  double arg7 = (double) 1.01 ;
  double arg8 = (double) .003 ;
  int arg9 = (int) 5 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  double val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMSERParams result;
  
  if (!SWIG_check_num_args("cvMSERParams",args.length(),9,0,0)) {
    SWIG_fail;
  }
  if (0<args.length()) {
    ecode1 = SWIG_AsVal_int(args(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvMSERParams" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = (int)(val1);
  }
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvMSERParams" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvMSERParams" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_float(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvMSERParams" "', argument " "4"" of type '" "float""'");
    } 
    arg4 = (float)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_float(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvMSERParams" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = (float)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvMSERParams" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_double(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvMSERParams" "', argument " "7"" of type '" "double""'");
    } 
    arg7 = (double)(val7);
  }
  if (7<args.length()) {
    ecode8 = SWIG_AsVal_double(args(7), &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "cvMSERParams" "', argument " "8"" of type '" "double""'");
    } 
    arg8 = (double)(val8);
  }
  if (8<args.length()) {
    ecode9 = SWIG_AsVal_int(args(8), &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cvMSERParams" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  {
    try {
      result = cvMSERParams(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvMSERParams((const CvMSERParams&)(result))), SWIGTYPE_p_CvMSERParams, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvExtractMSER (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvSeq **arg3 = (CvSeq **) 0 ;
  CvMemStorage *arg4 = (CvMemStorage *) 0 ;
  CvMSERParams arg5 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *vptr3 ;
  CvSeq *buffer3 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvExtractMSER",args.length(),5,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_CvSeq, 1)) == -1){
      SWIG_fail;
    }
    buffer3 = (CvSeq *) vptr3;
    arg3=&buffer3;
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvExtractMSER" "', argument " "4"" of type '" "CvMemStorage *""'"); 
  }
  arg4 = (CvMemStorage *)(argp4);
  {
    res5 = SWIG_ConvertPtr(args(4), &argp5, SWIGTYPE_p_CvMSERParams,  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvExtractMSER" "', argument " "5"" of type '" "CvMSERParams""'"); 
    }  
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvExtractMSER" "', argument " "5"" of type '" "CvMSERParams""'");
    } else {
      arg5 = *((CvMSERParams *)(argp5));
    }
  }
  {
    try {
      cvExtractMSER(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvStarKeypoint_pt_set (const octave_value_list& args, int nargout) {
  CvStarKeypoint *arg1 = (CvStarKeypoint *) 0 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStarKeypoint_pt_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarKeypoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarKeypoint_pt_set" "', argument " "1"" of type '" "CvStarKeypoint *""'"); 
  }
  arg1 = (CvStarKeypoint *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStarKeypoint_pt_set" "', argument " "2"" of type '" "CvPoint *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  if (arg1) (arg1)->pt = *arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarKeypoint_pt_get (const octave_value_list& args, int nargout) {
  CvStarKeypoint *arg1 = (CvStarKeypoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvStarKeypoint_pt_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarKeypoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarKeypoint_pt_get" "', argument " "1"" of type '" "CvStarKeypoint *""'"); 
  }
  arg1 = (CvStarKeypoint *)(argp1);
  result = (CvPoint *)& ((arg1)->pt);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarKeypoint_size_set (const octave_value_list& args, int nargout) {
  CvStarKeypoint *arg1 = (CvStarKeypoint *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStarKeypoint_size_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarKeypoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarKeypoint_size_set" "', argument " "1"" of type '" "CvStarKeypoint *""'"); 
  }
  arg1 = (CvStarKeypoint *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStarKeypoint_size_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->size = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarKeypoint_size_get (const octave_value_list& args, int nargout) {
  CvStarKeypoint *arg1 = (CvStarKeypoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStarKeypoint_size_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarKeypoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarKeypoint_size_get" "', argument " "1"" of type '" "CvStarKeypoint *""'"); 
  }
  arg1 = (CvStarKeypoint *)(argp1);
  result = (int) ((arg1)->size);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarKeypoint_response_set (const octave_value_list& args, int nargout) {
  CvStarKeypoint *arg1 = (CvStarKeypoint *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStarKeypoint_response_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarKeypoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarKeypoint_response_set" "', argument " "1"" of type '" "CvStarKeypoint *""'"); 
  }
  arg1 = (CvStarKeypoint *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStarKeypoint_response_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->response = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarKeypoint_response_get (const octave_value_list& args, int nargout) {
  CvStarKeypoint *arg1 = (CvStarKeypoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvStarKeypoint_response_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarKeypoint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarKeypoint_response_get" "', argument " "1"" of type '" "CvStarKeypoint *""'"); 
  }
  arg1 = (CvStarKeypoint *)(argp1);
  result = (float) ((arg1)->response);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvStarKeypoint (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStarKeypoint *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvStarKeypoint",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvStarKeypoint *)new CvStarKeypoint(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvStarKeypoint, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvStarKeypoint (const octave_value_list& args, int nargout) {
  CvStarKeypoint *arg1 = (CvStarKeypoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvStarKeypoint",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarKeypoint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvStarKeypoint" "', argument " "1"" of type '" "CvStarKeypoint *""'"); 
  }
  arg1 = (CvStarKeypoint *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvStarKeypoint_members[] = {
{"pt",0,_wrap_CvStarKeypoint_pt_get,_wrap_CvStarKeypoint_pt_set,0,0},
{"size",0,_wrap_CvStarKeypoint_size_get,_wrap_CvStarKeypoint_size_set,0,0},
{"response",0,_wrap_CvStarKeypoint_response_get,_wrap_CvStarKeypoint_response_set,0,0},
{0,0,0,0}
};
static const char *swig_CvStarKeypoint_base_names[] = {0};
static const swig_type_info *swig_CvStarKeypoint_base[] = {0};
static swig_octave_class _wrap_class_CvStarKeypoint = {"CvStarKeypoint", &SWIGTYPE_p_CvStarKeypoint,0,_wrap_new_CvStarKeypoint,0,_wrap_delete_CvStarKeypoint,swig_CvStarKeypoint_members,swig_CvStarKeypoint_base_names,swig_CvStarKeypoint_base };

static octave_value_list _wrap_cvStarKeypoint (const octave_value_list& args, int nargout) {
  CvPoint arg1 ;
  int arg2 ;
  float arg3 ;
  int val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStarKeypoint result;
  
  if (!SWIG_check_num_args("cvStarKeypoint",args.length(),3,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvPoint(args(0));
  }
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvStarKeypoint" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  ecode3 = SWIG_AsVal_float(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvStarKeypoint" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = (float)(val3);
  {
    try {
      result = cvStarKeypoint(arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvStarKeypoint((const CvStarKeypoint&)(result))), SWIGTYPE_p_CvStarKeypoint, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarDetectorParams_maxSize_set (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStarDetectorParams_maxSize_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarDetectorParams_maxSize_set" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStarDetectorParams_maxSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->maxSize = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarDetectorParams_maxSize_get (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStarDetectorParams_maxSize_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarDetectorParams_maxSize_get" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  result = (int) ((arg1)->maxSize);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarDetectorParams_responseThreshold_set (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStarDetectorParams_responseThreshold_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarDetectorParams_responseThreshold_set" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStarDetectorParams_responseThreshold_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->responseThreshold = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarDetectorParams_responseThreshold_get (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStarDetectorParams_responseThreshold_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarDetectorParams_responseThreshold_get" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  result = (int) ((arg1)->responseThreshold);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarDetectorParams_lineThresholdProjected_set (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStarDetectorParams_lineThresholdProjected_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarDetectorParams_lineThresholdProjected_set" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStarDetectorParams_lineThresholdProjected_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->lineThresholdProjected = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarDetectorParams_lineThresholdProjected_get (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStarDetectorParams_lineThresholdProjected_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarDetectorParams_lineThresholdProjected_get" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  result = (int) ((arg1)->lineThresholdProjected);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarDetectorParams_lineThresholdBinarized_set (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStarDetectorParams_lineThresholdBinarized_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarDetectorParams_lineThresholdBinarized_set" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStarDetectorParams_lineThresholdBinarized_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->lineThresholdBinarized = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarDetectorParams_lineThresholdBinarized_get (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStarDetectorParams_lineThresholdBinarized_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarDetectorParams_lineThresholdBinarized_get" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  result = (int) ((arg1)->lineThresholdBinarized);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarDetectorParams_suppressNonmaxSize_set (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStarDetectorParams_suppressNonmaxSize_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarDetectorParams_suppressNonmaxSize_set" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStarDetectorParams_suppressNonmaxSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->suppressNonmaxSize = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStarDetectorParams_suppressNonmaxSize_get (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStarDetectorParams_suppressNonmaxSize_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStarDetectorParams_suppressNonmaxSize_get" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  result = (int) ((arg1)->suppressNonmaxSize);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvStarDetectorParams (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStarDetectorParams *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvStarDetectorParams",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvStarDetectorParams *)new CvStarDetectorParams(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvStarDetectorParams, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvStarDetectorParams (const octave_value_list& args, int nargout) {
  CvStarDetectorParams *arg1 = (CvStarDetectorParams *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvStarDetectorParams",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStarDetectorParams, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvStarDetectorParams" "', argument " "1"" of type '" "CvStarDetectorParams *""'"); 
  }
  arg1 = (CvStarDetectorParams *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvStarDetectorParams_members[] = {
{"maxSize",0,_wrap_CvStarDetectorParams_maxSize_get,_wrap_CvStarDetectorParams_maxSize_set,0,0},
{"responseThreshold",0,_wrap_CvStarDetectorParams_responseThreshold_get,_wrap_CvStarDetectorParams_responseThreshold_set,0,0},
{"lineThresholdProjected",0,_wrap_CvStarDetectorParams_lineThresholdProjected_get,_wrap_CvStarDetectorParams_lineThresholdProjected_set,0,0},
{"lineThresholdBinarized",0,_wrap_CvStarDetectorParams_lineThresholdBinarized_get,_wrap_CvStarDetectorParams_lineThresholdBinarized_set,0,0},
{"suppressNonmaxSize",0,_wrap_CvStarDetectorParams_suppressNonmaxSize_get,_wrap_CvStarDetectorParams_suppressNonmaxSize_set,0,0},
{0,0,0,0}
};
static const char *swig_CvStarDetectorParams_base_names[] = {0};
static const swig_type_info *swig_CvStarDetectorParams_base[] = {0};
static swig_octave_class _wrap_class_CvStarDetectorParams = {"CvStarDetectorParams", &SWIGTYPE_p_CvStarDetectorParams,0,_wrap_new_CvStarDetectorParams,0,_wrap_delete_CvStarDetectorParams,swig_CvStarDetectorParams_members,swig_CvStarDetectorParams_base_names,swig_CvStarDetectorParams_base };

static octave_value_list _wrap_cvStarDetectorParams (const octave_value_list& args, int nargout) {
  int arg1 = (int) 45 ;
  int arg2 = (int) 30 ;
  int arg3 = (int) 10 ;
  int arg4 = (int) 8 ;
  int arg5 = (int) 5 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStarDetectorParams result;
  
  if (!SWIG_check_num_args("cvStarDetectorParams",args.length(),5,0,0)) {
    SWIG_fail;
  }
  if (0<args.length()) {
    ecode1 = SWIG_AsVal_int(args(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvStarDetectorParams" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = (int)(val1);
  }
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvStarDetectorParams" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvStarDetectorParams" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvStarDetectorParams" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_int(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvStarDetectorParams" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      result = cvStarDetectorParams(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj((new CvStarDetectorParams((const CvStarDetectorParams&)(result))), SWIGTYPE_p_CvStarDetectorParams, SWIG_POINTER_OWN |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvGetStarKeypoints (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvMemStorage *arg2 = (CvMemStorage *) 0 ;
  CvStarDetectorParams arg3 = (CvStarDetectorParams) cvStarDetectorParams() ;
  bool freearg1 = false ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq *result = 0 ;
  
  if (!SWIG_check_num_args("cvGetStarKeypoints",args.length(),3,2,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMemStorage, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvGetStarKeypoints" "', argument " "2"" of type '" "CvMemStorage *""'"); 
  }
  arg2 = (CvMemStorage *)(argp2);
  if (2<args.length()) {
    {
      res3 = SWIG_ConvertPtr(args(2), &argp3, SWIGTYPE_p_CvStarDetectorParams,  0 );
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvGetStarKeypoints" "', argument " "3"" of type '" "CvStarDetectorParams""'"); 
      }  
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvGetStarKeypoints" "', argument " "3"" of type '" "CvStarDetectorParams""'");
      } else {
        arg3 = *((CvStarDetectorParams *)(argp3));
      }
    }
  }
  {
    try {
      result = (CvSeq *)cvGetStarKeypoints((void const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvLoadHaarClassifierCascade (const octave_value_list& args, int nargout) {
  char *arg1 = (char *) 0 ;
  CvSize arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvHaarClassifierCascade *result = 0 ;
  
  if (!SWIG_check_num_args("cvLoadHaarClassifierCascade",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_AsCharPtrAndSize(args(0), &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvLoadHaarClassifierCascade" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = (char *)(buf1);
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvLoadHaarClassifierCascade" "', argument " "2"" of type '" "CvSize""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvLoadHaarClassifierCascade" "', argument " "2"" of type '" "CvSize""'");
    } else {
      arg2 = *((CvSize *)(argp2));
    }
  }
  {
    try {
      result = (CvHaarClassifierCascade *)cvLoadHaarClassifierCascade((char const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvHaarClassifierCascade, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseHaarClassifierCascade (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade **arg1 = (CvHaarClassifierCascade **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseHaarClassifierCascade",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseHaarClassifierCascade" "', argument " "1"" of type '" "CvHaarClassifierCascade **""'"); 
  }
  arg1 = (CvHaarClassifierCascade **)(argp1);
  {
    try {
      cvReleaseHaarClassifierCascade(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvSetImagesForHaarClassifierCascade (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  double arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  double val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvSetImagesForHaarClassifierCascade",args.length(),5,5,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvSetImagesForHaarClassifierCascade" "', argument " "1"" of type '" "CvHaarClassifierCascade *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  ecode5 = SWIG_AsVal_double(args(4), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvSetImagesForHaarClassifierCascade" "', argument " "5"" of type '" "double""'");
  } 
  arg5 = (double)(val5);
  {
    try {
      cvSetImagesForHaarClassifierCascade(arg1,(void const *)arg2,(void const *)arg3,(void const *)arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvRunHaarClassifierCascade (const octave_value_list& args, int nargout) {
  CvHaarClassifierCascade *arg1 = (CvHaarClassifierCascade *) 0 ;
  CvPoint arg2 ;
  int arg3 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvRunHaarClassifierCascade",args.length(),3,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvHaarClassifierCascade, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRunHaarClassifierCascade" "', argument " "1"" of type '" "CvHaarClassifierCascade const *""'"); 
  }
  arg1 = (CvHaarClassifierCascade *)(argp1);
  {
    arg2 = OctObject_to_CvPoint(args(1));
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_int(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvRunHaarClassifierCascade" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = (int)(val3);
  }
  {
    try {
      result = (int)cvRunHaarClassifierCascade((CvHaarClassifierCascade const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvUndistort2 (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvUndistort2",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvUndistort2" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvUndistort2" "', argument " "4"" of type '" "CvMat const *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  {
    try {
      cvUndistort2((void const *)arg1,arg2,(CvMat const *)arg3,(CvMat const *)arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvInitUndistortMap (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInitUndistortMap",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvInitUndistortMap" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvInitUndistortMap" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  {
    try {
      cvInitUndistortMap((CvMat const *)arg1,(CvMat const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvInitUndistortRectifyMap (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  CvArr *arg5 = (CvArr *) 0 ;
  CvArr *arg6 = (CvArr *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  bool freearg5 = false ;
  bool freearg6 = false ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInitUndistortRectifyMap",args.length(),6,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvInitUndistortRectifyMap" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvInitUndistortRectifyMap" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvInitUndistortRectifyMap" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvInitUndistortRectifyMap" "', argument " "4"" of type '" "CvMat const *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  {
    arg5 = OctObject_to_CvArr(args(4), &freearg5);
  }
  {
    arg6 = OctObject_to_CvArr(args(5), &freearg6);
  }
  {
    try {
      cvInitUndistortRectifyMap((CvMat const *)arg1,(CvMat const *)arg2,(CvMat const *)arg3,(CvMat const *)arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg5!=NULL && freearg5){
      cvReleaseData( arg5 );
      cvFree(&(arg5));
    }
  }
  {
    if(arg6!=NULL && freearg6){
      cvReleaseData( arg6 );
      cvFree(&(arg6));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvUndistortPoints (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  CvMat *arg5 = (CvMat *) 0 ;
  CvMat *arg6 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvUndistortPoints",args.length(),6,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvUndistortPoints" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvUndistortPoints" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvUndistortPoints" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvUndistortPoints" "', argument " "4"" of type '" "CvMat const *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  if (4<args.length()) {
    res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvUndistortPoints" "', argument " "5"" of type '" "CvMat const *""'"); 
    }
    arg5 = (CvMat *)(argp5);
  }
  if (5<args.length()) {
    res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvUndistortPoints" "', argument " "6"" of type '" "CvMat const *""'"); 
    }
    arg6 = (CvMat *)(argp6);
  }
  {
    try {
      cvUndistortPoints((CvMat const *)arg1,arg2,(CvMat const *)arg3,(CvMat const *)arg4,(CvMat const *)arg5,(CvMat const *)arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRodrigues2 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvRodrigues2",args.length(),3,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRodrigues2" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvRodrigues2" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (2<args.length()) {
    res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvRodrigues2" "', argument " "3"" of type '" "CvMat *""'"); 
    }
    arg3 = (CvMat *)(argp3);
  }
  {
    try {
      result = (int)cvRodrigues2((CvMat const *)arg1,arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindHomography (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  int arg4 = (int) 0 ;
  double arg5 = (double) 0 ;
  CvMat *arg6 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvFindHomography",args.length(),6,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFindHomography" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvFindHomography" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvFindHomography" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvFindHomography" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_double(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvFindHomography" "', argument " "5"" of type '" "double""'");
    } 
    arg5 = (double)(val5);
  }
  if (5<args.length()) {
    res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvFindHomography" "', argument " "6"" of type '" "CvMat *""'"); 
    }
    arg6 = (CvMat *)(argp6);
  }
  {
    try {
      result = (int)cvFindHomography((CvMat const *)arg1,(CvMat const *)arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRQDecomp3x3 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) NULL ;
  CvMat *arg5 = (CvMat *) NULL ;
  CvMat *arg6 = (CvMat *) NULL ;
  CvPoint3D64f *arg7 = (CvPoint3D64f *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvRQDecomp3x3",args.length(),7,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvRQDecomp3x3" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvRQDecomp3x3" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvRQDecomp3x3" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  if (3<args.length()) {
    res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvRQDecomp3x3" "', argument " "4"" of type '" "CvMat *""'"); 
    }
    arg4 = (CvMat *)(argp4);
  }
  if (4<args.length()) {
    res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvRQDecomp3x3" "', argument " "5"" of type '" "CvMat *""'"); 
    }
    arg5 = (CvMat *)(argp5);
  }
  if (5<args.length()) {
    res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvRQDecomp3x3" "', argument " "6"" of type '" "CvMat *""'"); 
    }
    arg6 = (CvMat *)(argp6);
  }
  if (6<args.length()) {
    res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_CvPoint3D64f, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvRQDecomp3x3" "', argument " "7"" of type '" "CvPoint3D64f *""'"); 
    }
    arg7 = (CvPoint3D64f *)(argp7);
  }
  {
    try {
      cvRQDecomp3x3((CvMat const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvDecomposeProjectionMatrix (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  CvMat *arg5 = (CvMat *) NULL ;
  CvMat *arg6 = (CvMat *) NULL ;
  CvMat *arg7 = (CvMat *) NULL ;
  CvPoint3D64f *arg8 = (CvPoint3D64f *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvDecomposeProjectionMatrix",args.length(),8,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvDecomposeProjectionMatrix" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvDecomposeProjectionMatrix" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvDecomposeProjectionMatrix" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvDecomposeProjectionMatrix" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  if (4<args.length()) {
    res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvDecomposeProjectionMatrix" "', argument " "5"" of type '" "CvMat *""'"); 
    }
    arg5 = (CvMat *)(argp5);
  }
  if (5<args.length()) {
    res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvDecomposeProjectionMatrix" "', argument " "6"" of type '" "CvMat *""'"); 
    }
    arg6 = (CvMat *)(argp6);
  }
  if (6<args.length()) {
    res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvDecomposeProjectionMatrix" "', argument " "7"" of type '" "CvMat *""'"); 
    }
    arg7 = (CvMat *)(argp7);
  }
  if (7<args.length()) {
    res8 = SWIG_ConvertPtr(args(7), &argp8,SWIGTYPE_p_CvPoint3D64f, 0 |  0 );
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cvDecomposeProjectionMatrix" "', argument " "8"" of type '" "CvPoint3D64f *""'"); 
    }
    arg8 = (CvPoint3D64f *)(argp8);
  }
  {
    try {
      cvDecomposeProjectionMatrix((CvMat const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCalcMatMulDeriv (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalcMatMulDeriv",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCalcMatMulDeriv" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCalcMatMulDeriv" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCalcMatMulDeriv" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCalcMatMulDeriv" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  {
    try {
      cvCalcMatMulDeriv((CvMat const *)arg1,(CvMat const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvComposeRT (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  CvMat *arg5 = (CvMat *) 0 ;
  CvMat *arg6 = (CvMat *) 0 ;
  CvMat *arg7 = (CvMat *) 0 ;
  CvMat *arg8 = (CvMat *) 0 ;
  CvMat *arg9 = (CvMat *) 0 ;
  CvMat *arg10 = (CvMat *) 0 ;
  CvMat *arg11 = (CvMat *) 0 ;
  CvMat *arg12 = (CvMat *) 0 ;
  CvMat *arg13 = (CvMat *) 0 ;
  CvMat *arg14 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  void *argp14 = 0 ;
  int res14 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvComposeRT",args.length(),14,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvComposeRT" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvComposeRT" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvComposeRT" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvComposeRT" "', argument " "4"" of type '" "CvMat const *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvComposeRT" "', argument " "5"" of type '" "CvMat *""'"); 
  }
  arg5 = (CvMat *)(argp5);
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvComposeRT" "', argument " "6"" of type '" "CvMat *""'"); 
  }
  arg6 = (CvMat *)(argp6);
  if (6<args.length()) {
    res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvComposeRT" "', argument " "7"" of type '" "CvMat *""'"); 
    }
    arg7 = (CvMat *)(argp7);
  }
  if (7<args.length()) {
    res8 = SWIG_ConvertPtr(args(7), &argp8,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cvComposeRT" "', argument " "8"" of type '" "CvMat *""'"); 
    }
    arg8 = (CvMat *)(argp8);
  }
  if (8<args.length()) {
    res9 = SWIG_ConvertPtr(args(8), &argp9,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cvComposeRT" "', argument " "9"" of type '" "CvMat *""'"); 
    }
    arg9 = (CvMat *)(argp9);
  }
  if (9<args.length()) {
    res10 = SWIG_ConvertPtr(args(9), &argp10,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "cvComposeRT" "', argument " "10"" of type '" "CvMat *""'"); 
    }
    arg10 = (CvMat *)(argp10);
  }
  if (10<args.length()) {
    res11 = SWIG_ConvertPtr(args(10), &argp11,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "cvComposeRT" "', argument " "11"" of type '" "CvMat *""'"); 
    }
    arg11 = (CvMat *)(argp11);
  }
  if (11<args.length()) {
    res12 = SWIG_ConvertPtr(args(11), &argp12,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "cvComposeRT" "', argument " "12"" of type '" "CvMat *""'"); 
    }
    arg12 = (CvMat *)(argp12);
  }
  if (12<args.length()) {
    res13 = SWIG_ConvertPtr(args(12), &argp13,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "cvComposeRT" "', argument " "13"" of type '" "CvMat *""'"); 
    }
    arg13 = (CvMat *)(argp13);
  }
  if (13<args.length()) {
    res14 = SWIG_ConvertPtr(args(13), &argp14,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res14)) {
      SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "cvComposeRT" "', argument " "14"" of type '" "CvMat *""'"); 
    }
    arg14 = (CvMat *)(argp14);
  }
  {
    try {
      cvComposeRT((CvMat const *)arg1,(CvMat const *)arg2,(CvMat const *)arg3,(CvMat const *)arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvProjectPoints2 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  CvMat *arg5 = (CvMat *) 0 ;
  CvMat *arg6 = (CvMat *) 0 ;
  CvMat *arg7 = (CvMat *) NULL ;
  CvMat *arg8 = (CvMat *) NULL ;
  CvMat *arg9 = (CvMat *) NULL ;
  CvMat *arg10 = (CvMat *) NULL ;
  CvMat *arg11 = (CvMat *) NULL ;
  double arg12 = (double) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  double val12 ;
  int ecode12 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvProjectPoints2",args.length(),12,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvProjectPoints2" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvProjectPoints2" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvProjectPoints2" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvProjectPoints2" "', argument " "4"" of type '" "CvMat const *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvProjectPoints2" "', argument " "5"" of type '" "CvMat const *""'"); 
  }
  arg5 = (CvMat *)(argp5);
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvProjectPoints2" "', argument " "6"" of type '" "CvMat *""'"); 
  }
  arg6 = (CvMat *)(argp6);
  if (6<args.length()) {
    res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvProjectPoints2" "', argument " "7"" of type '" "CvMat *""'"); 
    }
    arg7 = (CvMat *)(argp7);
  }
  if (7<args.length()) {
    res8 = SWIG_ConvertPtr(args(7), &argp8,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cvProjectPoints2" "', argument " "8"" of type '" "CvMat *""'"); 
    }
    arg8 = (CvMat *)(argp8);
  }
  if (8<args.length()) {
    res9 = SWIG_ConvertPtr(args(8), &argp9,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cvProjectPoints2" "', argument " "9"" of type '" "CvMat *""'"); 
    }
    arg9 = (CvMat *)(argp9);
  }
  if (9<args.length()) {
    res10 = SWIG_ConvertPtr(args(9), &argp10,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "cvProjectPoints2" "', argument " "10"" of type '" "CvMat *""'"); 
    }
    arg10 = (CvMat *)(argp10);
  }
  if (10<args.length()) {
    res11 = SWIG_ConvertPtr(args(10), &argp11,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "cvProjectPoints2" "', argument " "11"" of type '" "CvMat *""'"); 
    }
    arg11 = (CvMat *)(argp11);
  }
  if (11<args.length()) {
    ecode12 = SWIG_AsVal_double(args(11), &val12);
    if (!SWIG_IsOK(ecode12)) {
      SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "cvProjectPoints2" "', argument " "12"" of type '" "double""'");
    } 
    arg12 = (double)(val12);
  }
  {
    try {
      cvProjectPoints2((CvMat const *)arg1,(CvMat const *)arg2,(CvMat const *)arg3,(CvMat const *)arg4,(CvMat const *)arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindExtrinsicCameraParams2 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  CvMat *arg5 = (CvMat *) 0 ;
  CvMat *arg6 = (CvMat *) 0 ;
  int arg7 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFindExtrinsicCameraParams2",args.length(),7,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFindExtrinsicCameraParams2" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvFindExtrinsicCameraParams2" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvFindExtrinsicCameraParams2" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvFindExtrinsicCameraParams2" "', argument " "4"" of type '" "CvMat const *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvFindExtrinsicCameraParams2" "', argument " "5"" of type '" "CvMat *""'"); 
  }
  arg5 = (CvMat *)(argp5);
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvFindExtrinsicCameraParams2" "', argument " "6"" of type '" "CvMat *""'"); 
  }
  arg6 = (CvMat *)(argp6);
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_int(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvFindExtrinsicCameraParams2" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = (int)(val7);
  }
  {
    try {
      cvFindExtrinsicCameraParams2((CvMat const *)arg1,(CvMat const *)arg2,(CvMat const *)arg3,(CvMat const *)arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvInitIntrinsicParams2D (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvSize arg4 ;
  CvMat *arg5 = (CvMat *) 0 ;
  double arg6 = (double) 1. ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvInitIntrinsicParams2D",args.length(),6,5,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvInitIntrinsicParams2D" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvInitIntrinsicParams2D" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvInitIntrinsicParams2D" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  {
    res4 = SWIG_ConvertPtr(args(3), &argp4, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvInitIntrinsicParams2D" "', argument " "4"" of type '" "CvSize""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvInitIntrinsicParams2D" "', argument " "4"" of type '" "CvSize""'");
    } else {
      arg4 = *((CvSize *)(argp4));
    }
  }
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvInitIntrinsicParams2D" "', argument " "5"" of type '" "CvMat *""'"); 
  }
  arg5 = (CvMat *)(argp5);
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_double(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvInitIntrinsicParams2D" "', argument " "6"" of type '" "double""'");
    } 
    arg6 = (double)(val6);
  }
  {
    try {
      cvInitIntrinsicParams2D((CvMat const *)arg1,(CvMat const *)arg2,(CvMat const *)arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindChessboardCorners (const octave_value_list& args, int nargout) {
  void *arg1 = (void *) 0 ;
  CvSize arg2 ;
  CvPoint2D32f *arg3 = (CvPoint2D32f *) 0 ;
  int *arg4 = (int *) NULL ;
  int arg5 = (int) 1+2 ;
  int res1 ;
  CvSize *pattern_size2 ;
  CvPoint2D32f *tmp_corners2 ;
  int tmp_ncorners2 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvFindChessboardCorners",args.length(),3,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0),SWIG_as_voidptrptr(&arg1), 0, 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFindChessboardCorners" "', argument " "1"" of type '" "void const *""'"); 
  }
  {
    void * vptr;
    if( SWIG_ConvertPtr(args(1), &vptr, SWIGTYPE_p_CvSize, SWIG_POINTER_EXCEPTION ) == -1){
      SWIG_fail;
    }
    pattern_size2=(CvSize *)vptr;
    tmp_ncorners2 = pattern_size2->width*pattern_size2->height;
    
    tmp_corners2 = (CvPoint2D32f *) malloc(sizeof(CvPoint2D32f)*tmp_ncorners2);
    arg2 = *pattern_size2;
    arg3 = tmp_corners2;
    arg4 = &tmp_ncorners2;
  }
  if (2<args.length()) {
    ecode5 = SWIG_AsVal_int(args(2), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvFindChessboardCorners" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = (int)(val5);
  }
  {
    try {
      result = (int)cvFindChessboardCorners((void const *)arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    int i;
    octave_value to_add;
    
    // create the list to return
    to_add = OctList_New ( tmp_ncorners2 );
    
    // extract all the corner values of the result, and add it to the
    // final resulting list
    for (i = 0; i < tmp_ncorners2; i++) {
      CvPoint2D32f * pt = new CvPoint2D32f;
      pt->x = tmp_corners2[i].x;
      pt->y = tmp_corners2[i].y;
      
      OctList_SetItem (to_add, i,
        SWIG_NewPointerObj( pt, SWIGTYPE_p_CvPoint2D32f, 0));
    }
    
    _outp = SWIG_AppendResult( _outp, &to_add, 1);
    free(tmp_corners2);
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvDrawChessboardCorners (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvSize arg2 ;
  CvPoint2D32f *arg3 = (CvPoint2D32f *) 0 ;
  int arg4 ;
  int arg5 ;
  bool freearg1 = false ;
  void *argp2 ;
  int res2 = 0 ;
  int cornersCount3 ;
  CvPoint2D32f *corners3 ;
  int val5 ;
  int ecode5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvDrawChessboardCorners",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvDrawChessboardCorners" "', argument " "2"" of type '" "CvSize""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvDrawChessboardCorners" "', argument " "2"" of type '" "CvSize""'");
    } else {
      arg2 = *((CvSize *)(argp2));
    }
  }
  {
    int i;
    
    if(!OctList_Check(args(2))){
      error("Expected a list");
      SWIG_fail;
    }
    
    // get the size of the input array
    cornersCount3 = OctList_Size (args(2));
    arg4 = cornersCount3;
    
    // allocate the needed memory
    corners3 = (CvPoint2D32f *)malloc (arg4 * sizeof (CvPoint2D32f));
    arg3 = corners3;
    
    // the size of the array for the C call
    
    // extract all the points values from the list
    for (i = 0; i < arg4; i++) {
      octave_value item = OctList_GetItem (args(2), i);
      
      void *vptr;
      SWIG_Octave_ConvertPtr (item, &vptr,
        SWIGTYPE_p_CvPoint2D32f,
        SWIG_POINTER_EXCEPTION);
      CvPoint2D32f *p = (CvPoint2D32f *) vptr;;
      arg3 [i].x = p->x;
      arg3 [i].y = p->y;
    }
  }
  ecode5 = SWIG_AsVal_int(args(3), &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvDrawChessboardCorners" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = (int)(val5);
  {
    try {
      cvDrawChessboardCorners(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    int i;
    octave_value to_add;
    
    // create the list to return
    to_add = OctList_New (cornersCount3);
    
    // extract all the corner values of the result, and add it to the
    // final resulting list
    for (i = 0; i < cornersCount3; i++) {
      OctList_SetItem (to_add, i,
        SWIG_NewPointerObj (&(corners3 [i]),
          SWIGTYPE_p_CvPoint2D32f, 0));
    }
    
    _outp = SWIG_AppendResult( _outp, &to_add, 1);
  }
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvCalibrateCamera2 (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvSize arg4 ;
  CvMat *arg5 = (CvMat *) 0 ;
  CvMat *arg6 = (CvMat *) 0 ;
  CvMat *arg7 = (CvMat *) NULL ;
  CvMat *arg8 = (CvMat *) NULL ;
  int arg9 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalibrateCamera2",args.length(),9,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCalibrateCamera2" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCalibrateCamera2" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCalibrateCamera2" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  {
    res4 = SWIG_ConvertPtr(args(3), &argp4, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCalibrateCamera2" "', argument " "4"" of type '" "CvSize""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalibrateCamera2" "', argument " "4"" of type '" "CvSize""'");
    } else {
      arg4 = *((CvSize *)(argp4));
    }
  }
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvCalibrateCamera2" "', argument " "5"" of type '" "CvMat *""'"); 
  }
  arg5 = (CvMat *)(argp5);
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvCalibrateCamera2" "', argument " "6"" of type '" "CvMat *""'"); 
  }
  arg6 = (CvMat *)(argp6);
  if (6<args.length()) {
    res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvCalibrateCamera2" "', argument " "7"" of type '" "CvMat *""'"); 
    }
    arg7 = (CvMat *)(argp7);
  }
  if (7<args.length()) {
    res8 = SWIG_ConvertPtr(args(7), &argp8,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cvCalibrateCamera2" "', argument " "8"" of type '" "CvMat *""'"); 
    }
    arg8 = (CvMat *)(argp8);
  }
  if (8<args.length()) {
    ecode9 = SWIG_AsVal_int(args(8), &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "cvCalibrateCamera2" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = (int)(val9);
  }
  {
    try {
      cvCalibrateCamera2((CvMat const *)arg1,(CvMat const *)arg2,(CvMat const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCalibrationMatrixValues (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvSize arg2 ;
  double arg3 = (double) 0 ;
  double arg4 = (double) 0 ;
  double *arg5 = (double *) NULL ;
  double *arg6 = (double *) NULL ;
  double *arg7 = (double *) NULL ;
  CvPoint2D64f *arg8 = (CvPoint2D64f *) NULL ;
  double *arg9 = (double *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCalibrationMatrixValues",args.length(),9,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCalibrationMatrixValues" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  {
    res2 = SWIG_ConvertPtr(args(1), &argp2, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCalibrationMatrixValues" "', argument " "2"" of type '" "CvSize""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvCalibrationMatrixValues" "', argument " "2"" of type '" "CvSize""'");
    } else {
      arg2 = *((CvSize *)(argp2));
    }
  }
  if (2<args.length()) {
    ecode3 = SWIG_AsVal_double(args(2), &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvCalibrationMatrixValues" "', argument " "3"" of type '" "double""'");
    } 
    arg3 = (double)(val3);
  }
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_double(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvCalibrationMatrixValues" "', argument " "4"" of type '" "double""'");
    } 
    arg4 = (double)(val4);
  }
  if (4<args.length()) {
    res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_double, 0 |  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvCalibrationMatrixValues" "', argument " "5"" of type '" "double *""'"); 
    }
    arg5 = (double *)(argp5);
  }
  if (5<args.length()) {
    res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_double, 0 |  0 );
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvCalibrationMatrixValues" "', argument " "6"" of type '" "double *""'"); 
    }
    arg6 = (double *)(argp6);
  }
  if (6<args.length()) {
    res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_double, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvCalibrationMatrixValues" "', argument " "7"" of type '" "double *""'"); 
    }
    arg7 = (double *)(argp7);
  }
  if (7<args.length()) {
    res8 = SWIG_ConvertPtr(args(7), &argp8,SWIGTYPE_p_CvPoint2D64f, 0 |  0 );
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cvCalibrationMatrixValues" "', argument " "8"" of type '" "CvPoint2D64f *""'"); 
    }
    arg8 = (CvPoint2D64f *)(argp8);
  }
  if (8<args.length()) {
    res9 = SWIG_ConvertPtr(args(8), &argp9,SWIGTYPE_p_double, 0 |  0 );
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cvCalibrationMatrixValues" "', argument " "9"" of type '" "double *""'"); 
    }
    arg9 = (double *)(argp9);
  }
  {
    try {
      cvCalibrationMatrixValues((CvMat const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvStereoCalibrate (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  CvMat *arg5 = (CvMat *) 0 ;
  CvMat *arg6 = (CvMat *) 0 ;
  CvMat *arg7 = (CvMat *) 0 ;
  CvMat *arg8 = (CvMat *) 0 ;
  CvSize arg9 ;
  CvMat *arg10 = (CvMat *) 0 ;
  CvMat *arg11 = (CvMat *) 0 ;
  CvMat *arg12 = (CvMat *) 0 ;
  CvMat *arg13 = (CvMat *) 0 ;
  CvTermCriteria arg14 = (CvTermCriteria) cvTermCriteria( 1 +2,30,1e-6) ;
  int arg15 = (int) 256 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  void *argp14 ;
  int res14 = 0 ;
  int val15 ;
  int ecode15 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvStereoCalibrate",args.length(),15,11,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvStereoCalibrate" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvStereoCalibrate" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvStereoCalibrate" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvStereoCalibrate" "', argument " "4"" of type '" "CvMat const *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvStereoCalibrate" "', argument " "5"" of type '" "CvMat *""'"); 
  }
  arg5 = (CvMat *)(argp5);
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvStereoCalibrate" "', argument " "6"" of type '" "CvMat *""'"); 
  }
  arg6 = (CvMat *)(argp6);
  res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvStereoCalibrate" "', argument " "7"" of type '" "CvMat *""'"); 
  }
  arg7 = (CvMat *)(argp7);
  res8 = SWIG_ConvertPtr(args(7), &argp8,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cvStereoCalibrate" "', argument " "8"" of type '" "CvMat *""'"); 
  }
  arg8 = (CvMat *)(argp8);
  {
    res9 = SWIG_ConvertPtr(args(8), &argp9, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cvStereoCalibrate" "', argument " "9"" of type '" "CvSize""'"); 
    }  
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvStereoCalibrate" "', argument " "9"" of type '" "CvSize""'");
    } else {
      arg9 = *((CvSize *)(argp9));
    }
  }
  res10 = SWIG_ConvertPtr(args(9), &argp10,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res10)) {
    SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "cvStereoCalibrate" "', argument " "10"" of type '" "CvMat *""'"); 
  }
  arg10 = (CvMat *)(argp10);
  res11 = SWIG_ConvertPtr(args(10), &argp11,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res11)) {
    SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "cvStereoCalibrate" "', argument " "11"" of type '" "CvMat *""'"); 
  }
  arg11 = (CvMat *)(argp11);
  if (11<args.length()) {
    res12 = SWIG_ConvertPtr(args(11), &argp12,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "cvStereoCalibrate" "', argument " "12"" of type '" "CvMat *""'"); 
    }
    arg12 = (CvMat *)(argp12);
  }
  if (12<args.length()) {
    res13 = SWIG_ConvertPtr(args(12), &argp13,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "cvStereoCalibrate" "', argument " "13"" of type '" "CvMat *""'"); 
    }
    arg13 = (CvMat *)(argp13);
  }
  if (13<args.length()) {
    {
      res14 = SWIG_ConvertPtr(args(13), &argp14, SWIGTYPE_p_CvTermCriteria,  0 );
      if (!SWIG_IsOK(res14)) {
        SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "cvStereoCalibrate" "', argument " "14"" of type '" "CvTermCriteria""'"); 
      }  
      if (!argp14) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvStereoCalibrate" "', argument " "14"" of type '" "CvTermCriteria""'");
      } else {
        arg14 = *((CvTermCriteria *)(argp14));
      }
    }
  }
  if (14<args.length()) {
    ecode15 = SWIG_AsVal_int(args(14), &val15);
    if (!SWIG_IsOK(ecode15)) {
      SWIG_exception_fail(SWIG_ArgError(ecode15), "in method '" "cvStereoCalibrate" "', argument " "15"" of type '" "int""'");
    } 
    arg15 = (int)(val15);
  }
  {
    try {
      cvStereoCalibrate((CvMat const *)arg1,(CvMat const *)arg2,(CvMat const *)arg3,(CvMat const *)arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvStereoRectify (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  CvSize arg5 ;
  CvMat *arg6 = (CvMat *) 0 ;
  CvMat *arg7 = (CvMat *) 0 ;
  CvMat *arg8 = (CvMat *) 0 ;
  CvMat *arg9 = (CvMat *) 0 ;
  CvMat *arg10 = (CvMat *) 0 ;
  CvMat *arg11 = (CvMat *) 0 ;
  CvMat *arg12 = (CvMat *) 0 ;
  int arg13 = (int) 1024 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvStereoRectify",args.length(),13,11,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvStereoRectify" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvStereoRectify" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvStereoRectify" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvStereoRectify" "', argument " "4"" of type '" "CvMat const *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  {
    res5 = SWIG_ConvertPtr(args(4), &argp5, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvStereoRectify" "', argument " "5"" of type '" "CvSize""'"); 
    }  
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvStereoRectify" "', argument " "5"" of type '" "CvSize""'");
    } else {
      arg5 = *((CvSize *)(argp5));
    }
  }
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvStereoRectify" "', argument " "6"" of type '" "CvMat const *""'"); 
  }
  arg6 = (CvMat *)(argp6);
  res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvStereoRectify" "', argument " "7"" of type '" "CvMat const *""'"); 
  }
  arg7 = (CvMat *)(argp7);
  res8 = SWIG_ConvertPtr(args(7), &argp8,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "cvStereoRectify" "', argument " "8"" of type '" "CvMat *""'"); 
  }
  arg8 = (CvMat *)(argp8);
  res9 = SWIG_ConvertPtr(args(8), &argp9,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res9)) {
    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "cvStereoRectify" "', argument " "9"" of type '" "CvMat *""'"); 
  }
  arg9 = (CvMat *)(argp9);
  res10 = SWIG_ConvertPtr(args(9), &argp10,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res10)) {
    SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "cvStereoRectify" "', argument " "10"" of type '" "CvMat *""'"); 
  }
  arg10 = (CvMat *)(argp10);
  res11 = SWIG_ConvertPtr(args(10), &argp11,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res11)) {
    SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "cvStereoRectify" "', argument " "11"" of type '" "CvMat *""'"); 
  }
  arg11 = (CvMat *)(argp11);
  if (11<args.length()) {
    res12 = SWIG_ConvertPtr(args(11), &argp12,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "cvStereoRectify" "', argument " "12"" of type '" "CvMat *""'"); 
    }
    arg12 = (CvMat *)(argp12);
  }
  if (12<args.length()) {
    ecode13 = SWIG_AsVal_int(args(12), &val13);
    if (!SWIG_IsOK(ecode13)) {
      SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "cvStereoRectify" "', argument " "13"" of type '" "int""'");
    } 
    arg13 = (int)(val13);
  }
  {
    try {
      cvStereoRectify((CvMat const *)arg1,(CvMat const *)arg2,(CvMat const *)arg3,(CvMat const *)arg4,arg5,(CvMat const *)arg6,(CvMat const *)arg7,arg8,arg9,arg10,arg11,arg12,arg13); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvStereoRectifyUncalibrated (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvSize arg4 ;
  CvMat *arg5 = (CvMat *) 0 ;
  CvMat *arg6 = (CvMat *) 0 ;
  double arg7 = (double) 5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  double val7 ;
  int ecode7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvStereoRectifyUncalibrated",args.length(),7,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvStereoRectifyUncalibrated" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvStereoRectifyUncalibrated" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvStereoRectifyUncalibrated" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  {
    res4 = SWIG_ConvertPtr(args(3), &argp4, SWIGTYPE_p_CvSize,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvStereoRectifyUncalibrated" "', argument " "4"" of type '" "CvSize""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvStereoRectifyUncalibrated" "', argument " "4"" of type '" "CvSize""'");
    } else {
      arg4 = *((CvSize *)(argp4));
    }
  }
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvStereoRectifyUncalibrated" "', argument " "5"" of type '" "CvMat *""'"); 
  }
  arg5 = (CvMat *)(argp5);
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvStereoRectifyUncalibrated" "', argument " "6"" of type '" "CvMat *""'"); 
  }
  arg6 = (CvMat *)(argp6);
  if (6<args.length()) {
    ecode7 = SWIG_AsVal_double(args(6), &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "cvStereoRectifyUncalibrated" "', argument " "7"" of type '" "double""'");
    } 
    arg7 = (double)(val7);
  }
  {
    try {
      result = (int)cvStereoRectifyUncalibrated((CvMat const *)arg1,(CvMat const *)arg2,(CvMat const *)arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCreatePOSITObject (const octave_value_list& args, int nargout) {
  CvPoint3D32f *arg1 = (CvPoint3D32f *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPOSITObject *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreatePOSITObject",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPoint3D32f, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCreatePOSITObject" "', argument " "1"" of type '" "CvPoint3D32f *""'"); 
  }
  arg1 = (CvPoint3D32f *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreatePOSITObject" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvPOSITObject *)cvCreatePOSITObject(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPOSITObject, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvPOSIT (const octave_value_list& args, int nargout) {
  CvPOSITObject *arg1 = (CvPOSITObject *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  double arg3 ;
  CvTermCriteria arg4 ;
  CvMatr32f arg5 = (CvMatr32f) 0 ;
  CvVect32f arg6 = (CvVect32f) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvPOSIT",args.length(),6,6,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvPOSITObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvPOSIT" "', argument " "1"" of type '" "CvPOSITObject *""'"); 
  }
  arg1 = (CvPOSITObject *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvPOSIT" "', argument " "2"" of type '" "CvPoint2D32f *""'"); 
  }
  arg2 = (CvPoint2D32f *)(argp2);
  ecode3 = SWIG_AsVal_double(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvPOSIT" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = (double)(val3);
  {
    res4 = SWIG_ConvertPtr(args(3), &argp4, SWIGTYPE_p_CvTermCriteria,  0 );
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvPOSIT" "', argument " "4"" of type '" "CvTermCriteria""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "cvPOSIT" "', argument " "4"" of type '" "CvTermCriteria""'");
    } else {
      arg4 = *((CvTermCriteria *)(argp4));
    }
  }
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvPOSIT" "', argument " "5"" of type '" "CvMatr32f""'"); 
  }
  arg5 = (CvMatr32f)(argp5);
  res6 = SWIG_ConvertPtr(args(5), &argp6,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "cvPOSIT" "', argument " "6"" of type '" "CvVect32f""'"); 
  }
  arg6 = (CvVect32f)(argp6);
  {
    try {
      cvPOSIT(arg1,arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleasePOSITObject (const octave_value_list& args, int nargout) {
  CvPOSITObject **arg1 = (CvPOSITObject **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleasePOSITObject",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvPOSITObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleasePOSITObject" "', argument " "1"" of type '" "CvPOSITObject **""'"); 
  }
  arg1 = (CvPOSITObject **)(argp1);
  {
    try {
      cvReleasePOSITObject(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvRANSACUpdateNumIters (const octave_value_list& args, int nargout) {
  double arg1 ;
  double arg2 ;
  int arg3 ;
  int arg4 ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvRANSACUpdateNumIters",args.length(),4,4,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_double(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvRANSACUpdateNumIters" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = (double)(val1);
  ecode2 = SWIG_AsVal_double(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvRANSACUpdateNumIters" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = (double)(val2);
  ecode3 = SWIG_AsVal_int(args(2), &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "cvRANSACUpdateNumIters" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = (int)(val3);
  ecode4 = SWIG_AsVal_int(args(3), &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvRANSACUpdateNumIters" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = (int)(val4);
  {
    try {
      result = (int)cvRANSACUpdateNumIters(arg1,arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvConvertPointsHomogeneous (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvConvertPointsHomogeneous",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvConvertPointsHomogeneous" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvConvertPointsHomogeneous" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  {
    try {
      cvConvertPointsHomogeneous((CvMat const *)arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindFundamentalMat (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  int arg4 = (int) 8 ;
  double arg5 = (double) 3. ;
  double arg6 = (double) 0.99 ;
  CvMat *arg7 = (CvMat *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  double val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("cvFindFundamentalMat",args.length(),7,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvFindFundamentalMat" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvFindFundamentalMat" "', argument " "2"" of type '" "CvMat const *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvFindFundamentalMat" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvFindFundamentalMat" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  if (4<args.length()) {
    ecode5 = SWIG_AsVal_double(args(4), &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "cvFindFundamentalMat" "', argument " "5"" of type '" "double""'");
    } 
    arg5 = (double)(val5);
  }
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_double(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvFindFundamentalMat" "', argument " "6"" of type '" "double""'");
    } 
    arg6 = (double)(val6);
  }
  if (6<args.length()) {
    res7 = SWIG_ConvertPtr(args(6), &argp7,SWIGTYPE_p_CvMat, 0 |  0 );
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "cvFindFundamentalMat" "', argument " "7"" of type '" "CvMat *""'"); 
    }
    arg7 = (CvMat *)(argp7);
  }
  {
    try {
      result = (int)cvFindFundamentalMat((CvMat const *)arg1,(CvMat const *)arg2,arg3,arg4,arg5,arg6,arg7); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvComputeCorrespondEpilines (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  int arg2 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvComputeCorrespondEpilines",args.length(),4,4,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvComputeCorrespondEpilines" "', argument " "1"" of type '" "CvMat const *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvComputeCorrespondEpilines" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvComputeCorrespondEpilines" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvComputeCorrespondEpilines" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  {
    try {
      cvComputeCorrespondEpilines((CvMat const *)arg1,arg2,(CvMat const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvTriangulatePoints (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  CvMat *arg5 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvTriangulatePoints",args.length(),5,5,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvTriangulatePoints" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvTriangulatePoints" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvTriangulatePoints" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvTriangulatePoints" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvTriangulatePoints" "', argument " "5"" of type '" "CvMat *""'"); 
  }
  arg5 = (CvMat *)(argp5);
  {
    try {
      cvTriangulatePoints(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvCorrectMatches (const octave_value_list& args, int nargout) {
  CvMat *arg1 = (CvMat *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  CvMat *arg4 = (CvMat *) 0 ;
  CvMat *arg5 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvCorrectMatches",args.length(),5,5,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvCorrectMatches" "', argument " "1"" of type '" "CvMat *""'"); 
  }
  arg1 = (CvMat *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cvCorrectMatches" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvCorrectMatches" "', argument " "3"" of type '" "CvMat *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvCorrectMatches" "', argument " "4"" of type '" "CvMat *""'"); 
  }
  arg4 = (CvMat *)(argp4);
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvCorrectMatches" "', argument " "5"" of type '" "CvMat *""'"); 
  }
  arg5 = (CvMat *)(argp5);
  {
    try {
      cvCorrectMatches(arg1,arg2,arg3,arg4,arg5); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_preFilterType_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_preFilterType_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_preFilterType_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_preFilterType_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->preFilterType = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_preFilterType_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_preFilterType_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_preFilterType_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->preFilterType);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_preFilterSize_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_preFilterSize_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_preFilterSize_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_preFilterSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->preFilterSize = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_preFilterSize_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_preFilterSize_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_preFilterSize_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->preFilterSize);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_preFilterCap_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_preFilterCap_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_preFilterCap_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_preFilterCap_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->preFilterCap = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_preFilterCap_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_preFilterCap_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_preFilterCap_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->preFilterCap);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_SADWindowSize_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_SADWindowSize_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_SADWindowSize_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_SADWindowSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->SADWindowSize = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_SADWindowSize_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_SADWindowSize_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_SADWindowSize_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->SADWindowSize);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_minDisparity_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_minDisparity_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_minDisparity_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_minDisparity_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->minDisparity = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_minDisparity_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_minDisparity_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_minDisparity_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->minDisparity);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_numberOfDisparities_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_numberOfDisparities_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_numberOfDisparities_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_numberOfDisparities_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->numberOfDisparities = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_numberOfDisparities_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_numberOfDisparities_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_numberOfDisparities_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->numberOfDisparities);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_textureThreshold_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_textureThreshold_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_textureThreshold_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_textureThreshold_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->textureThreshold = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_textureThreshold_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_textureThreshold_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_textureThreshold_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->textureThreshold);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_uniquenessRatio_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_uniquenessRatio_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_uniquenessRatio_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_uniquenessRatio_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->uniquenessRatio = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_uniquenessRatio_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_uniquenessRatio_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_uniquenessRatio_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->uniquenessRatio);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_speckleWindowSize_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_speckleWindowSize_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_speckleWindowSize_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_speckleWindowSize_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->speckleWindowSize = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_speckleWindowSize_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_speckleWindowSize_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_speckleWindowSize_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->speckleWindowSize);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_speckleRange_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_speckleRange_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_speckleRange_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_speckleRange_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->speckleRange = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_speckleRange_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_speckleRange_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_speckleRange_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->speckleRange);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_trySmallerWindows_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_trySmallerWindows_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_trySmallerWindows_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoBMState_trySmallerWindows_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->trySmallerWindows = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_trySmallerWindows_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoBMState_trySmallerWindows_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_trySmallerWindows_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (int) ((arg1)->trySmallerWindows);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_preFilteredImg0_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_preFilteredImg0_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_preFilteredImg0_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoBMState_preFilteredImg0_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->preFilteredImg0 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_preFilteredImg0_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoBMState_preFilteredImg0_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_preFilteredImg0_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (CvMat *) ((arg1)->preFilteredImg0);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_preFilteredImg1_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_preFilteredImg1_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_preFilteredImg1_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoBMState_preFilteredImg1_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->preFilteredImg1 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_preFilteredImg1_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoBMState_preFilteredImg1_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_preFilteredImg1_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (CvMat *) ((arg1)->preFilteredImg1);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_slidingSumBuf_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_slidingSumBuf_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_slidingSumBuf_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoBMState_slidingSumBuf_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->slidingSumBuf = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_slidingSumBuf_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoBMState_slidingSumBuf_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_slidingSumBuf_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (CvMat *) ((arg1)->slidingSumBuf);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_dbmin_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_dbmin_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_dbmin_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoBMState_dbmin_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->dbmin = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_dbmin_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoBMState_dbmin_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_dbmin_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (CvMat *) ((arg1)->dbmin);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_dbmax_set (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoBMState_dbmax_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_dbmax_set" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoBMState_dbmax_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->dbmax = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoBMState_dbmax_get (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoBMState_dbmax_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoBMState_dbmax_get" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  result = (CvMat *) ((arg1)->dbmax);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvStereoBMState (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStereoBMState *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvStereoBMState",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvStereoBMState *)new CvStereoBMState(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvStereoBMState, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvStereoBMState (const octave_value_list& args, int nargout) {
  CvStereoBMState *arg1 = (CvStereoBMState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvStereoBMState",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoBMState, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvStereoBMState" "', argument " "1"" of type '" "CvStereoBMState *""'"); 
  }
  arg1 = (CvStereoBMState *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvStereoBMState_members[] = {
{"preFilterType",0,_wrap_CvStereoBMState_preFilterType_get,_wrap_CvStereoBMState_preFilterType_set,0,0},
{"preFilterSize",0,_wrap_CvStereoBMState_preFilterSize_get,_wrap_CvStereoBMState_preFilterSize_set,0,0},
{"preFilterCap",0,_wrap_CvStereoBMState_preFilterCap_get,_wrap_CvStereoBMState_preFilterCap_set,0,0},
{"SADWindowSize",0,_wrap_CvStereoBMState_SADWindowSize_get,_wrap_CvStereoBMState_SADWindowSize_set,0,0},
{"minDisparity",0,_wrap_CvStereoBMState_minDisparity_get,_wrap_CvStereoBMState_minDisparity_set,0,0},
{"numberOfDisparities",0,_wrap_CvStereoBMState_numberOfDisparities_get,_wrap_CvStereoBMState_numberOfDisparities_set,0,0},
{"textureThreshold",0,_wrap_CvStereoBMState_textureThreshold_get,_wrap_CvStereoBMState_textureThreshold_set,0,0},
{"uniquenessRatio",0,_wrap_CvStereoBMState_uniquenessRatio_get,_wrap_CvStereoBMState_uniquenessRatio_set,0,0},
{"speckleWindowSize",0,_wrap_CvStereoBMState_speckleWindowSize_get,_wrap_CvStereoBMState_speckleWindowSize_set,0,0},
{"speckleRange",0,_wrap_CvStereoBMState_speckleRange_get,_wrap_CvStereoBMState_speckleRange_set,0,0},
{"trySmallerWindows",0,_wrap_CvStereoBMState_trySmallerWindows_get,_wrap_CvStereoBMState_trySmallerWindows_set,0,0},
{"preFilteredImg0",0,_wrap_CvStereoBMState_preFilteredImg0_get,_wrap_CvStereoBMState_preFilteredImg0_set,0,0},
{"preFilteredImg1",0,_wrap_CvStereoBMState_preFilteredImg1_get,_wrap_CvStereoBMState_preFilteredImg1_set,0,0},
{"slidingSumBuf",0,_wrap_CvStereoBMState_slidingSumBuf_get,_wrap_CvStereoBMState_slidingSumBuf_set,0,0},
{"dbmin",0,_wrap_CvStereoBMState_dbmin_get,_wrap_CvStereoBMState_dbmin_set,0,0},
{"dbmax",0,_wrap_CvStereoBMState_dbmax_get,_wrap_CvStereoBMState_dbmax_set,0,0},
{0,0,0,0}
};
static const char *swig_CvStereoBMState_base_names[] = {0};
static const swig_type_info *swig_CvStereoBMState_base[] = {0};
static swig_octave_class _wrap_class_CvStereoBMState = {"CvStereoBMState", &SWIGTYPE_p_CvStereoBMState,0,_wrap_new_CvStereoBMState,0,_wrap_delete_CvStereoBMState,swig_CvStereoBMState_members,swig_CvStereoBMState_base_names,swig_CvStereoBMState_base };

static octave_value_list _wrap_cvCreateStereoBMState (const octave_value_list& args, int nargout) {
  int arg1 = (int) 0 ;
  int arg2 = (int) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStereoBMState *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateStereoBMState",args.length(),2,0,0)) {
    SWIG_fail;
  }
  if (0<args.length()) {
    ecode1 = SWIG_AsVal_int(args(0), &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateStereoBMState" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = (int)(val1);
  }
  if (1<args.length()) {
    ecode2 = SWIG_AsVal_int(args(1), &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateStereoBMState" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = (int)(val2);
  }
  {
    try {
      result = (CvStereoBMState *)cvCreateStereoBMState(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseStereoBMState (const octave_value_list& args, int nargout) {
  CvStereoBMState **arg1 = (CvStereoBMState **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseStereoBMState",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseStereoBMState" "', argument " "1"" of type '" "CvStereoBMState **""'"); 
  }
  arg1 = (CvStereoBMState **)(argp1);
  {
    try {
      cvReleaseStereoBMState(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindStereoCorrespondenceBM (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvStereoBMState *arg4 = (CvStereoBMState *) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFindStereoCorrespondenceBM",args.length(),4,4,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  res4 = SWIG_ConvertPtr(args(3), &argp4,SWIGTYPE_p_CvStereoBMState, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "cvFindStereoCorrespondenceBM" "', argument " "4"" of type '" "CvStereoBMState *""'"); 
  }
  arg4 = (CvStereoBMState *)(argp4);
  {
    try {
      cvFindStereoCorrespondenceBM((void const *)arg1,(void const *)arg2,arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_Ithreshold_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_Ithreshold_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_Ithreshold_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoGCState_Ithreshold_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->Ithreshold = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_Ithreshold_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoGCState_Ithreshold_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_Ithreshold_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (int) ((arg1)->Ithreshold);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_interactionRadius_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_interactionRadius_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_interactionRadius_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoGCState_interactionRadius_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->interactionRadius = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_interactionRadius_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoGCState_interactionRadius_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_interactionRadius_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (int) ((arg1)->interactionRadius);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_K_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_K_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_K_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoGCState_K_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->K = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_K_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvStereoGCState_K_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_K_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (float) ((arg1)->K);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_lambda_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_lambda_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_lambda_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoGCState_lambda_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->lambda = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_lambda_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvStereoGCState_lambda_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_lambda_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (float) ((arg1)->lambda);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_lambda1_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_lambda1_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_lambda1_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoGCState_lambda1_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->lambda1 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_lambda1_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvStereoGCState_lambda1_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_lambda1_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (float) ((arg1)->lambda1);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_lambda2_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_lambda2_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_lambda2_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  ecode2 = SWIG_AsVal_float(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoGCState_lambda2_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = (float)(val2);
  if (arg1) (arg1)->lambda2 = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_lambda2_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float result;
  
  if (!SWIG_check_num_args("CvStereoGCState_lambda2_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_lambda2_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (float) ((arg1)->lambda2);
  _outv = SWIG_From_float((float)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_occlusionCost_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_occlusionCost_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_occlusionCost_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoGCState_occlusionCost_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->occlusionCost = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_occlusionCost_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoGCState_occlusionCost_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_occlusionCost_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (int) ((arg1)->occlusionCost);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_minDisparity_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_minDisparity_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_minDisparity_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoGCState_minDisparity_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->minDisparity = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_minDisparity_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoGCState_minDisparity_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_minDisparity_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (int) ((arg1)->minDisparity);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_numberOfDisparities_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_numberOfDisparities_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_numberOfDisparities_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoGCState_numberOfDisparities_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->numberOfDisparities = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_numberOfDisparities_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoGCState_numberOfDisparities_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_numberOfDisparities_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (int) ((arg1)->numberOfDisparities);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_maxIters_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_maxIters_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_maxIters_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvStereoGCState_maxIters_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  if (arg1) (arg1)->maxIters = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_maxIters_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  int result;
  
  if (!SWIG_check_num_args("CvStereoGCState_maxIters_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_maxIters_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (int) ((arg1)->maxIters);
  _outv = SWIG_From_int((int)(result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_left_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_left_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_left_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoGCState_left_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->left = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_left_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoGCState_left_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_left_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (CvMat *) ((arg1)->left);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_right_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_right_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_right_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoGCState_right_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->right = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_right_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoGCState_right_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_right_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (CvMat *) ((arg1)->right);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_dispLeft_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_dispLeft_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_dispLeft_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoGCState_dispLeft_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->dispLeft = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_dispLeft_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoGCState_dispLeft_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_dispLeft_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (CvMat *) ((arg1)->dispLeft);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_dispRight_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_dispRight_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_dispRight_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoGCState_dispRight_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->dispRight = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_dispRight_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoGCState_dispRight_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_dispRight_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (CvMat *) ((arg1)->dispRight);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_ptrLeft_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_ptrLeft_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_ptrLeft_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoGCState_ptrLeft_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->ptrLeft = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_ptrLeft_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoGCState_ptrLeft_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_ptrLeft_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (CvMat *) ((arg1)->ptrLeft);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_ptrRight_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_ptrRight_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_ptrRight_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoGCState_ptrRight_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->ptrRight = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_ptrRight_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoGCState_ptrRight_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_ptrRight_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (CvMat *) ((arg1)->ptrRight);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_vtxBuf_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_vtxBuf_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_vtxBuf_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoGCState_vtxBuf_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->vtxBuf = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_vtxBuf_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoGCState_vtxBuf_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_vtxBuf_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (CvMat *) ((arg1)->vtxBuf);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_edgeBuf_set (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  CvMat *arg2 = (CvMat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvStereoGCState_edgeBuf_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_edgeBuf_set" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvMat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvStereoGCState_edgeBuf_set" "', argument " "2"" of type '" "CvMat *""'"); 
  }
  arg2 = (CvMat *)(argp2);
  if (arg1) (arg1)->edgeBuf = arg2;
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvStereoGCState_edgeBuf_get (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvMat *result = 0 ;
  
  if (!SWIG_check_num_args("CvStereoGCState_edgeBuf_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvStereoGCState_edgeBuf_get" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  result = (CvMat *) ((arg1)->edgeBuf);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvMat, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvStereoGCState (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStereoGCState *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvStereoGCState",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvStereoGCState *)new CvStereoGCState(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvStereoGCState, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvStereoGCState (const octave_value_list& args, int nargout) {
  CvStereoGCState *arg1 = (CvStereoGCState *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvStereoGCState",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvStereoGCState, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvStereoGCState" "', argument " "1"" of type '" "CvStereoGCState *""'"); 
  }
  arg1 = (CvStereoGCState *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvStereoGCState_members[] = {
{"Ithreshold",0,_wrap_CvStereoGCState_Ithreshold_get,_wrap_CvStereoGCState_Ithreshold_set,0,0},
{"interactionRadius",0,_wrap_CvStereoGCState_interactionRadius_get,_wrap_CvStereoGCState_interactionRadius_set,0,0},
{"K",0,_wrap_CvStereoGCState_K_get,_wrap_CvStereoGCState_K_set,0,0},
{"lambda",0,_wrap_CvStereoGCState_lambda_get,_wrap_CvStereoGCState_lambda_set,0,0},
{"lambda1",0,_wrap_CvStereoGCState_lambda1_get,_wrap_CvStereoGCState_lambda1_set,0,0},
{"lambda2",0,_wrap_CvStereoGCState_lambda2_get,_wrap_CvStereoGCState_lambda2_set,0,0},
{"occlusionCost",0,_wrap_CvStereoGCState_occlusionCost_get,_wrap_CvStereoGCState_occlusionCost_set,0,0},
{"minDisparity",0,_wrap_CvStereoGCState_minDisparity_get,_wrap_CvStereoGCState_minDisparity_set,0,0},
{"numberOfDisparities",0,_wrap_CvStereoGCState_numberOfDisparities_get,_wrap_CvStereoGCState_numberOfDisparities_set,0,0},
{"maxIters",0,_wrap_CvStereoGCState_maxIters_get,_wrap_CvStereoGCState_maxIters_set,0,0},
{"left",0,_wrap_CvStereoGCState_left_get,_wrap_CvStereoGCState_left_set,0,0},
{"right",0,_wrap_CvStereoGCState_right_get,_wrap_CvStereoGCState_right_set,0,0},
{"dispLeft",0,_wrap_CvStereoGCState_dispLeft_get,_wrap_CvStereoGCState_dispLeft_set,0,0},
{"dispRight",0,_wrap_CvStereoGCState_dispRight_get,_wrap_CvStereoGCState_dispRight_set,0,0},
{"ptrLeft",0,_wrap_CvStereoGCState_ptrLeft_get,_wrap_CvStereoGCState_ptrLeft_set,0,0},
{"ptrRight",0,_wrap_CvStereoGCState_ptrRight_get,_wrap_CvStereoGCState_ptrRight_set,0,0},
{"vtxBuf",0,_wrap_CvStereoGCState_vtxBuf_get,_wrap_CvStereoGCState_vtxBuf_set,0,0},
{"edgeBuf",0,_wrap_CvStereoGCState_edgeBuf_get,_wrap_CvStereoGCState_edgeBuf_set,0,0},
{0,0,0,0}
};
static const char *swig_CvStereoGCState_base_names[] = {0};
static const swig_type_info *swig_CvStereoGCState_base[] = {0};
static swig_octave_class _wrap_class_CvStereoGCState = {"CvStereoGCState", &SWIGTYPE_p_CvStereoGCState,0,_wrap_new_CvStereoGCState,0,_wrap_delete_CvStereoGCState,swig_CvStereoGCState_members,swig_CvStereoGCState_base_names,swig_CvStereoGCState_base };

static octave_value_list _wrap_cvCreateStereoGCState (const octave_value_list& args, int nargout) {
  int arg1 ;
  int arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvStereoGCState *result = 0 ;
  
  if (!SWIG_check_num_args("cvCreateStereoGCState",args.length(),2,2,0)) {
    SWIG_fail;
  }
  ecode1 = SWIG_AsVal_int(args(0), &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "cvCreateStereoGCState" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = (int)(val1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "cvCreateStereoGCState" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvStereoGCState *)cvCreateStereoGCState(arg1,arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvReleaseStereoGCState (const octave_value_list& args, int nargout) {
  CvStereoGCState **arg1 = (CvStereoGCState **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReleaseStereoGCState",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cvReleaseStereoGCState" "', argument " "1"" of type '" "CvStereoGCState **""'"); 
  }
  arg1 = (CvStereoGCState **)(argp1);
  {
    try {
      cvReleaseStereoGCState(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_cvFindStereoCorrespondenceGC (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvArr *arg3 = (CvArr *) 0 ;
  CvArr *arg4 = (CvArr *) 0 ;
  CvStereoGCState *arg5 = (CvStereoGCState *) 0 ;
  int arg6 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  bool freearg3 = false ;
  bool freearg4 = false ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvFindStereoCorrespondenceGC",args.length(),6,5,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  {
    arg3 = OctObject_to_CvArr(args(2), &freearg3);
  }
  {
    arg4 = OctObject_to_CvArr(args(3), &freearg4);
  }
  res5 = SWIG_ConvertPtr(args(4), &argp5,SWIGTYPE_p_CvStereoGCState, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "cvFindStereoCorrespondenceGC" "', argument " "5"" of type '" "CvStereoGCState *""'"); 
  }
  arg5 = (CvStereoGCState *)(argp5);
  if (5<args.length()) {
    ecode6 = SWIG_AsVal_int(args(5), &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "cvFindStereoCorrespondenceGC" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = (int)(val6);
  }
  {
    try {
      cvFindStereoCorrespondenceGC((void const *)arg1,(void const *)arg2,arg3,arg4,arg5,arg6); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
  {
    if(arg3!=NULL && freearg3){
      cvReleaseData( arg3 );
      cvFree(&(arg3));
    }
  }
  {
    if(arg4!=NULL && freearg4){
      cvReleaseData( arg4 );
      cvFree(&(arg4));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_cvReprojectImageTo3D (const octave_value_list& args, int nargout) {
  CvArr *arg1 = (CvArr *) 0 ;
  CvArr *arg2 = (CvArr *) 0 ;
  CvMat *arg3 = (CvMat *) 0 ;
  int arg4 = (int) 0 ;
  bool freearg1 = false ;
  bool freearg2 = false ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("cvReprojectImageTo3D",args.length(),4,3,0)) {
    SWIG_fail;
  }
  {
    arg1 = OctObject_to_CvArr(args(0), &freearg1);
  }
  {
    arg2 = OctObject_to_CvArr(args(1), &freearg2);
  }
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvMat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "cvReprojectImageTo3D" "', argument " "3"" of type '" "CvMat const *""'"); 
  }
  arg3 = (CvMat *)(argp3);
  if (3<args.length()) {
    ecode4 = SWIG_AsVal_int(args(3), &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "cvReprojectImageTo3D" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = (int)(val4);
  }
  {
    try {
      cvReprojectImageTo3D((void const *)arg1,arg2,(CvMat const *)arg3,arg4); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
  {
    if(arg1!=NULL && freearg1){
      cvReleaseData( arg1 );
      cvFree(&(arg1));
    }
  }
  {
    if(arg2!=NULL && freearg2){
      cvReleaseData( arg2 );
      cvFree(&(arg2));
    }
  }
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvLSH (const octave_value_list& args, int nargout) {
  CvLSH *arg1 = (CvLSH *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvLSH",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvLSH, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvLSH" "', argument " "1"" of type '" "CvLSH *""'"); 
  }
  arg1 = (CvLSH *)(argp1);
  {
    try {
      delete_CvLSH(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvLSH_members[] = {
{0,0,0,0}
};
static const char *swig_CvLSH_base_names[] = {0};
static const swig_type_info *swig_CvLSH_base[] = {0};
static swig_octave_class _wrap_class_CvLSH = {"CvLSH", &SWIGTYPE_p_CvLSH,0,0,0,_wrap_delete_CvLSH,swig_CvLSH_members,swig_CvLSH_base_names,swig_CvLSH_base };

static octave_value_list _wrap_CvTuple_CvPoint_2_val_set (const octave_value_list& args, int nargout) {
  CvTuple< CvPoint,2 > *arg1 = (CvTuple< CvPoint,2 > *) 0 ;
  CvPoint *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTuple_CvPoint_2_val_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_CvPoint_2_val_set" "', argument " "1"" of type '" "CvTuple< CvPoint,2 > *""'"); 
  }
  arg1 = (CvTuple< CvPoint,2 > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvTuple_CvPoint_2_val_set" "', argument " "2"" of type '" "CvPoint [2]""'"); 
  } 
  arg2 = (CvPoint *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) arg1->val[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""val""' of type '""CvPoint [2]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_CvPoint_2_val_get (const octave_value_list& args, int nargout) {
  CvTuple< CvPoint,2 > *arg1 = (CvTuple< CvPoint,2 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvTuple_CvPoint_2_val_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_CvPoint_2_val_get" "', argument " "1"" of type '" "CvTuple< CvPoint,2 > *""'"); 
  }
  arg1 = (CvTuple< CvPoint,2 > *)(argp1);
  result = (CvPoint *)(CvPoint *) ((arg1)->val);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_CvPoint_2___paren (const octave_value_list& args, int nargout) {
  CvTuple< CvPoint,2 > *arg1 = (CvTuple< CvPoint,2 > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvTuple_CvPoint_2___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_CvPoint_2___paren" "', argument " "1"" of type '" "CvTuple< CvPoint,2 > *""'"); 
  }
  arg1 = (CvTuple< CvPoint,2 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_CvPoint_2___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvPoint *) &(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_CvPoint_2___paren_asgn (const octave_value_list& args, int nargout) {
  CvTuple< CvPoint,2 > *arg1 = (CvTuple< CvPoint,2 > *) 0 ;
  int arg2 ;
  CvPoint *arg3 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTuple_CvPoint_2___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_CvPoint_2___paren_asgn" "', argument " "1"" of type '" "CvTuple< CvPoint,2 > *""'"); 
  }
  arg1 = (CvTuple< CvPoint,2 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_CvPoint_2___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvTuple_CvPoint_2___paren_asgn" "', argument " "3"" of type '" "CvPoint *""'"); 
  }
  arg3 = (CvPoint *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_CvPoint_2___brace (const octave_value_list& args, int nargout) {
  CvTuple< CvPoint,2 > *arg1 = (CvTuple< CvPoint,2 > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvTuple_CvPoint_2___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_CvPoint_2___brace" "', argument " "1"" of type '" "CvTuple< CvPoint,2 > *""'"); 
  }
  arg1 = (CvTuple< CvPoint,2 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_CvPoint_2___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvPoint *) &(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_CvPoint_2___brace_asgn (const octave_value_list& args, int nargout) {
  CvTuple< CvPoint,2 > *arg1 = (CvTuple< CvPoint,2 > *) 0 ;
  int arg2 ;
  CvPoint *arg3 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTuple_CvPoint_2___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_CvPoint_2___brace_asgn" "', argument " "1"" of type '" "CvTuple< CvPoint,2 > *""'"); 
  }
  arg1 = (CvTuple< CvPoint,2 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_CvPoint_2___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvTuple_CvPoint_2___brace_asgn" "', argument " "3"" of type '" "CvPoint *""'"); 
  }
  arg3 = (CvPoint *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvTuple_CvPoint_2 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< CvPoint,2 > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvTuple_CvPoint_2",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTuple< CvPoint,2 > *)new CvTuple< CvPoint,2 >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_CvPoint_2_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvTuple_CvPoint_2 (const octave_value_list& args, int nargout) {
  CvTuple< CvPoint,2 > *arg1 = (CvTuple< CvPoint,2 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvTuple_CvPoint_2",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_CvPoint_2_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvTuple_CvPoint_2" "', argument " "1"" of type '" "CvTuple< CvPoint,2 > *""'"); 
  }
  arg1 = (CvTuple< CvPoint,2 > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvTuple_CvPoint_2_members[] = {
{"val",0,_wrap_CvTuple_CvPoint_2_val_get,_wrap_CvTuple_CvPoint_2_val_set,0,0},
{"__paren",_wrap_CvTuple_CvPoint_2___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvTuple_CvPoint_2___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvTuple_CvPoint_2___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvTuple_CvPoint_2___brace_asgn,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvTuple_CvPoint_2_base_names[] = {0};
static const swig_type_info *swig_CvTuple_CvPoint_2_base[] = {0};
static swig_octave_class _wrap_class_CvTuple_CvPoint_2 = {"CvTuple_CvPoint_2", &SWIGTYPE_p_CvTupleT_CvPoint_2_t,0,_wrap_new_CvTuple_CvPoint_2,0,_wrap_delete_CvTuple_CvPoint_2,swig_CvTuple_CvPoint_2_members,swig_CvTuple_CvPoint_2_base_names,swig_CvTuple_CvPoint_2_base };

static octave_value_list _wrap_CvTuple_float_2_val_set (const octave_value_list& args, int nargout) {
  CvTuple< float,2 > *arg1 = (CvTuple< float,2 > *) 0 ;
  float *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTuple_float_2_val_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_2_val_set" "', argument " "1"" of type '" "CvTuple< float,2 > *""'"); 
  }
  arg1 = (CvTuple< float,2 > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvTuple_float_2_val_set" "', argument " "2"" of type '" "float [2]""'"); 
  } 
  arg2 = (float *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) arg1->val[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""val""' of type '""float [2]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_float_2_val_get (const octave_value_list& args, int nargout) {
  CvTuple< float,2 > *arg1 = (CvTuple< float,2 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvTuple_float_2_val_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_2_val_get" "', argument " "1"" of type '" "CvTuple< float,2 > *""'"); 
  }
  arg1 = (CvTuple< float,2 > *)(argp1);
  result = (float *)(float *) ((arg1)->val);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_float_2___paren (const octave_value_list& args, int nargout) {
  CvTuple< float,2 > *arg1 = (CvTuple< float,2 > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvTuple_float_2___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_2___paren" "', argument " "1"" of type '" "CvTuple< float,2 > *""'"); 
  }
  arg1 = (CvTuple< float,2 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_float_2___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (float *) &(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_float((float)(*result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_float_2___paren_asgn (const octave_value_list& args, int nargout) {
  CvTuple< float,2 > *arg1 = (CvTuple< float,2 > *) 0 ;
  int arg2 ;
  float *arg3 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTuple_float_2___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_2___paren_asgn" "', argument " "1"" of type '" "CvTuple< float,2 > *""'"); 
  }
  arg1 = (CvTuple< float,2 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_float_2___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvTuple_float_2___paren_asgn" "', argument " "3"" of type '" "float *""'"); 
  }
  arg3 = (float *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_float_2___brace (const octave_value_list& args, int nargout) {
  CvTuple< float,2 > *arg1 = (CvTuple< float,2 > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvTuple_float_2___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_2___brace" "', argument " "1"" of type '" "CvTuple< float,2 > *""'"); 
  }
  arg1 = (CvTuple< float,2 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_float_2___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (float *) &(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_float((float)(*result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_float_2___brace_asgn (const octave_value_list& args, int nargout) {
  CvTuple< float,2 > *arg1 = (CvTuple< float,2 > *) 0 ;
  int arg2 ;
  float *arg3 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTuple_float_2___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_2___brace_asgn" "', argument " "1"" of type '" "CvTuple< float,2 > *""'"); 
  }
  arg1 = (CvTuple< float,2 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_float_2___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvTuple_float_2___brace_asgn" "', argument " "3"" of type '" "float *""'"); 
  }
  arg3 = (float *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvTuple_float_2 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< float,2 > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvTuple_float_2",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTuple< float,2 > *)new CvTuple< float,2 >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_float_2_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvTuple_float_2 (const octave_value_list& args, int nargout) {
  CvTuple< float,2 > *arg1 = (CvTuple< float,2 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvTuple_float_2",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_2_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvTuple_float_2" "', argument " "1"" of type '" "CvTuple< float,2 > *""'"); 
  }
  arg1 = (CvTuple< float,2 > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvTuple_float_2_members[] = {
{"val",0,_wrap_CvTuple_float_2_val_get,_wrap_CvTuple_float_2_val_set,0,0},
{"__paren",_wrap_CvTuple_float_2___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvTuple_float_2___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvTuple_float_2___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvTuple_float_2___brace_asgn,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvTuple_float_2_base_names[] = {0};
static const swig_type_info *swig_CvTuple_float_2_base[] = {0};
static swig_octave_class _wrap_class_CvTuple_float_2 = {"CvTuple_float_2", &SWIGTYPE_p_CvTupleT_float_2_t,0,_wrap_new_CvTuple_float_2,0,_wrap_delete_CvTuple_float_2,swig_CvTuple_float_2_members,swig_CvTuple_float_2_base_names,swig_CvTuple_float_2_base };

static octave_value_list _wrap_CvTuple_float_3_val_set (const octave_value_list& args, int nargout) {
  CvTuple< float,3 > *arg1 = (CvTuple< float,3 > *) 0 ;
  float *arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTuple_float_3_val_set",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_3_val_set" "', argument " "1"" of type '" "CvTuple< float,3 > *""'"); 
  }
  arg1 = (CvTuple< float,3 > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvTuple_float_3_val_set" "', argument " "2"" of type '" "float [2]""'"); 
  } 
  arg2 = (float *)(argp2);
  {
    if (arg2) {
      size_t ii = 0;
      for (; ii < (size_t)2; ++ii) arg1->val[ii] = arg2[ii];
    } else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""val""' of type '""float [2]""'");
    }
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_float_3_val_get (const octave_value_list& args, int nargout) {
  CvTuple< float,3 > *arg1 = (CvTuple< float,3 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvTuple_float_3_val_get",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_3_val_get" "', argument " "1"" of type '" "CvTuple< float,3 > *""'"); 
  }
  arg1 = (CvTuple< float,3 > *)(argp1);
  result = (float *)(float *) ((arg1)->val);
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_float, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_float_3___paren (const octave_value_list& args, int nargout) {
  CvTuple< float,3 > *arg1 = (CvTuple< float,3 > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvTuple_float_3___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_3___paren" "', argument " "1"" of type '" "CvTuple< float,3 > *""'"); 
  }
  arg1 = (CvTuple< float,3 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_float_3___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (float *) &(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_float((float)(*result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_float_3___paren_asgn (const octave_value_list& args, int nargout) {
  CvTuple< float,3 > *arg1 = (CvTuple< float,3 > *) 0 ;
  int arg2 ;
  float *arg3 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTuple_float_3___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_3___paren_asgn" "', argument " "1"" of type '" "CvTuple< float,3 > *""'"); 
  }
  arg1 = (CvTuple< float,3 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_float_3___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvTuple_float_3___paren_asgn" "', argument " "3"" of type '" "float *""'"); 
  }
  arg3 = (float *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_float_3___brace (const octave_value_list& args, int nargout) {
  CvTuple< float,3 > *arg1 = (CvTuple< float,3 > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  float *result = 0 ;
  
  if (!SWIG_check_num_args("CvTuple_float_3___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_3___brace" "', argument " "1"" of type '" "CvTuple< float,3 > *""'"); 
  }
  arg1 = (CvTuple< float,3 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_float_3___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (float *) &(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_From_float((float)(*result));
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvTuple_float_3___brace_asgn (const octave_value_list& args, int nargout) {
  CvTuple< float,3 > *arg1 = (CvTuple< float,3 > *) 0 ;
  int arg2 ;
  float *arg3 = (float *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvTuple_float_3___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvTuple_float_3___brace_asgn" "', argument " "1"" of type '" "CvTuple< float,3 > *""'"); 
  }
  arg1 = (CvTuple< float,3 > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvTuple_float_3___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_float, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvTuple_float_3___brace_asgn" "', argument " "3"" of type '" "float *""'"); 
  }
  arg3 = (float *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvTuple_float_3 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< float,3 > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvTuple_float_3",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTuple< float,3 > *)new CvTuple< float,3 >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_float_3_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvTuple_float_3 (const octave_value_list& args, int nargout) {
  CvTuple< float,3 > *arg1 = (CvTuple< float,3 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvTuple_float_3",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTupleT_float_3_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvTuple_float_3" "', argument " "1"" of type '" "CvTuple< float,3 > *""'"); 
  }
  arg1 = (CvTuple< float,3 > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvTuple_float_3_members[] = {
{"val",0,_wrap_CvTuple_float_3_val_get,_wrap_CvTuple_float_3_val_set,0,0},
{"__paren",_wrap_CvTuple_float_3___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvTuple_float_3___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvTuple_float_3___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvTuple_float_3___brace_asgn,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvTuple_float_3_base_names[] = {0};
static const swig_type_info *swig_CvTuple_float_3_base[] = {0};
static swig_octave_class _wrap_class_CvTuple_float_3 = {"CvTuple_float_3", &SWIGTYPE_p_CvTupleT_float_3_t,0,_wrap_new_CvTuple_float_3,0,_wrap_delete_CvTuple_float_3,swig_CvTuple_float_3_members,swig_CvTuple_float_3_base_names,swig_CvTuple_float_3_base };

static octave_value_list _wrap_CvSeq_CvPoint_cast (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvPoint > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint_cast",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      result = (CvTypedSeq< CvPoint > *)CvTypedSeq< CvPoint >::SWIGTEMPLATEDISAMBIGUATOR cast(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvPoint_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint___paren (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint > *arg1 = (CvTypedSeq< CvPoint > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint___paren" "', argument " "1"" of type '" "CvTypedSeq< CvPoint > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvPoint *)(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint___paren_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint > *arg1 = (CvTypedSeq< CvPoint > *) 0 ;
  int arg2 ;
  CvPoint *arg3 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint___paren_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvPoint > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvPoint___paren_asgn" "', argument " "3"" of type '" "CvPoint *""'"); 
  }
  arg3 = (CvPoint *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint___brace (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint > *arg1 = (CvTypedSeq< CvPoint > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint___brace" "', argument " "1"" of type '" "CvTypedSeq< CvPoint > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvPoint *)(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint___brace_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint > *arg1 = (CvTypedSeq< CvPoint > *) 0 ;
  int arg2 ;
  CvPoint *arg3 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint___brace_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvPoint > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvPoint___brace_asgn" "', argument " "3"" of type '" "CvPoint *""'"); 
  }
  arg3 = (CvPoint *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint_append (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint > *arg1 = (CvTypedSeq< CvPoint > *) 0 ;
  CvPoint *arg2 = (CvPoint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint_append" "', argument " "1"" of type '" "CvTypedSeq< CvPoint > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_CvPoint_append" "', argument " "2"" of type '" "CvPoint *""'"); 
  }
  arg2 = (CvPoint *)(argp2);
  {
    try {
      (arg1)->append(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint_pop (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint > *arg1 = (CvTypedSeq< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint_pop" "', argument " "1"" of type '" "CvTypedSeq< CvPoint > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint > *)(argp1);
  {
    try {
      result = (CvPoint *)(arg1)->pop(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeq_CvPoint (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvPoint > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeq_CvPoint",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypedSeq< CvPoint > *)new CvTypedSeq< CvPoint >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvPoint_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeq_CvPoint (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint > *arg1 = (CvTypedSeq< CvPoint > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeq_CvPoint",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeq_CvPoint" "', argument " "1"" of type '" "CvTypedSeq< CvPoint > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeq_CvPoint_members[] = {
{"cast",_wrap_CvSeq_CvPoint_cast,0,0,1,0},
{"__paren",_wrap_CvSeq_CvPoint___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvSeq_CvPoint___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvSeq_CvPoint___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvSeq_CvPoint___brace_asgn,0,0,0,0},
{"append",_wrap_CvSeq_CvPoint_append,0,0,0,0},
{"pop",_wrap_CvSeq_CvPoint_pop,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSeq_CvPoint_base_names[] = {"_p_CvSeq",0};
static const swig_type_info *swig_CvSeq_CvPoint_base[] = {0,0};
static swig_octave_class _wrap_class_CvSeq_CvPoint = {"CvSeq_CvPoint", &SWIGTYPE_p_CvTypedSeqT_CvPoint_t,0,_wrap_new_CvSeq_CvPoint,0,_wrap_delete_CvSeq_CvPoint,swig_CvSeq_CvPoint_members,swig_CvSeq_CvPoint_base_names,swig_CvSeq_CvPoint_base };

static octave_value_list _wrap_CvSeq_CvPoint2D32f_cast (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvPoint2D32f > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint2D32f_cast",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      result = (CvTypedSeq< CvPoint2D32f > *)CvTypedSeq< CvPoint2D32f >::SWIGTEMPLATEDISAMBIGUATOR cast(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint2D32f___paren (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint2D32f > *arg1 = (CvTypedSeq< CvPoint2D32f > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint2D32f___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint2D32f___paren" "', argument " "1"" of type '" "CvTypedSeq< CvPoint2D32f > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint2D32f > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint2D32f___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvPoint2D32f *)(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint2D32f___paren_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint2D32f > *arg1 = (CvTypedSeq< CvPoint2D32f > *) 0 ;
  int arg2 ;
  CvPoint2D32f *arg3 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint2D32f___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint2D32f___paren_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvPoint2D32f > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint2D32f > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint2D32f___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvPoint2D32f___paren_asgn" "', argument " "3"" of type '" "CvPoint2D32f *""'"); 
  }
  arg3 = (CvPoint2D32f *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint2D32f___brace (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint2D32f > *arg1 = (CvTypedSeq< CvPoint2D32f > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint2D32f___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint2D32f___brace" "', argument " "1"" of type '" "CvTypedSeq< CvPoint2D32f > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint2D32f > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint2D32f___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvPoint2D32f *)(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint2D32f___brace_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint2D32f > *arg1 = (CvTypedSeq< CvPoint2D32f > *) 0 ;
  int arg2 ;
  CvPoint2D32f *arg3 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint2D32f___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint2D32f___brace_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvPoint2D32f > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint2D32f > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint2D32f___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvPoint2D32f___brace_asgn" "', argument " "3"" of type '" "CvPoint2D32f *""'"); 
  }
  arg3 = (CvPoint2D32f *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint2D32f_append (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint2D32f > *arg1 = (CvTypedSeq< CvPoint2D32f > *) 0 ;
  CvPoint2D32f *arg2 = (CvPoint2D32f *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint2D32f_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint2D32f_append" "', argument " "1"" of type '" "CvTypedSeq< CvPoint2D32f > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint2D32f > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_CvPoint2D32f_append" "', argument " "2"" of type '" "CvPoint2D32f *""'"); 
  }
  arg2 = (CvPoint2D32f *)(argp2);
  {
    try {
      (arg1)->append(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint2D32f_pop (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint2D32f > *arg1 = (CvTypedSeq< CvPoint2D32f > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvPoint2D32f *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint2D32f_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint2D32f_pop" "', argument " "1"" of type '" "CvTypedSeq< CvPoint2D32f > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint2D32f > *)(argp1);
  {
    try {
      result = (CvPoint2D32f *)(arg1)->pop(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvPoint2D32f, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeq_CvPoint2D32f (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvPoint2D32f > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeq_CvPoint2D32f",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypedSeq< CvPoint2D32f > *)new CvTypedSeq< CvPoint2D32f >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeq_CvPoint2D32f (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvPoint2D32f > *arg1 = (CvTypedSeq< CvPoint2D32f > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeq_CvPoint2D32f",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeq_CvPoint2D32f" "', argument " "1"" of type '" "CvTypedSeq< CvPoint2D32f > *""'"); 
  }
  arg1 = (CvTypedSeq< CvPoint2D32f > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeq_CvPoint2D32f_members[] = {
{"cast",_wrap_CvSeq_CvPoint2D32f_cast,0,0,1,0},
{"__paren",_wrap_CvSeq_CvPoint2D32f___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvSeq_CvPoint2D32f___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvSeq_CvPoint2D32f___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvSeq_CvPoint2D32f___brace_asgn,0,0,0,0},
{"append",_wrap_CvSeq_CvPoint2D32f_append,0,0,0,0},
{"pop",_wrap_CvSeq_CvPoint2D32f_pop,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSeq_CvPoint2D32f_base_names[] = {"_p_CvSeq",0};
static const swig_type_info *swig_CvSeq_CvPoint2D32f_base[] = {0,0};
static swig_octave_class _wrap_class_CvSeq_CvPoint2D32f = {"CvSeq_CvPoint2D32f", &SWIGTYPE_p_CvTypedSeqT_CvPoint2D32f_t,0,_wrap_new_CvSeq_CvPoint2D32f,0,_wrap_delete_CvSeq_CvPoint2D32f,swig_CvSeq_CvPoint2D32f_members,swig_CvSeq_CvPoint2D32f_base_names,swig_CvSeq_CvPoint2D32f_base };

static octave_value_list _wrap_CvSeq_CvRect_cast (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvRect > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvRect_cast",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      result = (CvTypedSeq< CvRect > *)CvTypedSeq< CvRect >::SWIGTEMPLATEDISAMBIGUATOR cast(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvRect___paren (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvRect > *arg1 = (CvTypedSeq< CvRect > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvRect___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvRect___paren" "', argument " "1"" of type '" "CvTypedSeq< CvRect > *""'"); 
  }
  arg1 = (CvTypedSeq< CvRect > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvRect___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvRect *)(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvRect, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvRect___paren_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvRect > *arg1 = (CvTypedSeq< CvRect > *) 0 ;
  int arg2 ;
  CvRect *arg3 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvRect___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvRect___paren_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvRect > *""'"); 
  }
  arg1 = (CvTypedSeq< CvRect > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvRect___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvRect___paren_asgn" "', argument " "3"" of type '" "CvRect *""'"); 
  }
  arg3 = (CvRect *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvRect___brace (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvRect > *arg1 = (CvTypedSeq< CvRect > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvRect___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvRect___brace" "', argument " "1"" of type '" "CvTypedSeq< CvRect > *""'"); 
  }
  arg1 = (CvTypedSeq< CvRect > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvRect___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvRect *)(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvRect, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvRect___brace_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvRect > *arg1 = (CvTypedSeq< CvRect > *) 0 ;
  int arg2 ;
  CvRect *arg3 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvRect___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvRect___brace_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvRect > *""'"); 
  }
  arg1 = (CvTypedSeq< CvRect > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvRect___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvRect___brace_asgn" "', argument " "3"" of type '" "CvRect *""'"); 
  }
  arg3 = (CvRect *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvRect_append (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvRect > *arg1 = (CvTypedSeq< CvRect > *) 0 ;
  CvRect *arg2 = (CvRect *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvRect_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvRect_append" "', argument " "1"" of type '" "CvTypedSeq< CvRect > *""'"); 
  }
  arg1 = (CvTypedSeq< CvRect > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvRect, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_CvRect_append" "', argument " "2"" of type '" "CvRect *""'"); 
  }
  arg2 = (CvRect *)(argp2);
  {
    try {
      (arg1)->append(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvRect_pop (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvRect > *arg1 = (CvTypedSeq< CvRect > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvRect *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvRect_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvRect_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvRect_pop" "', argument " "1"" of type '" "CvTypedSeq< CvRect > *""'"); 
  }
  arg1 = (CvTypedSeq< CvRect > *)(argp1);
  {
    try {
      result = (CvRect *)(arg1)->pop(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvRect, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeq_CvRect (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvRect > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeq_CvRect",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypedSeq< CvRect > *)new CvTypedSeq< CvRect >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvRect_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeq_CvRect (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvRect > *arg1 = (CvTypedSeq< CvRect > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeq_CvRect",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvRect_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeq_CvRect" "', argument " "1"" of type '" "CvTypedSeq< CvRect > *""'"); 
  }
  arg1 = (CvTypedSeq< CvRect > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeq_CvRect_members[] = {
{"cast",_wrap_CvSeq_CvRect_cast,0,0,1,0},
{"__paren",_wrap_CvSeq_CvRect___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvSeq_CvRect___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvSeq_CvRect___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvSeq_CvRect___brace_asgn,0,0,0,0},
{"append",_wrap_CvSeq_CvRect_append,0,0,0,0},
{"pop",_wrap_CvSeq_CvRect_pop,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSeq_CvRect_base_names[] = {"_p_CvSeq",0};
static const swig_type_info *swig_CvSeq_CvRect_base[] = {0,0};
static swig_octave_class _wrap_class_CvSeq_CvRect = {"CvSeq_CvRect", &SWIGTYPE_p_CvTypedSeqT_CvRect_t,0,_wrap_new_CvSeq_CvRect,0,_wrap_delete_CvSeq_CvRect,swig_CvSeq_CvRect_members,swig_CvSeq_CvRect_base_names,swig_CvSeq_CvRect_base };

static octave_value_list _wrap_CvSeq_CvSeq_cast (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvSeq * > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvSeq_cast",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      result = (CvTypedSeq< CvSeq * > *)CvTypedSeq< CvSeq * >::SWIGTEMPLATEDISAMBIGUATOR cast(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvSeq___paren (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvSeq * > *arg1 = (CvTypedSeq< CvSeq * > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq **result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvSeq___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvSeq___paren" "', argument " "1"" of type '" "CvTypedSeq< CvSeq * > *""'"); 
  }
  arg1 = (CvTypedSeq< CvSeq * > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvSeq___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvSeq **)(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvSeq___paren_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvSeq * > *arg1 = (CvTypedSeq< CvSeq * > *) 0 ;
  int arg2 ;
  CvSeq **arg3 = (CvSeq **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *vptr3 ;
  CvSeq *buffer3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvSeq___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvSeq___paren_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvSeq * > *""'"); 
  }
  arg1 = (CvTypedSeq< CvSeq * > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvSeq___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_CvSeq, 1)) == -1){
      SWIG_fail;
    }
    buffer3 = (CvSeq *) vptr3;
    arg3=&buffer3;
  }
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvSeq___brace (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvSeq * > *arg1 = (CvTypedSeq< CvSeq * > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq **result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvSeq___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvSeq___brace" "', argument " "1"" of type '" "CvTypedSeq< CvSeq * > *""'"); 
  }
  arg1 = (CvTypedSeq< CvSeq * > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvSeq___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvSeq **)(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvSeq___brace_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvSeq * > *arg1 = (CvTypedSeq< CvSeq * > *) 0 ;
  int arg2 ;
  CvSeq **arg3 = (CvSeq **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *vptr3 ;
  CvSeq *buffer3 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvSeq___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvSeq___brace_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvSeq * > *""'"); 
  }
  arg1 = (CvTypedSeq< CvSeq * > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvSeq___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    if ((SWIG_ConvertPtr(args(2), &vptr3, SWIGTYPE_p_CvSeq, 1)) == -1){
      SWIG_fail;
    }
    buffer3 = (CvSeq *) vptr3;
    arg3=&buffer3;
  }
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvSeq_append (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvSeq * > *arg1 = (CvTypedSeq< CvSeq * > *) 0 ;
  CvSeq **arg2 = (CvSeq **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *vptr2 ;
  CvSeq *buffer2 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvSeq_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvSeq_append" "', argument " "1"" of type '" "CvTypedSeq< CvSeq * > *""'"); 
  }
  arg1 = (CvTypedSeq< CvSeq * > *)(argp1);
  {
    if ((SWIG_ConvertPtr(args(1), &vptr2, SWIGTYPE_p_CvSeq, 1)) == -1){
      SWIG_fail;
    }
    buffer2 = (CvSeq *) vptr2;
    arg2=&buffer2;
  }
  {
    try {
      (arg1)->append(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvSeq_pop (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvSeq * > *arg1 = (CvTypedSeq< CvSeq * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvSeq **result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvSeq_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvSeq_pop" "', argument " "1"" of type '" "CvTypedSeq< CvSeq * > *""'"); 
  }
  arg1 = (CvTypedSeq< CvSeq * > *)(argp1);
  {
    try {
      result = (CvSeq **)(arg1)->pop(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_CvSeq, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeq_CvSeq (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvSeq * > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeq_CvSeq",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypedSeq< CvSeq * > *)new CvTypedSeq< CvSeq * >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeq_CvSeq (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvSeq * > *arg1 = (CvTypedSeq< CvSeq * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeq_CvSeq",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeq_CvSeq" "', argument " "1"" of type '" "CvTypedSeq< CvSeq * > *""'"); 
  }
  arg1 = (CvTypedSeq< CvSeq * > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeq_CvSeq_members[] = {
{"cast",_wrap_CvSeq_CvSeq_cast,0,0,1,0},
{"__paren",_wrap_CvSeq_CvSeq___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvSeq_CvSeq___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvSeq_CvSeq___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvSeq_CvSeq___brace_asgn,0,0,0,0},
{"append",_wrap_CvSeq_CvSeq_append,0,0,0,0},
{"pop",_wrap_CvSeq_CvSeq_pop,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSeq_CvSeq_base_names[] = {"_p_CvSeq",0};
static const swig_type_info *swig_CvSeq_CvSeq_base[] = {0,0};
static swig_octave_class _wrap_class_CvSeq_CvSeq = {"CvSeq_CvSeq", &SWIGTYPE_p_CvTypedSeqT_CvSeq_p_t,0,_wrap_new_CvSeq_CvSeq,0,_wrap_delete_CvSeq_CvSeq,swig_CvSeq_CvSeq_members,swig_CvSeq_CvSeq_base_names,swig_CvSeq_CvSeq_base };

static octave_value_list _wrap_CvSeq_CvQuadEdge2D_cast (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvQuadEdge2D > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvQuadEdge2D_cast",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      result = (CvTypedSeq< CvQuadEdge2D > *)CvTypedSeq< CvQuadEdge2D >::SWIGTEMPLATEDISAMBIGUATOR cast(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvQuadEdge2D___paren (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvQuadEdge2D > *arg1 = (CvTypedSeq< CvQuadEdge2D > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvQuadEdge2D *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvQuadEdge2D___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvQuadEdge2D___paren" "', argument " "1"" of type '" "CvTypedSeq< CvQuadEdge2D > *""'"); 
  }
  arg1 = (CvTypedSeq< CvQuadEdge2D > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvQuadEdge2D___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvQuadEdge2D *)(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvQuadEdge2D___paren_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvQuadEdge2D > *arg1 = (CvTypedSeq< CvQuadEdge2D > *) 0 ;
  int arg2 ;
  CvQuadEdge2D *arg3 = (CvQuadEdge2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvQuadEdge2D___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvQuadEdge2D___paren_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvQuadEdge2D > *""'"); 
  }
  arg1 = (CvTypedSeq< CvQuadEdge2D > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvQuadEdge2D___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvQuadEdge2D___paren_asgn" "', argument " "3"" of type '" "CvQuadEdge2D *""'"); 
  }
  arg3 = (CvQuadEdge2D *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvQuadEdge2D___brace (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvQuadEdge2D > *arg1 = (CvTypedSeq< CvQuadEdge2D > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvQuadEdge2D *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvQuadEdge2D___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvQuadEdge2D___brace" "', argument " "1"" of type '" "CvTypedSeq< CvQuadEdge2D > *""'"); 
  }
  arg1 = (CvTypedSeq< CvQuadEdge2D > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvQuadEdge2D___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvQuadEdge2D *)(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvQuadEdge2D___brace_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvQuadEdge2D > *arg1 = (CvTypedSeq< CvQuadEdge2D > *) 0 ;
  int arg2 ;
  CvQuadEdge2D *arg3 = (CvQuadEdge2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvQuadEdge2D___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvQuadEdge2D___brace_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvQuadEdge2D > *""'"); 
  }
  arg1 = (CvTypedSeq< CvQuadEdge2D > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvQuadEdge2D___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvQuadEdge2D___brace_asgn" "', argument " "3"" of type '" "CvQuadEdge2D *""'"); 
  }
  arg3 = (CvQuadEdge2D *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvQuadEdge2D_append (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvQuadEdge2D > *arg1 = (CvTypedSeq< CvQuadEdge2D > *) 0 ;
  CvQuadEdge2D *arg2 = (CvQuadEdge2D *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvQuadEdge2D_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvQuadEdge2D_append" "', argument " "1"" of type '" "CvTypedSeq< CvQuadEdge2D > *""'"); 
  }
  arg1 = (CvTypedSeq< CvQuadEdge2D > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_CvQuadEdge2D_append" "', argument " "2"" of type '" "CvQuadEdge2D *""'"); 
  }
  arg2 = (CvQuadEdge2D *)(argp2);
  {
    try {
      (arg1)->append(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvQuadEdge2D_pop (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvQuadEdge2D > *arg1 = (CvTypedSeq< CvQuadEdge2D > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvQuadEdge2D *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvQuadEdge2D_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvQuadEdge2D_pop" "', argument " "1"" of type '" "CvTypedSeq< CvQuadEdge2D > *""'"); 
  }
  arg1 = (CvTypedSeq< CvQuadEdge2D > *)(argp1);
  {
    try {
      result = (CvQuadEdge2D *)(arg1)->pop(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvQuadEdge2D, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeq_CvQuadEdge2D (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvQuadEdge2D > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeq_CvQuadEdge2D",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypedSeq< CvQuadEdge2D > *)new CvTypedSeq< CvQuadEdge2D >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeq_CvQuadEdge2D (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvQuadEdge2D > *arg1 = (CvTypedSeq< CvQuadEdge2D > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeq_CvQuadEdge2D",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeq_CvQuadEdge2D" "', argument " "1"" of type '" "CvTypedSeq< CvQuadEdge2D > *""'"); 
  }
  arg1 = (CvTypedSeq< CvQuadEdge2D > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeq_CvQuadEdge2D_members[] = {
{"cast",_wrap_CvSeq_CvQuadEdge2D_cast,0,0,1,0},
{"__paren",_wrap_CvSeq_CvQuadEdge2D___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvSeq_CvQuadEdge2D___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvSeq_CvQuadEdge2D___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvSeq_CvQuadEdge2D___brace_asgn,0,0,0,0},
{"append",_wrap_CvSeq_CvQuadEdge2D_append,0,0,0,0},
{"pop",_wrap_CvSeq_CvQuadEdge2D_pop,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSeq_CvQuadEdge2D_base_names[] = {"_p_CvSeq",0};
static const swig_type_info *swig_CvSeq_CvQuadEdge2D_base[] = {0,0};
static swig_octave_class _wrap_class_CvSeq_CvQuadEdge2D = {"CvSeq_CvQuadEdge2D", &SWIGTYPE_p_CvTypedSeqT_CvQuadEdge2D_t,0,_wrap_new_CvSeq_CvQuadEdge2D,0,_wrap_delete_CvSeq_CvQuadEdge2D,swig_CvSeq_CvQuadEdge2D_members,swig_CvSeq_CvQuadEdge2D_base_names,swig_CvSeq_CvQuadEdge2D_base };

static octave_value_list _wrap_CvSeq_CvConnectedComp_cast (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvConnectedComp > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvConnectedComp_cast",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      result = (CvTypedSeq< CvConnectedComp > *)CvTypedSeq< CvConnectedComp >::SWIGTEMPLATEDISAMBIGUATOR cast(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvConnectedComp___paren (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvConnectedComp > *arg1 = (CvTypedSeq< CvConnectedComp > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvConnectedComp *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvConnectedComp___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvConnectedComp___paren" "', argument " "1"" of type '" "CvTypedSeq< CvConnectedComp > *""'"); 
  }
  arg1 = (CvTypedSeq< CvConnectedComp > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvConnectedComp___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvConnectedComp *)(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvConnectedComp___paren_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvConnectedComp > *arg1 = (CvTypedSeq< CvConnectedComp > *) 0 ;
  int arg2 ;
  CvConnectedComp *arg3 = (CvConnectedComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvConnectedComp___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvConnectedComp___paren_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvConnectedComp > *""'"); 
  }
  arg1 = (CvTypedSeq< CvConnectedComp > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvConnectedComp___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvConnectedComp___paren_asgn" "', argument " "3"" of type '" "CvConnectedComp *""'"); 
  }
  arg3 = (CvConnectedComp *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvConnectedComp___brace (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvConnectedComp > *arg1 = (CvTypedSeq< CvConnectedComp > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvConnectedComp *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvConnectedComp___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvConnectedComp___brace" "', argument " "1"" of type '" "CvTypedSeq< CvConnectedComp > *""'"); 
  }
  arg1 = (CvTypedSeq< CvConnectedComp > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvConnectedComp___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvConnectedComp *)(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvConnectedComp___brace_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvConnectedComp > *arg1 = (CvTypedSeq< CvConnectedComp > *) 0 ;
  int arg2 ;
  CvConnectedComp *arg3 = (CvConnectedComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvConnectedComp___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvConnectedComp___brace_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvConnectedComp > *""'"); 
  }
  arg1 = (CvTypedSeq< CvConnectedComp > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvConnectedComp___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvConnectedComp___brace_asgn" "', argument " "3"" of type '" "CvConnectedComp *""'"); 
  }
  arg3 = (CvConnectedComp *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvConnectedComp_append (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvConnectedComp > *arg1 = (CvTypedSeq< CvConnectedComp > *) 0 ;
  CvConnectedComp *arg2 = (CvConnectedComp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvConnectedComp_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvConnectedComp_append" "', argument " "1"" of type '" "CvTypedSeq< CvConnectedComp > *""'"); 
  }
  arg1 = (CvTypedSeq< CvConnectedComp > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_CvConnectedComp_append" "', argument " "2"" of type '" "CvConnectedComp *""'"); 
  }
  arg2 = (CvConnectedComp *)(argp2);
  {
    try {
      (arg1)->append(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvConnectedComp_pop (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvConnectedComp > *arg1 = (CvTypedSeq< CvConnectedComp > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvConnectedComp *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvConnectedComp_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvConnectedComp_pop" "', argument " "1"" of type '" "CvTypedSeq< CvConnectedComp > *""'"); 
  }
  arg1 = (CvTypedSeq< CvConnectedComp > *)(argp1);
  {
    try {
      result = (CvConnectedComp *)(arg1)->pop(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvConnectedComp, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeq_CvConnectedComp (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvConnectedComp > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeq_CvConnectedComp",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypedSeq< CvConnectedComp > *)new CvTypedSeq< CvConnectedComp >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeq_CvConnectedComp (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvConnectedComp > *arg1 = (CvTypedSeq< CvConnectedComp > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeq_CvConnectedComp",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeq_CvConnectedComp" "', argument " "1"" of type '" "CvTypedSeq< CvConnectedComp > *""'"); 
  }
  arg1 = (CvTypedSeq< CvConnectedComp > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeq_CvConnectedComp_members[] = {
{"cast",_wrap_CvSeq_CvConnectedComp_cast,0,0,1,0},
{"__paren",_wrap_CvSeq_CvConnectedComp___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvSeq_CvConnectedComp___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvSeq_CvConnectedComp___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvSeq_CvConnectedComp___brace_asgn,0,0,0,0},
{"append",_wrap_CvSeq_CvConnectedComp_append,0,0,0,0},
{"pop",_wrap_CvSeq_CvConnectedComp_pop,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSeq_CvConnectedComp_base_names[] = {"_p_CvSeq",0};
static const swig_type_info *swig_CvSeq_CvConnectedComp_base[] = {0,0};
static swig_octave_class _wrap_class_CvSeq_CvConnectedComp = {"CvSeq_CvConnectedComp", &SWIGTYPE_p_CvTypedSeqT_CvConnectedComp_t,0,_wrap_new_CvSeq_CvConnectedComp,0,_wrap_delete_CvSeq_CvConnectedComp,swig_CvSeq_CvConnectedComp_members,swig_CvSeq_CvConnectedComp_base_names,swig_CvSeq_CvConnectedComp_base };

static octave_value_list _wrap_CvSeq_CvPoint_2_cast (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvTuple< CvPoint,2 > > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint_2_cast",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      result = (CvTypedSeq< CvTuple< CvPoint,2 > > *)CvTypedSeq< CvTuple< CvPoint,2 > >::SWIGTEMPLATEDISAMBIGUATOR cast(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint_2___paren (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< CvPoint,2 > > *arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< CvPoint,2 > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint_2___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint_2___paren" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< CvPoint,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint_2___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvTuple< CvPoint,2 > *)(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint_2___paren_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< CvPoint,2 > > *arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *) 0 ;
  int arg2 ;
  CvTuple< CvPoint,2 > *arg3 = (CvTuple< CvPoint,2 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint_2___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint_2___paren_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< CvPoint,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint_2___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvPoint_2___paren_asgn" "', argument " "3"" of type '" "CvTuple< CvPoint,2 > *""'"); 
  }
  arg3 = (CvTuple< CvPoint,2 > *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint_2___brace (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< CvPoint,2 > > *arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< CvPoint,2 > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint_2___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint_2___brace" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< CvPoint,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint_2___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvTuple< CvPoint,2 > *)(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint_2___brace_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< CvPoint,2 > > *arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *) 0 ;
  int arg2 ;
  CvTuple< CvPoint,2 > *arg3 = (CvTuple< CvPoint,2 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint_2___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint_2___brace_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< CvPoint,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_CvPoint_2___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_CvPoint_2___brace_asgn" "', argument " "3"" of type '" "CvTuple< CvPoint,2 > *""'"); 
  }
  arg3 = (CvTuple< CvPoint,2 > *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint_2_append (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< CvPoint,2 > > *arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *) 0 ;
  CvTuple< CvPoint,2 > *arg2 = (CvTuple< CvPoint,2 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint_2_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint_2_append" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< CvPoint,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_CvPoint_2_append" "', argument " "2"" of type '" "CvTuple< CvPoint,2 > *""'"); 
  }
  arg2 = (CvTuple< CvPoint,2 > *)(argp2);
  {
    try {
      (arg1)->append(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_CvPoint_2_pop (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< CvPoint,2 > > *arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< CvPoint,2 > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_CvPoint_2_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_CvPoint_2_pop" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< CvPoint,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *)(argp1);
  {
    try {
      result = (CvTuple< CvPoint,2 > *)(arg1)->pop(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_CvPoint_2_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeq_CvPoint_2 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvTuple< CvPoint,2 > > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeq_CvPoint_2",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypedSeq< CvTuple< CvPoint,2 > > *)new CvTypedSeq< CvTuple< CvPoint,2 > >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeq_CvPoint_2 (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< CvPoint,2 > > *arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeq_CvPoint_2",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeq_CvPoint_2" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< CvPoint,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< CvPoint,2 > > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeq_CvPoint_2_members[] = {
{"cast",_wrap_CvSeq_CvPoint_2_cast,0,0,1,0},
{"__paren",_wrap_CvSeq_CvPoint_2___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvSeq_CvPoint_2___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvSeq_CvPoint_2___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvSeq_CvPoint_2___brace_asgn,0,0,0,0},
{"append",_wrap_CvSeq_CvPoint_2_append,0,0,0,0},
{"pop",_wrap_CvSeq_CvPoint_2_pop,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSeq_CvPoint_2_base_names[] = {"_p_CvSeq",0};
static const swig_type_info *swig_CvSeq_CvPoint_2_base[] = {0,0};
static swig_octave_class _wrap_class_CvSeq_CvPoint_2 = {"CvSeq_CvPoint_2", &SWIGTYPE_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t,0,_wrap_new_CvSeq_CvPoint_2,0,_wrap_delete_CvSeq_CvPoint_2,swig_CvSeq_CvPoint_2_members,swig_CvSeq_CvPoint_2_base_names,swig_CvSeq_CvPoint_2_base };

static octave_value_list _wrap_CvSeq_float_2_cast (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvTuple< float,2 > > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_float_2_cast",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      result = (CvTypedSeq< CvTuple< float,2 > > *)CvTypedSeq< CvTuple< float,2 > >::SWIGTEMPLATEDISAMBIGUATOR cast(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_2___paren (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,2 > > *arg1 = (CvTypedSeq< CvTuple< float,2 > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< float,2 > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_float_2___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_2___paren" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,2 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_float_2___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvTuple< float,2 > *)(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_2___paren_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,2 > > *arg1 = (CvTypedSeq< CvTuple< float,2 > > *) 0 ;
  int arg2 ;
  CvTuple< float,2 > *arg3 = (CvTuple< float,2 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_float_2___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_2___paren_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,2 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_float_2___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_float_2___paren_asgn" "', argument " "3"" of type '" "CvTuple< float,2 > *""'"); 
  }
  arg3 = (CvTuple< float,2 > *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_2___brace (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,2 > > *arg1 = (CvTypedSeq< CvTuple< float,2 > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< float,2 > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_float_2___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_2___brace" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,2 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_float_2___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvTuple< float,2 > *)(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_2___brace_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,2 > > *arg1 = (CvTypedSeq< CvTuple< float,2 > > *) 0 ;
  int arg2 ;
  CvTuple< float,2 > *arg3 = (CvTuple< float,2 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_float_2___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_2___brace_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,2 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_float_2___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_float_2___brace_asgn" "', argument " "3"" of type '" "CvTuple< float,2 > *""'"); 
  }
  arg3 = (CvTuple< float,2 > *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_2_append (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,2 > > *arg1 = (CvTypedSeq< CvTuple< float,2 > > *) 0 ;
  CvTuple< float,2 > *arg2 = (CvTuple< float,2 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_float_2_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_2_append" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,2 > > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_float_2_append" "', argument " "2"" of type '" "CvTuple< float,2 > *""'"); 
  }
  arg2 = (CvTuple< float,2 > *)(argp2);
  {
    try {
      (arg1)->append(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_2_pop (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,2 > > *arg1 = (CvTypedSeq< CvTuple< float,2 > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< float,2 > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_float_2_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_2_pop" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,2 > > *)(argp1);
  {
    try {
      result = (CvTuple< float,2 > *)(arg1)->pop(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_float_2_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeq_float_2 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvTuple< float,2 > > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeq_float_2",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypedSeq< CvTuple< float,2 > > *)new CvTypedSeq< CvTuple< float,2 > >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeq_float_2 (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,2 > > *arg1 = (CvTypedSeq< CvTuple< float,2 > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeq_float_2",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeq_float_2" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,2 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,2 > > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeq_float_2_members[] = {
{"cast",_wrap_CvSeq_float_2_cast,0,0,1,0},
{"__paren",_wrap_CvSeq_float_2___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvSeq_float_2___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvSeq_float_2___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvSeq_float_2___brace_asgn,0,0,0,0},
{"append",_wrap_CvSeq_float_2_append,0,0,0,0},
{"pop",_wrap_CvSeq_float_2_pop,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSeq_float_2_base_names[] = {"_p_CvSeq",0};
static const swig_type_info *swig_CvSeq_float_2_base[] = {0,0};
static swig_octave_class _wrap_class_CvSeq_float_2 = {"CvSeq_float_2", &SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_2_t_t,0,_wrap_new_CvSeq_float_2,0,_wrap_delete_CvSeq_float_2,swig_CvSeq_float_2_members,swig_CvSeq_float_2_base_names,swig_CvSeq_float_2_base };

static octave_value_list _wrap_CvSeq_float_3_cast (const octave_value_list& args, int nargout) {
  CvSeq *arg1 = (CvSeq *) 0 ;
  void *ptr1 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvTuple< float,3 > > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_float_3_cast",args.length(),1,1,0)) {
    SWIG_fail;
  }
  {
    if( SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSeq, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSet, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvGraph, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvSubdiv2D, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvChain, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContour, 0) == -1 &&
      SWIG_ConvertPtr(args(0), &ptr1, SWIGTYPE_p_CvContourTree, 0) == -1 )
    {
      SWIG_exception (SWIG_TypeError, "could not convert to CvSeq");
      SWIG_fail;
    }
    arg1 = (CvSeq *) ptr1;
  }
  {
    try {
      result = (CvTypedSeq< CvTuple< float,3 > > *)CvTypedSeq< CvTuple< float,3 > >::SWIGTEMPLATEDISAMBIGUATOR cast(arg1); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_3___paren (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,3 > > *arg1 = (CvTypedSeq< CvTuple< float,3 > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< float,3 > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_float_3___paren",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_3___paren" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,3 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,3 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_float_3___paren" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvTuple< float,3 > *)(arg1)->__paren(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_3___paren_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,3 > > *arg1 = (CvTypedSeq< CvTuple< float,3 > > *) 0 ;
  int arg2 ;
  CvTuple< float,3 > *arg3 = (CvTuple< float,3 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_float_3___paren_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_3___paren_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,3 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,3 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_float_3___paren_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_float_3___paren_asgn" "', argument " "3"" of type '" "CvTuple< float,3 > *""'"); 
  }
  arg3 = (CvTuple< float,3 > *)(argp3);
  {
    try {
      (arg1)->__paren_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_3___brace (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,3 > > *arg1 = (CvTypedSeq< CvTuple< float,3 > > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< float,3 > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_float_3___brace",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_3___brace" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,3 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,3 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_float_3___brace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  {
    try {
      result = (CvTuple< float,3 > *)(arg1)->__brace(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_3___brace_asgn (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,3 > > *arg1 = (CvTypedSeq< CvTuple< float,3 > > *) 0 ;
  int arg2 ;
  CvTuple< float,3 > *arg3 = (CvTuple< float,3 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_float_3___brace_asgn",args.length(),3,3,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_3___brace_asgn" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,3 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,3 > > *)(argp1);
  ecode2 = SWIG_AsVal_int(args(1), &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CvSeq_float_3___brace_asgn" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = (int)(val2);
  res3 = SWIG_ConvertPtr(args(2), &argp3,SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CvSeq_float_3___brace_asgn" "', argument " "3"" of type '" "CvTuple< float,3 > *""'"); 
  }
  arg3 = (CvTuple< float,3 > *)(argp3);
  {
    try {
      (arg1)->__brace_asgn(arg2,arg3); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_3_append (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,3 > > *arg1 = (CvTypedSeq< CvTuple< float,3 > > *) 0 ;
  CvTuple< float,3 > *arg2 = (CvTuple< float,3 > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("CvSeq_float_3_append",args.length(),2,2,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_3_append" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,3 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,3 > > *)(argp1);
  res2 = SWIG_ConvertPtr(args(1), &argp2,SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CvSeq_float_3_append" "', argument " "2"" of type '" "CvTuple< float,3 > *""'"); 
  }
  arg2 = (CvTuple< float,3 > *)(argp2);
  {
    try {
      (arg1)->append(arg2); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_CvSeq_float_3_pop (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,3 > > *arg1 = (CvTypedSeq< CvTuple< float,3 > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTuple< float,3 > *result = 0 ;
  
  if (!SWIG_check_num_args("CvSeq_float_3_pop",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CvSeq_float_3_pop" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,3 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,3 > > *)(argp1);
  {
    try {
      result = (CvTuple< float,3 > *)(arg1)->pop(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTupleT_float_3_t, 0 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_new_CvSeq_float_3 (const octave_value_list& args, int nargout) {
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  CvTypedSeq< CvTuple< float,3 > > *result = 0 ;
  
  if (!SWIG_check_num_args("new_CvSeq_float_3",args.length(),0,0,0)) {
    SWIG_fail;
  }
  {
    try {
      result = (CvTypedSeq< CvTuple< float,3 > > *)new CvTypedSeq< CvTuple< float,3 > >(); 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t, 1 |  0 );
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static octave_value_list _wrap_delete_CvSeq_float_3 (const octave_value_list& args, int nargout) {
  CvTypedSeq< CvTuple< float,3 > > *arg1 = (CvTypedSeq< CvTuple< float,3 > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  octave_value_list _out;
  octave_value_list *_outp=&_out;
  octave_value _outv;
  
  if (!SWIG_check_num_args("delete_CvSeq_float_3",args.length(),1,1,0)) {
    SWIG_fail;
  }
  res1 = SWIG_ConvertPtr(args(0), &argp1,SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CvSeq_float_3" "', argument " "1"" of type '" "CvTypedSeq< CvTuple< float,3 > > *""'"); 
  }
  arg1 = (CvTypedSeq< CvTuple< float,3 > > *)(argp1);
  {
    try {
      delete arg1; 
    } 
    catch (...) 
    {
      SWIG_fail;
    } 
  }
  _outv = octave_value();
  if (_outv.is_defined()) _outp = SWIG_Octave_AppendOutput(_outp, _outv);
fail:
  return _out;
}


static swig_octave_member swig_CvSeq_float_3_members[] = {
{"cast",_wrap_CvSeq_float_3_cast,0,0,1,0},
{"__paren",_wrap_CvSeq_float_3___paren,0,0,0,0},
{"__paren_asgn",_wrap_CvSeq_float_3___paren_asgn,0,0,0,0},
{"__brace",_wrap_CvSeq_float_3___brace,0,0,0,0},
{"__brace_asgn",_wrap_CvSeq_float_3___brace_asgn,0,0,0,0},
{"append",_wrap_CvSeq_float_3_append,0,0,0,0},
{"pop",_wrap_CvSeq_float_3_pop,0,0,0,0},
{0,0,0,0}
};
static const char *swig_CvSeq_float_3_base_names[] = {"_p_CvSeq",0};
static const swig_type_info *swig_CvSeq_float_3_base[] = {0,0};
static swig_octave_class _wrap_class_CvSeq_float_3 = {"CvSeq_float_3", &SWIGTYPE_p_CvTypedSeqT_CvTupleT_float_3_t_t,0,_wrap_new_CvSeq_float_3,0,_wrap_delete_CvSeq_float_3,swig_CvSeq_float_3_members,swig_CvSeq_float_3_base_names,swig_CvSeq_float_3_base };


static const struct swig_octave_member swig_globals[] = {
{"new_CvRNG_Wrapper",_wrap_new_CvRNG_Wrapper,0,0,2,_wrap_new_CvRNG_Wrapper_texinfo},
{"CvRNG_Wrapper_ptr",_wrap_CvRNG_Wrapper_ptr,0,0,2,_wrap_CvRNG_Wrapper_ptr_texinfo},
{"CvRNG_Wrapper_ref",_wrap_CvRNG_Wrapper_ref,0,0,2,_wrap_CvRNG_Wrapper_ref_texinfo},
{"CvRNG_Wrapper___eq__",_wrap_CvRNG_Wrapper___eq__,0,0,2,_wrap_CvRNG_Wrapper___eq___texinfo},
{"CvRNG_Wrapper___ne__",_wrap_CvRNG_Wrapper___ne__,0,0,2,_wrap_CvRNG_Wrapper___ne___texinfo},
{"delete_CvRNG_Wrapper",_wrap_delete_CvRNG_Wrapper,0,0,2,_wrap_delete_CvRNG_Wrapper_texinfo},
{"new_CvSubdiv2DEdge_Wrapper",_wrap_new_CvSubdiv2DEdge_Wrapper,0,0,2,_wrap_new_CvSubdiv2DEdge_Wrapper_texinfo},
{"CvSubdiv2DEdge_Wrapper_ptr",_wrap_CvSubdiv2DEdge_Wrapper_ptr,0,0,2,_wrap_CvSubdiv2DEdge_Wrapper_ptr_texinfo},
{"CvSubdiv2DEdge_Wrapper_ref",_wrap_CvSubdiv2DEdge_Wrapper_ref,0,0,2,_wrap_CvSubdiv2DEdge_Wrapper_ref_texinfo},
{"CvSubdiv2DEdge_Wrapper___eq__",_wrap_CvSubdiv2DEdge_Wrapper___eq__,0,0,2,_wrap_CvSubdiv2DEdge_Wrapper___eq___texinfo},
{"CvSubdiv2DEdge_Wrapper___ne__",_wrap_CvSubdiv2DEdge_Wrapper___ne__,0,0,2,_wrap_CvSubdiv2DEdge_Wrapper___ne___texinfo},
{"delete_CvSubdiv2DEdge_Wrapper",_wrap_delete_CvSubdiv2DEdge_Wrapper,0,0,2,_wrap_delete_CvSubdiv2DEdge_Wrapper_texinfo},
{"delete_OctSwigIterator",_wrap_delete_OctSwigIterator,0,0,2,_wrap_delete_OctSwigIterator_texinfo},
{"OctSwigIterator_value",_wrap_OctSwigIterator_value,0,0,2,_wrap_OctSwigIterator_value_texinfo},
{"OctSwigIterator_incr",_wrap_OctSwigIterator_incr,0,0,2,_wrap_OctSwigIterator_incr_texinfo},
{"OctSwigIterator_decr",_wrap_OctSwigIterator_decr,0,0,2,_wrap_OctSwigIterator_decr_texinfo},
{"OctSwigIterator_distance",_wrap_OctSwigIterator_distance,0,0,2,_wrap_OctSwigIterator_distance_texinfo},
{"OctSwigIterator_equal",_wrap_OctSwigIterator_equal,0,0,2,_wrap_OctSwigIterator_equal_texinfo},
{"OctSwigIterator_copy",_wrap_OctSwigIterator_copy,0,0,2,_wrap_OctSwigIterator_copy_texinfo},
{"OctSwigIterator_next",_wrap_OctSwigIterator_next,0,0,2,_wrap_OctSwigIterator_next_texinfo},
{"OctSwigIterator_previous",_wrap_OctSwigIterator_previous,0,0,2,_wrap_OctSwigIterator_previous_texinfo},
{"OctSwigIterator_advance",_wrap_OctSwigIterator_advance,0,0,2,_wrap_OctSwigIterator_advance_texinfo},
{"OctSwigIterator___eq__",_wrap_OctSwigIterator___eq__,0,0,2,_wrap_OctSwigIterator___eq___texinfo},
{"OctSwigIterator___ne__",_wrap_OctSwigIterator___ne__,0,0,2,_wrap_OctSwigIterator___ne___texinfo},
{"OctSwigIterator___incr__",_wrap_OctSwigIterator___incr__,0,0,2,_wrap_OctSwigIterator___incr___texinfo},
{"OctSwigIterator___decr__",_wrap_OctSwigIterator___decr__,0,0,2,_wrap_OctSwigIterator___decr___texinfo},
{"OctSwigIterator___add__",_wrap_OctSwigIterator___add__,0,0,2,_wrap_OctSwigIterator___add___texinfo},
{"OctSwigIterator___sub__",_wrap_OctSwigIterator___sub__,0,0,2,_wrap_OctSwigIterator___sub___texinfo},
{"FloatVector_pop",_wrap_FloatVector_pop,0,0,2,_wrap_FloatVector_pop_texinfo},
{"FloatVector___paren__",_wrap_FloatVector___paren__,0,0,2,_wrap_FloatVector___paren___texinfo},
{"FloatVector___paren_asgn__",_wrap_FloatVector___paren_asgn__,0,0,2,_wrap_FloatVector___paren_asgn___texinfo},
{"FloatVector_append",_wrap_FloatVector_append,0,0,2,_wrap_FloatVector_append_texinfo},
{"FloatVector_empty",_wrap_FloatVector_empty,0,0,2,_wrap_FloatVector_empty_texinfo},
{"FloatVector_size",_wrap_FloatVector_size,0,0,2,_wrap_FloatVector_size_texinfo},
{"FloatVector_clear",_wrap_FloatVector_clear,0,0,2,_wrap_FloatVector_clear_texinfo},
{"FloatVector_swap",_wrap_FloatVector_swap,0,0,2,_wrap_FloatVector_swap_texinfo},
{"FloatVector_get_allocator",_wrap_FloatVector_get_allocator,0,0,2,_wrap_FloatVector_get_allocator_texinfo},
{"FloatVector_begin",_wrap_FloatVector_begin,0,0,2,_wrap_FloatVector_begin_texinfo},
{"FloatVector_end",_wrap_FloatVector_end,0,0,2,_wrap_FloatVector_end_texinfo},
{"FloatVector_rbegin",_wrap_FloatVector_rbegin,0,0,2,_wrap_FloatVector_rbegin_texinfo},
{"FloatVector_rend",_wrap_FloatVector_rend,0,0,2,_wrap_FloatVector_rend_texinfo},
{"FloatVector_pop_back",_wrap_FloatVector_pop_back,0,0,2,_wrap_FloatVector_pop_back_texinfo},
{"FloatVector_erase",_wrap_FloatVector_erase,0,0,2,_wrap_FloatVector_erase_texinfo},
{"new_FloatVector",_wrap_new_FloatVector,0,0,2,_wrap_new_FloatVector_texinfo},
{"FloatVector_push_back",_wrap_FloatVector_push_back,0,0,2,_wrap_FloatVector_push_back_texinfo},
{"FloatVector_front",_wrap_FloatVector_front,0,0,2,_wrap_FloatVector_front_texinfo},
{"FloatVector_back",_wrap_FloatVector_back,0,0,2,_wrap_FloatVector_back_texinfo},
{"FloatVector_assign",_wrap_FloatVector_assign,0,0,2,_wrap_FloatVector_assign_texinfo},
{"FloatVector_resize",_wrap_FloatVector_resize,0,0,2,_wrap_FloatVector_resize_texinfo},
{"FloatVector_insert",_wrap_FloatVector_insert,0,0,2,_wrap_FloatVector_insert_texinfo},
{"FloatVector_reserve",_wrap_FloatVector_reserve,0,0,2,_wrap_FloatVector_reserve_texinfo},
{"FloatVector_capacity",_wrap_FloatVector_capacity,0,0,2,_wrap_FloatVector_capacity_texinfo},
{"delete_FloatVector",_wrap_delete_FloatVector,0,0,2,_wrap_delete_FloatVector_texinfo},
{"CvPointVector_pop",_wrap_CvPointVector_pop,0,0,2,_wrap_CvPointVector_pop_texinfo},
{"CvPointVector___paren__",_wrap_CvPointVector___paren__,0,0,2,_wrap_CvPointVector___paren___texinfo},
{"CvPointVector___paren_asgn__",_wrap_CvPointVector___paren_asgn__,0,0,2,_wrap_CvPointVector___paren_asgn___texinfo},
{"CvPointVector_append",_wrap_CvPointVector_append,0,0,2,_wrap_CvPointVector_append_texinfo},
{"CvPointVector_empty",_wrap_CvPointVector_empty,0,0,2,_wrap_CvPointVector_empty_texinfo},
{"CvPointVector_size",_wrap_CvPointVector_size,0,0,2,_wrap_CvPointVector_size_texinfo},
{"CvPointVector_clear",_wrap_CvPointVector_clear,0,0,2,_wrap_CvPointVector_clear_texinfo},
{"CvPointVector_swap",_wrap_CvPointVector_swap,0,0,2,_wrap_CvPointVector_swap_texinfo},
{"CvPointVector_get_allocator",_wrap_CvPointVector_get_allocator,0,0,2,_wrap_CvPointVector_get_allocator_texinfo},
{"CvPointVector_begin",_wrap_CvPointVector_begin,0,0,2,_wrap_CvPointVector_begin_texinfo},
{"CvPointVector_end",_wrap_CvPointVector_end,0,0,2,_wrap_CvPointVector_end_texinfo},
{"CvPointVector_rbegin",_wrap_CvPointVector_rbegin,0,0,2,_wrap_CvPointVector_rbegin_texinfo},
{"CvPointVector_rend",_wrap_CvPointVector_rend,0,0,2,_wrap_CvPointVector_rend_texinfo},
{"CvPointVector_pop_back",_wrap_CvPointVector_pop_back,0,0,2,_wrap_CvPointVector_pop_back_texinfo},
{"CvPointVector_erase",_wrap_CvPointVector_erase,0,0,2,_wrap_CvPointVector_erase_texinfo},
{"new_CvPointVector",_wrap_new_CvPointVector,0,0,2,_wrap_new_CvPointVector_texinfo},
{"CvPointVector_push_back",_wrap_CvPointVector_push_back,0,0,2,_wrap_CvPointVector_push_back_texinfo},
{"CvPointVector_front",_wrap_CvPointVector_front,0,0,2,_wrap_CvPointVector_front_texinfo},
{"CvPointVector_back",_wrap_CvPointVector_back,0,0,2,_wrap_CvPointVector_back_texinfo},
{"CvPointVector_assign",_wrap_CvPointVector_assign,0,0,2,_wrap_CvPointVector_assign_texinfo},
{"CvPointVector_resize",_wrap_CvPointVector_resize,0,0,2,_wrap_CvPointVector_resize_texinfo},
{"CvPointVector_insert",_wrap_CvPointVector_insert,0,0,2,_wrap_CvPointVector_insert_texinfo},
{"CvPointVector_reserve",_wrap_CvPointVector_reserve,0,0,2,_wrap_CvPointVector_reserve_texinfo},
{"CvPointVector_capacity",_wrap_CvPointVector_capacity,0,0,2,_wrap_CvPointVector_capacity_texinfo},
{"delete_CvPointVector",_wrap_delete_CvPointVector,0,0,2,_wrap_delete_CvPointVector_texinfo},
{"cvCvtSeqToArray",_wrap_cvCvtSeqToArray,0,0,2,_wrap_cvCvtSeqToArray_texinfo},
{"cvArcLength",_wrap_cvArcLength,0,0,2,_wrap_cvArcLength_texinfo},
{"cvContourPerimeter",_wrap_cvContourPerimeter,0,0,2,_wrap_cvContourPerimeter_texinfo},
{"cvHaarDetectObjects",_wrap_cvHaarDetectObjects,0,0,2,_wrap_cvHaarDetectObjects_texinfo},
{"cvSegmentMotion",_wrap_cvSegmentMotion,0,0,2,_wrap_cvSegmentMotion_texinfo},
{"cvApproxPoly",_wrap_cvApproxPoly,0,0,2,_wrap_cvApproxPoly_texinfo},
{"cvConvexHull2",_wrap_cvConvexHull2,0,0,2,_wrap_cvConvexHull2_texinfo},
{"cvSnakeImage",_wrap_cvSnakeImage,0,0,2,_wrap_cvSnakeImage_texinfo},
{"cvFree",_wrap_cvFree,0,0,2,_wrap_cvFree_texinfo},
{"CV_READ_CHAIN_POINT",_wrap_CV_READ_CHAIN_POINT,0,0,2,_wrap_CV_READ_CHAIN_POINT_texinfo},
{"CV_MAT_ELEM_PTR",_wrap_CV_MAT_ELEM_PTR,0,0,2,_wrap_CV_MAT_ELEM_PTR_texinfo},
{"CV_MAT_ELEM_PTR_FAST",_wrap_CV_MAT_ELEM_PTR_FAST,0,0,2,_wrap_CV_MAT_ELEM_PTR_FAST_texinfo},
{"CV_NODE_VAL",_wrap_CV_NODE_VAL,0,0,2,_wrap_CV_NODE_VAL_texinfo},
{"CV_NODE_IDX",_wrap_CV_NODE_IDX,0,0,2,_wrap_CV_NODE_IDX_texinfo},
{"CV_SUBDIV2D_NEXT_EDGE",_wrap_CV_SUBDIV2D_NEXT_EDGE,0,0,2,_wrap_CV_SUBDIV2D_NEXT_EDGE_texinfo},
{"CV_SWAP",_wrap_CV_SWAP,0,0,2,_wrap_CV_SWAP_texinfo},
{"CV_IMIN",_wrap_CV_IMIN,0,0,2,_wrap_CV_IMIN_texinfo},
{"CV_IMAX",_wrap_CV_IMAX,0,0,2,_wrap_CV_IMAX_texinfo},
{"CV_IABS",_wrap_CV_IABS,0,0,2,_wrap_CV_IABS_texinfo},
{"CV_CMP",_wrap_CV_CMP,0,0,2,_wrap_CV_CMP_texinfo},
{"CV_SIGN",_wrap_CV_SIGN,0,0,2,_wrap_CV_SIGN_texinfo},
{"cvInvSqrt",_wrap_cvInvSqrt,0,0,2,_wrap_cvInvSqrt_texinfo},
{"cvSqrt",_wrap_cvSqrt,0,0,2,_wrap_cvSqrt_texinfo},
{"CV_IS_IMAGE_HDR",_wrap_CV_IS_IMAGE_HDR,0,0,2,_wrap_CV_IS_IMAGE_HDR_texinfo},
{"CV_IS_IMAGE",_wrap_CV_IS_IMAGE,0,0,2,_wrap_CV_IS_IMAGE_texinfo},
{"CV_MAT_DEPTH",_wrap_CV_MAT_DEPTH,0,0,2,_wrap_CV_MAT_DEPTH_texinfo},
{"CV_MAKETYPE",_wrap_CV_MAKETYPE,0,0,2,_wrap_CV_MAKETYPE_texinfo},
{"CV_8UC",_wrap_CV_8UC,0,0,2,_wrap_CV_8UC_texinfo},
{"CV_8SC",_wrap_CV_8SC,0,0,2,_wrap_CV_8SC_texinfo},
{"CV_16UC",_wrap_CV_16UC,0,0,2,_wrap_CV_16UC_texinfo},
{"CV_16SC",_wrap_CV_16SC,0,0,2,_wrap_CV_16SC_texinfo},
{"CV_32SC",_wrap_CV_32SC,0,0,2,_wrap_CV_32SC_texinfo},
{"CV_32FC",_wrap_CV_32FC,0,0,2,_wrap_CV_32FC_texinfo},
{"CV_64FC",_wrap_CV_64FC,0,0,2,_wrap_CV_64FC_texinfo},
{"CV_MAT_CN",_wrap_CV_MAT_CN,0,0,2,_wrap_CV_MAT_CN_texinfo},
{"CV_MAT_TYPE",_wrap_CV_MAT_TYPE,0,0,2,_wrap_CV_MAT_TYPE_texinfo},
{"CV_IS_MAT_CONT",_wrap_CV_IS_MAT_CONT,0,0,2,_wrap_CV_IS_MAT_CONT_texinfo},
{"CV_IS_TEMP_MAT",_wrap_CV_IS_TEMP_MAT,0,0,2,_wrap_CV_IS_TEMP_MAT_texinfo},
{"CV_IS_MAT_HDR",_wrap_CV_IS_MAT_HDR,0,0,2,_wrap_CV_IS_MAT_HDR_texinfo},
{"CV_IS_MAT",_wrap_CV_IS_MAT,0,0,2,_wrap_CV_IS_MAT_texinfo},
{"CV_IS_MASK_ARR",_wrap_CV_IS_MASK_ARR,0,0,2,_wrap_CV_IS_MASK_ARR_texinfo},
{"CV_ARE_TYPES_EQ",_wrap_CV_ARE_TYPES_EQ,0,0,2,_wrap_CV_ARE_TYPES_EQ_texinfo},
{"CV_ARE_CNS_EQ",_wrap_CV_ARE_CNS_EQ,0,0,2,_wrap_CV_ARE_CNS_EQ_texinfo},
{"CV_ARE_DEPTHS_EQ",_wrap_CV_ARE_DEPTHS_EQ,0,0,2,_wrap_CV_ARE_DEPTHS_EQ_texinfo},
{"CV_ARE_SIZES_EQ",_wrap_CV_ARE_SIZES_EQ,0,0,2,_wrap_CV_ARE_SIZES_EQ_texinfo},
{"CV_IS_MAT_CONST",_wrap_CV_IS_MAT_CONST,0,0,2,_wrap_CV_IS_MAT_CONST_texinfo},
{"CV_ELEM_SIZE1",_wrap_CV_ELEM_SIZE1,0,0,2,_wrap_CV_ELEM_SIZE1_texinfo},
{"CV_ELEM_SIZE",_wrap_CV_ELEM_SIZE,0,0,2,_wrap_CV_ELEM_SIZE_texinfo},
{"CV_IS_MATND_HDR",_wrap_CV_IS_MATND_HDR,0,0,2,_wrap_CV_IS_MATND_HDR_texinfo},
{"CV_IS_MATND",_wrap_CV_IS_MATND,0,0,2,_wrap_CV_IS_MATND_texinfo},
{"CV_IS_SPARSE_MAT_HDR",_wrap_CV_IS_SPARSE_MAT_HDR,0,0,2,_wrap_CV_IS_SPARSE_MAT_HDR_texinfo},
{"CV_IS_SPARSE_MAT",_wrap_CV_IS_SPARSE_MAT,0,0,2,_wrap_CV_IS_SPARSE_MAT_texinfo},
{"CV_IS_HIST",_wrap_CV_IS_HIST,0,0,2,_wrap_CV_IS_HIST_texinfo},
{"CV_IS_UNIFORM_HIST",_wrap_CV_IS_UNIFORM_HIST,0,0,2,_wrap_CV_IS_UNIFORM_HIST_texinfo},
{"CV_IS_SPARSE_HIST",_wrap_CV_IS_SPARSE_HIST,0,0,2,_wrap_CV_IS_SPARSE_HIST_texinfo},
{"CV_HIST_HAS_RANGES",_wrap_CV_HIST_HAS_RANGES,0,0,2,_wrap_CV_HIST_HAS_RANGES_texinfo},
{"CV_IS_STORAGE",_wrap_CV_IS_STORAGE,0,0,2,_wrap_CV_IS_STORAGE_texinfo},
{"CV_IS_SET_ELEM",_wrap_CV_IS_SET_ELEM,0,0,2,_wrap_CV_IS_SET_ELEM_texinfo},
{"CV_IS_SEQ",_wrap_CV_IS_SEQ,0,0,2,_wrap_CV_IS_SEQ_texinfo},
{"CV_IS_SET",_wrap_CV_IS_SET,0,0,2,_wrap_CV_IS_SET_texinfo},
{"CV_SEQ_ELTYPE",_wrap_CV_SEQ_ELTYPE,0,0,2,_wrap_CV_SEQ_ELTYPE_texinfo},
{"CV_SEQ_KIND",_wrap_CV_SEQ_KIND,0,0,2,_wrap_CV_SEQ_KIND_texinfo},
{"CV_IS_SEQ_INDEX",_wrap_CV_IS_SEQ_INDEX,0,0,2,_wrap_CV_IS_SEQ_INDEX_texinfo},
{"CV_IS_SEQ_CURVE",_wrap_CV_IS_SEQ_CURVE,0,0,2,_wrap_CV_IS_SEQ_CURVE_texinfo},
{"CV_IS_SEQ_CLOSED",_wrap_CV_IS_SEQ_CLOSED,0,0,2,_wrap_CV_IS_SEQ_CLOSED_texinfo},
{"CV_IS_SEQ_CONVEX",_wrap_CV_IS_SEQ_CONVEX,0,0,2,_wrap_CV_IS_SEQ_CONVEX_texinfo},
{"CV_IS_SEQ_HOLE",_wrap_CV_IS_SEQ_HOLE,0,0,2,_wrap_CV_IS_SEQ_HOLE_texinfo},
{"CV_IS_SEQ_SIMPLE",_wrap_CV_IS_SEQ_SIMPLE,0,0,2,_wrap_CV_IS_SEQ_SIMPLE_texinfo},
{"CV_IS_SEQ_POINT_SET",_wrap_CV_IS_SEQ_POINT_SET,0,0,2,_wrap_CV_IS_SEQ_POINT_SET_texinfo},
{"CV_IS_SEQ_POINT_SUBSET",_wrap_CV_IS_SEQ_POINT_SUBSET,0,0,2,_wrap_CV_IS_SEQ_POINT_SUBSET_texinfo},
{"CV_IS_SEQ_POLYLINE",_wrap_CV_IS_SEQ_POLYLINE,0,0,2,_wrap_CV_IS_SEQ_POLYLINE_texinfo},
{"CV_IS_SEQ_POLYGON",_wrap_CV_IS_SEQ_POLYGON,0,0,2,_wrap_CV_IS_SEQ_POLYGON_texinfo},
{"CV_IS_SEQ_CHAIN",_wrap_CV_IS_SEQ_CHAIN,0,0,2,_wrap_CV_IS_SEQ_CHAIN_texinfo},
{"CV_IS_SEQ_CONTOUR",_wrap_CV_IS_SEQ_CONTOUR,0,0,2,_wrap_CV_IS_SEQ_CONTOUR_texinfo},
{"CV_IS_SEQ_CHAIN_CONTOUR",_wrap_CV_IS_SEQ_CHAIN_CONTOUR,0,0,2,_wrap_CV_IS_SEQ_CHAIN_CONTOUR_texinfo},
{"CV_IS_SEQ_POLYGON_TREE",_wrap_CV_IS_SEQ_POLYGON_TREE,0,0,2,_wrap_CV_IS_SEQ_POLYGON_TREE_texinfo},
{"CV_IS_GRAPH",_wrap_CV_IS_GRAPH,0,0,2,_wrap_CV_IS_GRAPH_texinfo},
{"CV_IS_GRAPH_ORIENTED",_wrap_CV_IS_GRAPH_ORIENTED,0,0,2,_wrap_CV_IS_GRAPH_ORIENTED_texinfo},
{"CV_IS_SUBDIV2D",_wrap_CV_IS_SUBDIV2D,0,0,2,_wrap_CV_IS_SUBDIV2D_texinfo},
{"CV_WRITE_SEQ_ELEM_VAR",_wrap_CV_WRITE_SEQ_ELEM_VAR,0,0,2,_wrap_CV_WRITE_SEQ_ELEM_VAR_texinfo},
{"CV_WRITE_SEQ_ELEM",_wrap_CV_WRITE_SEQ_ELEM,0,0,2,_wrap_CV_WRITE_SEQ_ELEM_texinfo},
{"CV_NEXT_SEQ_ELEM",_wrap_CV_NEXT_SEQ_ELEM,0,0,2,_wrap_CV_NEXT_SEQ_ELEM_texinfo},
{"CV_PREV_SEQ_ELEM",_wrap_CV_PREV_SEQ_ELEM,0,0,2,_wrap_CV_PREV_SEQ_ELEM_texinfo},
{"CV_READ_SEQ_ELEM",_wrap_CV_READ_SEQ_ELEM,0,0,2,_wrap_CV_READ_SEQ_ELEM_texinfo},
{"CV_REV_READ_SEQ_ELEM",_wrap_CV_REV_READ_SEQ_ELEM,0,0,2,_wrap_CV_REV_READ_SEQ_ELEM_texinfo},
{"CV_CURRENT_POINT",_wrap_CV_CURRENT_POINT,0,0,2,_wrap_CV_CURRENT_POINT_texinfo},
{"CV_PREV_POINT",_wrap_CV_PREV_POINT,0,0,2,_wrap_CV_PREV_POINT_texinfo},
{"CV_READ_EDGE",_wrap_CV_READ_EDGE,0,0,2,_wrap_CV_READ_EDGE_texinfo},
{"CV_NEXT_GRAPH_EDGE",_wrap_CV_NEXT_GRAPH_EDGE,0,0,2,_wrap_CV_NEXT_GRAPH_EDGE_texinfo},
{"CV_NODE_TYPE",_wrap_CV_NODE_TYPE,0,0,2,_wrap_CV_NODE_TYPE_texinfo},
{"CV_NODE_IS_INT",_wrap_CV_NODE_IS_INT,0,0,2,_wrap_CV_NODE_IS_INT_texinfo},
{"CV_NODE_IS_REAL",_wrap_CV_NODE_IS_REAL,0,0,2,_wrap_CV_NODE_IS_REAL_texinfo},
{"CV_NODE_IS_STRING",_wrap_CV_NODE_IS_STRING,0,0,2,_wrap_CV_NODE_IS_STRING_texinfo},
{"CV_NODE_IS_SEQ",_wrap_CV_NODE_IS_SEQ,0,0,2,_wrap_CV_NODE_IS_SEQ_texinfo},
{"CV_NODE_IS_MAP",_wrap_CV_NODE_IS_MAP,0,0,2,_wrap_CV_NODE_IS_MAP_texinfo},
{"CV_NODE_IS_COLLECTION",_wrap_CV_NODE_IS_COLLECTION,0,0,2,_wrap_CV_NODE_IS_COLLECTION_texinfo},
{"CV_NODE_IS_FLOW",_wrap_CV_NODE_IS_FLOW,0,0,2,_wrap_CV_NODE_IS_FLOW_texinfo},
{"CV_NODE_IS_EMPTY",_wrap_CV_NODE_IS_EMPTY,0,0,2,_wrap_CV_NODE_IS_EMPTY_texinfo},
{"CV_NODE_IS_USER",_wrap_CV_NODE_IS_USER,0,0,2,_wrap_CV_NODE_IS_USER_texinfo},
{"CV_NODE_HAS_NAME",_wrap_CV_NODE_HAS_NAME,0,0,2,_wrap_CV_NODE_HAS_NAME_texinfo},
{"CV_NODE_SEQ_IS_SIMPLE",_wrap_CV_NODE_SEQ_IS_SIMPLE,0,0,2,_wrap_CV_NODE_SEQ_IS_SIMPLE_texinfo},
{"cvReshapeND",_wrap_cvReshapeND,0,0,2,_wrap_cvReshapeND_texinfo},
{"cvConvert",_wrap_cvConvert,0,0,2,_wrap_cvConvert_texinfo},
{"cvAXPY",_wrap_cvAXPY,0,0,2,_wrap_cvAXPY_texinfo},
{"cvAbs",_wrap_cvAbs,0,0,2,_wrap_cvAbs_texinfo},
{"cvMatMulAdd",_wrap_cvMatMulAdd,0,0,2,_wrap_cvMatMulAdd_texinfo},
{"cvMatMul",_wrap_cvMatMul,0,0,2,_wrap_cvMatMul_texinfo},
{"cvGetGraphVtx",_wrap_cvGetGraphVtx,0,0,2,_wrap_cvGetGraphVtx_texinfo},
{"cvGraphVtxIdx",_wrap_cvGraphVtxIdx,0,0,2,_wrap_cvGraphVtxIdx_texinfo},
{"cvGraphEdgeIdx",_wrap_cvGraphEdgeIdx,0,0,2,_wrap_cvGraphEdgeIdx_texinfo},
{"cvGraphGetVtxCount",_wrap_cvGraphGetVtxCount,0,0,2,_wrap_cvGraphGetVtxCount_texinfo},
{"cvGraphGetEdgeCount",_wrap_cvGraphGetEdgeCount,0,0,2,_wrap_cvGraphGetEdgeCount_texinfo},
{"CV_IS_GRAPH_VERTEX_VISITED",_wrap_CV_IS_GRAPH_VERTEX_VISITED,0,0,2,_wrap_CV_IS_GRAPH_VERTEX_VISITED_texinfo},
{"CV_IS_GRAPH_EDGE_VISITED",_wrap_CV_IS_GRAPH_EDGE_VISITED,0,0,2,_wrap_CV_IS_GRAPH_EDGE_VISITED_texinfo},
{"CV_RGB",_wrap_CV_RGB,0,0,2,_wrap_CV_RGB_texinfo},
{"CV_NEXT_LINE_POINT",_wrap_CV_NEXT_LINE_POINT,0,0,2,_wrap_CV_NEXT_LINE_POINT_texinfo},
{"CV_INIT_3X3_DELTAS",_wrap_CV_INIT_3X3_DELTAS,0,0,2,_wrap_CV_INIT_3X3_DELTAS_texinfo},
{"CV_IS_HAAR_CLASSIFIER",_wrap_CV_IS_HAAR_CLASSIFIER,0,0,2,_wrap_CV_IS_HAAR_CLASSIFIER_texinfo},
{"cvCalcBackProject",_wrap_cvCalcBackProject,0,0,2,_wrap_cvCalcBackProject_texinfo},
{"cvCalcBackProjectPatch",_wrap_cvCalcBackProjectPatch,0,0,2,_wrap_cvCalcBackProjectPatch_texinfo},
{"cvCreateImage",_wrap_cvCreateImage,0,0,2,_wrap_cvCreateImage_texinfo},
{"cvCloneImage",_wrap_cvCloneImage,0,0,2,_wrap_cvCloneImage_texinfo},
{"Cv32suf_i_set",_wrap_Cv32suf_i_set,0,0,2,0},
{"Cv32suf_i_get",_wrap_Cv32suf_i_get,0,0,2,0},
{"Cv32suf_u_set",_wrap_Cv32suf_u_set,0,0,2,0},
{"Cv32suf_u_get",_wrap_Cv32suf_u_get,0,0,2,0},
{"Cv32suf_f_set",_wrap_Cv32suf_f_set,0,0,2,0},
{"Cv32suf_f_get",_wrap_Cv32suf_f_get,0,0,2,0},
{"new_Cv32suf",_wrap_new_Cv32suf,0,0,2,_wrap_new_Cv32suf_texinfo},
{"delete_Cv32suf",_wrap_delete_Cv32suf,0,0,2,_wrap_delete_Cv32suf_texinfo},
{"Cv64suf_i_set",_wrap_Cv64suf_i_set,0,0,2,0},
{"Cv64suf_i_get",_wrap_Cv64suf_i_get,0,0,2,0},
{"Cv64suf_u_set",_wrap_Cv64suf_u_set,0,0,2,0},
{"Cv64suf_u_get",_wrap_Cv64suf_u_get,0,0,2,0},
{"Cv64suf_f_set",_wrap_Cv64suf_f_set,0,0,2,0},
{"Cv64suf_f_get",_wrap_Cv64suf_f_get,0,0,2,0},
{"new_Cv64suf",_wrap_new_Cv64suf,0,0,2,_wrap_new_Cv64suf_texinfo},
{"delete_Cv64suf",_wrap_delete_Cv64suf,0,0,2,_wrap_delete_Cv64suf_texinfo},
{"cvRound",_wrap_cvRound,0,0,2,_wrap_cvRound_texinfo},
{"cvFloor",_wrap_cvFloor,0,0,2,_wrap_cvFloor_texinfo},
{"cvCeil",_wrap_cvCeil,0,0,2,_wrap_cvCeil_texinfo},
{"cvIsNaN",_wrap_cvIsNaN,0,0,2,_wrap_cvIsNaN_texinfo},
{"cvIsInf",_wrap_cvIsInf,0,0,2,_wrap_cvIsInf_texinfo},
{"cvRNG",_wrap_cvRNG,0,0,2,_wrap_cvRNG_texinfo},
{"cvRandInt",_wrap_cvRandInt,0,0,2,_wrap_cvRandInt_texinfo},
{"cvRandReal",_wrap_cvRandReal,0,0,2,_wrap_cvRandReal_texinfo},
{"IplImage_ID_set",_wrap_IplImage_ID_set,0,0,2,0},
{"IplImage_ID_get",_wrap_IplImage_ID_get,0,0,2,0},
{"IplImage_nChannels_set",_wrap_IplImage_nChannels_set,0,0,2,0},
{"IplImage_nChannels_get",_wrap_IplImage_nChannels_get,0,0,2,0},
{"IplImage_depth_set",_wrap_IplImage_depth_set,0,0,2,0},
{"IplImage_depth_get",_wrap_IplImage_depth_get,0,0,2,0},
{"IplImage_dataOrder_set",_wrap_IplImage_dataOrder_set,0,0,2,0},
{"IplImage_dataOrder_get",_wrap_IplImage_dataOrder_get,0,0,2,0},
{"IplImage_origin_set",_wrap_IplImage_origin_set,0,0,2,0},
{"IplImage_origin_get",_wrap_IplImage_origin_get,0,0,2,0},
{"IplImage_align_set",_wrap_IplImage_align_set,0,0,2,0},
{"IplImage_align_get",_wrap_IplImage_align_get,0,0,2,0},
{"IplImage_width_set",_wrap_IplImage_width_set,0,0,2,0},
{"IplImage_width_get",_wrap_IplImage_width_get,0,0,2,0},
{"IplImage_height_set",_wrap_IplImage_height_set,0,0,2,0},
{"IplImage_height_get",_wrap_IplImage_height_get,0,0,2,0},
{"IplImage_roi_set",_wrap_IplImage_roi_set,0,0,2,0},
{"IplImage_roi_get",_wrap_IplImage_roi_get,0,0,2,0},
{"IplImage_imageSize_set",_wrap_IplImage_imageSize_set,0,0,2,0},
{"IplImage_imageSize_get",_wrap_IplImage_imageSize_get,0,0,2,0},
{"IplImage_widthStep_set",_wrap_IplImage_widthStep_set,0,0,2,0},
{"IplImage_widthStep_get",_wrap_IplImage_widthStep_get,0,0,2,0},
{"delete_IplImage",_wrap_delete_IplImage,0,0,2,_wrap_delete_IplImage_texinfo},
{"IplImage___add__",_wrap_IplImage___add__,0,0,2,_wrap_IplImage___add___texinfo},
{"IplImage___xor__",_wrap_IplImage___xor__,0,0,2,_wrap_IplImage___xor___texinfo},
{"IplImage___sub__",_wrap_IplImage___sub__,0,0,2,_wrap_IplImage___sub___texinfo},
{"IplImage___ge__",_wrap_IplImage___ge__,0,0,2,_wrap_IplImage___ge___texinfo},
{"IplImage___eq__",_wrap_IplImage___eq__,0,0,2,_wrap_IplImage___eq___texinfo},
{"IplImage___le__",_wrap_IplImage___le__,0,0,2,_wrap_IplImage___le___texinfo},
{"IplImage___ne__",_wrap_IplImage___ne__,0,0,2,_wrap_IplImage___ne___texinfo},
{"IplImage___lt__",_wrap_IplImage___lt__,0,0,2,_wrap_IplImage___lt___texinfo},
{"IplImage___gt__",_wrap_IplImage___gt__,0,0,2,_wrap_IplImage___gt___texinfo},
{"IplImage___mul__",_wrap_IplImage___mul__,0,0,2,_wrap_IplImage___mul___texinfo},
{"IplImage___div__",_wrap_IplImage___div__,0,0,2,_wrap_IplImage___div___texinfo},
{"IplImage___radd__",_wrap_IplImage___radd__,0,0,2,_wrap_IplImage___radd___texinfo},
{"IplImage___rsub__",_wrap_IplImage___rsub__,0,0,2,_wrap_IplImage___rsub___texinfo},
{"IplImage___rmul__",_wrap_IplImage___rmul__,0,0,2,_wrap_IplImage___rmul___texinfo},
{"IplImage___rdiv__",_wrap_IplImage___rdiv__,0,0,2,_wrap_IplImage___rdiv___texinfo},
{"IplImage___ror__",_wrap_IplImage___ror__,0,0,2,_wrap_IplImage___ror___texinfo},
{"IplImage___rand__",_wrap_IplImage___rand__,0,0,2,_wrap_IplImage___rand___texinfo},
{"IplImage___rxor__",_wrap_IplImage___rxor__,0,0,2,_wrap_IplImage___rxor___texinfo},
{"IplImage___req__",_wrap_IplImage___req__,0,0,2,_wrap_IplImage___req___texinfo},
{"IplImage___rgt__",_wrap_IplImage___rgt__,0,0,2,_wrap_IplImage___rgt___texinfo},
{"IplImage___rge__",_wrap_IplImage___rge__,0,0,2,_wrap_IplImage___rge___texinfo},
{"IplImage___rlt__",_wrap_IplImage___rlt__,0,0,2,_wrap_IplImage___rlt___texinfo},
{"IplImage___rle__",_wrap_IplImage___rle__,0,0,2,_wrap_IplImage___rle___texinfo},
{"IplImage___rne__",_wrap_IplImage___rne__,0,0,2,_wrap_IplImage___rne___texinfo},
{"IplImage___pow__",_wrap_IplImage___pow__,0,0,2,_wrap_IplImage___pow___texinfo},
{"IplImage___str",_wrap_IplImage___str,0,0,2,_wrap_IplImage___str_texinfo},
{"IplImage___paren_asgn",_wrap_IplImage___paren_asgn,0,0,2,_wrap_IplImage___paren_asgn_texinfo},
{"IplImage___paren",_wrap_IplImage___paren,0,0,2,_wrap_IplImage___paren_texinfo},
{"IplROI_coi_set",_wrap_IplROI_coi_set,0,0,2,0},
{"IplROI_coi_get",_wrap_IplROI_coi_get,0,0,2,0},
{"IplROI_xOffset_set",_wrap_IplROI_xOffset_set,0,0,2,0},
{"IplROI_xOffset_get",_wrap_IplROI_xOffset_get,0,0,2,0},
{"IplROI_yOffset_set",_wrap_IplROI_yOffset_set,0,0,2,0},
{"IplROI_yOffset_get",_wrap_IplROI_yOffset_get,0,0,2,0},
{"IplROI_width_set",_wrap_IplROI_width_set,0,0,2,0},
{"IplROI_width_get",_wrap_IplROI_width_get,0,0,2,0},
{"IplROI_height_set",_wrap_IplROI_height_set,0,0,2,0},
{"IplROI_height_get",_wrap_IplROI_height_get,0,0,2,0},
{"new_IplROI",_wrap_new_IplROI,0,0,2,_wrap_new_IplROI_texinfo},
{"delete_IplROI",_wrap_delete_IplROI,0,0,2,_wrap_delete_IplROI_texinfo},
{"IplConvKernel_nCols_set",_wrap_IplConvKernel_nCols_set,0,0,2,0},
{"IplConvKernel_nCols_get",_wrap_IplConvKernel_nCols_get,0,0,2,0},
{"IplConvKernel_nRows_set",_wrap_IplConvKernel_nRows_set,0,0,2,0},
{"IplConvKernel_nRows_get",_wrap_IplConvKernel_nRows_get,0,0,2,0},
{"IplConvKernel_anchorX_set",_wrap_IplConvKernel_anchorX_set,0,0,2,0},
{"IplConvKernel_anchorX_get",_wrap_IplConvKernel_anchorX_get,0,0,2,0},
{"IplConvKernel_anchorY_set",_wrap_IplConvKernel_anchorY_set,0,0,2,0},
{"IplConvKernel_anchorY_get",_wrap_IplConvKernel_anchorY_get,0,0,2,0},
{"IplConvKernel_values_set",_wrap_IplConvKernel_values_set,0,0,2,0},
{"IplConvKernel_values_get",_wrap_IplConvKernel_values_get,0,0,2,0},
{"IplConvKernel_nShiftR_set",_wrap_IplConvKernel_nShiftR_set,0,0,2,0},
{"IplConvKernel_nShiftR_get",_wrap_IplConvKernel_nShiftR_get,0,0,2,0},
{"delete_IplConvKernel",_wrap_delete_IplConvKernel,0,0,2,_wrap_delete_IplConvKernel_texinfo},
{"IplConvKernelFP_nCols_set",_wrap_IplConvKernelFP_nCols_set,0,0,2,0},
{"IplConvKernelFP_nCols_get",_wrap_IplConvKernelFP_nCols_get,0,0,2,0},
{"IplConvKernelFP_nRows_set",_wrap_IplConvKernelFP_nRows_set,0,0,2,0},
{"IplConvKernelFP_nRows_get",_wrap_IplConvKernelFP_nRows_get,0,0,2,0},
{"IplConvKernelFP_anchorX_set",_wrap_IplConvKernelFP_anchorX_set,0,0,2,0},
{"IplConvKernelFP_anchorX_get",_wrap_IplConvKernelFP_anchorX_get,0,0,2,0},
{"IplConvKernelFP_anchorY_set",_wrap_IplConvKernelFP_anchorY_set,0,0,2,0},
{"IplConvKernelFP_anchorY_get",_wrap_IplConvKernelFP_anchorY_get,0,0,2,0},
{"IplConvKernelFP_values_set",_wrap_IplConvKernelFP_values_set,0,0,2,0},
{"IplConvKernelFP_values_get",_wrap_IplConvKernelFP_values_get,0,0,2,0},
{"new_IplConvKernelFP",_wrap_new_IplConvKernelFP,0,0,2,_wrap_new_IplConvKernelFP_texinfo},
{"delete_IplConvKernelFP",_wrap_delete_IplConvKernelFP,0,0,2,_wrap_delete_IplConvKernelFP_texinfo},
{"CvMat_type_set",_wrap_CvMat_type_set,0,0,2,0},
{"CvMat_type_get",_wrap_CvMat_type_get,0,0,2,0},
{"CvMat_step_set",_wrap_CvMat_step_set,0,0,2,0},
{"CvMat_step_get",_wrap_CvMat_step_get,0,0,2,0},
{"CvMat_refcount_set",_wrap_CvMat_refcount_set,0,0,2,0},
{"CvMat_refcount_get",_wrap_CvMat_refcount_get,0,0,2,0},
{"CvMat_hdr_refcount_set",_wrap_CvMat_hdr_refcount_set,0,0,2,0},
{"CvMat_hdr_refcount_get",_wrap_CvMat_hdr_refcount_get,0,0,2,0},
{"CvMat_data_get",_wrap_CvMat_data_get,0,0,2,0},
{"delete_CvMat",_wrap_delete_CvMat,0,0,2,_wrap_delete_CvMat_texinfo},
{"CvMat_depth_set",_wrap_CvMat_depth_set,0,0,2,0},
{"CvMat_depth_get",_wrap_CvMat_depth_get,0,0,2,0},
{"CvMat_nChannels_set",_wrap_CvMat_nChannels_set,0,0,2,0},
{"CvMat_nChannels_get",_wrap_CvMat_nChannels_get,0,0,2,0},
{"CvMat_dataOrder_set",_wrap_CvMat_dataOrder_set,0,0,2,0},
{"CvMat_dataOrder_get",_wrap_CvMat_dataOrder_get,0,0,2,0},
{"CvMat_origin_set",_wrap_CvMat_origin_set,0,0,2,0},
{"CvMat_origin_get",_wrap_CvMat_origin_get,0,0,2,0},
{"CvMat_width_set",_wrap_CvMat_width_set,0,0,2,0},
{"CvMat_width_get",_wrap_CvMat_width_get,0,0,2,0},
{"CvMat_height_set",_wrap_CvMat_height_set,0,0,2,0},
{"CvMat_height_get",_wrap_CvMat_height_get,0,0,2,0},
{"CvMat_imageSize_set",_wrap_CvMat_imageSize_set,0,0,2,0},
{"CvMat_imageSize_get",_wrap_CvMat_imageSize_get,0,0,2,0},
{"CvMat_widthStep_set",_wrap_CvMat_widthStep_set,0,0,2,0},
{"CvMat_widthStep_get",_wrap_CvMat_widthStep_get,0,0,2,0},
{"CvMat_rows_set",_wrap_CvMat_rows_set,0,0,2,0},
{"CvMat_rows_get",_wrap_CvMat_rows_get,0,0,2,0},
{"CvMat_cols_set",_wrap_CvMat_cols_set,0,0,2,0},
{"CvMat_cols_get",_wrap_CvMat_cols_get,0,0,2,0},
{"CvMat___add__",_wrap_CvMat___add__,0,0,2,_wrap_CvMat___add___texinfo},
{"CvMat___xor__",_wrap_CvMat___xor__,0,0,2,_wrap_CvMat___xor___texinfo},
{"CvMat___sub__",_wrap_CvMat___sub__,0,0,2,_wrap_CvMat___sub___texinfo},
{"CvMat___ge__",_wrap_CvMat___ge__,0,0,2,_wrap_CvMat___ge___texinfo},
{"CvMat___eq__",_wrap_CvMat___eq__,0,0,2,_wrap_CvMat___eq___texinfo},
{"CvMat___le__",_wrap_CvMat___le__,0,0,2,_wrap_CvMat___le___texinfo},
{"CvMat___ne__",_wrap_CvMat___ne__,0,0,2,_wrap_CvMat___ne___texinfo},
{"CvMat___lt__",_wrap_CvMat___lt__,0,0,2,_wrap_CvMat___lt___texinfo},
{"CvMat___gt__",_wrap_CvMat___gt__,0,0,2,_wrap_CvMat___gt___texinfo},
{"CvMat___mul__",_wrap_CvMat___mul__,0,0,2,_wrap_CvMat___mul___texinfo},
{"CvMat___div__",_wrap_CvMat___div__,0,0,2,_wrap_CvMat___div___texinfo},
{"CvMat___radd__",_wrap_CvMat___radd__,0,0,2,_wrap_CvMat___radd___texinfo},
{"CvMat___rsub__",_wrap_CvMat___rsub__,0,0,2,_wrap_CvMat___rsub___texinfo},
{"CvMat___rmul__",_wrap_CvMat___rmul__,0,0,2,_wrap_CvMat___rmul___texinfo},
{"CvMat___rdiv__",_wrap_CvMat___rdiv__,0,0,2,_wrap_CvMat___rdiv___texinfo},
{"CvMat___ror__",_wrap_CvMat___ror__,0,0,2,_wrap_CvMat___ror___texinfo},
{"CvMat___rand__",_wrap_CvMat___rand__,0,0,2,_wrap_CvMat___rand___texinfo},
{"CvMat___rxor__",_wrap_CvMat___rxor__,0,0,2,_wrap_CvMat___rxor___texinfo},
{"CvMat___req__",_wrap_CvMat___req__,0,0,2,_wrap_CvMat___req___texinfo},
{"CvMat___rgt__",_wrap_CvMat___rgt__,0,0,2,_wrap_CvMat___rgt___texinfo},
{"CvMat___rge__",_wrap_CvMat___rge__,0,0,2,_wrap_CvMat___rge___texinfo},
{"CvMat___rlt__",_wrap_CvMat___rlt__,0,0,2,_wrap_CvMat___rlt___texinfo},
{"CvMat___rle__",_wrap_CvMat___rle__,0,0,2,_wrap_CvMat___rle___texinfo},
{"CvMat___rne__",_wrap_CvMat___rne__,0,0,2,_wrap_CvMat___rne___texinfo},
{"CvMat___pow__",_wrap_CvMat___pow__,0,0,2,_wrap_CvMat___pow___texinfo},
{"CvMat___str",_wrap_CvMat___str,0,0,2,_wrap_CvMat___str_texinfo},
{"CvMat___paren_asgn",_wrap_CvMat___paren_asgn,0,0,2,_wrap_CvMat___paren_asgn_texinfo},
{"CvMat___paren",_wrap_CvMat___paren,0,0,2,_wrap_CvMat___paren_texinfo},
{"CvMat_imageData_set",_wrap_CvMat_imageData_set,0,0,2,0},
{"CvMat_imageData_get",_wrap_CvMat_imageData_get,0,0,2,0},
{"CvMat_data_ptr_set",_wrap_CvMat_data_ptr_set,0,0,2,0},
{"CvMat_data_ptr_get",_wrap_CvMat_data_ptr_get,0,0,2,0},
{"CvMat_data_s_set",_wrap_CvMat_data_s_set,0,0,2,0},
{"CvMat_data_s_get",_wrap_CvMat_data_s_get,0,0,2,0},
{"CvMat_data_i_set",_wrap_CvMat_data_i_set,0,0,2,0},
{"CvMat_data_i_get",_wrap_CvMat_data_i_get,0,0,2,0},
{"CvMat_data_fl_set",_wrap_CvMat_data_fl_set,0,0,2,0},
{"CvMat_data_fl_get",_wrap_CvMat_data_fl_get,0,0,2,0},
{"CvMat_data_db_set",_wrap_CvMat_data_db_set,0,0,2,0},
{"CvMat_data_db_get",_wrap_CvMat_data_db_get,0,0,2,0},
{"new_CvMat_data",_wrap_new_CvMat_data,0,0,2,_wrap_new_CvMat_data_texinfo},
{"delete_CvMat_data",_wrap_delete_CvMat_data,0,0,2,_wrap_delete_CvMat_data_texinfo},
{"cvMat",_wrap_cvMat,0,0,2,_wrap_cvMat_texinfo},
{"cvmGet",_wrap_cvmGet,0,0,2,_wrap_cvmGet_texinfo},
{"cvmSet",_wrap_cvmSet,0,0,2,_wrap_cvmSet_texinfo},
{"cvIplDepth",_wrap_cvIplDepth,0,0,2,_wrap_cvIplDepth_texinfo},
{"CvMatND_type_set",_wrap_CvMatND_type_set,0,0,2,0},
{"CvMatND_type_get",_wrap_CvMatND_type_get,0,0,2,0},
{"CvMatND_dims_set",_wrap_CvMatND_dims_set,0,0,2,0},
{"CvMatND_dims_get",_wrap_CvMatND_dims_get,0,0,2,0},
{"CvMatND_refcount_set",_wrap_CvMatND_refcount_set,0,0,2,0},
{"CvMatND_refcount_get",_wrap_CvMatND_refcount_get,0,0,2,0},
{"CvMatND_hdr_refcount_set",_wrap_CvMatND_hdr_refcount_set,0,0,2,0},
{"CvMatND_hdr_refcount_get",_wrap_CvMatND_hdr_refcount_get,0,0,2,0},
{"CvMatND_dim_get",_wrap_CvMatND_dim_get,0,0,2,0},
{"CvMatND_data_get",_wrap_CvMatND_data_get,0,0,2,0},
{"delete_CvMatND",_wrap_delete_CvMatND,0,0,2,_wrap_delete_CvMatND_texinfo},
{"CvMatND_dim_size_set",_wrap_CvMatND_dim_size_set,0,0,2,0},
{"CvMatND_dim_size_get",_wrap_CvMatND_dim_size_get,0,0,2,0},
{"CvMatND_dim_step_set",_wrap_CvMatND_dim_step_set,0,0,2,0},
{"CvMatND_dim_step_get",_wrap_CvMatND_dim_step_get,0,0,2,0},
{"new_CvMatND_dim",_wrap_new_CvMatND_dim,0,0,2,_wrap_new_CvMatND_dim_texinfo},
{"delete_CvMatND_dim",_wrap_delete_CvMatND_dim,0,0,2,_wrap_delete_CvMatND_dim_texinfo},
{"CvMatND_data_ptr_set",_wrap_CvMatND_data_ptr_set,0,0,2,0},
{"CvMatND_data_ptr_get",_wrap_CvMatND_data_ptr_get,0,0,2,0},
{"CvMatND_data_fl_set",_wrap_CvMatND_data_fl_set,0,0,2,0},
{"CvMatND_data_fl_get",_wrap_CvMatND_data_fl_get,0,0,2,0},
{"CvMatND_data_db_set",_wrap_CvMatND_data_db_set,0,0,2,0},
{"CvMatND_data_db_get",_wrap_CvMatND_data_db_get,0,0,2,0},
{"CvMatND_data_i_set",_wrap_CvMatND_data_i_set,0,0,2,0},
{"CvMatND_data_i_get",_wrap_CvMatND_data_i_get,0,0,2,0},
{"CvMatND_data_s_set",_wrap_CvMatND_data_s_set,0,0,2,0},
{"CvMatND_data_s_get",_wrap_CvMatND_data_s_get,0,0,2,0},
{"new_CvMatND_data",_wrap_new_CvMatND_data,0,0,2,_wrap_new_CvMatND_data_texinfo},
{"delete_CvMatND_data",_wrap_delete_CvMatND_data,0,0,2,_wrap_delete_CvMatND_data_texinfo},
{"CvSparseMat_type_set",_wrap_CvSparseMat_type_set,0,0,2,0},
{"CvSparseMat_type_get",_wrap_CvSparseMat_type_get,0,0,2,0},
{"CvSparseMat_dims_set",_wrap_CvSparseMat_dims_set,0,0,2,0},
{"CvSparseMat_dims_get",_wrap_CvSparseMat_dims_get,0,0,2,0},
{"CvSparseMat_refcount_set",_wrap_CvSparseMat_refcount_set,0,0,2,0},
{"CvSparseMat_refcount_get",_wrap_CvSparseMat_refcount_get,0,0,2,0},
{"CvSparseMat_hdr_refcount_set",_wrap_CvSparseMat_hdr_refcount_set,0,0,2,0},
{"CvSparseMat_hdr_refcount_get",_wrap_CvSparseMat_hdr_refcount_get,0,0,2,0},
{"CvSparseMat_heap_set",_wrap_CvSparseMat_heap_set,0,0,2,0},
{"CvSparseMat_heap_get",_wrap_CvSparseMat_heap_get,0,0,2,0},
{"CvSparseMat_hashtable_set",_wrap_CvSparseMat_hashtable_set,0,0,2,0},
{"CvSparseMat_hashtable_get",_wrap_CvSparseMat_hashtable_get,0,0,2,0},
{"CvSparseMat_hashsize_set",_wrap_CvSparseMat_hashsize_set,0,0,2,0},
{"CvSparseMat_hashsize_get",_wrap_CvSparseMat_hashsize_get,0,0,2,0},
{"CvSparseMat_valoffset_set",_wrap_CvSparseMat_valoffset_set,0,0,2,0},
{"CvSparseMat_valoffset_get",_wrap_CvSparseMat_valoffset_get,0,0,2,0},
{"CvSparseMat_idxoffset_set",_wrap_CvSparseMat_idxoffset_set,0,0,2,0},
{"CvSparseMat_idxoffset_get",_wrap_CvSparseMat_idxoffset_get,0,0,2,0},
{"CvSparseMat_size_set",_wrap_CvSparseMat_size_set,0,0,2,0},
{"CvSparseMat_size_get",_wrap_CvSparseMat_size_get,0,0,2,0},
{"delete_CvSparseMat",_wrap_delete_CvSparseMat,0,0,2,_wrap_delete_CvSparseMat_texinfo},
{"CvSparseNode_hashval_set",_wrap_CvSparseNode_hashval_set,0,0,2,0},
{"CvSparseNode_hashval_get",_wrap_CvSparseNode_hashval_get,0,0,2,0},
{"CvSparseNode_next_set",_wrap_CvSparseNode_next_set,0,0,2,0},
{"CvSparseNode_next_get",_wrap_CvSparseNode_next_get,0,0,2,0},
{"new_CvSparseNode",_wrap_new_CvSparseNode,0,0,2,_wrap_new_CvSparseNode_texinfo},
{"delete_CvSparseNode",_wrap_delete_CvSparseNode,0,0,2,_wrap_delete_CvSparseNode_texinfo},
{"CvSparseMatIterator_mat_set",_wrap_CvSparseMatIterator_mat_set,0,0,2,0},
{"CvSparseMatIterator_mat_get",_wrap_CvSparseMatIterator_mat_get,0,0,2,0},
{"CvSparseMatIterator_node_set",_wrap_CvSparseMatIterator_node_set,0,0,2,0},
{"CvSparseMatIterator_node_get",_wrap_CvSparseMatIterator_node_get,0,0,2,0},
{"CvSparseMatIterator_curidx_set",_wrap_CvSparseMatIterator_curidx_set,0,0,2,0},
{"CvSparseMatIterator_curidx_get",_wrap_CvSparseMatIterator_curidx_get,0,0,2,0},
{"new_CvSparseMatIterator",_wrap_new_CvSparseMatIterator,0,0,2,_wrap_new_CvSparseMatIterator_texinfo},
{"delete_CvSparseMatIterator",_wrap_delete_CvSparseMatIterator,0,0,2,_wrap_delete_CvSparseMatIterator_texinfo},
{"CvHistogram_type_set",_wrap_CvHistogram_type_set,0,0,2,0},
{"CvHistogram_type_get",_wrap_CvHistogram_type_get,0,0,2,0},
{"CvHistogram_bins_set",_wrap_CvHistogram_bins_set,0,0,2,0},
{"CvHistogram_bins_get",_wrap_CvHistogram_bins_get,0,0,2,0},
{"CvHistogram_thresh_set",_wrap_CvHistogram_thresh_set,0,0,2,0},
{"CvHistogram_thresh_get",_wrap_CvHistogram_thresh_get,0,0,2,0},
{"CvHistogram_thresh2_set",_wrap_CvHistogram_thresh2_set,0,0,2,0},
{"CvHistogram_thresh2_get",_wrap_CvHistogram_thresh2_get,0,0,2,0},
{"CvHistogram_mat_set",_wrap_CvHistogram_mat_set,0,0,2,0},
{"CvHistogram_mat_get",_wrap_CvHistogram_mat_get,0,0,2,0},
{"delete_CvHistogram",_wrap_delete_CvHistogram,0,0,2,_wrap_delete_CvHistogram_texinfo},
{"CvRect_x_set",_wrap_CvRect_x_set,0,0,2,0},
{"CvRect_x_get",_wrap_CvRect_x_get,0,0,2,0},
{"CvRect_y_set",_wrap_CvRect_y_set,0,0,2,0},
{"CvRect_y_get",_wrap_CvRect_y_get,0,0,2,0},
{"CvRect_width_set",_wrap_CvRect_width_set,0,0,2,0},
{"CvRect_width_get",_wrap_CvRect_width_get,0,0,2,0},
{"CvRect_height_set",_wrap_CvRect_height_set,0,0,2,0},
{"CvRect_height_get",_wrap_CvRect_height_get,0,0,2,0},
{"new_CvRect",_wrap_new_CvRect,0,0,2,_wrap_new_CvRect_texinfo},
{"delete_CvRect",_wrap_delete_CvRect,0,0,2,_wrap_delete_CvRect_texinfo},
{"cvRect",_wrap_cvRect,0,0,2,_wrap_cvRect_texinfo},
{"cvRectToROI",_wrap_cvRectToROI,0,0,2,_wrap_cvRectToROI_texinfo},
{"cvROIToRect",_wrap_cvROIToRect,0,0,2,_wrap_cvROIToRect_texinfo},
{"CvTermCriteria_type_set",_wrap_CvTermCriteria_type_set,0,0,2,0},
{"CvTermCriteria_type_get",_wrap_CvTermCriteria_type_get,0,0,2,0},
{"CvTermCriteria_max_iter_set",_wrap_CvTermCriteria_max_iter_set,0,0,2,0},
{"CvTermCriteria_max_iter_get",_wrap_CvTermCriteria_max_iter_get,0,0,2,0},
{"CvTermCriteria_epsilon_set",_wrap_CvTermCriteria_epsilon_set,0,0,2,0},
{"CvTermCriteria_epsilon_get",_wrap_CvTermCriteria_epsilon_get,0,0,2,0},
{"new_CvTermCriteria",_wrap_new_CvTermCriteria,0,0,2,_wrap_new_CvTermCriteria_texinfo},
{"delete_CvTermCriteria",_wrap_delete_CvTermCriteria,0,0,2,_wrap_delete_CvTermCriteria_texinfo},
{"cvTermCriteria",_wrap_cvTermCriteria,0,0,2,_wrap_cvTermCriteria_texinfo},
{"CvPoint_x_set",_wrap_CvPoint_x_set,0,0,2,0},
{"CvPoint_x_get",_wrap_CvPoint_x_get,0,0,2,0},
{"CvPoint_y_set",_wrap_CvPoint_y_set,0,0,2,0},
{"CvPoint_y_get",_wrap_CvPoint_y_get,0,0,2,0},
{"CvPoint___str__",_wrap_CvPoint___str__,0,0,2,_wrap_CvPoint___str___texinfo},
{"CvPoint___repr__",_wrap_CvPoint___repr__,0,0,2,_wrap_CvPoint___repr___texinfo},
{"new_CvPoint",_wrap_new_CvPoint,0,0,2,_wrap_new_CvPoint_texinfo},
{"delete_CvPoint",_wrap_delete_CvPoint,0,0,2,_wrap_delete_CvPoint_texinfo},
{"cvPoint",_wrap_cvPoint,0,0,2,_wrap_cvPoint_texinfo},
{"CvPoint2D32f_x_set",_wrap_CvPoint2D32f_x_set,0,0,2,0},
{"CvPoint2D32f_x_get",_wrap_CvPoint2D32f_x_get,0,0,2,0},
{"CvPoint2D32f_y_set",_wrap_CvPoint2D32f_y_set,0,0,2,0},
{"CvPoint2D32f_y_get",_wrap_CvPoint2D32f_y_get,0,0,2,0},
{"CvPoint2D32f___str__",_wrap_CvPoint2D32f___str__,0,0,2,_wrap_CvPoint2D32f___str___texinfo},
{"CvPoint2D32f___repr__",_wrap_CvPoint2D32f___repr__,0,0,2,_wrap_CvPoint2D32f___repr___texinfo},
{"new_CvPoint2D32f",_wrap_new_CvPoint2D32f,0,0,2,_wrap_new_CvPoint2D32f_texinfo},
{"delete_CvPoint2D32f",_wrap_delete_CvPoint2D32f,0,0,2,_wrap_delete_CvPoint2D32f_texinfo},
{"cvPoint2D32f",_wrap_cvPoint2D32f,0,0,2,_wrap_cvPoint2D32f_texinfo},
{"cvPointTo32f",_wrap_cvPointTo32f,0,0,2,_wrap_cvPointTo32f_texinfo},
{"cvPointFrom32f",_wrap_cvPointFrom32f,0,0,2,_wrap_cvPointFrom32f_texinfo},
{"CvPoint3D32f_x_set",_wrap_CvPoint3D32f_x_set,0,0,2,0},
{"CvPoint3D32f_x_get",_wrap_CvPoint3D32f_x_get,0,0,2,0},
{"CvPoint3D32f_y_set",_wrap_CvPoint3D32f_y_set,0,0,2,0},
{"CvPoint3D32f_y_get",_wrap_CvPoint3D32f_y_get,0,0,2,0},
{"CvPoint3D32f_z_set",_wrap_CvPoint3D32f_z_set,0,0,2,0},
{"CvPoint3D32f_z_get",_wrap_CvPoint3D32f_z_get,0,0,2,0},
{"new_CvPoint3D32f",_wrap_new_CvPoint3D32f,0,0,2,_wrap_new_CvPoint3D32f_texinfo},
{"delete_CvPoint3D32f",_wrap_delete_CvPoint3D32f,0,0,2,_wrap_delete_CvPoint3D32f_texinfo},
{"cvPoint3D32f",_wrap_cvPoint3D32f,0,0,2,_wrap_cvPoint3D32f_texinfo},
{"CvPoint2D64f_x_set",_wrap_CvPoint2D64f_x_set,0,0,2,0},
{"CvPoint2D64f_x_get",_wrap_CvPoint2D64f_x_get,0,0,2,0},
{"CvPoint2D64f_y_set",_wrap_CvPoint2D64f_y_set,0,0,2,0},
{"CvPoint2D64f_y_get",_wrap_CvPoint2D64f_y_get,0,0,2,0},
{"new_CvPoint2D64f",_wrap_new_CvPoint2D64f,0,0,2,_wrap_new_CvPoint2D64f_texinfo},
{"delete_CvPoint2D64f",_wrap_delete_CvPoint2D64f,0,0,2,_wrap_delete_CvPoint2D64f_texinfo},
{"cvPoint2D64f",_wrap_cvPoint2D64f,0,0,2,_wrap_cvPoint2D64f_texinfo},
{"CvPoint3D64f_x_set",_wrap_CvPoint3D64f_x_set,0,0,2,0},
{"CvPoint3D64f_x_get",_wrap_CvPoint3D64f_x_get,0,0,2,0},
{"CvPoint3D64f_y_set",_wrap_CvPoint3D64f_y_set,0,0,2,0},
{"CvPoint3D64f_y_get",_wrap_CvPoint3D64f_y_get,0,0,2,0},
{"CvPoint3D64f_z_set",_wrap_CvPoint3D64f_z_set,0,0,2,0},
{"CvPoint3D64f_z_get",_wrap_CvPoint3D64f_z_get,0,0,2,0},
{"new_CvPoint3D64f",_wrap_new_CvPoint3D64f,0,0,2,_wrap_new_CvPoint3D64f_texinfo},
{"delete_CvPoint3D64f",_wrap_delete_CvPoint3D64f,0,0,2,_wrap_delete_CvPoint3D64f_texinfo},
{"cvPoint3D64f",_wrap_cvPoint3D64f,0,0,2,_wrap_cvPoint3D64f_texinfo},
{"CvSize_width_set",_wrap_CvSize_width_set,0,0,2,0},
{"CvSize_width_get",_wrap_CvSize_width_get,0,0,2,0},
{"CvSize_height_set",_wrap_CvSize_height_set,0,0,2,0},
{"CvSize_height_get",_wrap_CvSize_height_get,0,0,2,0},
{"new_CvSize",_wrap_new_CvSize,0,0,2,_wrap_new_CvSize_texinfo},
{"delete_CvSize",_wrap_delete_CvSize,0,0,2,_wrap_delete_CvSize_texinfo},
{"cvSize",_wrap_cvSize,0,0,2,_wrap_cvSize_texinfo},
{"CvSize2D32f_width_set",_wrap_CvSize2D32f_width_set,0,0,2,0},
{"CvSize2D32f_width_get",_wrap_CvSize2D32f_width_get,0,0,2,0},
{"CvSize2D32f_height_set",_wrap_CvSize2D32f_height_set,0,0,2,0},
{"CvSize2D32f_height_get",_wrap_CvSize2D32f_height_get,0,0,2,0},
{"new_CvSize2D32f",_wrap_new_CvSize2D32f,0,0,2,_wrap_new_CvSize2D32f_texinfo},
{"delete_CvSize2D32f",_wrap_delete_CvSize2D32f,0,0,2,_wrap_delete_CvSize2D32f_texinfo},
{"cvSize2D32f",_wrap_cvSize2D32f,0,0,2,_wrap_cvSize2D32f_texinfo},
{"CvBox2D_center_set",_wrap_CvBox2D_center_set,0,0,2,0},
{"CvBox2D_center_get",_wrap_CvBox2D_center_get,0,0,2,0},
{"CvBox2D_size_set",_wrap_CvBox2D_size_set,0,0,2,0},
{"CvBox2D_size_get",_wrap_CvBox2D_size_get,0,0,2,0},
{"CvBox2D_angle_set",_wrap_CvBox2D_angle_set,0,0,2,0},
{"CvBox2D_angle_get",_wrap_CvBox2D_angle_get,0,0,2,0},
{"new_CvBox2D",_wrap_new_CvBox2D,0,0,2,_wrap_new_CvBox2D_texinfo},
{"delete_CvBox2D",_wrap_delete_CvBox2D,0,0,2,_wrap_delete_CvBox2D_texinfo},
{"CvLineIterator_ptr_set",_wrap_CvLineIterator_ptr_set,0,0,2,0},
{"CvLineIterator_ptr_get",_wrap_CvLineIterator_ptr_get,0,0,2,0},
{"CvLineIterator_err_set",_wrap_CvLineIterator_err_set,0,0,2,0},
{"CvLineIterator_err_get",_wrap_CvLineIterator_err_get,0,0,2,0},
{"CvLineIterator_plus_delta_set",_wrap_CvLineIterator_plus_delta_set,0,0,2,0},
{"CvLineIterator_plus_delta_get",_wrap_CvLineIterator_plus_delta_get,0,0,2,0},
{"CvLineIterator_minus_delta_set",_wrap_CvLineIterator_minus_delta_set,0,0,2,0},
{"CvLineIterator_minus_delta_get",_wrap_CvLineIterator_minus_delta_get,0,0,2,0},
{"CvLineIterator_plus_step_set",_wrap_CvLineIterator_plus_step_set,0,0,2,0},
{"CvLineIterator_plus_step_get",_wrap_CvLineIterator_plus_step_get,0,0,2,0},
{"CvLineIterator_minus_step_set",_wrap_CvLineIterator_minus_step_set,0,0,2,0},
{"CvLineIterator_minus_step_get",_wrap_CvLineIterator_minus_step_get,0,0,2,0},
{"new_CvLineIterator",_wrap_new_CvLineIterator,0,0,2,_wrap_new_CvLineIterator_texinfo},
{"delete_CvLineIterator",_wrap_delete_CvLineIterator,0,0,2,_wrap_delete_CvLineIterator_texinfo},
{"CvSlice_start_index_set",_wrap_CvSlice_start_index_set,0,0,2,0},
{"CvSlice_start_index_get",_wrap_CvSlice_start_index_get,0,0,2,0},
{"CvSlice_end_index_set",_wrap_CvSlice_end_index_set,0,0,2,0},
{"CvSlice_end_index_get",_wrap_CvSlice_end_index_get,0,0,2,0},
{"new_CvSlice",_wrap_new_CvSlice,0,0,2,_wrap_new_CvSlice_texinfo},
{"delete_CvSlice",_wrap_delete_CvSlice,0,0,2,_wrap_delete_CvSlice_texinfo},
{"cvSlice",_wrap_cvSlice,0,0,2,_wrap_cvSlice_texinfo},
{"CvScalar_val_set",_wrap_CvScalar_val_set,0,0,2,0},
{"CvScalar_val_get",_wrap_CvScalar_val_get,0,0,2,0},
{"CvScalar___str__",_wrap_CvScalar___str__,0,0,2,_wrap_CvScalar___str___texinfo},
{"CvScalar___repr__",_wrap_CvScalar___repr__,0,0,2,_wrap_CvScalar___repr___texinfo},
{"CvScalar___getitem__",_wrap_CvScalar___getitem__,0,0,2,_wrap_CvScalar___getitem___texinfo},
{"CvScalar___setitem__",_wrap_CvScalar___setitem__,0,0,2,_wrap_CvScalar___setitem___texinfo},
{"new_CvScalar",_wrap_new_CvScalar,0,0,2,_wrap_new_CvScalar_texinfo},
{"delete_CvScalar",_wrap_delete_CvScalar,0,0,2,_wrap_delete_CvScalar_texinfo},
{"cvScalar",_wrap_cvScalar,0,0,2,_wrap_cvScalar_texinfo},
{"cvRealScalar",_wrap_cvRealScalar,0,0,2,_wrap_cvRealScalar_texinfo},
{"cvScalarAll",_wrap_cvScalarAll,0,0,2,_wrap_cvScalarAll_texinfo},
{"CvMemBlock_prev_set",_wrap_CvMemBlock_prev_set,0,0,2,0},
{"CvMemBlock_prev_get",_wrap_CvMemBlock_prev_get,0,0,2,0},
{"CvMemBlock_next_set",_wrap_CvMemBlock_next_set,0,0,2,0},
{"CvMemBlock_next_get",_wrap_CvMemBlock_next_get,0,0,2,0},
{"new_CvMemBlock",_wrap_new_CvMemBlock,0,0,2,_wrap_new_CvMemBlock_texinfo},
{"delete_CvMemBlock",_wrap_delete_CvMemBlock,0,0,2,_wrap_delete_CvMemBlock_texinfo},
{"CvMemStorage_signature_set",_wrap_CvMemStorage_signature_set,0,0,2,0},
{"CvMemStorage_signature_get",_wrap_CvMemStorage_signature_get,0,0,2,0},
{"CvMemStorage_bottom_set",_wrap_CvMemStorage_bottom_set,0,0,2,0},
{"CvMemStorage_bottom_get",_wrap_CvMemStorage_bottom_get,0,0,2,0},
{"CvMemStorage_top_set",_wrap_CvMemStorage_top_set,0,0,2,0},
{"CvMemStorage_top_get",_wrap_CvMemStorage_top_get,0,0,2,0},
{"CvMemStorage_parent_set",_wrap_CvMemStorage_parent_set,0,0,2,0},
{"CvMemStorage_parent_get",_wrap_CvMemStorage_parent_get,0,0,2,0},
{"CvMemStorage_block_size_set",_wrap_CvMemStorage_block_size_set,0,0,2,0},
{"CvMemStorage_block_size_get",_wrap_CvMemStorage_block_size_get,0,0,2,0},
{"CvMemStorage_free_space_set",_wrap_CvMemStorage_free_space_set,0,0,2,0},
{"CvMemStorage_free_space_get",_wrap_CvMemStorage_free_space_get,0,0,2,0},
{"delete_CvMemStorage",_wrap_delete_CvMemStorage,0,0,2,_wrap_delete_CvMemStorage_texinfo},
{"CvMemStoragePos_top_set",_wrap_CvMemStoragePos_top_set,0,0,2,0},
{"CvMemStoragePos_top_get",_wrap_CvMemStoragePos_top_get,0,0,2,0},
{"CvMemStoragePos_free_space_set",_wrap_CvMemStoragePos_free_space_set,0,0,2,0},
{"CvMemStoragePos_free_space_get",_wrap_CvMemStoragePos_free_space_get,0,0,2,0},
{"new_CvMemStoragePos",_wrap_new_CvMemStoragePos,0,0,2,_wrap_new_CvMemStoragePos_texinfo},
{"delete_CvMemStoragePos",_wrap_delete_CvMemStoragePos,0,0,2,_wrap_delete_CvMemStoragePos_texinfo},
{"CvSeqBlock_prev_set",_wrap_CvSeqBlock_prev_set,0,0,2,0},
{"CvSeqBlock_prev_get",_wrap_CvSeqBlock_prev_get,0,0,2,0},
{"CvSeqBlock_next_set",_wrap_CvSeqBlock_next_set,0,0,2,0},
{"CvSeqBlock_next_get",_wrap_CvSeqBlock_next_get,0,0,2,0},
{"CvSeqBlock_start_index_set",_wrap_CvSeqBlock_start_index_set,0,0,2,0},
{"CvSeqBlock_start_index_get",_wrap_CvSeqBlock_start_index_get,0,0,2,0},
{"CvSeqBlock_count_set",_wrap_CvSeqBlock_count_set,0,0,2,0},
{"CvSeqBlock_count_get",_wrap_CvSeqBlock_count_get,0,0,2,0},
{"CvSeqBlock_data_set",_wrap_CvSeqBlock_data_set,0,0,2,0},
{"CvSeqBlock_data_get",_wrap_CvSeqBlock_data_get,0,0,2,0},
{"new_CvSeqBlock",_wrap_new_CvSeqBlock,0,0,2,_wrap_new_CvSeqBlock_texinfo},
{"delete_CvSeqBlock",_wrap_delete_CvSeqBlock,0,0,2,_wrap_delete_CvSeqBlock_texinfo},
{"CvSeq_flags_set",_wrap_CvSeq_flags_set,0,0,2,0},
{"CvSeq_flags_get",_wrap_CvSeq_flags_get,0,0,2,0},
{"CvSeq_header_size_set",_wrap_CvSeq_header_size_set,0,0,2,0},
{"CvSeq_header_size_get",_wrap_CvSeq_header_size_get,0,0,2,0},
{"CvSeq_h_prev_set",_wrap_CvSeq_h_prev_set,0,0,2,0},
{"CvSeq_h_prev_get",_wrap_CvSeq_h_prev_get,0,0,2,0},
{"CvSeq_h_next_set",_wrap_CvSeq_h_next_set,0,0,2,0},
{"CvSeq_h_next_get",_wrap_CvSeq_h_next_get,0,0,2,0},
{"CvSeq_v_prev_set",_wrap_CvSeq_v_prev_set,0,0,2,0},
{"CvSeq_v_prev_get",_wrap_CvSeq_v_prev_get,0,0,2,0},
{"CvSeq_v_next_set",_wrap_CvSeq_v_next_set,0,0,2,0},
{"CvSeq_v_next_get",_wrap_CvSeq_v_next_get,0,0,2,0},
{"CvSeq_total_set",_wrap_CvSeq_total_set,0,0,2,0},
{"CvSeq_total_get",_wrap_CvSeq_total_get,0,0,2,0},
{"CvSeq_elem_size_set",_wrap_CvSeq_elem_size_set,0,0,2,0},
{"CvSeq_elem_size_get",_wrap_CvSeq_elem_size_get,0,0,2,0},
{"CvSeq_block_max_set",_wrap_CvSeq_block_max_set,0,0,2,0},
{"CvSeq_block_max_get",_wrap_CvSeq_block_max_get,0,0,2,0},
{"CvSeq_ptr_set",_wrap_CvSeq_ptr_set,0,0,2,0},
{"CvSeq_ptr_get",_wrap_CvSeq_ptr_get,0,0,2,0},
{"CvSeq_delta_elems_set",_wrap_CvSeq_delta_elems_set,0,0,2,0},
{"CvSeq_delta_elems_get",_wrap_CvSeq_delta_elems_get,0,0,2,0},
{"CvSeq_storage_set",_wrap_CvSeq_storage_set,0,0,2,0},
{"CvSeq_storage_get",_wrap_CvSeq_storage_get,0,0,2,0},
{"CvSeq_free_blocks_set",_wrap_CvSeq_free_blocks_set,0,0,2,0},
{"CvSeq_free_blocks_get",_wrap_CvSeq_free_blocks_get,0,0,2,0},
{"CvSeq_first_set",_wrap_CvSeq_first_set,0,0,2,0},
{"CvSeq_first_get",_wrap_CvSeq_first_get,0,0,2,0},
{"new_CvSeq",_wrap_new_CvSeq,0,0,2,_wrap_new_CvSeq_texinfo},
{"delete_CvSeq",_wrap_delete_CvSeq,0,0,2,_wrap_delete_CvSeq_texinfo},
{"CvSetElem_flags_set",_wrap_CvSetElem_flags_set,0,0,2,0},
{"CvSetElem_flags_get",_wrap_CvSetElem_flags_get,0,0,2,0},
{"CvSetElem_next_free_set",_wrap_CvSetElem_next_free_set,0,0,2,0},
{"CvSetElem_next_free_get",_wrap_CvSetElem_next_free_get,0,0,2,0},
{"new_CvSetElem",_wrap_new_CvSetElem,0,0,2,_wrap_new_CvSetElem_texinfo},
{"delete_CvSetElem",_wrap_delete_CvSetElem,0,0,2,_wrap_delete_CvSetElem_texinfo},
{"CvSet_flags_set",_wrap_CvSet_flags_set,0,0,2,0},
{"CvSet_flags_get",_wrap_CvSet_flags_get,0,0,2,0},
{"CvSet_header_size_set",_wrap_CvSet_header_size_set,0,0,2,0},
{"CvSet_header_size_get",_wrap_CvSet_header_size_get,0,0,2,0},
{"CvSet_h_prev_set",_wrap_CvSet_h_prev_set,0,0,2,0},
{"CvSet_h_prev_get",_wrap_CvSet_h_prev_get,0,0,2,0},
{"CvSet_h_next_set",_wrap_CvSet_h_next_set,0,0,2,0},
{"CvSet_h_next_get",_wrap_CvSet_h_next_get,0,0,2,0},
{"CvSet_v_prev_set",_wrap_CvSet_v_prev_set,0,0,2,0},
{"CvSet_v_prev_get",_wrap_CvSet_v_prev_get,0,0,2,0},
{"CvSet_v_next_set",_wrap_CvSet_v_next_set,0,0,2,0},
{"CvSet_v_next_get",_wrap_CvSet_v_next_get,0,0,2,0},
{"CvSet_total_set",_wrap_CvSet_total_set,0,0,2,0},
{"CvSet_total_get",_wrap_CvSet_total_get,0,0,2,0},
{"CvSet_elem_size_set",_wrap_CvSet_elem_size_set,0,0,2,0},
{"CvSet_elem_size_get",_wrap_CvSet_elem_size_get,0,0,2,0},
{"CvSet_block_max_set",_wrap_CvSet_block_max_set,0,0,2,0},
{"CvSet_block_max_get",_wrap_CvSet_block_max_get,0,0,2,0},
{"CvSet_ptr_set",_wrap_CvSet_ptr_set,0,0,2,0},
{"CvSet_ptr_get",_wrap_CvSet_ptr_get,0,0,2,0},
{"CvSet_delta_elems_set",_wrap_CvSet_delta_elems_set,0,0,2,0},
{"CvSet_delta_elems_get",_wrap_CvSet_delta_elems_get,0,0,2,0},
{"CvSet_storage_set",_wrap_CvSet_storage_set,0,0,2,0},
{"CvSet_storage_get",_wrap_CvSet_storage_get,0,0,2,0},
{"CvSet_free_blocks_set",_wrap_CvSet_free_blocks_set,0,0,2,0},
{"CvSet_free_blocks_get",_wrap_CvSet_free_blocks_get,0,0,2,0},
{"CvSet_first_set",_wrap_CvSet_first_set,0,0,2,0},
{"CvSet_first_get",_wrap_CvSet_first_get,0,0,2,0},
{"CvSet_free_elems_set",_wrap_CvSet_free_elems_set,0,0,2,0},
{"CvSet_free_elems_get",_wrap_CvSet_free_elems_get,0,0,2,0},
{"CvSet_active_count_set",_wrap_CvSet_active_count_set,0,0,2,0},
{"CvSet_active_count_get",_wrap_CvSet_active_count_get,0,0,2,0},
{"new_CvSet",_wrap_new_CvSet,0,0,2,_wrap_new_CvSet_texinfo},
{"delete_CvSet",_wrap_delete_CvSet,0,0,2,_wrap_delete_CvSet_texinfo},
{"CvGraphEdge_flags_set",_wrap_CvGraphEdge_flags_set,0,0,2,0},
{"CvGraphEdge_flags_get",_wrap_CvGraphEdge_flags_get,0,0,2,0},
{"CvGraphEdge_weight_set",_wrap_CvGraphEdge_weight_set,0,0,2,0},
{"CvGraphEdge_weight_get",_wrap_CvGraphEdge_weight_get,0,0,2,0},
{"CvGraphEdge_next_set",_wrap_CvGraphEdge_next_set,0,0,2,0},
{"CvGraphEdge_next_get",_wrap_CvGraphEdge_next_get,0,0,2,0},
{"CvGraphEdge_vtx_set",_wrap_CvGraphEdge_vtx_set,0,0,2,0},
{"CvGraphEdge_vtx_get",_wrap_CvGraphEdge_vtx_get,0,0,2,0},
{"new_CvGraphEdge",_wrap_new_CvGraphEdge,0,0,2,_wrap_new_CvGraphEdge_texinfo},
{"delete_CvGraphEdge",_wrap_delete_CvGraphEdge,0,0,2,_wrap_delete_CvGraphEdge_texinfo},
{"CvGraphVtx_flags_set",_wrap_CvGraphVtx_flags_set,0,0,2,0},
{"CvGraphVtx_flags_get",_wrap_CvGraphVtx_flags_get,0,0,2,0},
{"CvGraphVtx_first_set",_wrap_CvGraphVtx_first_set,0,0,2,0},
{"CvGraphVtx_first_get",_wrap_CvGraphVtx_first_get,0,0,2,0},
{"new_CvGraphVtx",_wrap_new_CvGraphVtx,0,0,2,_wrap_new_CvGraphVtx_texinfo},
{"delete_CvGraphVtx",_wrap_delete_CvGraphVtx,0,0,2,_wrap_delete_CvGraphVtx_texinfo},
{"CvGraphVtx2D_flags_set",_wrap_CvGraphVtx2D_flags_set,0,0,2,0},
{"CvGraphVtx2D_flags_get",_wrap_CvGraphVtx2D_flags_get,0,0,2,0},
{"CvGraphVtx2D_first_set",_wrap_CvGraphVtx2D_first_set,0,0,2,0},
{"CvGraphVtx2D_first_get",_wrap_CvGraphVtx2D_first_get,0,0,2,0},
{"CvGraphVtx2D_ptr_set",_wrap_CvGraphVtx2D_ptr_set,0,0,2,0},
{"CvGraphVtx2D_ptr_get",_wrap_CvGraphVtx2D_ptr_get,0,0,2,0},
{"new_CvGraphVtx2D",_wrap_new_CvGraphVtx2D,0,0,2,_wrap_new_CvGraphVtx2D_texinfo},
{"delete_CvGraphVtx2D",_wrap_delete_CvGraphVtx2D,0,0,2,_wrap_delete_CvGraphVtx2D_texinfo},
{"CvGraph_flags_set",_wrap_CvGraph_flags_set,0,0,2,0},
{"CvGraph_flags_get",_wrap_CvGraph_flags_get,0,0,2,0},
{"CvGraph_header_size_set",_wrap_CvGraph_header_size_set,0,0,2,0},
{"CvGraph_header_size_get",_wrap_CvGraph_header_size_get,0,0,2,0},
{"CvGraph_h_prev_set",_wrap_CvGraph_h_prev_set,0,0,2,0},
{"CvGraph_h_prev_get",_wrap_CvGraph_h_prev_get,0,0,2,0},
{"CvGraph_h_next_set",_wrap_CvGraph_h_next_set,0,0,2,0},
{"CvGraph_h_next_get",_wrap_CvGraph_h_next_get,0,0,2,0},
{"CvGraph_v_prev_set",_wrap_CvGraph_v_prev_set,0,0,2,0},
{"CvGraph_v_prev_get",_wrap_CvGraph_v_prev_get,0,0,2,0},
{"CvGraph_v_next_set",_wrap_CvGraph_v_next_set,0,0,2,0},
{"CvGraph_v_next_get",_wrap_CvGraph_v_next_get,0,0,2,0},
{"CvGraph_total_set",_wrap_CvGraph_total_set,0,0,2,0},
{"CvGraph_total_get",_wrap_CvGraph_total_get,0,0,2,0},
{"CvGraph_elem_size_set",_wrap_CvGraph_elem_size_set,0,0,2,0},
{"CvGraph_elem_size_get",_wrap_CvGraph_elem_size_get,0,0,2,0},
{"CvGraph_block_max_set",_wrap_CvGraph_block_max_set,0,0,2,0},
{"CvGraph_block_max_get",_wrap_CvGraph_block_max_get,0,0,2,0},
{"CvGraph_ptr_set",_wrap_CvGraph_ptr_set,0,0,2,0},
{"CvGraph_ptr_get",_wrap_CvGraph_ptr_get,0,0,2,0},
{"CvGraph_delta_elems_set",_wrap_CvGraph_delta_elems_set,0,0,2,0},
{"CvGraph_delta_elems_get",_wrap_CvGraph_delta_elems_get,0,0,2,0},
{"CvGraph_storage_set",_wrap_CvGraph_storage_set,0,0,2,0},
{"CvGraph_storage_get",_wrap_CvGraph_storage_get,0,0,2,0},
{"CvGraph_free_blocks_set",_wrap_CvGraph_free_blocks_set,0,0,2,0},
{"CvGraph_free_blocks_get",_wrap_CvGraph_free_blocks_get,0,0,2,0},
{"CvGraph_first_set",_wrap_CvGraph_first_set,0,0,2,0},
{"CvGraph_first_get",_wrap_CvGraph_first_get,0,0,2,0},
{"CvGraph_free_elems_set",_wrap_CvGraph_free_elems_set,0,0,2,0},
{"CvGraph_free_elems_get",_wrap_CvGraph_free_elems_get,0,0,2,0},
{"CvGraph_active_count_set",_wrap_CvGraph_active_count_set,0,0,2,0},
{"CvGraph_active_count_get",_wrap_CvGraph_active_count_get,0,0,2,0},
{"CvGraph_edges_set",_wrap_CvGraph_edges_set,0,0,2,0},
{"CvGraph_edges_get",_wrap_CvGraph_edges_get,0,0,2,0},
{"new_CvGraph",_wrap_new_CvGraph,0,0,2,_wrap_new_CvGraph_texinfo},
{"delete_CvGraph",_wrap_delete_CvGraph,0,0,2,_wrap_delete_CvGraph_texinfo},
{"CvChain_flags_set",_wrap_CvChain_flags_set,0,0,2,0},
{"CvChain_flags_get",_wrap_CvChain_flags_get,0,0,2,0},
{"CvChain_header_size_set",_wrap_CvChain_header_size_set,0,0,2,0},
{"CvChain_header_size_get",_wrap_CvChain_header_size_get,0,0,2,0},
{"CvChain_h_prev_set",_wrap_CvChain_h_prev_set,0,0,2,0},
{"CvChain_h_prev_get",_wrap_CvChain_h_prev_get,0,0,2,0},
{"CvChain_h_next_set",_wrap_CvChain_h_next_set,0,0,2,0},
{"CvChain_h_next_get",_wrap_CvChain_h_next_get,0,0,2,0},
{"CvChain_v_prev_set",_wrap_CvChain_v_prev_set,0,0,2,0},
{"CvChain_v_prev_get",_wrap_CvChain_v_prev_get,0,0,2,0},
{"CvChain_v_next_set",_wrap_CvChain_v_next_set,0,0,2,0},
{"CvChain_v_next_get",_wrap_CvChain_v_next_get,0,0,2,0},
{"CvChain_total_set",_wrap_CvChain_total_set,0,0,2,0},
{"CvChain_total_get",_wrap_CvChain_total_get,0,0,2,0},
{"CvChain_elem_size_set",_wrap_CvChain_elem_size_set,0,0,2,0},
{"CvChain_elem_size_get",_wrap_CvChain_elem_size_get,0,0,2,0},
{"CvChain_block_max_set",_wrap_CvChain_block_max_set,0,0,2,0},
{"CvChain_block_max_get",_wrap_CvChain_block_max_get,0,0,2,0},
{"CvChain_ptr_set",_wrap_CvChain_ptr_set,0,0,2,0},
{"CvChain_ptr_get",_wrap_CvChain_ptr_get,0,0,2,0},
{"CvChain_delta_elems_set",_wrap_CvChain_delta_elems_set,0,0,2,0},
{"CvChain_delta_elems_get",_wrap_CvChain_delta_elems_get,0,0,2,0},
{"CvChain_storage_set",_wrap_CvChain_storage_set,0,0,2,0},
{"CvChain_storage_get",_wrap_CvChain_storage_get,0,0,2,0},
{"CvChain_free_blocks_set",_wrap_CvChain_free_blocks_set,0,0,2,0},
{"CvChain_free_blocks_get",_wrap_CvChain_free_blocks_get,0,0,2,0},
{"CvChain_first_set",_wrap_CvChain_first_set,0,0,2,0},
{"CvChain_first_get",_wrap_CvChain_first_get,0,0,2,0},
{"CvChain_origin_set",_wrap_CvChain_origin_set,0,0,2,0},
{"CvChain_origin_get",_wrap_CvChain_origin_get,0,0,2,0},
{"new_CvChain",_wrap_new_CvChain,0,0,2,_wrap_new_CvChain_texinfo},
{"delete_CvChain",_wrap_delete_CvChain,0,0,2,_wrap_delete_CvChain_texinfo},
{"CvContour_flags_set",_wrap_CvContour_flags_set,0,0,2,0},
{"CvContour_flags_get",_wrap_CvContour_flags_get,0,0,2,0},
{"CvContour_header_size_set",_wrap_CvContour_header_size_set,0,0,2,0},
{"CvContour_header_size_get",_wrap_CvContour_header_size_get,0,0,2,0},
{"CvContour_h_prev_set",_wrap_CvContour_h_prev_set,0,0,2,0},
{"CvContour_h_prev_get",_wrap_CvContour_h_prev_get,0,0,2,0},
{"CvContour_h_next_set",_wrap_CvContour_h_next_set,0,0,2,0},
{"CvContour_h_next_get",_wrap_CvContour_h_next_get,0,0,2,0},
{"CvContour_v_prev_set",_wrap_CvContour_v_prev_set,0,0,2,0},
{"CvContour_v_prev_get",_wrap_CvContour_v_prev_get,0,0,2,0},
{"CvContour_v_next_set",_wrap_CvContour_v_next_set,0,0,2,0},
{"CvContour_v_next_get",_wrap_CvContour_v_next_get,0,0,2,0},
{"CvContour_total_set",_wrap_CvContour_total_set,0,0,2,0},
{"CvContour_total_get",_wrap_CvContour_total_get,0,0,2,0},
{"CvContour_elem_size_set",_wrap_CvContour_elem_size_set,0,0,2,0},
{"CvContour_elem_size_get",_wrap_CvContour_elem_size_get,0,0,2,0},
{"CvContour_block_max_set",_wrap_CvContour_block_max_set,0,0,2,0},
{"CvContour_block_max_get",_wrap_CvContour_block_max_get,0,0,2,0},
{"CvContour_ptr_set",_wrap_CvContour_ptr_set,0,0,2,0},
{"CvContour_ptr_get",_wrap_CvContour_ptr_get,0,0,2,0},
{"CvContour_delta_elems_set",_wrap_CvContour_delta_elems_set,0,0,2,0},
{"CvContour_delta_elems_get",_wrap_CvContour_delta_elems_get,0,0,2,0},
{"CvContour_storage_set",_wrap_CvContour_storage_set,0,0,2,0},
{"CvContour_storage_get",_wrap_CvContour_storage_get,0,0,2,0},
{"CvContour_free_blocks_set",_wrap_CvContour_free_blocks_set,0,0,2,0},
{"CvContour_free_blocks_get",_wrap_CvContour_free_blocks_get,0,0,2,0},
{"CvContour_first_set",_wrap_CvContour_first_set,0,0,2,0},
{"CvContour_first_get",_wrap_CvContour_first_get,0,0,2,0},
{"CvContour_rect_set",_wrap_CvContour_rect_set,0,0,2,0},
{"CvContour_rect_get",_wrap_CvContour_rect_get,0,0,2,0},
{"CvContour_color_set",_wrap_CvContour_color_set,0,0,2,0},
{"CvContour_color_get",_wrap_CvContour_color_get,0,0,2,0},
{"CvContour_reserved_set",_wrap_CvContour_reserved_set,0,0,2,0},
{"CvContour_reserved_get",_wrap_CvContour_reserved_get,0,0,2,0},
{"new_CvContour",_wrap_new_CvContour,0,0,2,_wrap_new_CvContour_texinfo},
{"delete_CvContour",_wrap_delete_CvContour,0,0,2,_wrap_delete_CvContour_texinfo},
{"CvSeqWriter_header_size_set",_wrap_CvSeqWriter_header_size_set,0,0,2,0},
{"CvSeqWriter_header_size_get",_wrap_CvSeqWriter_header_size_get,0,0,2,0},
{"CvSeqWriter_seq_set",_wrap_CvSeqWriter_seq_set,0,0,2,0},
{"CvSeqWriter_seq_get",_wrap_CvSeqWriter_seq_get,0,0,2,0},
{"CvSeqWriter_block_set",_wrap_CvSeqWriter_block_set,0,0,2,0},
{"CvSeqWriter_block_get",_wrap_CvSeqWriter_block_get,0,0,2,0},
{"CvSeqWriter_ptr_set",_wrap_CvSeqWriter_ptr_set,0,0,2,0},
{"CvSeqWriter_ptr_get",_wrap_CvSeqWriter_ptr_get,0,0,2,0},
{"CvSeqWriter_block_min_set",_wrap_CvSeqWriter_block_min_set,0,0,2,0},
{"CvSeqWriter_block_min_get",_wrap_CvSeqWriter_block_min_get,0,0,2,0},
{"CvSeqWriter_block_max_set",_wrap_CvSeqWriter_block_max_set,0,0,2,0},
{"CvSeqWriter_block_max_get",_wrap_CvSeqWriter_block_max_get,0,0,2,0},
{"new_CvSeqWriter",_wrap_new_CvSeqWriter,0,0,2,_wrap_new_CvSeqWriter_texinfo},
{"delete_CvSeqWriter",_wrap_delete_CvSeqWriter,0,0,2,_wrap_delete_CvSeqWriter_texinfo},
{"CvSeqReader_header_size_set",_wrap_CvSeqReader_header_size_set,0,0,2,0},
{"CvSeqReader_header_size_get",_wrap_CvSeqReader_header_size_get,0,0,2,0},
{"CvSeqReader_seq_set",_wrap_CvSeqReader_seq_set,0,0,2,0},
{"CvSeqReader_seq_get",_wrap_CvSeqReader_seq_get,0,0,2,0},
{"CvSeqReader_block_set",_wrap_CvSeqReader_block_set,0,0,2,0},
{"CvSeqReader_block_get",_wrap_CvSeqReader_block_get,0,0,2,0},
{"CvSeqReader_ptr_set",_wrap_CvSeqReader_ptr_set,0,0,2,0},
{"CvSeqReader_ptr_get",_wrap_CvSeqReader_ptr_get,0,0,2,0},
{"CvSeqReader_block_min_set",_wrap_CvSeqReader_block_min_set,0,0,2,0},
{"CvSeqReader_block_min_get",_wrap_CvSeqReader_block_min_get,0,0,2,0},
{"CvSeqReader_block_max_set",_wrap_CvSeqReader_block_max_set,0,0,2,0},
{"CvSeqReader_block_max_get",_wrap_CvSeqReader_block_max_get,0,0,2,0},
{"CvSeqReader_delta_index_set",_wrap_CvSeqReader_delta_index_set,0,0,2,0},
{"CvSeqReader_delta_index_get",_wrap_CvSeqReader_delta_index_get,0,0,2,0},
{"CvSeqReader_prev_elem_set",_wrap_CvSeqReader_prev_elem_set,0,0,2,0},
{"CvSeqReader_prev_elem_get",_wrap_CvSeqReader_prev_elem_get,0,0,2,0},
{"new_CvSeqReader",_wrap_new_CvSeqReader,0,0,2,_wrap_new_CvSeqReader_texinfo},
{"delete_CvSeqReader",_wrap_delete_CvSeqReader,0,0,2,_wrap_delete_CvSeqReader_texinfo},
{"CvAttrList_attr_set",_wrap_CvAttrList_attr_set,0,0,2,0},
{"CvAttrList_attr_get",_wrap_CvAttrList_attr_get,0,0,2,0},
{"CvAttrList_next_set",_wrap_CvAttrList_next_set,0,0,2,0},
{"CvAttrList_next_get",_wrap_CvAttrList_next_get,0,0,2,0},
{"new_CvAttrList",_wrap_new_CvAttrList,0,0,2,_wrap_new_CvAttrList_texinfo},
{"delete_CvAttrList",_wrap_delete_CvAttrList,0,0,2,_wrap_delete_CvAttrList_texinfo},
{"cvAttrList",_wrap_cvAttrList,0,0,2,_wrap_cvAttrList_texinfo},
{"CvString_len_set",_wrap_CvString_len_set,0,0,2,0},
{"CvString_len_get",_wrap_CvString_len_get,0,0,2,0},
{"CvString_ptr_set",_wrap_CvString_ptr_set,0,0,2,0},
{"CvString_ptr_get",_wrap_CvString_ptr_get,0,0,2,0},
{"new_CvString",_wrap_new_CvString,0,0,2,_wrap_new_CvString_texinfo},
{"delete_CvString",_wrap_delete_CvString,0,0,2,_wrap_delete_CvString_texinfo},
{"CvStringHashNode_hashval_set",_wrap_CvStringHashNode_hashval_set,0,0,2,0},
{"CvStringHashNode_hashval_get",_wrap_CvStringHashNode_hashval_get,0,0,2,0},
{"CvStringHashNode_str_set",_wrap_CvStringHashNode_str_set,0,0,2,0},
{"CvStringHashNode_str_get",_wrap_CvStringHashNode_str_get,0,0,2,0},
{"CvStringHashNode_next_set",_wrap_CvStringHashNode_next_set,0,0,2,0},
{"CvStringHashNode_next_get",_wrap_CvStringHashNode_next_get,0,0,2,0},
{"new_CvStringHashNode",_wrap_new_CvStringHashNode,0,0,2,_wrap_new_CvStringHashNode_texinfo},
{"delete_CvStringHashNode",_wrap_delete_CvStringHashNode,0,0,2,_wrap_delete_CvStringHashNode_texinfo},
{"CvFileNode_tag_set",_wrap_CvFileNode_tag_set,0,0,2,0},
{"CvFileNode_tag_get",_wrap_CvFileNode_tag_get,0,0,2,0},
{"CvFileNode_info_set",_wrap_CvFileNode_info_set,0,0,2,0},
{"CvFileNode_info_get",_wrap_CvFileNode_info_get,0,0,2,0},
{"CvFileNode_data_get",_wrap_CvFileNode_data_get,0,0,2,0},
{"new_CvFileNode",_wrap_new_CvFileNode,0,0,2,_wrap_new_CvFileNode_texinfo},
{"delete_CvFileNode",_wrap_delete_CvFileNode,0,0,2,_wrap_delete_CvFileNode_texinfo},
{"CvFileNode_data_f_set",_wrap_CvFileNode_data_f_set,0,0,2,0},
{"CvFileNode_data_f_get",_wrap_CvFileNode_data_f_get,0,0,2,0},
{"CvFileNode_data_i_set",_wrap_CvFileNode_data_i_set,0,0,2,0},
{"CvFileNode_data_i_get",_wrap_CvFileNode_data_i_get,0,0,2,0},
{"CvFileNode_data_str_set",_wrap_CvFileNode_data_str_set,0,0,2,0},
{"CvFileNode_data_str_get",_wrap_CvFileNode_data_str_get,0,0,2,0},
{"CvFileNode_data_seq_set",_wrap_CvFileNode_data_seq_set,0,0,2,0},
{"CvFileNode_data_seq_get",_wrap_CvFileNode_data_seq_get,0,0,2,0},
{"CvFileNode_data_map_set",_wrap_CvFileNode_data_map_set,0,0,2,0},
{"CvFileNode_data_map_get",_wrap_CvFileNode_data_map_get,0,0,2,0},
{"new_CvFileNode_data",_wrap_new_CvFileNode_data,0,0,2,_wrap_new_CvFileNode_data_texinfo},
{"delete_CvFileNode_data",_wrap_delete_CvFileNode_data,0,0,2,_wrap_delete_CvFileNode_data_texinfo},
{"CvTypeInfo_flags_set",_wrap_CvTypeInfo_flags_set,0,0,2,0},
{"CvTypeInfo_flags_get",_wrap_CvTypeInfo_flags_get,0,0,2,0},
{"CvTypeInfo_header_size_set",_wrap_CvTypeInfo_header_size_set,0,0,2,0},
{"CvTypeInfo_header_size_get",_wrap_CvTypeInfo_header_size_get,0,0,2,0},
{"CvTypeInfo_prev_set",_wrap_CvTypeInfo_prev_set,0,0,2,0},
{"CvTypeInfo_prev_get",_wrap_CvTypeInfo_prev_get,0,0,2,0},
{"CvTypeInfo_next_set",_wrap_CvTypeInfo_next_set,0,0,2,0},
{"CvTypeInfo_next_get",_wrap_CvTypeInfo_next_get,0,0,2,0},
{"CvTypeInfo_type_name_set",_wrap_CvTypeInfo_type_name_set,0,0,2,0},
{"CvTypeInfo_type_name_get",_wrap_CvTypeInfo_type_name_get,0,0,2,0},
{"CvTypeInfo_is_instance_set",_wrap_CvTypeInfo_is_instance_set,0,0,2,0},
{"CvTypeInfo_is_instance_get",_wrap_CvTypeInfo_is_instance_get,0,0,2,0},
{"CvTypeInfo_release_set",_wrap_CvTypeInfo_release_set,0,0,2,0},
{"CvTypeInfo_release_get",_wrap_CvTypeInfo_release_get,0,0,2,0},
{"CvTypeInfo_read_set",_wrap_CvTypeInfo_read_set,0,0,2,0},
{"CvTypeInfo_read_get",_wrap_CvTypeInfo_read_get,0,0,2,0},
{"CvTypeInfo_write_set",_wrap_CvTypeInfo_write_set,0,0,2,0},
{"CvTypeInfo_write_get",_wrap_CvTypeInfo_write_get,0,0,2,0},
{"CvTypeInfo_clone_set",_wrap_CvTypeInfo_clone_set,0,0,2,0},
{"CvTypeInfo_clone_get",_wrap_CvTypeInfo_clone_get,0,0,2,0},
{"new_CvTypeInfo",_wrap_new_CvTypeInfo,0,0,2,_wrap_new_CvTypeInfo_texinfo},
{"delete_CvTypeInfo",_wrap_delete_CvTypeInfo,0,0,2,_wrap_delete_CvTypeInfo_texinfo},
{"CvPluginFuncInfo_func_addr_set",_wrap_CvPluginFuncInfo_func_addr_set,0,0,2,0},
{"CvPluginFuncInfo_func_addr_get",_wrap_CvPluginFuncInfo_func_addr_get,0,0,2,0},
{"CvPluginFuncInfo_default_func_addr_set",_wrap_CvPluginFuncInfo_default_func_addr_set,0,0,2,0},
{"CvPluginFuncInfo_default_func_addr_get",_wrap_CvPluginFuncInfo_default_func_addr_get,0,0,2,0},
{"CvPluginFuncInfo_func_names_set",_wrap_CvPluginFuncInfo_func_names_set,0,0,2,0},
{"CvPluginFuncInfo_func_names_get",_wrap_CvPluginFuncInfo_func_names_get,0,0,2,0},
{"CvPluginFuncInfo_search_modules_set",_wrap_CvPluginFuncInfo_search_modules_set,0,0,2,0},
{"CvPluginFuncInfo_search_modules_get",_wrap_CvPluginFuncInfo_search_modules_get,0,0,2,0},
{"CvPluginFuncInfo_loaded_from_set",_wrap_CvPluginFuncInfo_loaded_from_set,0,0,2,0},
{"CvPluginFuncInfo_loaded_from_get",_wrap_CvPluginFuncInfo_loaded_from_get,0,0,2,0},
{"new_CvPluginFuncInfo",_wrap_new_CvPluginFuncInfo,0,0,2,_wrap_new_CvPluginFuncInfo_texinfo},
{"delete_CvPluginFuncInfo",_wrap_delete_CvPluginFuncInfo,0,0,2,_wrap_delete_CvPluginFuncInfo_texinfo},
{"CvModuleInfo_next_set",_wrap_CvModuleInfo_next_set,0,0,2,0},
{"CvModuleInfo_next_get",_wrap_CvModuleInfo_next_get,0,0,2,0},
{"CvModuleInfo_name_set",_wrap_CvModuleInfo_name_set,0,0,2,0},
{"CvModuleInfo_name_get",_wrap_CvModuleInfo_name_get,0,0,2,0},
{"CvModuleInfo_version_set",_wrap_CvModuleInfo_version_set,0,0,2,0},
{"CvModuleInfo_version_get",_wrap_CvModuleInfo_version_get,0,0,2,0},
{"CvModuleInfo_func_tab_set",_wrap_CvModuleInfo_func_tab_set,0,0,2,0},
{"CvModuleInfo_func_tab_get",_wrap_CvModuleInfo_func_tab_get,0,0,2,0},
{"new_CvModuleInfo",_wrap_new_CvModuleInfo,0,0,2,_wrap_new_CvModuleInfo_texinfo},
{"delete_CvModuleInfo",_wrap_delete_CvModuleInfo,0,0,2,_wrap_delete_CvModuleInfo_texinfo},
{"cvAlloc",_wrap_cvAlloc,0,0,2,_wrap_cvAlloc_texinfo},
{"cvFree_",_wrap_cvFree_,0,0,2,_wrap_cvFree__texinfo},
{"cvReleaseImageHeader",_wrap_cvReleaseImageHeader,0,0,2,_wrap_cvReleaseImageHeader_texinfo},
{"cvReleaseImage",_wrap_cvReleaseImage,0,0,2,_wrap_cvReleaseImage_texinfo},
{"cvResetImageROI",_wrap_cvResetImageROI,0,0,2,_wrap_cvResetImageROI_texinfo},
{"cvCreateMatHeader",_wrap_cvCreateMatHeader,0,0,2,_wrap_cvCreateMatHeader_texinfo},
{"cvInitMatHeader",_wrap_cvInitMatHeader,0,0,2,_wrap_cvInitMatHeader_texinfo},
{"cvCreateMat",_wrap_cvCreateMat,0,0,2,_wrap_cvCreateMat_texinfo},
{"cvReleaseMat",_wrap_cvReleaseMat,0,0,2,_wrap_cvReleaseMat_texinfo},
{"cvDecRefData",_wrap_cvDecRefData,0,0,2,_wrap_cvDecRefData_texinfo},
{"cvIncRefData",_wrap_cvIncRefData,0,0,2,_wrap_cvIncRefData_texinfo},
{"cvCloneMat",_wrap_cvCloneMat,0,0,2,_wrap_cvCloneMat_texinfo},
{"cvGetSubRect",_wrap_cvGetSubRect,0,0,2,_wrap_cvGetSubRect_texinfo},
{"cvGetRows",_wrap_cvGetRows,0,0,2,_wrap_cvGetRows_texinfo},
{"cvGetRow",_wrap_cvGetRow,0,0,2,_wrap_cvGetRow_texinfo},
{"cvGetCols",_wrap_cvGetCols,0,0,2,_wrap_cvGetCols_texinfo},
{"cvGetCol",_wrap_cvGetCol,0,0,2,_wrap_cvGetCol_texinfo},
{"cvGetDiag",_wrap_cvGetDiag,0,0,2,_wrap_cvGetDiag_texinfo},
{"cvScalarToRawData",_wrap_cvScalarToRawData,0,0,2,_wrap_cvScalarToRawData_texinfo},
{"cvRawDataToScalar",_wrap_cvRawDataToScalar,0,0,2,_wrap_cvRawDataToScalar_texinfo},
{"cvCreateMatNDHeader",_wrap_cvCreateMatNDHeader,0,0,2,_wrap_cvCreateMatNDHeader_texinfo},
{"cvCreateMatND",_wrap_cvCreateMatND,0,0,2,_wrap_cvCreateMatND_texinfo},
{"cvInitMatNDHeader",_wrap_cvInitMatNDHeader,0,0,2,_wrap_cvInitMatNDHeader_texinfo},
{"cvReleaseMatND",_wrap_cvReleaseMatND,0,0,2,_wrap_cvReleaseMatND_texinfo},
{"cvCloneMatND",_wrap_cvCloneMatND,0,0,2,_wrap_cvCloneMatND_texinfo},
{"cvCreateSparseMat",_wrap_cvCreateSparseMat,0,0,2,_wrap_cvCreateSparseMat_texinfo},
{"cvReleaseSparseMat",_wrap_cvReleaseSparseMat,0,0,2,_wrap_cvReleaseSparseMat_texinfo},
{"cvCloneSparseMat",_wrap_cvCloneSparseMat,0,0,2,_wrap_cvCloneSparseMat_texinfo},
{"cvInitSparseMatIterator",_wrap_cvInitSparseMatIterator,0,0,2,_wrap_cvInitSparseMatIterator_texinfo},
{"cvGetNextSparseNode",_wrap_cvGetNextSparseNode,0,0,2,_wrap_cvGetNextSparseNode_texinfo},
{"CvNArrayIterator_count_set",_wrap_CvNArrayIterator_count_set,0,0,2,0},
{"CvNArrayIterator_count_get",_wrap_CvNArrayIterator_count_get,0,0,2,0},
{"CvNArrayIterator_dims_set",_wrap_CvNArrayIterator_dims_set,0,0,2,0},
{"CvNArrayIterator_dims_get",_wrap_CvNArrayIterator_dims_get,0,0,2,0},
{"CvNArrayIterator_size_set",_wrap_CvNArrayIterator_size_set,0,0,2,0},
{"CvNArrayIterator_size_get",_wrap_CvNArrayIterator_size_get,0,0,2,0},
{"CvNArrayIterator_ptr_set",_wrap_CvNArrayIterator_ptr_set,0,0,2,0},
{"CvNArrayIterator_ptr_get",_wrap_CvNArrayIterator_ptr_get,0,0,2,0},
{"CvNArrayIterator_stack_set",_wrap_CvNArrayIterator_stack_set,0,0,2,0},
{"CvNArrayIterator_stack_get",_wrap_CvNArrayIterator_stack_get,0,0,2,0},
{"CvNArrayIterator_hdr_set",_wrap_CvNArrayIterator_hdr_set,0,0,2,0},
{"CvNArrayIterator_hdr_get",_wrap_CvNArrayIterator_hdr_get,0,0,2,0},
{"new_CvNArrayIterator",_wrap_new_CvNArrayIterator,0,0,2,_wrap_new_CvNArrayIterator_texinfo},
{"delete_CvNArrayIterator",_wrap_delete_CvNArrayIterator,0,0,2,_wrap_delete_CvNArrayIterator_texinfo},
{"cvInitNArrayIterator",_wrap_cvInitNArrayIterator,0,0,2,_wrap_cvInitNArrayIterator_texinfo},
{"cvNextNArraySlice",_wrap_cvNextNArraySlice,0,0,2,_wrap_cvNextNArraySlice_texinfo},
{"cvGetElemType",_wrap_cvGetElemType,0,0,2,_wrap_cvGetElemType_texinfo},
{"cvGetDims",_wrap_cvGetDims,0,0,2,_wrap_cvGetDims_texinfo},
{"cvGetDimSize",_wrap_cvGetDimSize,0,0,2,_wrap_cvGetDimSize_texinfo},
{"cvPtr1D",_wrap_cvPtr1D,0,0,2,_wrap_cvPtr1D_texinfo},
{"cvPtr2D",_wrap_cvPtr2D,0,0,2,_wrap_cvPtr2D_texinfo},
{"cvPtr3D",_wrap_cvPtr3D,0,0,2,_wrap_cvPtr3D_texinfo},
{"cvPtrND",_wrap_cvPtrND,0,0,2,_wrap_cvPtrND_texinfo},
{"cvGet1D",_wrap_cvGet1D,0,0,2,_wrap_cvGet1D_texinfo},
{"cvGet2D",_wrap_cvGet2D,0,0,2,_wrap_cvGet2D_texinfo},
{"cvGet3D",_wrap_cvGet3D,0,0,2,_wrap_cvGet3D_texinfo},
{"cvGetND",_wrap_cvGetND,0,0,2,_wrap_cvGetND_texinfo},
{"cvGetReal1D",_wrap_cvGetReal1D,0,0,2,_wrap_cvGetReal1D_texinfo},
{"cvGetReal2D",_wrap_cvGetReal2D,0,0,2,_wrap_cvGetReal2D_texinfo},
{"cvGetReal3D",_wrap_cvGetReal3D,0,0,2,_wrap_cvGetReal3D_texinfo},
{"cvGetRealND",_wrap_cvGetRealND,0,0,2,_wrap_cvGetRealND_texinfo},
{"cvSet1D",_wrap_cvSet1D,0,0,2,_wrap_cvSet1D_texinfo},
{"cvSet2D",_wrap_cvSet2D,0,0,2,_wrap_cvSet2D_texinfo},
{"cvSet3D",_wrap_cvSet3D,0,0,2,_wrap_cvSet3D_texinfo},
{"cvSetND",_wrap_cvSetND,0,0,2,_wrap_cvSetND_texinfo},
{"cvSetReal1D",_wrap_cvSetReal1D,0,0,2,_wrap_cvSetReal1D_texinfo},
{"cvSetReal2D",_wrap_cvSetReal2D,0,0,2,_wrap_cvSetReal2D_texinfo},
{"cvSetReal3D",_wrap_cvSetReal3D,0,0,2,_wrap_cvSetReal3D_texinfo},
{"cvSetRealND",_wrap_cvSetRealND,0,0,2,_wrap_cvSetRealND_texinfo},
{"cvClearND",_wrap_cvClearND,0,0,2,_wrap_cvClearND_texinfo},
{"cvGetMat",_wrap_cvGetMat,0,0,2,_wrap_cvGetMat_texinfo},
{"cvReshapeMatND",_wrap_cvReshapeMatND,0,0,2,_wrap_cvReshapeMatND_texinfo},
{"cvReshape",_wrap_cvReshape,0,0,2,_wrap_cvReshape_texinfo},
{"cvRepeat",_wrap_cvRepeat,0,0,2,_wrap_cvRepeat_texinfo},
{"cvCreateData",_wrap_cvCreateData,0,0,2,_wrap_cvCreateData_texinfo},
{"cvReleaseData",_wrap_cvReleaseData,0,0,2,_wrap_cvReleaseData_texinfo},
{"cvSetData",_wrap_cvSetData,0,0,2,_wrap_cvSetData_texinfo},
{"cvGetRawData",_wrap_cvGetRawData,0,0,2,_wrap_cvGetRawData_texinfo},
{"cvGetSize",_wrap_cvGetSize,0,0,2,_wrap_cvGetSize_texinfo},
{"cvCopy",_wrap_cvCopy,0,0,2,_wrap_cvCopy_texinfo},
{"cvSet",_wrap_cvSet,0,0,2,_wrap_cvSet_texinfo},
{"cvSetZero",_wrap_cvSetZero,0,0,2,_wrap_cvSetZero_texinfo},
{"cvSplit",_wrap_cvSplit,0,0,2,_wrap_cvSplit_texinfo},
{"cvMerge",_wrap_cvMerge,0,0,2,_wrap_cvMerge_texinfo},
{"cvMixChannels",_wrap_cvMixChannels,0,0,2,_wrap_cvMixChannels_texinfo},
{"cvConvertScale",_wrap_cvConvertScale,0,0,2,_wrap_cvConvertScale_texinfo},
{"cvConvertScaleAbs",_wrap_cvConvertScaleAbs,0,0,2,_wrap_cvConvertScaleAbs_texinfo},
{"cvCheckTermCriteria",_wrap_cvCheckTermCriteria,0,0,2,_wrap_cvCheckTermCriteria_texinfo},
{"cvAdd",_wrap_cvAdd,0,0,2,_wrap_cvAdd_texinfo},
{"cvAddS",_wrap_cvAddS,0,0,2,_wrap_cvAddS_texinfo},
{"cvSub",_wrap_cvSub,0,0,2,_wrap_cvSub_texinfo},
{"cvSubS",_wrap_cvSubS,0,0,2,_wrap_cvSubS_texinfo},
{"cvSubRS",_wrap_cvSubRS,0,0,2,_wrap_cvSubRS_texinfo},
{"cvMul",_wrap_cvMul,0,0,2,_wrap_cvMul_texinfo},
{"cvDiv",_wrap_cvDiv,0,0,2,_wrap_cvDiv_texinfo},
{"cvScaleAdd",_wrap_cvScaleAdd,0,0,2,_wrap_cvScaleAdd_texinfo},
{"cvAddWeighted",_wrap_cvAddWeighted,0,0,2,_wrap_cvAddWeighted_texinfo},
{"cvDotProduct",_wrap_cvDotProduct,0,0,2,_wrap_cvDotProduct_texinfo},
{"cvAnd",_wrap_cvAnd,0,0,2,_wrap_cvAnd_texinfo},
{"cvAndS",_wrap_cvAndS,0,0,2,_wrap_cvAndS_texinfo},
{"cvOr",_wrap_cvOr,0,0,2,_wrap_cvOr_texinfo},
{"cvOrS",_wrap_cvOrS,0,0,2,_wrap_cvOrS_texinfo},
{"cvXor",_wrap_cvXor,0,0,2,_wrap_cvXor_texinfo},
{"cvXorS",_wrap_cvXorS,0,0,2,_wrap_cvXorS_texinfo},
{"cvNot",_wrap_cvNot,0,0,2,_wrap_cvNot_texinfo},
{"cvInRange",_wrap_cvInRange,0,0,2,_wrap_cvInRange_texinfo},
{"cvInRangeS",_wrap_cvInRangeS,0,0,2,_wrap_cvInRangeS_texinfo},
{"cvCmp",_wrap_cvCmp,0,0,2,_wrap_cvCmp_texinfo},
{"cvCmpS",_wrap_cvCmpS,0,0,2,_wrap_cvCmpS_texinfo},
{"cvMin",_wrap_cvMin,0,0,2,_wrap_cvMin_texinfo},
{"cvMax",_wrap_cvMax,0,0,2,_wrap_cvMax_texinfo},
{"cvMinS",_wrap_cvMinS,0,0,2,_wrap_cvMinS_texinfo},
{"cvMaxS",_wrap_cvMaxS,0,0,2,_wrap_cvMaxS_texinfo},
{"cvAbsDiff",_wrap_cvAbsDiff,0,0,2,_wrap_cvAbsDiff_texinfo},
{"cvAbsDiffS",_wrap_cvAbsDiffS,0,0,2,_wrap_cvAbsDiffS_texinfo},
{"cvCartToPolar",_wrap_cvCartToPolar,0,0,2,_wrap_cvCartToPolar_texinfo},
{"cvPolarToCart",_wrap_cvPolarToCart,0,0,2,_wrap_cvPolarToCart_texinfo},
{"cvPow",_wrap_cvPow,0,0,2,_wrap_cvPow_texinfo},
{"cvExp",_wrap_cvExp,0,0,2,_wrap_cvExp_texinfo},
{"cvLog",_wrap_cvLog,0,0,2,_wrap_cvLog_texinfo},
{"cvFastArctan",_wrap_cvFastArctan,0,0,2,_wrap_cvFastArctan_texinfo},
{"cvCbrt",_wrap_cvCbrt,0,0,2,_wrap_cvCbrt_texinfo},
{"cvCheckArr",_wrap_cvCheckArr,0,0,2,_wrap_cvCheckArr_texinfo},
{"cvRandArr",_wrap_cvRandArr,0,0,2,_wrap_cvRandArr_texinfo},
{"cvRandShuffle",_wrap_cvRandShuffle,0,0,2,_wrap_cvRandShuffle_texinfo},
{"cvSort",_wrap_cvSort,0,0,2,_wrap_cvSort_texinfo},
{"cvSolveCubic",_wrap_cvSolveCubic,0,0,2,_wrap_cvSolveCubic_texinfo},
{"cvSolvePoly",_wrap_cvSolvePoly,0,0,2,_wrap_cvSolvePoly_texinfo},
{"cvCrossProduct",_wrap_cvCrossProduct,0,0,2,_wrap_cvCrossProduct_texinfo},
{"cvGEMM",_wrap_cvGEMM,0,0,2,_wrap_cvGEMM_texinfo},
{"cvTransform",_wrap_cvTransform,0,0,2,_wrap_cvTransform_texinfo},
{"cvPerspectiveTransform",_wrap_cvPerspectiveTransform,0,0,2,_wrap_cvPerspectiveTransform_texinfo},
{"cvMulTransposed",_wrap_cvMulTransposed,0,0,2,_wrap_cvMulTransposed_texinfo},
{"cvTranspose",_wrap_cvTranspose,0,0,2,_wrap_cvTranspose_texinfo},
{"cvCompleteSymm",_wrap_cvCompleteSymm,0,0,2,_wrap_cvCompleteSymm_texinfo},
{"cvFlip",_wrap_cvFlip,0,0,2,_wrap_cvFlip_texinfo},
{"cvSVD",_wrap_cvSVD,0,0,2,_wrap_cvSVD_texinfo},
{"cvSVBkSb",_wrap_cvSVBkSb,0,0,2,_wrap_cvSVBkSb_texinfo},
{"cvInvert",_wrap_cvInvert,0,0,2,_wrap_cvInvert_texinfo},
{"cvSolve",_wrap_cvSolve,0,0,2,_wrap_cvSolve_texinfo},
{"cvDet",_wrap_cvDet,0,0,2,_wrap_cvDet_texinfo},
{"cvTrace",_wrap_cvTrace,0,0,2,_wrap_cvTrace_texinfo},
{"cvEigenVV",_wrap_cvEigenVV,0,0,2,_wrap_cvEigenVV_texinfo},
{"cvSetIdentity",_wrap_cvSetIdentity,0,0,2,_wrap_cvSetIdentity_texinfo},
{"cvRange",_wrap_cvRange,0,0,2,_wrap_cvRange_texinfo},
{"cvCalcCovarMatrix",_wrap_cvCalcCovarMatrix,0,0,2,_wrap_cvCalcCovarMatrix_texinfo},
{"cvCalcPCA",_wrap_cvCalcPCA,0,0,2,_wrap_cvCalcPCA_texinfo},
{"cvProjectPCA",_wrap_cvProjectPCA,0,0,2,_wrap_cvProjectPCA_texinfo},
{"cvBackProjectPCA",_wrap_cvBackProjectPCA,0,0,2,_wrap_cvBackProjectPCA_texinfo},
{"cvMahalanobis",_wrap_cvMahalanobis,0,0,2,_wrap_cvMahalanobis_texinfo},
{"cvSum",_wrap_cvSum,0,0,2,_wrap_cvSum_texinfo},
{"cvCountNonZero",_wrap_cvCountNonZero,0,0,2,_wrap_cvCountNonZero_texinfo},
{"cvAvg",_wrap_cvAvg,0,0,2,_wrap_cvAvg_texinfo},
{"cvAvgSdv",_wrap_cvAvgSdv,0,0,2,_wrap_cvAvgSdv_texinfo},
{"cvMinMaxLoc",_wrap_cvMinMaxLoc,0,0,2,_wrap_cvMinMaxLoc_texinfo},
{"cvNorm",_wrap_cvNorm,0,0,2,_wrap_cvNorm_texinfo},
{"cvNormalize",_wrap_cvNormalize,0,0,2,_wrap_cvNormalize_texinfo},
{"cvReduce",_wrap_cvReduce,0,0,2,_wrap_cvReduce_texinfo},
{"cvDFT",_wrap_cvDFT,0,0,2,_wrap_cvDFT_texinfo},
{"cvMulSpectrums",_wrap_cvMulSpectrums,0,0,2,_wrap_cvMulSpectrums_texinfo},
{"cvGetOptimalDFTSize",_wrap_cvGetOptimalDFTSize,0,0,2,_wrap_cvGetOptimalDFTSize_texinfo},
{"cvDCT",_wrap_cvDCT,0,0,2,_wrap_cvDCT_texinfo},
{"cvSliceLength",_wrap_cvSliceLength,0,0,2,_wrap_cvSliceLength_texinfo},
{"cvCreateMemStorage",_wrap_cvCreateMemStorage,0,0,2,_wrap_cvCreateMemStorage_texinfo},
{"cvCreateChildMemStorage",_wrap_cvCreateChildMemStorage,0,0,2,_wrap_cvCreateChildMemStorage_texinfo},
{"cvReleaseMemStorage",_wrap_cvReleaseMemStorage,0,0,2,_wrap_cvReleaseMemStorage_texinfo},
{"cvClearMemStorage",_wrap_cvClearMemStorage,0,0,2,_wrap_cvClearMemStorage_texinfo},
{"cvSaveMemStoragePos",_wrap_cvSaveMemStoragePos,0,0,2,_wrap_cvSaveMemStoragePos_texinfo},
{"cvRestoreMemStoragePos",_wrap_cvRestoreMemStoragePos,0,0,2,_wrap_cvRestoreMemStoragePos_texinfo},
{"cvMemStorageAlloc",_wrap_cvMemStorageAlloc,0,0,2,_wrap_cvMemStorageAlloc_texinfo},
{"cvMemStorageAllocString",_wrap_cvMemStorageAllocString,0,0,2,_wrap_cvMemStorageAllocString_texinfo},
{"cvCreateSeq",_wrap_cvCreateSeq,0,0,2,_wrap_cvCreateSeq_texinfo},
{"cvSetSeqBlockSize",_wrap_cvSetSeqBlockSize,0,0,2,_wrap_cvSetSeqBlockSize_texinfo},
{"cvSeqPush",_wrap_cvSeqPush,0,0,2,_wrap_cvSeqPush_texinfo},
{"cvSeqPushFront",_wrap_cvSeqPushFront,0,0,2,_wrap_cvSeqPushFront_texinfo},
{"cvSeqPop",_wrap_cvSeqPop,0,0,2,_wrap_cvSeqPop_texinfo},
{"cvSeqPopFront",_wrap_cvSeqPopFront,0,0,2,_wrap_cvSeqPopFront_texinfo},
{"cvSeqPushMulti",_wrap_cvSeqPushMulti,0,0,2,_wrap_cvSeqPushMulti_texinfo},
{"cvSeqPopMulti",_wrap_cvSeqPopMulti,0,0,2,_wrap_cvSeqPopMulti_texinfo},
{"cvSeqInsert",_wrap_cvSeqInsert,0,0,2,_wrap_cvSeqInsert_texinfo},
{"cvSeqRemove",_wrap_cvSeqRemove,0,0,2,_wrap_cvSeqRemove_texinfo},
{"cvClearSeq",_wrap_cvClearSeq,0,0,2,_wrap_cvClearSeq_texinfo},
{"cvGetSeqElem",_wrap_cvGetSeqElem,0,0,2,_wrap_cvGetSeqElem_texinfo},
{"cvSeqElemIdx",_wrap_cvSeqElemIdx,0,0,2,_wrap_cvSeqElemIdx_texinfo},
{"cvStartAppendToSeq",_wrap_cvStartAppendToSeq,0,0,2,_wrap_cvStartAppendToSeq_texinfo},
{"cvStartWriteSeq",_wrap_cvStartWriteSeq,0,0,2,_wrap_cvStartWriteSeq_texinfo},
{"cvEndWriteSeq",_wrap_cvEndWriteSeq,0,0,2,_wrap_cvEndWriteSeq_texinfo},
{"cvFlushSeqWriter",_wrap_cvFlushSeqWriter,0,0,2,_wrap_cvFlushSeqWriter_texinfo},
{"cvStartReadSeq",_wrap_cvStartReadSeq,0,0,2,_wrap_cvStartReadSeq_texinfo},
{"cvGetSeqReaderPos",_wrap_cvGetSeqReaderPos,0,0,2,_wrap_cvGetSeqReaderPos_texinfo},
{"cvSetSeqReaderPos",_wrap_cvSetSeqReaderPos,0,0,2,_wrap_cvSetSeqReaderPos_texinfo},
{"cvMakeSeqHeaderForArray",_wrap_cvMakeSeqHeaderForArray,0,0,2,_wrap_cvMakeSeqHeaderForArray_texinfo},
{"cvSeqSlice",_wrap_cvSeqSlice,0,0,2,_wrap_cvSeqSlice_texinfo},
{"cvCloneSeq",_wrap_cvCloneSeq,0,0,2,_wrap_cvCloneSeq_texinfo},
{"cvSeqRemoveSlice",_wrap_cvSeqRemoveSlice,0,0,2,_wrap_cvSeqRemoveSlice_texinfo},
{"cvSeqInsertSlice",_wrap_cvSeqInsertSlice,0,0,2,_wrap_cvSeqInsertSlice_texinfo},
{"cvSeqSort",_wrap_cvSeqSort,0,0,2,_wrap_cvSeqSort_texinfo},
{"cvSeqSearch",_wrap_cvSeqSearch,0,0,2,_wrap_cvSeqSearch_texinfo},
{"cvSeqInvert",_wrap_cvSeqInvert,0,0,2,_wrap_cvSeqInvert_texinfo},
{"cvSeqPartition",_wrap_cvSeqPartition,0,0,2,_wrap_cvSeqPartition_texinfo},
{"cvChangeSeqBlock",_wrap_cvChangeSeqBlock,0,0,2,_wrap_cvChangeSeqBlock_texinfo},
{"cvCreateSeqBlock",_wrap_cvCreateSeqBlock,0,0,2,_wrap_cvCreateSeqBlock_texinfo},
{"cvCreateSet",_wrap_cvCreateSet,0,0,2,_wrap_cvCreateSet_texinfo},
{"cvSetAdd",_wrap_cvSetAdd,0,0,2,_wrap_cvSetAdd_texinfo},
{"cvSetNew",_wrap_cvSetNew,0,0,2,_wrap_cvSetNew_texinfo},
{"cvSetRemoveByPtr",_wrap_cvSetRemoveByPtr,0,0,2,_wrap_cvSetRemoveByPtr_texinfo},
{"cvSetRemove",_wrap_cvSetRemove,0,0,2,_wrap_cvSetRemove_texinfo},
{"cvGetSetElem",_wrap_cvGetSetElem,0,0,2,_wrap_cvGetSetElem_texinfo},
{"cvClearSet",_wrap_cvClearSet,0,0,2,_wrap_cvClearSet_texinfo},
{"cvCreateGraph",_wrap_cvCreateGraph,0,0,2,_wrap_cvCreateGraph_texinfo},
{"cvGraphAddVtx",_wrap_cvGraphAddVtx,0,0,2,_wrap_cvGraphAddVtx_texinfo},
{"cvGraphRemoveVtx",_wrap_cvGraphRemoveVtx,0,0,2,_wrap_cvGraphRemoveVtx_texinfo},
{"cvGraphRemoveVtxByPtr",_wrap_cvGraphRemoveVtxByPtr,0,0,2,_wrap_cvGraphRemoveVtxByPtr_texinfo},
{"cvGraphAddEdge",_wrap_cvGraphAddEdge,0,0,2,_wrap_cvGraphAddEdge_texinfo},
{"cvGraphAddEdgeByPtr",_wrap_cvGraphAddEdgeByPtr,0,0,2,_wrap_cvGraphAddEdgeByPtr_texinfo},
{"cvGraphRemoveEdge",_wrap_cvGraphRemoveEdge,0,0,2,_wrap_cvGraphRemoveEdge_texinfo},
{"cvGraphRemoveEdgeByPtr",_wrap_cvGraphRemoveEdgeByPtr,0,0,2,_wrap_cvGraphRemoveEdgeByPtr_texinfo},
{"cvFindGraphEdge",_wrap_cvFindGraphEdge,0,0,2,_wrap_cvFindGraphEdge_texinfo},
{"cvFindGraphEdgeByPtr",_wrap_cvFindGraphEdgeByPtr,0,0,2,_wrap_cvFindGraphEdgeByPtr_texinfo},
{"cvClearGraph",_wrap_cvClearGraph,0,0,2,_wrap_cvClearGraph_texinfo},
{"cvGraphVtxDegree",_wrap_cvGraphVtxDegree,0,0,2,_wrap_cvGraphVtxDegree_texinfo},
{"cvGraphVtxDegreeByPtr",_wrap_cvGraphVtxDegreeByPtr,0,0,2,_wrap_cvGraphVtxDegreeByPtr_texinfo},
{"CvGraphScanner_vtx_set",_wrap_CvGraphScanner_vtx_set,0,0,2,0},
{"CvGraphScanner_vtx_get",_wrap_CvGraphScanner_vtx_get,0,0,2,0},
{"CvGraphScanner_dst_set",_wrap_CvGraphScanner_dst_set,0,0,2,0},
{"CvGraphScanner_dst_get",_wrap_CvGraphScanner_dst_get,0,0,2,0},
{"CvGraphScanner_edge_set",_wrap_CvGraphScanner_edge_set,0,0,2,0},
{"CvGraphScanner_edge_get",_wrap_CvGraphScanner_edge_get,0,0,2,0},
{"CvGraphScanner_graph_set",_wrap_CvGraphScanner_graph_set,0,0,2,0},
{"CvGraphScanner_graph_get",_wrap_CvGraphScanner_graph_get,0,0,2,0},
{"CvGraphScanner_stack_set",_wrap_CvGraphScanner_stack_set,0,0,2,0},
{"CvGraphScanner_stack_get",_wrap_CvGraphScanner_stack_get,0,0,2,0},
{"CvGraphScanner_index_set",_wrap_CvGraphScanner_index_set,0,0,2,0},
{"CvGraphScanner_index_get",_wrap_CvGraphScanner_index_get,0,0,2,0},
{"CvGraphScanner_mask_set",_wrap_CvGraphScanner_mask_set,0,0,2,0},
{"CvGraphScanner_mask_get",_wrap_CvGraphScanner_mask_get,0,0,2,0},
{"delete_CvGraphScanner",_wrap_delete_CvGraphScanner,0,0,2,_wrap_delete_CvGraphScanner_texinfo},
{"cvCreateGraphScanner",_wrap_cvCreateGraphScanner,0,0,2,_wrap_cvCreateGraphScanner_texinfo},
{"cvReleaseGraphScanner",_wrap_cvReleaseGraphScanner,0,0,2,_wrap_cvReleaseGraphScanner_texinfo},
{"cvNextGraphItem",_wrap_cvNextGraphItem,0,0,2,_wrap_cvNextGraphItem_texinfo},
{"cvCloneGraph",_wrap_cvCloneGraph,0,0,2,_wrap_cvCloneGraph_texinfo},
{"cvLine",_wrap_cvLine,0,0,2,_wrap_cvLine_texinfo},
{"cvRectangle",_wrap_cvRectangle,0,0,2,_wrap_cvRectangle_texinfo},
{"cvCircle",_wrap_cvCircle,0,0,2,_wrap_cvCircle_texinfo},
{"cvEllipse",_wrap_cvEllipse,0,0,2,_wrap_cvEllipse_texinfo},
{"cvEllipseBox",_wrap_cvEllipseBox,0,0,2,_wrap_cvEllipseBox_texinfo},
{"cvFillConvexPoly",_wrap_cvFillConvexPoly,0,0,2,_wrap_cvFillConvexPoly_texinfo},
{"cvFillPoly",_wrap_cvFillPoly,0,0,2,_wrap_cvFillPoly_texinfo},
{"cvPolyLine",_wrap_cvPolyLine,0,0,2,_wrap_cvPolyLine_texinfo},
{"cvClipLine",_wrap_cvClipLine,0,0,2,_wrap_cvClipLine_texinfo},
{"cvInitLineIterator",_wrap_cvInitLineIterator,0,0,2,_wrap_cvInitLineIterator_texinfo},
{"CvFont_font_face_set",_wrap_CvFont_font_face_set,0,0,2,0},
{"CvFont_font_face_get",_wrap_CvFont_font_face_get,0,0,2,0},
{"CvFont_ascii_set",_wrap_CvFont_ascii_set,0,0,2,0},
{"CvFont_ascii_get",_wrap_CvFont_ascii_get,0,0,2,0},
{"CvFont_greek_set",_wrap_CvFont_greek_set,0,0,2,0},
{"CvFont_greek_get",_wrap_CvFont_greek_get,0,0,2,0},
{"CvFont_cyrillic_set",_wrap_CvFont_cyrillic_set,0,0,2,0},
{"CvFont_cyrillic_get",_wrap_CvFont_cyrillic_get,0,0,2,0},
{"CvFont_hscale_set",_wrap_CvFont_hscale_set,0,0,2,0},
{"CvFont_hscale_get",_wrap_CvFont_hscale_get,0,0,2,0},
{"CvFont_vscale_set",_wrap_CvFont_vscale_set,0,0,2,0},
{"CvFont_vscale_get",_wrap_CvFont_vscale_get,0,0,2,0},
{"CvFont_shear_set",_wrap_CvFont_shear_set,0,0,2,0},
{"CvFont_shear_get",_wrap_CvFont_shear_get,0,0,2,0},
{"CvFont_thickness_set",_wrap_CvFont_thickness_set,0,0,2,0},
{"CvFont_thickness_get",_wrap_CvFont_thickness_get,0,0,2,0},
{"CvFont_dx_set",_wrap_CvFont_dx_set,0,0,2,0},
{"CvFont_dx_get",_wrap_CvFont_dx_get,0,0,2,0},
{"CvFont_line_type_set",_wrap_CvFont_line_type_set,0,0,2,0},
{"CvFont_line_type_get",_wrap_CvFont_line_type_get,0,0,2,0},
{"new_CvFont",_wrap_new_CvFont,0,0,2,_wrap_new_CvFont_texinfo},
{"delete_CvFont",_wrap_delete_CvFont,0,0,2,_wrap_delete_CvFont_texinfo},
{"cvInitFont",_wrap_cvInitFont,0,0,2,_wrap_cvInitFont_texinfo},
{"cvFont",_wrap_cvFont,0,0,2,_wrap_cvFont_texinfo},
{"cvPutText",_wrap_cvPutText,0,0,2,_wrap_cvPutText_texinfo},
{"cvGetTextSize",_wrap_cvGetTextSize,0,0,2,_wrap_cvGetTextSize_texinfo},
{"cvColorToScalar",_wrap_cvColorToScalar,0,0,2,_wrap_cvColorToScalar_texinfo},
{"cvEllipse2Poly",_wrap_cvEllipse2Poly,0,0,2,_wrap_cvEllipse2Poly_texinfo},
{"cvDrawContours",_wrap_cvDrawContours,0,0,2,_wrap_cvDrawContours_texinfo},
{"cvLUT",_wrap_cvLUT,0,0,2,_wrap_cvLUT_texinfo},
{"CvTreeNodeIterator_node_set",_wrap_CvTreeNodeIterator_node_set,0,0,2,0},
{"CvTreeNodeIterator_node_get",_wrap_CvTreeNodeIterator_node_get,0,0,2,0},
{"CvTreeNodeIterator_level_set",_wrap_CvTreeNodeIterator_level_set,0,0,2,0},
{"CvTreeNodeIterator_level_get",_wrap_CvTreeNodeIterator_level_get,0,0,2,0},
{"CvTreeNodeIterator_max_level_set",_wrap_CvTreeNodeIterator_max_level_set,0,0,2,0},
{"CvTreeNodeIterator_max_level_get",_wrap_CvTreeNodeIterator_max_level_get,0,0,2,0},
{"new_CvTreeNodeIterator",_wrap_new_CvTreeNodeIterator,0,0,2,_wrap_new_CvTreeNodeIterator_texinfo},
{"delete_CvTreeNodeIterator",_wrap_delete_CvTreeNodeIterator,0,0,2,_wrap_delete_CvTreeNodeIterator_texinfo},
{"cvInitTreeNodeIterator",_wrap_cvInitTreeNodeIterator,0,0,2,_wrap_cvInitTreeNodeIterator_texinfo},
{"cvNextTreeNode",_wrap_cvNextTreeNode,0,0,2,_wrap_cvNextTreeNode_texinfo},
{"cvPrevTreeNode",_wrap_cvPrevTreeNode,0,0,2,_wrap_cvPrevTreeNode_texinfo},
{"cvInsertNodeIntoTree",_wrap_cvInsertNodeIntoTree,0,0,2,_wrap_cvInsertNodeIntoTree_texinfo},
{"cvRemoveNodeFromTree",_wrap_cvRemoveNodeFromTree,0,0,2,_wrap_cvRemoveNodeFromTree_texinfo},
{"cvTreeToNodeSeq",_wrap_cvTreeToNodeSeq,0,0,2,_wrap_cvTreeToNodeSeq_texinfo},
{"cvKMeans2",_wrap_cvKMeans2,0,0,2,_wrap_cvKMeans2_texinfo},
{"cvRegisterModule",_wrap_cvRegisterModule,0,0,2,_wrap_cvRegisterModule_texinfo},
{"cvUseOptimized",_wrap_cvUseOptimized,0,0,2,_wrap_cvUseOptimized_texinfo},
{"cvGetModuleInfo",_wrap_cvGetModuleInfo,0,0,2,_wrap_cvGetModuleInfo_texinfo},
{"cvGetErrStatus",_wrap_cvGetErrStatus,0,0,2,_wrap_cvGetErrStatus_texinfo},
{"cvSetErrStatus",_wrap_cvSetErrStatus,0,0,2,_wrap_cvSetErrStatus_texinfo},
{"cvGetErrMode",_wrap_cvGetErrMode,0,0,2,_wrap_cvGetErrMode_texinfo},
{"cvSetErrMode",_wrap_cvSetErrMode,0,0,2,_wrap_cvSetErrMode_texinfo},
{"cvError",_wrap_cvError,0,0,2,_wrap_cvError_texinfo},
{"cvErrorStr",_wrap_cvErrorStr,0,0,2,_wrap_cvErrorStr_texinfo},
{"cvGetErrInfo",_wrap_cvGetErrInfo,0,0,2,_wrap_cvGetErrInfo_texinfo},
{"cvErrorFromIppStatus",_wrap_cvErrorFromIppStatus,0,0,2,_wrap_cvErrorFromIppStatus_texinfo},
{"cvRedirectError",_wrap_cvRedirectError,0,0,2,_wrap_cvRedirectError_texinfo},
{"cvNulDevReport",_wrap_cvNulDevReport,0,0,2,_wrap_cvNulDevReport_texinfo},
{"cvStdErrReport",_wrap_cvStdErrReport,0,0,2,_wrap_cvStdErrReport_texinfo},
{"cvGuiBoxReport",_wrap_cvGuiBoxReport,0,0,2,_wrap_cvGuiBoxReport_texinfo},
{"cvSetMemoryManager",_wrap_cvSetMemoryManager,0,0,2,_wrap_cvSetMemoryManager_texinfo},
{"cvSetIPLAllocators",_wrap_cvSetIPLAllocators,0,0,2,_wrap_cvSetIPLAllocators_texinfo},
{"cvOpenFileStorage",_wrap_cvOpenFileStorage,0,0,2,_wrap_cvOpenFileStorage_texinfo},
{"cvReleaseFileStorage",_wrap_cvReleaseFileStorage,0,0,2,_wrap_cvReleaseFileStorage_texinfo},
{"cvAttrValue",_wrap_cvAttrValue,0,0,2,_wrap_cvAttrValue_texinfo},
{"cvStartWriteStruct",_wrap_cvStartWriteStruct,0,0,2,_wrap_cvStartWriteStruct_texinfo},
{"cvEndWriteStruct",_wrap_cvEndWriteStruct,0,0,2,_wrap_cvEndWriteStruct_texinfo},
{"cvWriteInt",_wrap_cvWriteInt,0,0,2,_wrap_cvWriteInt_texinfo},
{"cvWriteReal",_wrap_cvWriteReal,0,0,2,_wrap_cvWriteReal_texinfo},
{"cvWriteString",_wrap_cvWriteString,0,0,2,_wrap_cvWriteString_texinfo},
{"cvWriteComment",_wrap_cvWriteComment,0,0,2,_wrap_cvWriteComment_texinfo},
{"cvWrite",_wrap_cvWrite,0,0,2,_wrap_cvWrite_texinfo},
{"cvStartNextStream",_wrap_cvStartNextStream,0,0,2,_wrap_cvStartNextStream_texinfo},
{"cvWriteRawData",_wrap_cvWriteRawData,0,0,2,_wrap_cvWriteRawData_texinfo},
{"cvGetHashedKey",_wrap_cvGetHashedKey,0,0,2,_wrap_cvGetHashedKey_texinfo},
{"cvGetRootFileNode",_wrap_cvGetRootFileNode,0,0,2,_wrap_cvGetRootFileNode_texinfo},
{"cvGetFileNode",_wrap_cvGetFileNode,0,0,2,_wrap_cvGetFileNode_texinfo},
{"cvGetFileNodeByName",_wrap_cvGetFileNodeByName,0,0,2,_wrap_cvGetFileNodeByName_texinfo},
{"cvReadInt",_wrap_cvReadInt,0,0,2,_wrap_cvReadInt_texinfo},
{"cvReadIntByName",_wrap_cvReadIntByName,0,0,2,_wrap_cvReadIntByName_texinfo},
{"cvReadReal",_wrap_cvReadReal,0,0,2,_wrap_cvReadReal_texinfo},
{"cvReadRealByName",_wrap_cvReadRealByName,0,0,2,_wrap_cvReadRealByName_texinfo},
{"cvReadString",_wrap_cvReadString,0,0,2,_wrap_cvReadString_texinfo},
{"cvReadStringByName",_wrap_cvReadStringByName,0,0,2,_wrap_cvReadStringByName_texinfo},
{"cvRead",_wrap_cvRead,0,0,2,_wrap_cvRead_texinfo},
{"cvReadByName",_wrap_cvReadByName,0,0,2,_wrap_cvReadByName_texinfo},
{"cvStartReadRawData",_wrap_cvStartReadRawData,0,0,2,_wrap_cvStartReadRawData_texinfo},
{"cvReadRawDataSlice",_wrap_cvReadRawDataSlice,0,0,2,_wrap_cvReadRawDataSlice_texinfo},
{"cvReadRawData",_wrap_cvReadRawData,0,0,2,_wrap_cvReadRawData_texinfo},
{"cvWriteFileNode",_wrap_cvWriteFileNode,0,0,2,_wrap_cvWriteFileNode_texinfo},
{"cvGetFileNodeName",_wrap_cvGetFileNodeName,0,0,2,_wrap_cvGetFileNodeName_texinfo},
{"cvRegisterType",_wrap_cvRegisterType,0,0,2,_wrap_cvRegisterType_texinfo},
{"cvUnregisterType",_wrap_cvUnregisterType,0,0,2,_wrap_cvUnregisterType_texinfo},
{"cvFirstType",_wrap_cvFirstType,0,0,2,_wrap_cvFirstType_texinfo},
{"cvFindType",_wrap_cvFindType,0,0,2,_wrap_cvFindType_texinfo},
{"cvTypeOf",_wrap_cvTypeOf,0,0,2,_wrap_cvTypeOf_texinfo},
{"cvRelease",_wrap_cvRelease,0,0,2,_wrap_cvRelease_texinfo},
{"cvClone",_wrap_cvClone,0,0,2,_wrap_cvClone_texinfo},
{"cvSave",_wrap_cvSave,0,0,2,_wrap_cvSave_texinfo},
{"cvLoad",_wrap_cvLoad,0,0,2,_wrap_cvLoad_texinfo},
{"cvGetTickCount",_wrap_cvGetTickCount,0,0,2,_wrap_cvGetTickCount_texinfo},
{"cvGetTickFrequency",_wrap_cvGetTickFrequency,0,0,2,_wrap_cvGetTickFrequency_texinfo},
{"cvGetNumThreads",_wrap_cvGetNumThreads,0,0,2,_wrap_cvGetNumThreads_texinfo},
{"cvSetNumThreads",_wrap_cvSetNumThreads,0,0,2,_wrap_cvSetNumThreads_texinfo},
{"cvGetThreadNum",_wrap_cvGetThreadNum,0,0,2,_wrap_cvGetThreadNum_texinfo},
{"cvSetImageIOFunctions",_wrap_cvSetImageIOFunctions,0,0,2,_wrap_cvSetImageIOFunctions_texinfo},
{"new_CvImage",_wrap_new_CvImage,0,0,2,_wrap_new_CvImage_texinfo},
{"delete_CvImage",_wrap_delete_CvImage,0,0,2,_wrap_delete_CvImage_texinfo},
{"CvImage_clone",_wrap_CvImage_clone,0,0,2,_wrap_CvImage_clone_texinfo},
{"CvImage_create",_wrap_CvImage_create,0,0,2,_wrap_CvImage_create_texinfo},
{"CvImage_release",_wrap_CvImage_release,0,0,2,_wrap_CvImage_release_texinfo},
{"CvImage_clear",_wrap_CvImage_clear,0,0,2,_wrap_CvImage_clear_texinfo},
{"CvImage_attach",_wrap_CvImage_attach,0,0,2,_wrap_CvImage_attach_texinfo},
{"CvImage_detach",_wrap_CvImage_detach,0,0,2,_wrap_CvImage_detach_texinfo},
{"CvImage_load",_wrap_CvImage_load,0,0,2,_wrap_CvImage_load_texinfo},
{"CvImage_read",_wrap_CvImage_read,0,0,2,_wrap_CvImage_read_texinfo},
{"CvImage_save",_wrap_CvImage_save,0,0,2,_wrap_CvImage_save_texinfo},
{"CvImage_write",_wrap_CvImage_write,0,0,2,_wrap_CvImage_write_texinfo},
{"CvImage_show",_wrap_CvImage_show,0,0,2,_wrap_CvImage_show_texinfo},
{"CvImage_is_valid",_wrap_CvImage_is_valid,0,0,2,_wrap_CvImage_is_valid_texinfo},
{"CvImage_width",_wrap_CvImage_width,0,0,2,_wrap_CvImage_width_texinfo},
{"CvImage_height",_wrap_CvImage_height,0,0,2,_wrap_CvImage_height_texinfo},
{"CvImage_size",_wrap_CvImage_size,0,0,2,_wrap_CvImage_size_texinfo},
{"CvImage_roi_size",_wrap_CvImage_roi_size,0,0,2,_wrap_CvImage_roi_size_texinfo},
{"CvImage_roi",_wrap_CvImage_roi,0,0,2,_wrap_CvImage_roi_texinfo},
{"CvImage_coi",_wrap_CvImage_coi,0,0,2,_wrap_CvImage_coi_texinfo},
{"CvImage_set_roi",_wrap_CvImage_set_roi,0,0,2,_wrap_CvImage_set_roi_texinfo},
{"CvImage_reset_roi",_wrap_CvImage_reset_roi,0,0,2,_wrap_CvImage_reset_roi_texinfo},
{"CvImage_set_coi",_wrap_CvImage_set_coi,0,0,2,_wrap_CvImage_set_coi_texinfo},
{"CvImage_depth",_wrap_CvImage_depth,0,0,2,_wrap_CvImage_depth_texinfo},
{"CvImage_channels",_wrap_CvImage_channels,0,0,2,_wrap_CvImage_channels_texinfo},
{"CvImage_pix_size",_wrap_CvImage_pix_size,0,0,2,_wrap_CvImage_pix_size_texinfo},
{"CvImage_data",_wrap_CvImage_data,0,0,2,_wrap_CvImage_data_texinfo},
{"CvImage_step",_wrap_CvImage_step,0,0,2,_wrap_CvImage_step_texinfo},
{"CvImage_origin",_wrap_CvImage_origin,0,0,2,_wrap_CvImage_origin_texinfo},
{"CvImage_roi_row",_wrap_CvImage_roi_row,0,0,2,_wrap_CvImage_roi_row_texinfo},
{"CvImage_asIplImage",_wrap_CvImage_asIplImage,0,0,2,_wrap_CvImage_asIplImage_texinfo},
{"new_CvMatrix",_wrap_new_CvMatrix,0,0,2,_wrap_new_CvMatrix_texinfo},
{"delete_CvMatrix",_wrap_delete_CvMatrix,0,0,2,_wrap_delete_CvMatrix_texinfo},
{"CvMatrix_clone",_wrap_CvMatrix_clone,0,0,2,_wrap_CvMatrix_clone_texinfo},
{"CvMatrix_set",_wrap_CvMatrix_set,0,0,2,_wrap_CvMatrix_set_texinfo},
{"CvMatrix_create",_wrap_CvMatrix_create,0,0,2,_wrap_CvMatrix_create_texinfo},
{"CvMatrix_addref",_wrap_CvMatrix_addref,0,0,2,_wrap_CvMatrix_addref_texinfo},
{"CvMatrix_release",_wrap_CvMatrix_release,0,0,2,_wrap_CvMatrix_release_texinfo},
{"CvMatrix_clear",_wrap_CvMatrix_clear,0,0,2,_wrap_CvMatrix_clear_texinfo},
{"CvMatrix_load",_wrap_CvMatrix_load,0,0,2,_wrap_CvMatrix_load_texinfo},
{"CvMatrix_read",_wrap_CvMatrix_read,0,0,2,_wrap_CvMatrix_read_texinfo},
{"CvMatrix_save",_wrap_CvMatrix_save,0,0,2,_wrap_CvMatrix_save_texinfo},
{"CvMatrix_write",_wrap_CvMatrix_write,0,0,2,_wrap_CvMatrix_write_texinfo},
{"CvMatrix_show",_wrap_CvMatrix_show,0,0,2,_wrap_CvMatrix_show_texinfo},
{"CvMatrix_is_valid",_wrap_CvMatrix_is_valid,0,0,2,_wrap_CvMatrix_is_valid_texinfo},
{"CvMatrix_rows",_wrap_CvMatrix_rows,0,0,2,_wrap_CvMatrix_rows_texinfo},
{"CvMatrix_cols",_wrap_CvMatrix_cols,0,0,2,_wrap_CvMatrix_cols_texinfo},
{"CvMatrix_size",_wrap_CvMatrix_size,0,0,2,_wrap_CvMatrix_size_texinfo},
{"CvMatrix_type",_wrap_CvMatrix_type,0,0,2,_wrap_CvMatrix_type_texinfo},
{"CvMatrix_depth",_wrap_CvMatrix_depth,0,0,2,_wrap_CvMatrix_depth_texinfo},
{"CvMatrix_channels",_wrap_CvMatrix_channels,0,0,2,_wrap_CvMatrix_channels_texinfo},
{"CvMatrix_pix_size",_wrap_CvMatrix_pix_size,0,0,2,_wrap_CvMatrix_pix_size_texinfo},
{"CvMatrix_data",_wrap_CvMatrix_data,0,0,2,_wrap_CvMatrix_data_texinfo},
{"CvMatrix_step",_wrap_CvMatrix_step,0,0,2,_wrap_CvMatrix_step_texinfo},
{"CvMatrix_set_data",_wrap_CvMatrix_set_data,0,0,2,_wrap_CvMatrix_set_data_texinfo},
{"CvMatrix_row",_wrap_CvMatrix_row,0,0,2,_wrap_CvMatrix_row_texinfo},
{"CvMatrix_asCvMat",_wrap_CvMatrix_asCvMat,0,0,2,_wrap_CvMatrix_asCvMat_texinfo},
{"new_CvModule",_wrap_new_CvModule,0,0,2,_wrap_new_CvModule_texinfo},
{"delete_CvModule",_wrap_delete_CvModule,0,0,2,_wrap_delete_CvModule_texinfo},
{"CvModule_info_set",_wrap_CvModule_info_set,0,0,2,0},
{"CvModule_info_get",_wrap_CvModule_info_get,0,0,2,0},
{"CvModule_first",0,_wrap_CvModule_first_get,_wrap_CvModule_first_set,2,0},
{"CvModule_last",0,_wrap_CvModule_last_get,_wrap_CvModule_last_set,2,0},
{"new_CvType",_wrap_new_CvType,0,0,2,_wrap_new_CvType_texinfo},
{"delete_CvType",_wrap_delete_CvType,0,0,2,_wrap_delete_CvType_texinfo},
{"CvType_info_set",_wrap_CvType_info_set,0,0,2,0},
{"CvType_info_get",_wrap_CvType_info_get,0,0,2,0},
{"CvType_first",0,_wrap_CvType_first_get,_wrap_CvType_first_set,2,0},
{"CvType_last",0,_wrap_CvType_last_get,_wrap_CvType_last_set,2,0},
{"CvMoments_m00_set",_wrap_CvMoments_m00_set,0,0,2,0},
{"CvMoments_m00_get",_wrap_CvMoments_m00_get,0,0,2,0},
{"CvMoments_m10_set",_wrap_CvMoments_m10_set,0,0,2,0},
{"CvMoments_m10_get",_wrap_CvMoments_m10_get,0,0,2,0},
{"CvMoments_m01_set",_wrap_CvMoments_m01_set,0,0,2,0},
{"CvMoments_m01_get",_wrap_CvMoments_m01_get,0,0,2,0},
{"CvMoments_m20_set",_wrap_CvMoments_m20_set,0,0,2,0},
{"CvMoments_m20_get",_wrap_CvMoments_m20_get,0,0,2,0},
{"CvMoments_m11_set",_wrap_CvMoments_m11_set,0,0,2,0},
{"CvMoments_m11_get",_wrap_CvMoments_m11_get,0,0,2,0},
{"CvMoments_m02_set",_wrap_CvMoments_m02_set,0,0,2,0},
{"CvMoments_m02_get",_wrap_CvMoments_m02_get,0,0,2,0},
{"CvMoments_m30_set",_wrap_CvMoments_m30_set,0,0,2,0},
{"CvMoments_m30_get",_wrap_CvMoments_m30_get,0,0,2,0},
{"CvMoments_m21_set",_wrap_CvMoments_m21_set,0,0,2,0},
{"CvMoments_m21_get",_wrap_CvMoments_m21_get,0,0,2,0},
{"CvMoments_m12_set",_wrap_CvMoments_m12_set,0,0,2,0},
{"CvMoments_m12_get",_wrap_CvMoments_m12_get,0,0,2,0},
{"CvMoments_m03_set",_wrap_CvMoments_m03_set,0,0,2,0},
{"CvMoments_m03_get",_wrap_CvMoments_m03_get,0,0,2,0},
{"CvMoments_mu20_set",_wrap_CvMoments_mu20_set,0,0,2,0},
{"CvMoments_mu20_get",_wrap_CvMoments_mu20_get,0,0,2,0},
{"CvMoments_mu11_set",_wrap_CvMoments_mu11_set,0,0,2,0},
{"CvMoments_mu11_get",_wrap_CvMoments_mu11_get,0,0,2,0},
{"CvMoments_mu02_set",_wrap_CvMoments_mu02_set,0,0,2,0},
{"CvMoments_mu02_get",_wrap_CvMoments_mu02_get,0,0,2,0},
{"CvMoments_mu30_set",_wrap_CvMoments_mu30_set,0,0,2,0},
{"CvMoments_mu30_get",_wrap_CvMoments_mu30_get,0,0,2,0},
{"CvMoments_mu21_set",_wrap_CvMoments_mu21_set,0,0,2,0},
{"CvMoments_mu21_get",_wrap_CvMoments_mu21_get,0,0,2,0},
{"CvMoments_mu12_set",_wrap_CvMoments_mu12_set,0,0,2,0},
{"CvMoments_mu12_get",_wrap_CvMoments_mu12_get,0,0,2,0},
{"CvMoments_mu03_set",_wrap_CvMoments_mu03_set,0,0,2,0},
{"CvMoments_mu03_get",_wrap_CvMoments_mu03_get,0,0,2,0},
{"CvMoments_inv_sqrt_m00_set",_wrap_CvMoments_inv_sqrt_m00_set,0,0,2,0},
{"CvMoments_inv_sqrt_m00_get",_wrap_CvMoments_inv_sqrt_m00_get,0,0,2,0},
{"new_CvMoments",_wrap_new_CvMoments,0,0,2,_wrap_new_CvMoments_texinfo},
{"delete_CvMoments",_wrap_delete_CvMoments,0,0,2,_wrap_delete_CvMoments_texinfo},
{"CvHuMoments_hu1_set",_wrap_CvHuMoments_hu1_set,0,0,2,0},
{"CvHuMoments_hu1_get",_wrap_CvHuMoments_hu1_get,0,0,2,0},
{"CvHuMoments_hu2_set",_wrap_CvHuMoments_hu2_set,0,0,2,0},
{"CvHuMoments_hu2_get",_wrap_CvHuMoments_hu2_get,0,0,2,0},
{"CvHuMoments_hu3_set",_wrap_CvHuMoments_hu3_set,0,0,2,0},
{"CvHuMoments_hu3_get",_wrap_CvHuMoments_hu3_get,0,0,2,0},
{"CvHuMoments_hu4_set",_wrap_CvHuMoments_hu4_set,0,0,2,0},
{"CvHuMoments_hu4_get",_wrap_CvHuMoments_hu4_get,0,0,2,0},
{"CvHuMoments_hu5_set",_wrap_CvHuMoments_hu5_set,0,0,2,0},
{"CvHuMoments_hu5_get",_wrap_CvHuMoments_hu5_get,0,0,2,0},
{"CvHuMoments_hu6_set",_wrap_CvHuMoments_hu6_set,0,0,2,0},
{"CvHuMoments_hu6_get",_wrap_CvHuMoments_hu6_get,0,0,2,0},
{"CvHuMoments_hu7_set",_wrap_CvHuMoments_hu7_set,0,0,2,0},
{"CvHuMoments_hu7_get",_wrap_CvHuMoments_hu7_get,0,0,2,0},
{"new_CvHuMoments",_wrap_new_CvHuMoments,0,0,2,_wrap_new_CvHuMoments_texinfo},
{"delete_CvHuMoments",_wrap_delete_CvHuMoments,0,0,2,_wrap_delete_CvHuMoments_texinfo},
{"CvConnectedComp_area_set",_wrap_CvConnectedComp_area_set,0,0,2,0},
{"CvConnectedComp_area_get",_wrap_CvConnectedComp_area_get,0,0,2,0},
{"CvConnectedComp_value_set",_wrap_CvConnectedComp_value_set,0,0,2,0},
{"CvConnectedComp_value_get",_wrap_CvConnectedComp_value_get,0,0,2,0},
{"CvConnectedComp_rect_set",_wrap_CvConnectedComp_rect_set,0,0,2,0},
{"CvConnectedComp_rect_get",_wrap_CvConnectedComp_rect_get,0,0,2,0},
{"CvConnectedComp_contour_set",_wrap_CvConnectedComp_contour_set,0,0,2,0},
{"CvConnectedComp_contour_get",_wrap_CvConnectedComp_contour_get,0,0,2,0},
{"new_CvConnectedComp",_wrap_new_CvConnectedComp,0,0,2,_wrap_new_CvConnectedComp_texinfo},
{"delete_CvConnectedComp",_wrap_delete_CvConnectedComp,0,0,2,_wrap_delete_CvConnectedComp_texinfo},
{"CvChainPtReader_header_size_set",_wrap_CvChainPtReader_header_size_set,0,0,2,0},
{"CvChainPtReader_header_size_get",_wrap_CvChainPtReader_header_size_get,0,0,2,0},
{"CvChainPtReader_seq_set",_wrap_CvChainPtReader_seq_set,0,0,2,0},
{"CvChainPtReader_seq_get",_wrap_CvChainPtReader_seq_get,0,0,2,0},
{"CvChainPtReader_block_set",_wrap_CvChainPtReader_block_set,0,0,2,0},
{"CvChainPtReader_block_get",_wrap_CvChainPtReader_block_get,0,0,2,0},
{"CvChainPtReader_ptr_set",_wrap_CvChainPtReader_ptr_set,0,0,2,0},
{"CvChainPtReader_ptr_get",_wrap_CvChainPtReader_ptr_get,0,0,2,0},
{"CvChainPtReader_block_min_set",_wrap_CvChainPtReader_block_min_set,0,0,2,0},
{"CvChainPtReader_block_min_get",_wrap_CvChainPtReader_block_min_get,0,0,2,0},
{"CvChainPtReader_block_max_set",_wrap_CvChainPtReader_block_max_set,0,0,2,0},
{"CvChainPtReader_block_max_get",_wrap_CvChainPtReader_block_max_get,0,0,2,0},
{"CvChainPtReader_delta_index_set",_wrap_CvChainPtReader_delta_index_set,0,0,2,0},
{"CvChainPtReader_delta_index_get",_wrap_CvChainPtReader_delta_index_get,0,0,2,0},
{"CvChainPtReader_prev_elem_set",_wrap_CvChainPtReader_prev_elem_set,0,0,2,0},
{"CvChainPtReader_prev_elem_get",_wrap_CvChainPtReader_prev_elem_get,0,0,2,0},
{"CvChainPtReader_code_set",_wrap_CvChainPtReader_code_set,0,0,2,0},
{"CvChainPtReader_code_get",_wrap_CvChainPtReader_code_get,0,0,2,0},
{"CvChainPtReader_pt_set",_wrap_CvChainPtReader_pt_set,0,0,2,0},
{"CvChainPtReader_pt_get",_wrap_CvChainPtReader_pt_get,0,0,2,0},
{"CvChainPtReader_deltas_set",_wrap_CvChainPtReader_deltas_set,0,0,2,0},
{"CvChainPtReader_deltas_get",_wrap_CvChainPtReader_deltas_get,0,0,2,0},
{"new_CvChainPtReader",_wrap_new_CvChainPtReader,0,0,2,_wrap_new_CvChainPtReader_texinfo},
{"delete_CvChainPtReader",_wrap_delete_CvChainPtReader,0,0,2,_wrap_delete_CvChainPtReader_texinfo},
{"CvContourTree_flags_set",_wrap_CvContourTree_flags_set,0,0,2,0},
{"CvContourTree_flags_get",_wrap_CvContourTree_flags_get,0,0,2,0},
{"CvContourTree_header_size_set",_wrap_CvContourTree_header_size_set,0,0,2,0},
{"CvContourTree_header_size_get",_wrap_CvContourTree_header_size_get,0,0,2,0},
{"CvContourTree_h_prev_set",_wrap_CvContourTree_h_prev_set,0,0,2,0},
{"CvContourTree_h_prev_get",_wrap_CvContourTree_h_prev_get,0,0,2,0},
{"CvContourTree_h_next_set",_wrap_CvContourTree_h_next_set,0,0,2,0},
{"CvContourTree_h_next_get",_wrap_CvContourTree_h_next_get,0,0,2,0},
{"CvContourTree_v_prev_set",_wrap_CvContourTree_v_prev_set,0,0,2,0},
{"CvContourTree_v_prev_get",_wrap_CvContourTree_v_prev_get,0,0,2,0},
{"CvContourTree_v_next_set",_wrap_CvContourTree_v_next_set,0,0,2,0},
{"CvContourTree_v_next_get",_wrap_CvContourTree_v_next_get,0,0,2,0},
{"CvContourTree_total_set",_wrap_CvContourTree_total_set,0,0,2,0},
{"CvContourTree_total_get",_wrap_CvContourTree_total_get,0,0,2,0},
{"CvContourTree_elem_size_set",_wrap_CvContourTree_elem_size_set,0,0,2,0},
{"CvContourTree_elem_size_get",_wrap_CvContourTree_elem_size_get,0,0,2,0},
{"CvContourTree_block_max_set",_wrap_CvContourTree_block_max_set,0,0,2,0},
{"CvContourTree_block_max_get",_wrap_CvContourTree_block_max_get,0,0,2,0},
{"CvContourTree_ptr_set",_wrap_CvContourTree_ptr_set,0,0,2,0},
{"CvContourTree_ptr_get",_wrap_CvContourTree_ptr_get,0,0,2,0},
{"CvContourTree_delta_elems_set",_wrap_CvContourTree_delta_elems_set,0,0,2,0},
{"CvContourTree_delta_elems_get",_wrap_CvContourTree_delta_elems_get,0,0,2,0},
{"CvContourTree_storage_set",_wrap_CvContourTree_storage_set,0,0,2,0},
{"CvContourTree_storage_get",_wrap_CvContourTree_storage_get,0,0,2,0},
{"CvContourTree_free_blocks_set",_wrap_CvContourTree_free_blocks_set,0,0,2,0},
{"CvContourTree_free_blocks_get",_wrap_CvContourTree_free_blocks_get,0,0,2,0},
{"CvContourTree_first_set",_wrap_CvContourTree_first_set,0,0,2,0},
{"CvContourTree_first_get",_wrap_CvContourTree_first_get,0,0,2,0},
{"CvContourTree_p1_set",_wrap_CvContourTree_p1_set,0,0,2,0},
{"CvContourTree_p1_get",_wrap_CvContourTree_p1_get,0,0,2,0},
{"CvContourTree_p2_set",_wrap_CvContourTree_p2_set,0,0,2,0},
{"CvContourTree_p2_get",_wrap_CvContourTree_p2_get,0,0,2,0},
{"new_CvContourTree",_wrap_new_CvContourTree,0,0,2,_wrap_new_CvContourTree_texinfo},
{"delete_CvContourTree",_wrap_delete_CvContourTree,0,0,2,_wrap_delete_CvContourTree_texinfo},
{"CvConvexityDefect_start_set",_wrap_CvConvexityDefect_start_set,0,0,2,0},
{"CvConvexityDefect_start_get",_wrap_CvConvexityDefect_start_get,0,0,2,0},
{"CvConvexityDefect_end_set",_wrap_CvConvexityDefect_end_set,0,0,2,0},
{"CvConvexityDefect_end_get",_wrap_CvConvexityDefect_end_get,0,0,2,0},
{"CvConvexityDefect_depth_point_set",_wrap_CvConvexityDefect_depth_point_set,0,0,2,0},
{"CvConvexityDefect_depth_point_get",_wrap_CvConvexityDefect_depth_point_get,0,0,2,0},
{"CvConvexityDefect_depth_set",_wrap_CvConvexityDefect_depth_set,0,0,2,0},
{"CvConvexityDefect_depth_get",_wrap_CvConvexityDefect_depth_get,0,0,2,0},
{"new_CvConvexityDefect",_wrap_new_CvConvexityDefect,0,0,2,_wrap_new_CvConvexityDefect_texinfo},
{"delete_CvConvexityDefect",_wrap_delete_CvConvexityDefect,0,0,2,_wrap_delete_CvConvexityDefect_texinfo},
{"CvQuadEdge2D_flags_set",_wrap_CvQuadEdge2D_flags_set,0,0,2,0},
{"CvQuadEdge2D_flags_get",_wrap_CvQuadEdge2D_flags_get,0,0,2,0},
{"CvQuadEdge2D_pt_set",_wrap_CvQuadEdge2D_pt_set,0,0,2,0},
{"CvQuadEdge2D_pt_get",_wrap_CvQuadEdge2D_pt_get,0,0,2,0},
{"CvQuadEdge2D_next_set",_wrap_CvQuadEdge2D_next_set,0,0,2,0},
{"CvQuadEdge2D_next_get",_wrap_CvQuadEdge2D_next_get,0,0,2,0},
{"new_CvQuadEdge2D",_wrap_new_CvQuadEdge2D,0,0,2,_wrap_new_CvQuadEdge2D_texinfo},
{"delete_CvQuadEdge2D",_wrap_delete_CvQuadEdge2D,0,0,2,_wrap_delete_CvQuadEdge2D_texinfo},
{"CvSubdiv2DPoint_flags_set",_wrap_CvSubdiv2DPoint_flags_set,0,0,2,0},
{"CvSubdiv2DPoint_flags_get",_wrap_CvSubdiv2DPoint_flags_get,0,0,2,0},
{"CvSubdiv2DPoint_first_set",_wrap_CvSubdiv2DPoint_first_set,0,0,2,0},
{"CvSubdiv2DPoint_first_get",_wrap_CvSubdiv2DPoint_first_get,0,0,2,0},
{"CvSubdiv2DPoint_pt_set",_wrap_CvSubdiv2DPoint_pt_set,0,0,2,0},
{"CvSubdiv2DPoint_pt_get",_wrap_CvSubdiv2DPoint_pt_get,0,0,2,0},
{"new_CvSubdiv2DPoint",_wrap_new_CvSubdiv2DPoint,0,0,2,_wrap_new_CvSubdiv2DPoint_texinfo},
{"delete_CvSubdiv2DPoint",_wrap_delete_CvSubdiv2DPoint,0,0,2,_wrap_delete_CvSubdiv2DPoint_texinfo},
{"CvSubdiv2D_flags_set",_wrap_CvSubdiv2D_flags_set,0,0,2,0},
{"CvSubdiv2D_flags_get",_wrap_CvSubdiv2D_flags_get,0,0,2,0},
{"CvSubdiv2D_header_size_set",_wrap_CvSubdiv2D_header_size_set,0,0,2,0},
{"CvSubdiv2D_header_size_get",_wrap_CvSubdiv2D_header_size_get,0,0,2,0},
{"CvSubdiv2D_h_prev_set",_wrap_CvSubdiv2D_h_prev_set,0,0,2,0},
{"CvSubdiv2D_h_prev_get",_wrap_CvSubdiv2D_h_prev_get,0,0,2,0},
{"CvSubdiv2D_h_next_set",_wrap_CvSubdiv2D_h_next_set,0,0,2,0},
{"CvSubdiv2D_h_next_get",_wrap_CvSubdiv2D_h_next_get,0,0,2,0},
{"CvSubdiv2D_v_prev_set",_wrap_CvSubdiv2D_v_prev_set,0,0,2,0},
{"CvSubdiv2D_v_prev_get",_wrap_CvSubdiv2D_v_prev_get,0,0,2,0},
{"CvSubdiv2D_v_next_set",_wrap_CvSubdiv2D_v_next_set,0,0,2,0},
{"CvSubdiv2D_v_next_get",_wrap_CvSubdiv2D_v_next_get,0,0,2,0},
{"CvSubdiv2D_total_set",_wrap_CvSubdiv2D_total_set,0,0,2,0},
{"CvSubdiv2D_total_get",_wrap_CvSubdiv2D_total_get,0,0,2,0},
{"CvSubdiv2D_elem_size_set",_wrap_CvSubdiv2D_elem_size_set,0,0,2,0},
{"CvSubdiv2D_elem_size_get",_wrap_CvSubdiv2D_elem_size_get,0,0,2,0},
{"CvSubdiv2D_block_max_set",_wrap_CvSubdiv2D_block_max_set,0,0,2,0},
{"CvSubdiv2D_block_max_get",_wrap_CvSubdiv2D_block_max_get,0,0,2,0},
{"CvSubdiv2D_ptr_set",_wrap_CvSubdiv2D_ptr_set,0,0,2,0},
{"CvSubdiv2D_ptr_get",_wrap_CvSubdiv2D_ptr_get,0,0,2,0},
{"CvSubdiv2D_delta_elems_set",_wrap_CvSubdiv2D_delta_elems_set,0,0,2,0},
{"CvSubdiv2D_delta_elems_get",_wrap_CvSubdiv2D_delta_elems_get,0,0,2,0},
{"CvSubdiv2D_storage_set",_wrap_CvSubdiv2D_storage_set,0,0,2,0},
{"CvSubdiv2D_storage_get",_wrap_CvSubdiv2D_storage_get,0,0,2,0},
{"CvSubdiv2D_free_blocks_set",_wrap_CvSubdiv2D_free_blocks_set,0,0,2,0},
{"CvSubdiv2D_free_blocks_get",_wrap_CvSubdiv2D_free_blocks_get,0,0,2,0},
{"CvSubdiv2D_first_set",_wrap_CvSubdiv2D_first_set,0,0,2,0},
{"CvSubdiv2D_first_get",_wrap_CvSubdiv2D_first_get,0,0,2,0},
{"CvSubdiv2D_free_elems_set",_wrap_CvSubdiv2D_free_elems_set,0,0,2,0},
{"CvSubdiv2D_free_elems_get",_wrap_CvSubdiv2D_free_elems_get,0,0,2,0},
{"CvSubdiv2D_active_count_set",_wrap_CvSubdiv2D_active_count_set,0,0,2,0},
{"CvSubdiv2D_active_count_get",_wrap_CvSubdiv2D_active_count_get,0,0,2,0},
{"CvSubdiv2D_quad_edges_set",_wrap_CvSubdiv2D_quad_edges_set,0,0,2,0},
{"CvSubdiv2D_quad_edges_get",_wrap_CvSubdiv2D_quad_edges_get,0,0,2,0},
{"CvSubdiv2D_is_geometry_valid_set",_wrap_CvSubdiv2D_is_geometry_valid_set,0,0,2,0},
{"CvSubdiv2D_is_geometry_valid_get",_wrap_CvSubdiv2D_is_geometry_valid_get,0,0,2,0},
{"CvSubdiv2D_recent_edge_set",_wrap_CvSubdiv2D_recent_edge_set,0,0,2,0},
{"CvSubdiv2D_recent_edge_get",_wrap_CvSubdiv2D_recent_edge_get,0,0,2,0},
{"CvSubdiv2D_topleft_set",_wrap_CvSubdiv2D_topleft_set,0,0,2,0},
{"CvSubdiv2D_topleft_get",_wrap_CvSubdiv2D_topleft_get,0,0,2,0},
{"CvSubdiv2D_bottomright_set",_wrap_CvSubdiv2D_bottomright_set,0,0,2,0},
{"CvSubdiv2D_bottomright_get",_wrap_CvSubdiv2D_bottomright_get,0,0,2,0},
{"CvSubdiv2D_edges_set",_wrap_CvSubdiv2D_edges_set,0,0,2,0},
{"CvSubdiv2D_edges_get",_wrap_CvSubdiv2D_edges_get,0,0,2,0},
{"CvSubdiv2D_typed_edges_get",_wrap_CvSubdiv2D_typed_edges_get,0,0,2,_wrap_CvSubdiv2D_typed_edges_get_texinfo},
{"CvSubdiv2D_typed_edges_set",_wrap_CvSubdiv2D_typed_edges_set,0,0,2,_wrap_CvSubdiv2D_typed_edges_set_texinfo},
{"new_CvSubdiv2D",_wrap_new_CvSubdiv2D,0,0,2,_wrap_new_CvSubdiv2D_texinfo},
{"delete_CvSubdiv2D",_wrap_delete_CvSubdiv2D,0,0,2,_wrap_delete_CvSubdiv2D_texinfo},
{"CvMatrix3_m_set",_wrap_CvMatrix3_m_set,0,0,2,0},
{"CvMatrix3_m_get",_wrap_CvMatrix3_m_get,0,0,2,0},
{"new_CvMatrix3",_wrap_new_CvMatrix3,0,0,2,_wrap_new_CvMatrix3_texinfo},
{"delete_CvMatrix3",_wrap_delete_CvMatrix3,0,0,2,_wrap_delete_CvMatrix3_texinfo},
{"CvConDensation_MP_set",_wrap_CvConDensation_MP_set,0,0,2,0},
{"CvConDensation_MP_get",_wrap_CvConDensation_MP_get,0,0,2,0},
{"CvConDensation_DP_set",_wrap_CvConDensation_DP_set,0,0,2,0},
{"CvConDensation_DP_get",_wrap_CvConDensation_DP_get,0,0,2,0},
{"CvConDensation_DynamMatr_set",_wrap_CvConDensation_DynamMatr_set,0,0,2,0},
{"CvConDensation_DynamMatr_get",_wrap_CvConDensation_DynamMatr_get,0,0,2,0},
{"CvConDensation_State_set",_wrap_CvConDensation_State_set,0,0,2,0},
{"CvConDensation_State_get",_wrap_CvConDensation_State_get,0,0,2,0},
{"CvConDensation_SamplesNum_set",_wrap_CvConDensation_SamplesNum_set,0,0,2,0},
{"CvConDensation_SamplesNum_get",_wrap_CvConDensation_SamplesNum_get,0,0,2,0},
{"CvConDensation_flSamples_set",_wrap_CvConDensation_flSamples_set,0,0,2,0},
{"CvConDensation_flSamples_get",_wrap_CvConDensation_flSamples_get,0,0,2,0},
{"CvConDensation_flNewSamples_set",_wrap_CvConDensation_flNewSamples_set,0,0,2,0},
{"CvConDensation_flNewSamples_get",_wrap_CvConDensation_flNewSamples_get,0,0,2,0},
{"CvConDensation_flConfidence_set",_wrap_CvConDensation_flConfidence_set,0,0,2,0},
{"CvConDensation_flConfidence_get",_wrap_CvConDensation_flConfidence_get,0,0,2,0},
{"CvConDensation_flCumulative_set",_wrap_CvConDensation_flCumulative_set,0,0,2,0},
{"CvConDensation_flCumulative_get",_wrap_CvConDensation_flCumulative_get,0,0,2,0},
{"CvConDensation_Temp_set",_wrap_CvConDensation_Temp_set,0,0,2,0},
{"CvConDensation_Temp_get",_wrap_CvConDensation_Temp_get,0,0,2,0},
{"CvConDensation_RandomSample_set",_wrap_CvConDensation_RandomSample_set,0,0,2,0},
{"CvConDensation_RandomSample_get",_wrap_CvConDensation_RandomSample_get,0,0,2,0},
{"CvConDensation_RandS_set",_wrap_CvConDensation_RandS_set,0,0,2,0},
{"CvConDensation_RandS_get",_wrap_CvConDensation_RandS_get,0,0,2,0},
{"delete_CvConDensation",_wrap_delete_CvConDensation,0,0,2,_wrap_delete_CvConDensation_texinfo},
{"CvKalman_MP_set",_wrap_CvKalman_MP_set,0,0,2,0},
{"CvKalman_MP_get",_wrap_CvKalman_MP_get,0,0,2,0},
{"CvKalman_DP_set",_wrap_CvKalman_DP_set,0,0,2,0},
{"CvKalman_DP_get",_wrap_CvKalman_DP_get,0,0,2,0},
{"CvKalman_CP_set",_wrap_CvKalman_CP_set,0,0,2,0},
{"CvKalman_CP_get",_wrap_CvKalman_CP_get,0,0,2,0},
{"CvKalman_PosterState_set",_wrap_CvKalman_PosterState_set,0,0,2,0},
{"CvKalman_PosterState_get",_wrap_CvKalman_PosterState_get,0,0,2,0},
{"CvKalman_PriorState_set",_wrap_CvKalman_PriorState_set,0,0,2,0},
{"CvKalman_PriorState_get",_wrap_CvKalman_PriorState_get,0,0,2,0},
{"CvKalman_DynamMatr_set",_wrap_CvKalman_DynamMatr_set,0,0,2,0},
{"CvKalman_DynamMatr_get",_wrap_CvKalman_DynamMatr_get,0,0,2,0},
{"CvKalman_MeasurementMatr_set",_wrap_CvKalman_MeasurementMatr_set,0,0,2,0},
{"CvKalman_MeasurementMatr_get",_wrap_CvKalman_MeasurementMatr_get,0,0,2,0},
{"CvKalman_MNCovariance_set",_wrap_CvKalman_MNCovariance_set,0,0,2,0},
{"CvKalman_MNCovariance_get",_wrap_CvKalman_MNCovariance_get,0,0,2,0},
{"CvKalman_PNCovariance_set",_wrap_CvKalman_PNCovariance_set,0,0,2,0},
{"CvKalman_PNCovariance_get",_wrap_CvKalman_PNCovariance_get,0,0,2,0},
{"CvKalman_KalmGainMatr_set",_wrap_CvKalman_KalmGainMatr_set,0,0,2,0},
{"CvKalman_KalmGainMatr_get",_wrap_CvKalman_KalmGainMatr_get,0,0,2,0},
{"CvKalman_PriorErrorCovariance_set",_wrap_CvKalman_PriorErrorCovariance_set,0,0,2,0},
{"CvKalman_PriorErrorCovariance_get",_wrap_CvKalman_PriorErrorCovariance_get,0,0,2,0},
{"CvKalman_PosterErrorCovariance_set",_wrap_CvKalman_PosterErrorCovariance_set,0,0,2,0},
{"CvKalman_PosterErrorCovariance_get",_wrap_CvKalman_PosterErrorCovariance_get,0,0,2,0},
{"CvKalman_Temp1_set",_wrap_CvKalman_Temp1_set,0,0,2,0},
{"CvKalman_Temp1_get",_wrap_CvKalman_Temp1_get,0,0,2,0},
{"CvKalman_Temp2_set",_wrap_CvKalman_Temp2_set,0,0,2,0},
{"CvKalman_Temp2_get",_wrap_CvKalman_Temp2_get,0,0,2,0},
{"CvKalman_state_pre_set",_wrap_CvKalman_state_pre_set,0,0,2,0},
{"CvKalman_state_pre_get",_wrap_CvKalman_state_pre_get,0,0,2,0},
{"CvKalman_state_post_set",_wrap_CvKalman_state_post_set,0,0,2,0},
{"CvKalman_state_post_get",_wrap_CvKalman_state_post_get,0,0,2,0},
{"CvKalman_transition_matrix_set",_wrap_CvKalman_transition_matrix_set,0,0,2,0},
{"CvKalman_transition_matrix_get",_wrap_CvKalman_transition_matrix_get,0,0,2,0},
{"CvKalman_control_matrix_set",_wrap_CvKalman_control_matrix_set,0,0,2,0},
{"CvKalman_control_matrix_get",_wrap_CvKalman_control_matrix_get,0,0,2,0},
{"CvKalman_measurement_matrix_set",_wrap_CvKalman_measurement_matrix_set,0,0,2,0},
{"CvKalman_measurement_matrix_get",_wrap_CvKalman_measurement_matrix_get,0,0,2,0},
{"CvKalman_process_noise_cov_set",_wrap_CvKalman_process_noise_cov_set,0,0,2,0},
{"CvKalman_process_noise_cov_get",_wrap_CvKalman_process_noise_cov_get,0,0,2,0},
{"CvKalman_measurement_noise_cov_set",_wrap_CvKalman_measurement_noise_cov_set,0,0,2,0},
{"CvKalman_measurement_noise_cov_get",_wrap_CvKalman_measurement_noise_cov_get,0,0,2,0},
{"CvKalman_error_cov_pre_set",_wrap_CvKalman_error_cov_pre_set,0,0,2,0},
{"CvKalman_error_cov_pre_get",_wrap_CvKalman_error_cov_pre_get,0,0,2,0},
{"CvKalman_gain_set",_wrap_CvKalman_gain_set,0,0,2,0},
{"CvKalman_gain_get",_wrap_CvKalman_gain_get,0,0,2,0},
{"CvKalman_error_cov_post_set",_wrap_CvKalman_error_cov_post_set,0,0,2,0},
{"CvKalman_error_cov_post_get",_wrap_CvKalman_error_cov_post_get,0,0,2,0},
{"CvKalman_temp1_set",_wrap_CvKalman_temp1_set,0,0,2,0},
{"CvKalman_temp1_get",_wrap_CvKalman_temp1_get,0,0,2,0},
{"CvKalman_temp2_set",_wrap_CvKalman_temp2_set,0,0,2,0},
{"CvKalman_temp2_get",_wrap_CvKalman_temp2_get,0,0,2,0},
{"CvKalman_temp3_set",_wrap_CvKalman_temp3_set,0,0,2,0},
{"CvKalman_temp3_get",_wrap_CvKalman_temp3_get,0,0,2,0},
{"CvKalman_temp4_set",_wrap_CvKalman_temp4_set,0,0,2,0},
{"CvKalman_temp4_get",_wrap_CvKalman_temp4_get,0,0,2,0},
{"CvKalman_temp5_set",_wrap_CvKalman_temp5_set,0,0,2,0},
{"CvKalman_temp5_get",_wrap_CvKalman_temp5_get,0,0,2,0},
{"delete_CvKalman",_wrap_delete_CvKalman,0,0,2,_wrap_delete_CvKalman_texinfo},
{"CvHaarFeature_tilted_set",_wrap_CvHaarFeature_tilted_set,0,0,2,0},
{"CvHaarFeature_tilted_get",_wrap_CvHaarFeature_tilted_get,0,0,2,0},
{"CvHaarFeature_rect_get",_wrap_CvHaarFeature_rect_get,0,0,2,0},
{"new_CvHaarFeature",_wrap_new_CvHaarFeature,0,0,2,_wrap_new_CvHaarFeature_texinfo},
{"delete_CvHaarFeature",_wrap_delete_CvHaarFeature,0,0,2,_wrap_delete_CvHaarFeature_texinfo},
{"CvHaarFeature_rect_r_set",_wrap_CvHaarFeature_rect_r_set,0,0,2,0},
{"CvHaarFeature_rect_r_get",_wrap_CvHaarFeature_rect_r_get,0,0,2,0},
{"CvHaarFeature_rect_weight_set",_wrap_CvHaarFeature_rect_weight_set,0,0,2,0},
{"CvHaarFeature_rect_weight_get",_wrap_CvHaarFeature_rect_weight_get,0,0,2,0},
{"new_CvHaarFeature_rect",_wrap_new_CvHaarFeature_rect,0,0,2,_wrap_new_CvHaarFeature_rect_texinfo},
{"delete_CvHaarFeature_rect",_wrap_delete_CvHaarFeature_rect,0,0,2,_wrap_delete_CvHaarFeature_rect_texinfo},
{"CvHaarClassifier_count_set",_wrap_CvHaarClassifier_count_set,0,0,2,0},
{"CvHaarClassifier_count_get",_wrap_CvHaarClassifier_count_get,0,0,2,0},
{"CvHaarClassifier_haar_feature_set",_wrap_CvHaarClassifier_haar_feature_set,0,0,2,0},
{"CvHaarClassifier_haar_feature_get",_wrap_CvHaarClassifier_haar_feature_get,0,0,2,0},
{"CvHaarClassifier_threshold_set",_wrap_CvHaarClassifier_threshold_set,0,0,2,0},
{"CvHaarClassifier_threshold_get",_wrap_CvHaarClassifier_threshold_get,0,0,2,0},
{"CvHaarClassifier_left_set",_wrap_CvHaarClassifier_left_set,0,0,2,0},
{"CvHaarClassifier_left_get",_wrap_CvHaarClassifier_left_get,0,0,2,0},
{"CvHaarClassifier_right_set",_wrap_CvHaarClassifier_right_set,0,0,2,0},
{"CvHaarClassifier_right_get",_wrap_CvHaarClassifier_right_get,0,0,2,0},
{"CvHaarClassifier_alpha_set",_wrap_CvHaarClassifier_alpha_set,0,0,2,0},
{"CvHaarClassifier_alpha_get",_wrap_CvHaarClassifier_alpha_get,0,0,2,0},
{"new_CvHaarClassifier",_wrap_new_CvHaarClassifier,0,0,2,_wrap_new_CvHaarClassifier_texinfo},
{"delete_CvHaarClassifier",_wrap_delete_CvHaarClassifier,0,0,2,_wrap_delete_CvHaarClassifier_texinfo},
{"CvHaarStageClassifier_count_set",_wrap_CvHaarStageClassifier_count_set,0,0,2,0},
{"CvHaarStageClassifier_count_get",_wrap_CvHaarStageClassifier_count_get,0,0,2,0},
{"CvHaarStageClassifier_threshold_set",_wrap_CvHaarStageClassifier_threshold_set,0,0,2,0},
{"CvHaarStageClassifier_threshold_get",_wrap_CvHaarStageClassifier_threshold_get,0,0,2,0},
{"CvHaarStageClassifier_classifier_set",_wrap_CvHaarStageClassifier_classifier_set,0,0,2,0},
{"CvHaarStageClassifier_classifier_get",_wrap_CvHaarStageClassifier_classifier_get,0,0,2,0},
{"CvHaarStageClassifier_next_set",_wrap_CvHaarStageClassifier_next_set,0,0,2,0},
{"CvHaarStageClassifier_next_get",_wrap_CvHaarStageClassifier_next_get,0,0,2,0},
{"CvHaarStageClassifier_child_set",_wrap_CvHaarStageClassifier_child_set,0,0,2,0},
{"CvHaarStageClassifier_child_get",_wrap_CvHaarStageClassifier_child_get,0,0,2,0},
{"CvHaarStageClassifier_parent_set",_wrap_CvHaarStageClassifier_parent_set,0,0,2,0},
{"CvHaarStageClassifier_parent_get",_wrap_CvHaarStageClassifier_parent_get,0,0,2,0},
{"new_CvHaarStageClassifier",_wrap_new_CvHaarStageClassifier,0,0,2,_wrap_new_CvHaarStageClassifier_texinfo},
{"delete_CvHaarStageClassifier",_wrap_delete_CvHaarStageClassifier,0,0,2,_wrap_delete_CvHaarStageClassifier_texinfo},
{"CvHaarClassifierCascade_flags_set",_wrap_CvHaarClassifierCascade_flags_set,0,0,2,0},
{"CvHaarClassifierCascade_flags_get",_wrap_CvHaarClassifierCascade_flags_get,0,0,2,0},
{"CvHaarClassifierCascade_count_set",_wrap_CvHaarClassifierCascade_count_set,0,0,2,0},
{"CvHaarClassifierCascade_count_get",_wrap_CvHaarClassifierCascade_count_get,0,0,2,0},
{"CvHaarClassifierCascade_orig_window_size_set",_wrap_CvHaarClassifierCascade_orig_window_size_set,0,0,2,0},
{"CvHaarClassifierCascade_orig_window_size_get",_wrap_CvHaarClassifierCascade_orig_window_size_get,0,0,2,0},
{"CvHaarClassifierCascade_real_window_size_set",_wrap_CvHaarClassifierCascade_real_window_size_set,0,0,2,0},
{"CvHaarClassifierCascade_real_window_size_get",_wrap_CvHaarClassifierCascade_real_window_size_get,0,0,2,0},
{"CvHaarClassifierCascade_scale_set",_wrap_CvHaarClassifierCascade_scale_set,0,0,2,0},
{"CvHaarClassifierCascade_scale_get",_wrap_CvHaarClassifierCascade_scale_get,0,0,2,0},
{"CvHaarClassifierCascade_stage_classifier_set",_wrap_CvHaarClassifierCascade_stage_classifier_set,0,0,2,0},
{"CvHaarClassifierCascade_stage_classifier_get",_wrap_CvHaarClassifierCascade_stage_classifier_get,0,0,2,0},
{"CvHaarClassifierCascade_hid_cascade_set",_wrap_CvHaarClassifierCascade_hid_cascade_set,0,0,2,0},
{"CvHaarClassifierCascade_hid_cascade_get",_wrap_CvHaarClassifierCascade_hid_cascade_get,0,0,2,0},
{"delete_CvHaarClassifierCascade",_wrap_delete_CvHaarClassifierCascade,0,0,2,_wrap_delete_CvHaarClassifierCascade_texinfo},
{"CvAvgComp_rect_set",_wrap_CvAvgComp_rect_set,0,0,2,0},
{"CvAvgComp_rect_get",_wrap_CvAvgComp_rect_get,0,0,2,0},
{"CvAvgComp_neighbors_set",_wrap_CvAvgComp_neighbors_set,0,0,2,0},
{"CvAvgComp_neighbors_get",_wrap_CvAvgComp_neighbors_get,0,0,2,0},
{"new_CvAvgComp",_wrap_new_CvAvgComp,0,0,2,_wrap_new_CvAvgComp_texinfo},
{"delete_CvAvgComp",_wrap_delete_CvAvgComp,0,0,2,_wrap_delete_CvAvgComp_texinfo},
{"cvCopyMakeBorder",_wrap_cvCopyMakeBorder,0,0,2,_wrap_cvCopyMakeBorder_texinfo},
{"cvSmooth",_wrap_cvSmooth,0,0,2,_wrap_cvSmooth_texinfo},
{"cvFilter2D",_wrap_cvFilter2D,0,0,2,_wrap_cvFilter2D_texinfo},
{"cvIntegral",_wrap_cvIntegral,0,0,2,_wrap_cvIntegral_texinfo},
{"cvPyrDown",_wrap_cvPyrDown,0,0,2,_wrap_cvPyrDown_texinfo},
{"cvPyrUp",_wrap_cvPyrUp,0,0,2,_wrap_cvPyrUp_texinfo},
{"cvCreatePyramid",_wrap_cvCreatePyramid,0,0,2,_wrap_cvCreatePyramid_texinfo},
{"cvReleasePyramid",_wrap_cvReleasePyramid,0,0,2,_wrap_cvReleasePyramid_texinfo},
{"cvPyrSegmentationUntyped",_wrap_cvPyrSegmentationUntyped,0,0,2,_wrap_cvPyrSegmentationUntyped_texinfo},
{"cvPyrMeanShiftFiltering",_wrap_cvPyrMeanShiftFiltering,0,0,2,_wrap_cvPyrMeanShiftFiltering_texinfo},
{"cvWatershed",_wrap_cvWatershed,0,0,2,_wrap_cvWatershed_texinfo},
{"cvInpaint",_wrap_cvInpaint,0,0,2,_wrap_cvInpaint_texinfo},
{"cvSobel",_wrap_cvSobel,0,0,2,_wrap_cvSobel_texinfo},
{"cvLaplace",_wrap_cvLaplace,0,0,2,_wrap_cvLaplace_texinfo},
{"cvCvtColor",_wrap_cvCvtColor,0,0,2,_wrap_cvCvtColor_texinfo},
{"cvResize",_wrap_cvResize,0,0,2,_wrap_cvResize_texinfo},
{"cvWarpAffine",_wrap_cvWarpAffine,0,0,2,_wrap_cvWarpAffine_texinfo},
{"cvGetAffineTransform",_wrap_cvGetAffineTransform,0,0,2,_wrap_cvGetAffineTransform_texinfo},
{"cv2DRotationMatrix",_wrap_cv2DRotationMatrix,0,0,2,_wrap_cv2DRotationMatrix_texinfo},
{"cvWarpPerspective",_wrap_cvWarpPerspective,0,0,2,_wrap_cvWarpPerspective_texinfo},
{"cvGetPerspectiveTransform",_wrap_cvGetPerspectiveTransform,0,0,2,_wrap_cvGetPerspectiveTransform_texinfo},
{"cvRemap",_wrap_cvRemap,0,0,2,_wrap_cvRemap_texinfo},
{"cvConvertMaps",_wrap_cvConvertMaps,0,0,2,_wrap_cvConvertMaps_texinfo},
{"cvLogPolar",_wrap_cvLogPolar,0,0,2,_wrap_cvLogPolar_texinfo},
{"cvLinearPolar",_wrap_cvLinearPolar,0,0,2,_wrap_cvLinearPolar_texinfo},
{"cvCreateStructuringElementEx",_wrap_cvCreateStructuringElementEx,0,0,2,_wrap_cvCreateStructuringElementEx_texinfo},
{"cvReleaseStructuringElement",_wrap_cvReleaseStructuringElement,0,0,2,_wrap_cvReleaseStructuringElement_texinfo},
{"cvErode",_wrap_cvErode,0,0,2,_wrap_cvErode_texinfo},
{"cvDilate",_wrap_cvDilate,0,0,2,_wrap_cvDilate_texinfo},
{"cvMorphologyEx",_wrap_cvMorphologyEx,0,0,2,_wrap_cvMorphologyEx_texinfo},
{"cvMoments",_wrap_cvMoments,0,0,2,_wrap_cvMoments_texinfo},
{"cvGetSpatialMoment",_wrap_cvGetSpatialMoment,0,0,2,_wrap_cvGetSpatialMoment_texinfo},
{"cvGetCentralMoment",_wrap_cvGetCentralMoment,0,0,2,_wrap_cvGetCentralMoment_texinfo},
{"cvGetNormalizedCentralMoment",_wrap_cvGetNormalizedCentralMoment,0,0,2,_wrap_cvGetNormalizedCentralMoment_texinfo},
{"cvGetHuMoments",_wrap_cvGetHuMoments,0,0,2,_wrap_cvGetHuMoments_texinfo},
{"cvSampleLine",_wrap_cvSampleLine,0,0,2,_wrap_cvSampleLine_texinfo},
{"cvGetRectSubPix",_wrap_cvGetRectSubPix,0,0,2,_wrap_cvGetRectSubPix_texinfo},
{"cvGetQuadrangleSubPix",_wrap_cvGetQuadrangleSubPix,0,0,2,_wrap_cvGetQuadrangleSubPix_texinfo},
{"cvMatchTemplate",_wrap_cvMatchTemplate,0,0,2,_wrap_cvMatchTemplate_texinfo},
{"cvCalcEMD2",_wrap_cvCalcEMD2,0,0,2,_wrap_cvCalcEMD2_texinfo},
{"cvFindContoursUntyped",_wrap_cvFindContoursUntyped,0,0,2,_wrap_cvFindContoursUntyped_texinfo},
{"cvStartFindContours",_wrap_cvStartFindContours,0,0,2,_wrap_cvStartFindContours_texinfo},
{"cvFindNextContour",_wrap_cvFindNextContour,0,0,2,_wrap_cvFindNextContour_texinfo},
{"cvSubstituteContour",_wrap_cvSubstituteContour,0,0,2,_wrap_cvSubstituteContour_texinfo},
{"cvEndFindContours",_wrap_cvEndFindContours,0,0,2,_wrap_cvEndFindContours_texinfo},
{"cvApproxChainsUntyped",_wrap_cvApproxChainsUntyped,0,0,2,_wrap_cvApproxChainsUntyped_texinfo},
{"cvStartReadChainPoints",_wrap_cvStartReadChainPoints,0,0,2,_wrap_cvStartReadChainPoints_texinfo},
{"cvReadChainPoint",_wrap_cvReadChainPoint,0,0,2,_wrap_cvReadChainPoint_texinfo},
{"cvCalcOpticalFlowLK",_wrap_cvCalcOpticalFlowLK,0,0,2,_wrap_cvCalcOpticalFlowLK_texinfo},
{"cvCalcOpticalFlowBM",_wrap_cvCalcOpticalFlowBM,0,0,2,_wrap_cvCalcOpticalFlowBM_texinfo},
{"cvCalcOpticalFlowHS",_wrap_cvCalcOpticalFlowHS,0,0,2,_wrap_cvCalcOpticalFlowHS_texinfo},
{"cvCalcOpticalFlowPyrLK",_wrap_cvCalcOpticalFlowPyrLK,0,0,2,_wrap_cvCalcOpticalFlowPyrLK_texinfo},
{"cvCalcAffineFlowPyrLK",_wrap_cvCalcAffineFlowPyrLK,0,0,2,_wrap_cvCalcAffineFlowPyrLK_texinfo},
{"cvEstimateRigidTransform",_wrap_cvEstimateRigidTransform,0,0,2,_wrap_cvEstimateRigidTransform_texinfo},
{"cvUpdateMotionHistory",_wrap_cvUpdateMotionHistory,0,0,2,_wrap_cvUpdateMotionHistory_texinfo},
{"cvCalcMotionGradient",_wrap_cvCalcMotionGradient,0,0,2,_wrap_cvCalcMotionGradient_texinfo},
{"cvCalcGlobalOrientation",_wrap_cvCalcGlobalOrientation,0,0,2,_wrap_cvCalcGlobalOrientation_texinfo},
{"cvAcc",_wrap_cvAcc,0,0,2,_wrap_cvAcc_texinfo},
{"cvSquareAcc",_wrap_cvSquareAcc,0,0,2,_wrap_cvSquareAcc_texinfo},
{"cvMultiplyAcc",_wrap_cvMultiplyAcc,0,0,2,_wrap_cvMultiplyAcc_texinfo},
{"cvRunningAvg",_wrap_cvRunningAvg,0,0,2,_wrap_cvRunningAvg_texinfo},
{"cvCamShift",_wrap_cvCamShift,0,0,2,_wrap_cvCamShift_texinfo},
{"cvMeanShift",_wrap_cvMeanShift,0,0,2,_wrap_cvMeanShift_texinfo},
{"cvCreateConDensation",_wrap_cvCreateConDensation,0,0,2,_wrap_cvCreateConDensation_texinfo},
{"cvReleaseConDensation",_wrap_cvReleaseConDensation,0,0,2,_wrap_cvReleaseConDensation_texinfo},
{"cvConDensUpdateByTime",_wrap_cvConDensUpdateByTime,0,0,2,_wrap_cvConDensUpdateByTime_texinfo},
{"cvConDensInitSampleSet",_wrap_cvConDensInitSampleSet,0,0,2,_wrap_cvConDensInitSampleSet_texinfo},
{"cvCreateKalman",_wrap_cvCreateKalman,0,0,2,_wrap_cvCreateKalman_texinfo},
{"cvReleaseKalman",_wrap_cvReleaseKalman,0,0,2,_wrap_cvReleaseKalman_texinfo},
{"cvKalmanPredict",_wrap_cvKalmanPredict,0,0,2,_wrap_cvKalmanPredict_texinfo},
{"cvKalmanCorrect",_wrap_cvKalmanCorrect,0,0,2,_wrap_cvKalmanCorrect_texinfo},
{"cvInitSubdivDelaunay2D",_wrap_cvInitSubdivDelaunay2D,0,0,2,_wrap_cvInitSubdivDelaunay2D_texinfo},
{"cvCreateSubdiv2D",_wrap_cvCreateSubdiv2D,0,0,2,_wrap_cvCreateSubdiv2D_texinfo},
{"cvCreateSubdivDelaunay2D",_wrap_cvCreateSubdivDelaunay2D,0,0,2,_wrap_cvCreateSubdivDelaunay2D_texinfo},
{"cvSubdivDelaunay2DInsert",_wrap_cvSubdivDelaunay2DInsert,0,0,2,_wrap_cvSubdivDelaunay2DInsert_texinfo},
{"cvSubdiv2DLocate",_wrap_cvSubdiv2DLocate,0,0,2,_wrap_cvSubdiv2DLocate_texinfo},
{"cvCalcSubdivVoronoi2D",_wrap_cvCalcSubdivVoronoi2D,0,0,2,_wrap_cvCalcSubdivVoronoi2D_texinfo},
{"cvClearSubdivVoronoi2D",_wrap_cvClearSubdivVoronoi2D,0,0,2,_wrap_cvClearSubdivVoronoi2D_texinfo},
{"cvFindNearestPoint2D",_wrap_cvFindNearestPoint2D,0,0,2,_wrap_cvFindNearestPoint2D_texinfo},
{"cvSubdiv2DNextEdge",_wrap_cvSubdiv2DNextEdge,0,0,2,_wrap_cvSubdiv2DNextEdge_texinfo},
{"cvSubdiv2DRotateEdge",_wrap_cvSubdiv2DRotateEdge,0,0,2,_wrap_cvSubdiv2DRotateEdge_texinfo},
{"cvSubdiv2DSymEdge",_wrap_cvSubdiv2DSymEdge,0,0,2,_wrap_cvSubdiv2DSymEdge_texinfo},
{"cvSubdiv2DGetEdge",_wrap_cvSubdiv2DGetEdge,0,0,2,_wrap_cvSubdiv2DGetEdge_texinfo},
{"cvSubdiv2DEdgeOrg",_wrap_cvSubdiv2DEdgeOrg,0,0,2,_wrap_cvSubdiv2DEdgeOrg_texinfo},
{"cvSubdiv2DEdgeDst",_wrap_cvSubdiv2DEdgeDst,0,0,2,_wrap_cvSubdiv2DEdgeDst_texinfo},
{"cvTriangleArea",_wrap_cvTriangleArea,0,0,2,_wrap_cvTriangleArea_texinfo},
{"cvFindDominantPoints",_wrap_cvFindDominantPoints,0,0,2,_wrap_cvFindDominantPoints_texinfo},
{"cvBoundingRect",_wrap_cvBoundingRect,0,0,2,_wrap_cvBoundingRect_texinfo},
{"cvContourArea",_wrap_cvContourArea,0,0,2,_wrap_cvContourArea_texinfo},
{"cvMinAreaRect2",_wrap_cvMinAreaRect2,0,0,2,_wrap_cvMinAreaRect2_texinfo},
{"cvMinEnclosingCircle",_wrap_cvMinEnclosingCircle,0,0,2,_wrap_cvMinEnclosingCircle_texinfo},
{"cvMatchShapes",_wrap_cvMatchShapes,0,0,2,_wrap_cvMatchShapes_texinfo},
{"cvCreateContourTree",_wrap_cvCreateContourTree,0,0,2,_wrap_cvCreateContourTree_texinfo},
{"cvContourFromContourTreeUntyped",_wrap_cvContourFromContourTreeUntyped,0,0,2,_wrap_cvContourFromContourTreeUntyped_texinfo},
{"cvMatchContourTrees",_wrap_cvMatchContourTrees,0,0,2,_wrap_cvMatchContourTrees_texinfo},
{"cvCalcPGH",_wrap_cvCalcPGH,0,0,2,_wrap_cvCalcPGH_texinfo},
{"cvCheckContourConvexity",_wrap_cvCheckContourConvexity,0,0,2,_wrap_cvCheckContourConvexity_texinfo},
{"cvConvexityDefectsUntyped",_wrap_cvConvexityDefectsUntyped,0,0,2,_wrap_cvConvexityDefectsUntyped_texinfo},
{"cvFitEllipse2",_wrap_cvFitEllipse2,0,0,2,_wrap_cvFitEllipse2_texinfo},
{"cvMaxRect",_wrap_cvMaxRect,0,0,2,_wrap_cvMaxRect_texinfo},
{"cvBoxPoints",_wrap_cvBoxPoints,0,0,2,_wrap_cvBoxPoints_texinfo},
{"cvPointSeqFromMat",_wrap_cvPointSeqFromMat,0,0,2,_wrap_cvPointSeqFromMat_texinfo},
{"cvPointPolygonTest",_wrap_cvPointPolygonTest,0,0,2,_wrap_cvPointPolygonTest_texinfo},
{"cvCreateHist",_wrap_cvCreateHist,0,0,2,_wrap_cvCreateHist_texinfo},
{"cvSetHistBinRanges",_wrap_cvSetHistBinRanges,0,0,2,_wrap_cvSetHistBinRanges_texinfo},
{"cvMakeHistHeaderForArray",_wrap_cvMakeHistHeaderForArray,0,0,2,_wrap_cvMakeHistHeaderForArray_texinfo},
{"cvReleaseHist",_wrap_cvReleaseHist,0,0,2,_wrap_cvReleaseHist_texinfo},
{"cvClearHist",_wrap_cvClearHist,0,0,2,_wrap_cvClearHist_texinfo},
{"cvGetMinMaxHistValue",_wrap_cvGetMinMaxHistValue,0,0,2,_wrap_cvGetMinMaxHistValue_texinfo},
{"cvNormalizeHist",_wrap_cvNormalizeHist,0,0,2,_wrap_cvNormalizeHist_texinfo},
{"cvThreshHist",_wrap_cvThreshHist,0,0,2,_wrap_cvThreshHist_texinfo},
{"cvCompareHist",_wrap_cvCompareHist,0,0,2,_wrap_cvCompareHist_texinfo},
{"cvCopyHist",_wrap_cvCopyHist,0,0,2,_wrap_cvCopyHist_texinfo},
{"cvCalcBayesianProb",_wrap_cvCalcBayesianProb,0,0,2,_wrap_cvCalcBayesianProb_texinfo},
{"cvCalcArrHist",_wrap_cvCalcArrHist,0,0,2,_wrap_cvCalcArrHist_texinfo},
{"cvCalcImageHist",_wrap_cvCalcImageHist,0,0,2,_wrap_cvCalcImageHist_texinfo},
{"cvCalcArrBackProject",_wrap_cvCalcArrBackProject,0,0,2,_wrap_cvCalcArrBackProject_texinfo},
{"cvCalcArrBackProjectPatch",_wrap_cvCalcArrBackProjectPatch,0,0,2,_wrap_cvCalcArrBackProjectPatch_texinfo},
{"cvCalcProbDensity",_wrap_cvCalcProbDensity,0,0,2,_wrap_cvCalcProbDensity_texinfo},
{"cvEqualizeHist",_wrap_cvEqualizeHist,0,0,2,_wrap_cvEqualizeHist_texinfo},
{"cvCalcImageHomography",_wrap_cvCalcImageHomography,0,0,2,_wrap_cvCalcImageHomography_texinfo},
{"cvDistTransform",_wrap_cvDistTransform,0,0,2,_wrap_cvDistTransform_texinfo},
{"cvThreshold",_wrap_cvThreshold,0,0,2,_wrap_cvThreshold_texinfo},
{"cvAdaptiveThreshold",_wrap_cvAdaptiveThreshold,0,0,2,_wrap_cvAdaptiveThreshold_texinfo},
{"cvFloodFill",_wrap_cvFloodFill,0,0,2,_wrap_cvFloodFill_texinfo},
{"cvCanny",_wrap_cvCanny,0,0,2,_wrap_cvCanny_texinfo},
{"cvPreCornerDetect",_wrap_cvPreCornerDetect,0,0,2,_wrap_cvPreCornerDetect_texinfo},
{"cvCornerEigenValsAndVecs",_wrap_cvCornerEigenValsAndVecs,0,0,2,_wrap_cvCornerEigenValsAndVecs_texinfo},
{"cvCornerMinEigenVal",_wrap_cvCornerMinEigenVal,0,0,2,_wrap_cvCornerMinEigenVal_texinfo},
{"cvCornerHarris",_wrap_cvCornerHarris,0,0,2,_wrap_cvCornerHarris_texinfo},
{"cvFindCornerSubPix",_wrap_cvFindCornerSubPix,0,0,2,_wrap_cvFindCornerSubPix_texinfo},
{"cvGoodFeaturesToTrack",_wrap_cvGoodFeaturesToTrack,0,0,2,_wrap_cvGoodFeaturesToTrack_texinfo},
{"cvHoughLinesUntyped",_wrap_cvHoughLinesUntyped,0,0,2,_wrap_cvHoughLinesUntyped_texinfo},
{"cvHoughCirclesUntyped",_wrap_cvHoughCirclesUntyped,0,0,2,_wrap_cvHoughCirclesUntyped_texinfo},
{"cvFitLine",_wrap_cvFitLine,0,0,2,_wrap_cvFitLine_texinfo},
{"cvCreateKDTree",_wrap_cvCreateKDTree,0,0,2,_wrap_cvCreateKDTree_texinfo},
{"cvCreateSpillTree",_wrap_cvCreateSpillTree,0,0,2,_wrap_cvCreateSpillTree_texinfo},
{"cvReleaseFeatureTree",_wrap_cvReleaseFeatureTree,0,0,2,_wrap_cvReleaseFeatureTree_texinfo},
{"cvFindFeatures",_wrap_cvFindFeatures,0,0,2,_wrap_cvFindFeatures_texinfo},
{"cvFindFeaturesBoxed",_wrap_cvFindFeaturesBoxed,0,0,2,_wrap_cvFindFeaturesBoxed_texinfo},
{"cvCreateLSH",_wrap_cvCreateLSH,0,0,2,_wrap_cvCreateLSH_texinfo},
{"cvCreateMemoryLSH",_wrap_cvCreateMemoryLSH,0,0,2,_wrap_cvCreateMemoryLSH_texinfo},
{"cvReleaseLSH",_wrap_cvReleaseLSH,0,0,2,_wrap_cvReleaseLSH_texinfo},
{"LSHSize",_wrap_LSHSize,0,0,2,_wrap_LSHSize_texinfo},
{"cvLSHAdd",_wrap_cvLSHAdd,0,0,2,_wrap_cvLSHAdd_texinfo},
{"cvLSHRemove",_wrap_cvLSHRemove,0,0,2,_wrap_cvLSHRemove_texinfo},
{"cvLSHQuery",_wrap_cvLSHQuery,0,0,2,_wrap_cvLSHQuery_texinfo},
{"CvSURFPoint_pt_set",_wrap_CvSURFPoint_pt_set,0,0,2,0},
{"CvSURFPoint_pt_get",_wrap_CvSURFPoint_pt_get,0,0,2,0},
{"CvSURFPoint_laplacian_set",_wrap_CvSURFPoint_laplacian_set,0,0,2,0},
{"CvSURFPoint_laplacian_get",_wrap_CvSURFPoint_laplacian_get,0,0,2,0},
{"CvSURFPoint_size_set",_wrap_CvSURFPoint_size_set,0,0,2,0},
{"CvSURFPoint_size_get",_wrap_CvSURFPoint_size_get,0,0,2,0},
{"CvSURFPoint_dir_set",_wrap_CvSURFPoint_dir_set,0,0,2,0},
{"CvSURFPoint_dir_get",_wrap_CvSURFPoint_dir_get,0,0,2,0},
{"CvSURFPoint_hessian_set",_wrap_CvSURFPoint_hessian_set,0,0,2,0},
{"CvSURFPoint_hessian_get",_wrap_CvSURFPoint_hessian_get,0,0,2,0},
{"new_CvSURFPoint",_wrap_new_CvSURFPoint,0,0,2,_wrap_new_CvSURFPoint_texinfo},
{"delete_CvSURFPoint",_wrap_delete_CvSURFPoint,0,0,2,_wrap_delete_CvSURFPoint_texinfo},
{"cvSURFPoint",_wrap_cvSURFPoint,0,0,2,_wrap_cvSURFPoint_texinfo},
{"CvSURFParams_extended_set",_wrap_CvSURFParams_extended_set,0,0,2,0},
{"CvSURFParams_extended_get",_wrap_CvSURFParams_extended_get,0,0,2,0},
{"CvSURFParams_hessianThreshold_set",_wrap_CvSURFParams_hessianThreshold_set,0,0,2,0},
{"CvSURFParams_hessianThreshold_get",_wrap_CvSURFParams_hessianThreshold_get,0,0,2,0},
{"CvSURFParams_nOctaves_set",_wrap_CvSURFParams_nOctaves_set,0,0,2,0},
{"CvSURFParams_nOctaves_get",_wrap_CvSURFParams_nOctaves_get,0,0,2,0},
{"CvSURFParams_nOctaveLayers_set",_wrap_CvSURFParams_nOctaveLayers_set,0,0,2,0},
{"CvSURFParams_nOctaveLayers_get",_wrap_CvSURFParams_nOctaveLayers_get,0,0,2,0},
{"new_CvSURFParams",_wrap_new_CvSURFParams,0,0,2,_wrap_new_CvSURFParams_texinfo},
{"delete_CvSURFParams",_wrap_delete_CvSURFParams,0,0,2,_wrap_delete_CvSURFParams_texinfo},
{"cvSURFParams",_wrap_cvSURFParams,0,0,2,_wrap_cvSURFParams_texinfo},
{"cvExtractSURF",_wrap_cvExtractSURF,0,0,2,_wrap_cvExtractSURF_texinfo},
{"CvMSERParams_delta_set",_wrap_CvMSERParams_delta_set,0,0,2,0},
{"CvMSERParams_delta_get",_wrap_CvMSERParams_delta_get,0,0,2,0},
{"CvMSERParams_maxArea_set",_wrap_CvMSERParams_maxArea_set,0,0,2,0},
{"CvMSERParams_maxArea_get",_wrap_CvMSERParams_maxArea_get,0,0,2,0},
{"CvMSERParams_minArea_set",_wrap_CvMSERParams_minArea_set,0,0,2,0},
{"CvMSERParams_minArea_get",_wrap_CvMSERParams_minArea_get,0,0,2,0},
{"CvMSERParams_maxVariation_set",_wrap_CvMSERParams_maxVariation_set,0,0,2,0},
{"CvMSERParams_maxVariation_get",_wrap_CvMSERParams_maxVariation_get,0,0,2,0},
{"CvMSERParams_minDiversity_set",_wrap_CvMSERParams_minDiversity_set,0,0,2,0},
{"CvMSERParams_minDiversity_get",_wrap_CvMSERParams_minDiversity_get,0,0,2,0},
{"CvMSERParams_maxEvolution_set",_wrap_CvMSERParams_maxEvolution_set,0,0,2,0},
{"CvMSERParams_maxEvolution_get",_wrap_CvMSERParams_maxEvolution_get,0,0,2,0},
{"CvMSERParams_areaThreshold_set",_wrap_CvMSERParams_areaThreshold_set,0,0,2,0},
{"CvMSERParams_areaThreshold_get",_wrap_CvMSERParams_areaThreshold_get,0,0,2,0},
{"CvMSERParams_minMargin_set",_wrap_CvMSERParams_minMargin_set,0,0,2,0},
{"CvMSERParams_minMargin_get",_wrap_CvMSERParams_minMargin_get,0,0,2,0},
{"CvMSERParams_edgeBlurSize_set",_wrap_CvMSERParams_edgeBlurSize_set,0,0,2,0},
{"CvMSERParams_edgeBlurSize_get",_wrap_CvMSERParams_edgeBlurSize_get,0,0,2,0},
{"new_CvMSERParams",_wrap_new_CvMSERParams,0,0,2,_wrap_new_CvMSERParams_texinfo},
{"delete_CvMSERParams",_wrap_delete_CvMSERParams,0,0,2,_wrap_delete_CvMSERParams_texinfo},
{"cvMSERParams",_wrap_cvMSERParams,0,0,2,_wrap_cvMSERParams_texinfo},
{"cvExtractMSER",_wrap_cvExtractMSER,0,0,2,_wrap_cvExtractMSER_texinfo},
{"CvStarKeypoint_pt_set",_wrap_CvStarKeypoint_pt_set,0,0,2,0},
{"CvStarKeypoint_pt_get",_wrap_CvStarKeypoint_pt_get,0,0,2,0},
{"CvStarKeypoint_size_set",_wrap_CvStarKeypoint_size_set,0,0,2,0},
{"CvStarKeypoint_size_get",_wrap_CvStarKeypoint_size_get,0,0,2,0},
{"CvStarKeypoint_response_set",_wrap_CvStarKeypoint_response_set,0,0,2,0},
{"CvStarKeypoint_response_get",_wrap_CvStarKeypoint_response_get,0,0,2,0},
{"new_CvStarKeypoint",_wrap_new_CvStarKeypoint,0,0,2,_wrap_new_CvStarKeypoint_texinfo},
{"delete_CvStarKeypoint",_wrap_delete_CvStarKeypoint,0,0,2,_wrap_delete_CvStarKeypoint_texinfo},
{"cvStarKeypoint",_wrap_cvStarKeypoint,0,0,2,_wrap_cvStarKeypoint_texinfo},
{"CvStarDetectorParams_maxSize_set",_wrap_CvStarDetectorParams_maxSize_set,0,0,2,0},
{"CvStarDetectorParams_maxSize_get",_wrap_CvStarDetectorParams_maxSize_get,0,0,2,0},
{"CvStarDetectorParams_responseThreshold_set",_wrap_CvStarDetectorParams_responseThreshold_set,0,0,2,0},
{"CvStarDetectorParams_responseThreshold_get",_wrap_CvStarDetectorParams_responseThreshold_get,0,0,2,0},
{"CvStarDetectorParams_lineThresholdProjected_set",_wrap_CvStarDetectorParams_lineThresholdProjected_set,0,0,2,0},
{"CvStarDetectorParams_lineThresholdProjected_get",_wrap_CvStarDetectorParams_lineThresholdProjected_get,0,0,2,0},
{"CvStarDetectorParams_lineThresholdBinarized_set",_wrap_CvStarDetectorParams_lineThresholdBinarized_set,0,0,2,0},
{"CvStarDetectorParams_lineThresholdBinarized_get",_wrap_CvStarDetectorParams_lineThresholdBinarized_get,0,0,2,0},
{"CvStarDetectorParams_suppressNonmaxSize_set",_wrap_CvStarDetectorParams_suppressNonmaxSize_set,0,0,2,0},
{"CvStarDetectorParams_suppressNonmaxSize_get",_wrap_CvStarDetectorParams_suppressNonmaxSize_get,0,0,2,0},
{"new_CvStarDetectorParams",_wrap_new_CvStarDetectorParams,0,0,2,_wrap_new_CvStarDetectorParams_texinfo},
{"delete_CvStarDetectorParams",_wrap_delete_CvStarDetectorParams,0,0,2,_wrap_delete_CvStarDetectorParams_texinfo},
{"cvStarDetectorParams",_wrap_cvStarDetectorParams,0,0,2,_wrap_cvStarDetectorParams_texinfo},
{"cvGetStarKeypoints",_wrap_cvGetStarKeypoints,0,0,2,_wrap_cvGetStarKeypoints_texinfo},
{"cvLoadHaarClassifierCascade",_wrap_cvLoadHaarClassifierCascade,0,0,2,_wrap_cvLoadHaarClassifierCascade_texinfo},
{"cvReleaseHaarClassifierCascade",_wrap_cvReleaseHaarClassifierCascade,0,0,2,_wrap_cvReleaseHaarClassifierCascade_texinfo},
{"cvSetImagesForHaarClassifierCascade",_wrap_cvSetImagesForHaarClassifierCascade,0,0,2,_wrap_cvSetImagesForHaarClassifierCascade_texinfo},
{"cvRunHaarClassifierCascade",_wrap_cvRunHaarClassifierCascade,0,0,2,_wrap_cvRunHaarClassifierCascade_texinfo},
{"cvUndistort2",_wrap_cvUndistort2,0,0,2,_wrap_cvUndistort2_texinfo},
{"cvInitUndistortMap",_wrap_cvInitUndistortMap,0,0,2,_wrap_cvInitUndistortMap_texinfo},
{"cvInitUndistortRectifyMap",_wrap_cvInitUndistortRectifyMap,0,0,2,_wrap_cvInitUndistortRectifyMap_texinfo},
{"cvUndistortPoints",_wrap_cvUndistortPoints,0,0,2,_wrap_cvUndistortPoints_texinfo},
{"cvRodrigues2",_wrap_cvRodrigues2,0,0,2,_wrap_cvRodrigues2_texinfo},
{"cvFindHomography",_wrap_cvFindHomography,0,0,2,_wrap_cvFindHomography_texinfo},
{"cvRQDecomp3x3",_wrap_cvRQDecomp3x3,0,0,2,_wrap_cvRQDecomp3x3_texinfo},
{"cvDecomposeProjectionMatrix",_wrap_cvDecomposeProjectionMatrix,0,0,2,_wrap_cvDecomposeProjectionMatrix_texinfo},
{"cvCalcMatMulDeriv",_wrap_cvCalcMatMulDeriv,0,0,2,_wrap_cvCalcMatMulDeriv_texinfo},
{"cvComposeRT",_wrap_cvComposeRT,0,0,2,_wrap_cvComposeRT_texinfo},
{"cvProjectPoints2",_wrap_cvProjectPoints2,0,0,2,_wrap_cvProjectPoints2_texinfo},
{"cvFindExtrinsicCameraParams2",_wrap_cvFindExtrinsicCameraParams2,0,0,2,_wrap_cvFindExtrinsicCameraParams2_texinfo},
{"cvInitIntrinsicParams2D",_wrap_cvInitIntrinsicParams2D,0,0,2,_wrap_cvInitIntrinsicParams2D_texinfo},
{"cvFindChessboardCorners",_wrap_cvFindChessboardCorners,0,0,2,_wrap_cvFindChessboardCorners_texinfo},
{"cvDrawChessboardCorners",_wrap_cvDrawChessboardCorners,0,0,2,_wrap_cvDrawChessboardCorners_texinfo},
{"cvCalibrateCamera2",_wrap_cvCalibrateCamera2,0,0,2,_wrap_cvCalibrateCamera2_texinfo},
{"cvCalibrationMatrixValues",_wrap_cvCalibrationMatrixValues,0,0,2,_wrap_cvCalibrationMatrixValues_texinfo},
{"cvStereoCalibrate",_wrap_cvStereoCalibrate,0,0,2,_wrap_cvStereoCalibrate_texinfo},
{"cvStereoRectify",_wrap_cvStereoRectify,0,0,2,_wrap_cvStereoRectify_texinfo},
{"cvStereoRectifyUncalibrated",_wrap_cvStereoRectifyUncalibrated,0,0,2,_wrap_cvStereoRectifyUncalibrated_texinfo},
{"cvCreatePOSITObject",_wrap_cvCreatePOSITObject,0,0,2,_wrap_cvCreatePOSITObject_texinfo},
{"cvPOSIT",_wrap_cvPOSIT,0,0,2,_wrap_cvPOSIT_texinfo},
{"cvReleasePOSITObject",_wrap_cvReleasePOSITObject,0,0,2,_wrap_cvReleasePOSITObject_texinfo},
{"cvRANSACUpdateNumIters",_wrap_cvRANSACUpdateNumIters,0,0,2,_wrap_cvRANSACUpdateNumIters_texinfo},
{"cvConvertPointsHomogeneous",_wrap_cvConvertPointsHomogeneous,0,0,2,_wrap_cvConvertPointsHomogeneous_texinfo},
{"cvFindFundamentalMat",_wrap_cvFindFundamentalMat,0,0,2,_wrap_cvFindFundamentalMat_texinfo},
{"cvComputeCorrespondEpilines",_wrap_cvComputeCorrespondEpilines,0,0,2,_wrap_cvComputeCorrespondEpilines_texinfo},
{"cvTriangulatePoints",_wrap_cvTriangulatePoints,0,0,2,_wrap_cvTriangulatePoints_texinfo},
{"cvCorrectMatches",_wrap_cvCorrectMatches,0,0,2,_wrap_cvCorrectMatches_texinfo},
{"CvStereoBMState_preFilterType_set",_wrap_CvStereoBMState_preFilterType_set,0,0,2,0},
{"CvStereoBMState_preFilterType_get",_wrap_CvStereoBMState_preFilterType_get,0,0,2,0},
{"CvStereoBMState_preFilterSize_set",_wrap_CvStereoBMState_preFilterSize_set,0,0,2,0},
{"CvStereoBMState_preFilterSize_get",_wrap_CvStereoBMState_preFilterSize_get,0,0,2,0},
{"CvStereoBMState_preFilterCap_set",_wrap_CvStereoBMState_preFilterCap_set,0,0,2,0},
{"CvStereoBMState_preFilterCap_get",_wrap_CvStereoBMState_preFilterCap_get,0,0,2,0},
{"CvStereoBMState_SADWindowSize_set",_wrap_CvStereoBMState_SADWindowSize_set,0,0,2,0},
{"CvStereoBMState_SADWindowSize_get",_wrap_CvStereoBMState_SADWindowSize_get,0,0,2,0},
{"CvStereoBMState_minDisparity_set",_wrap_CvStereoBMState_minDisparity_set,0,0,2,0},
{"CvStereoBMState_minDisparity_get",_wrap_CvStereoBMState_minDisparity_get,0,0,2,0},
{"CvStereoBMState_numberOfDisparities_set",_wrap_CvStereoBMState_numberOfDisparities_set,0,0,2,0},
{"CvStereoBMState_numberOfDisparities_get",_wrap_CvStereoBMState_numberOfDisparities_get,0,0,2,0},
{"CvStereoBMState_textureThreshold_set",_wrap_CvStereoBMState_textureThreshold_set,0,0,2,0},
{"CvStereoBMState_textureThreshold_get",_wrap_CvStereoBMState_textureThreshold_get,0,0,2,0},
{"CvStereoBMState_uniquenessRatio_set",_wrap_CvStereoBMState_uniquenessRatio_set,0,0,2,0},
{"CvStereoBMState_uniquenessRatio_get",_wrap_CvStereoBMState_uniquenessRatio_get,0,0,2,0},
{"CvStereoBMState_speckleWindowSize_set",_wrap_CvStereoBMState_speckleWindowSize_set,0,0,2,0},
{"CvStereoBMState_speckleWindowSize_get",_wrap_CvStereoBMState_speckleWindowSize_get,0,0,2,0},
{"CvStereoBMState_speckleRange_set",_wrap_CvStereoBMState_speckleRange_set,0,0,2,0},
{"CvStereoBMState_speckleRange_get",_wrap_CvStereoBMState_speckleRange_get,0,0,2,0},
{"CvStereoBMState_trySmallerWindows_set",_wrap_CvStereoBMState_trySmallerWindows_set,0,0,2,0},
{"CvStereoBMState_trySmallerWindows_get",_wrap_CvStereoBMState_trySmallerWindows_get,0,0,2,0},
{"CvStereoBMState_preFilteredImg0_set",_wrap_CvStereoBMState_preFilteredImg0_set,0,0,2,0},
{"CvStereoBMState_preFilteredImg0_get",_wrap_CvStereoBMState_preFilteredImg0_get,0,0,2,0},
{"CvStereoBMState_preFilteredImg1_set",_wrap_CvStereoBMState_preFilteredImg1_set,0,0,2,0},
{"CvStereoBMState_preFilteredImg1_get",_wrap_CvStereoBMState_preFilteredImg1_get,0,0,2,0},
{"CvStereoBMState_slidingSumBuf_set",_wrap_CvStereoBMState_slidingSumBuf_set,0,0,2,0},
{"CvStereoBMState_slidingSumBuf_get",_wrap_CvStereoBMState_slidingSumBuf_get,0,0,2,0},
{"CvStereoBMState_dbmin_set",_wrap_CvStereoBMState_dbmin_set,0,0,2,0},
{"CvStereoBMState_dbmin_get",_wrap_CvStereoBMState_dbmin_get,0,0,2,0},
{"CvStereoBMState_dbmax_set",_wrap_CvStereoBMState_dbmax_set,0,0,2,0},
{"CvStereoBMState_dbmax_get",_wrap_CvStereoBMState_dbmax_get,0,0,2,0},
{"new_CvStereoBMState",_wrap_new_CvStereoBMState,0,0,2,_wrap_new_CvStereoBMState_texinfo},
{"delete_CvStereoBMState",_wrap_delete_CvStereoBMState,0,0,2,_wrap_delete_CvStereoBMState_texinfo},
{"cvCreateStereoBMState",_wrap_cvCreateStereoBMState,0,0,2,_wrap_cvCreateStereoBMState_texinfo},
{"cvReleaseStereoBMState",_wrap_cvReleaseStereoBMState,0,0,2,_wrap_cvReleaseStereoBMState_texinfo},
{"cvFindStereoCorrespondenceBM",_wrap_cvFindStereoCorrespondenceBM,0,0,2,_wrap_cvFindStereoCorrespondenceBM_texinfo},
{"CvStereoGCState_Ithreshold_set",_wrap_CvStereoGCState_Ithreshold_set,0,0,2,0},
{"CvStereoGCState_Ithreshold_get",_wrap_CvStereoGCState_Ithreshold_get,0,0,2,0},
{"CvStereoGCState_interactionRadius_set",_wrap_CvStereoGCState_interactionRadius_set,0,0,2,0},
{"CvStereoGCState_interactionRadius_get",_wrap_CvStereoGCState_interactionRadius_get,0,0,2,0},
{"CvStereoGCState_K_set",_wrap_CvStereoGCState_K_set,0,0,2,0},
{"CvStereoGCState_K_get",_wrap_CvStereoGCState_K_get,0,0,2,0},
{"CvStereoGCState_lambda_set",_wrap_CvStereoGCState_lambda_set,0,0,2,0},
{"CvStereoGCState_lambda_get",_wrap_CvStereoGCState_lambda_get,0,0,2,0},
{"CvStereoGCState_lambda1_set",_wrap_CvStereoGCState_lambda1_set,0,0,2,0},
{"CvStereoGCState_lambda1_get",_wrap_CvStereoGCState_lambda1_get,0,0,2,0},
{"CvStereoGCState_lambda2_set",_wrap_CvStereoGCState_lambda2_set,0,0,2,0},
{"CvStereoGCState_lambda2_get",_wrap_CvStereoGCState_lambda2_get,0,0,2,0},
{"CvStereoGCState_occlusionCost_set",_wrap_CvStereoGCState_occlusionCost_set,0,0,2,0},
{"CvStereoGCState_occlusionCost_get",_wrap_CvStereoGCState_occlusionCost_get,0,0,2,0},
{"CvStereoGCState_minDisparity_set",_wrap_CvStereoGCState_minDisparity_set,0,0,2,0},
{"CvStereoGCState_minDisparity_get",_wrap_CvStereoGCState_minDisparity_get,0,0,2,0},
{"CvStereoGCState_numberOfDisparities_set",_wrap_CvStereoGCState_numberOfDisparities_set,0,0,2,0},
{"CvStereoGCState_numberOfDisparities_get",_wrap_CvStereoGCState_numberOfDisparities_get,0,0,2,0},
{"CvStereoGCState_maxIters_set",_wrap_CvStereoGCState_maxIters_set,0,0,2,0},
{"CvStereoGCState_maxIters_get",_wrap_CvStereoGCState_maxIters_get,0,0,2,0},
{"CvStereoGCState_left_set",_wrap_CvStereoGCState_left_set,0,0,2,0},
{"CvStereoGCState_left_get",_wrap_CvStereoGCState_left_get,0,0,2,0},
{"CvStereoGCState_right_set",_wrap_CvStereoGCState_right_set,0,0,2,0},
{"CvStereoGCState_right_get",_wrap_CvStereoGCState_right_get,0,0,2,0},
{"CvStereoGCState_dispLeft_set",_wrap_CvStereoGCState_dispLeft_set,0,0,2,0},
{"CvStereoGCState_dispLeft_get",_wrap_CvStereoGCState_dispLeft_get,0,0,2,0},
{"CvStereoGCState_dispRight_set",_wrap_CvStereoGCState_dispRight_set,0,0,2,0},
{"CvStereoGCState_dispRight_get",_wrap_CvStereoGCState_dispRight_get,0,0,2,0},
{"CvStereoGCState_ptrLeft_set",_wrap_CvStereoGCState_ptrLeft_set,0,0,2,0},
{"CvStereoGCState_ptrLeft_get",_wrap_CvStereoGCState_ptrLeft_get,0,0,2,0},
{"CvStereoGCState_ptrRight_set",_wrap_CvStereoGCState_ptrRight_set,0,0,2,0},
{"CvStereoGCState_ptrRight_get",_wrap_CvStereoGCState_ptrRight_get,0,0,2,0},
{"CvStereoGCState_vtxBuf_set",_wrap_CvStereoGCState_vtxBuf_set,0,0,2,0},
{"CvStereoGCState_vtxBuf_get",_wrap_CvStereoGCState_vtxBuf_get,0,0,2,0},
{"CvStereoGCState_edgeBuf_set",_wrap_CvStereoGCState_edgeBuf_set,0,0,2,0},
{"CvStereoGCState_edgeBuf_get",_wrap_CvStereoGCState_edgeBuf_get,0,0,2,0},
{"new_CvStereoGCState",_wrap_new_CvStereoGCState,0,0,2,_wrap_new_CvStereoGCState_texinfo},
{"delete_CvStereoGCState",_wrap_delete_CvStereoGCState,0,0,2,_wrap_delete_CvStereoGCState_texinfo},
{"cvCreateStereoGCState",_wrap_cvCreateStereoGCState,0,0,2,_wrap_cvCreateStereoGCState_texinfo},
{"cvReleaseStereoGCState",_wrap_cvReleaseStereoGCState,0,0,2,_wrap_cvReleaseStereoGCState_texinfo},
{"cvFindStereoCorrespondenceGC",_wrap_cvFindStereoCorrespondenceGC,0,0,2,_wrap_cvFindStereoCorrespondenceGC_texinfo},
{"cvReprojectImageTo3D",_wrap_cvReprojectImageTo3D,0,0,2,_wrap_cvReprojectImageTo3D_texinfo},
{"delete_CvLSH",_wrap_delete_CvLSH,0,0,2,_wrap_delete_CvLSH_texinfo},
{"CvTuple_CvPoint_2_val_set",_wrap_CvTuple_CvPoint_2_val_set,0,0,2,0},
{"CvTuple_CvPoint_2_val_get",_wrap_CvTuple_CvPoint_2_val_get,0,0,2,0},
{"CvTuple_CvPoint_2___paren",_wrap_CvTuple_CvPoint_2___paren,0,0,2,_wrap_CvTuple_CvPoint_2___paren_texinfo},
{"CvTuple_CvPoint_2___paren_asgn",_wrap_CvTuple_CvPoint_2___paren_asgn,0,0,2,_wrap_CvTuple_CvPoint_2___paren_asgn_texinfo},
{"CvTuple_CvPoint_2___brace",_wrap_CvTuple_CvPoint_2___brace,0,0,2,_wrap_CvTuple_CvPoint_2___brace_texinfo},
{"CvTuple_CvPoint_2___brace_asgn",_wrap_CvTuple_CvPoint_2___brace_asgn,0,0,2,_wrap_CvTuple_CvPoint_2___brace_asgn_texinfo},
{"new_CvTuple_CvPoint_2",_wrap_new_CvTuple_CvPoint_2,0,0,2,_wrap_new_CvTuple_CvPoint_2_texinfo},
{"delete_CvTuple_CvPoint_2",_wrap_delete_CvTuple_CvPoint_2,0,0,2,_wrap_delete_CvTuple_CvPoint_2_texinfo},
{"CvTuple_float_2_val_set",_wrap_CvTuple_float_2_val_set,0,0,2,0},
{"CvTuple_float_2_val_get",_wrap_CvTuple_float_2_val_get,0,0,2,0},
{"CvTuple_float_2___paren",_wrap_CvTuple_float_2___paren,0,0,2,_wrap_CvTuple_float_2___paren_texinfo},
{"CvTuple_float_2___paren_asgn",_wrap_CvTuple_float_2___paren_asgn,0,0,2,_wrap_CvTuple_float_2___paren_asgn_texinfo},
{"CvTuple_float_2___brace",_wrap_CvTuple_float_2___brace,0,0,2,_wrap_CvTuple_float_2___brace_texinfo},
{"CvTuple_float_2___brace_asgn",_wrap_CvTuple_float_2___brace_asgn,0,0,2,_wrap_CvTuple_float_2___brace_asgn_texinfo},
{"new_CvTuple_float_2",_wrap_new_CvTuple_float_2,0,0,2,_wrap_new_CvTuple_float_2_texinfo},
{"delete_CvTuple_float_2",_wrap_delete_CvTuple_float_2,0,0,2,_wrap_delete_CvTuple_float_2_texinfo},
{"CvTuple_float_3_val_set",_wrap_CvTuple_float_3_val_set,0,0,2,0},
{"CvTuple_float_3_val_get",_wrap_CvTuple_float_3_val_get,0,0,2,0},
{"CvTuple_float_3___paren",_wrap_CvTuple_float_3___paren,0,0,2,_wrap_CvTuple_float_3___paren_texinfo},
{"CvTuple_float_3___paren_asgn",_wrap_CvTuple_float_3___paren_asgn,0,0,2,_wrap_CvTuple_float_3___paren_asgn_texinfo},
{"CvTuple_float_3___brace",_wrap_CvTuple_float_3___brace,0,0,2,_wrap_CvTuple_float_3___brace_texinfo},
{"CvTuple_float_3___brace_asgn",_wrap_CvTuple_float_3___brace_asgn,0,0,2,_wrap_CvTuple_float_3___brace_asgn_texinfo},
{"new_CvTuple_float_3",_wrap_new_CvTuple_float_3,0,0,2,_wrap_new_CvTuple_float_3_texinfo},
{"delete_CvTuple_float_3",_wrap_delete_CvTuple_float_3,0,0,2,_wrap_delete_CvTuple_float_3_texinfo},
{"CvSeq_CvPoint_cast",_wrap_CvSeq_CvPoint_cast,0,0,2,_wrap_CvSeq_CvPoint_cast_texinfo},
{"CvSeq_CvPoint___paren",_wrap_CvSeq_CvPoint___paren,0,0,2,_wrap_CvSeq_CvPoint___paren_texinfo},
{"CvSeq_CvPoint___paren_asgn",_wrap_CvSeq_CvPoint___paren_asgn,0,0,2,_wrap_CvSeq_CvPoint___paren_asgn_texinfo},
{"CvSeq_CvPoint___brace",_wrap_CvSeq_CvPoint___brace,0,0,2,_wrap_CvSeq_CvPoint___brace_texinfo},
{"CvSeq_CvPoint___brace_asgn",_wrap_CvSeq_CvPoint___brace_asgn,0,0,2,_wrap_CvSeq_CvPoint___brace_asgn_texinfo},
{"CvSeq_CvPoint_append",_wrap_CvSeq_CvPoint_append,0,0,2,_wrap_CvSeq_CvPoint_append_texinfo},
{"CvSeq_CvPoint_pop",_wrap_CvSeq_CvPoint_pop,0,0,2,_wrap_CvSeq_CvPoint_pop_texinfo},
{"new_CvSeq_CvPoint",_wrap_new_CvSeq_CvPoint,0,0,2,_wrap_new_CvSeq_CvPoint_texinfo},
{"delete_CvSeq_CvPoint",_wrap_delete_CvSeq_CvPoint,0,0,2,_wrap_delete_CvSeq_CvPoint_texinfo},
{"CvSeq_CvPoint2D32f_cast",_wrap_CvSeq_CvPoint2D32f_cast,0,0,2,_wrap_CvSeq_CvPoint2D32f_cast_texinfo},
{"CvSeq_CvPoint2D32f___paren",_wrap_CvSeq_CvPoint2D32f___paren,0,0,2,_wrap_CvSeq_CvPoint2D32f___paren_texinfo},
{"CvSeq_CvPoint2D32f___paren_asgn",_wrap_CvSeq_CvPoint2D32f___paren_asgn,0,0,2,_wrap_CvSeq_CvPoint2D32f___paren_asgn_texinfo},
{"CvSeq_CvPoint2D32f___brace",_wrap_CvSeq_CvPoint2D32f___brace,0,0,2,_wrap_CvSeq_CvPoint2D32f___brace_texinfo},
{"CvSeq_CvPoint2D32f___brace_asgn",_wrap_CvSeq_CvPoint2D32f___brace_asgn,0,0,2,_wrap_CvSeq_CvPoint2D32f___brace_asgn_texinfo},
{"CvSeq_CvPoint2D32f_append",_wrap_CvSeq_CvPoint2D32f_append,0,0,2,_wrap_CvSeq_CvPoint2D32f_append_texinfo},
{"CvSeq_CvPoint2D32f_pop",_wrap_CvSeq_CvPoint2D32f_pop,0,0,2,_wrap_CvSeq_CvPoint2D32f_pop_texinfo},
{"new_CvSeq_CvPoint2D32f",_wrap_new_CvSeq_CvPoint2D32f,0,0,2,_wrap_new_CvSeq_CvPoint2D32f_texinfo},
{"delete_CvSeq_CvPoint2D32f",_wrap_delete_CvSeq_CvPoint2D32f,0,0,2,_wrap_delete_CvSeq_CvPoint2D32f_texinfo},
{"CvSeq_CvRect_cast",_wrap_CvSeq_CvRect_cast,0,0,2,_wrap_CvSeq_CvRect_cast_texinfo},
{"CvSeq_CvRect___paren",_wrap_CvSeq_CvRect___paren,0,0,2,_wrap_CvSeq_CvRect___paren_texinfo},
{"CvSeq_CvRect___paren_asgn",_wrap_CvSeq_CvRect___paren_asgn,0,0,2,_wrap_CvSeq_CvRect___paren_asgn_texinfo},
{"CvSeq_CvRect___brace",_wrap_CvSeq_CvRect___brace,0,0,2,_wrap_CvSeq_CvRect___brace_texinfo},
{"CvSeq_CvRect___brace_asgn",_wrap_CvSeq_CvRect___brace_asgn,0,0,2,_wrap_CvSeq_CvRect___brace_asgn_texinfo},
{"CvSeq_CvRect_append",_wrap_CvSeq_CvRect_append,0,0,2,_wrap_CvSeq_CvRect_append_texinfo},
{"CvSeq_CvRect_pop",_wrap_CvSeq_CvRect_pop,0,0,2,_wrap_CvSeq_CvRect_pop_texinfo},
{"new_CvSeq_CvRect",_wrap_new_CvSeq_CvRect,0,0,2,_wrap_new_CvSeq_CvRect_texinfo},
{"delete_CvSeq_CvRect",_wrap_delete_CvSeq_CvRect,0,0,2,_wrap_delete_CvSeq_CvRect_texinfo},
{"CvSeq_CvSeq_cast",_wrap_CvSeq_CvSeq_cast,0,0,2,_wrap_CvSeq_CvSeq_cast_texinfo},
{"CvSeq_CvSeq___paren",_wrap_CvSeq_CvSeq___paren,0,0,2,_wrap_CvSeq_CvSeq___paren_texinfo},
{"CvSeq_CvSeq___paren_asgn",_wrap_CvSeq_CvSeq___paren_asgn,0,0,2,_wrap_CvSeq_CvSeq___paren_asgn_texinfo},
{"CvSeq_CvSeq___brace",_wrap_CvSeq_CvSeq___brace,0,0,2,_wrap_CvSeq_CvSeq___brace_texinfo},
{"CvSeq_CvSeq___brace_asgn",_wrap_CvSeq_CvSeq___brace_asgn,0,0,2,_wrap_CvSeq_CvSeq___brace_asgn_texinfo},
{"CvSeq_CvSeq_append",_wrap_CvSeq_CvSeq_append,0,0,2,_wrap_CvSeq_CvSeq_append_texinfo},
{"CvSeq_CvSeq_pop",_wrap_CvSeq_CvSeq_pop,0,0,2,_wrap_CvSeq_CvSeq_pop_texinfo},
{"new_CvSeq_CvSeq",_wrap_new_CvSeq_CvSeq,0,0,2,_wrap_new_CvSeq_CvSeq_texinfo},
{"delete_CvSeq_CvSeq",_wrap_delete_CvSeq_CvSeq,0,0,2,_wrap_delete_CvSeq_CvSeq_texinfo},
{"CvSeq_CvQuadEdge2D_cast",_wrap_CvSeq_CvQuadEdge2D_cast,0,0,2,_wrap_CvSeq_CvQuadEdge2D_cast_texinfo},
{"CvSeq_CvQuadEdge2D___paren",_wrap_CvSeq_CvQuadEdge2D___paren,0,0,2,_wrap_CvSeq_CvQuadEdge2D___paren_texinfo},
{"CvSeq_CvQuadEdge2D___paren_asgn",_wrap_CvSeq_CvQuadEdge2D___paren_asgn,0,0,2,_wrap_CvSeq_CvQuadEdge2D___paren_asgn_texinfo},
{"CvSeq_CvQuadEdge2D___brace",_wrap_CvSeq_CvQuadEdge2D___brace,0,0,2,_wrap_CvSeq_CvQuadEdge2D___brace_texinfo},
{"CvSeq_CvQuadEdge2D___brace_asgn",_wrap_CvSeq_CvQuadEdge2D___brace_asgn,0,0,2,_wrap_CvSeq_CvQuadEdge2D___brace_asgn_texinfo},
{"CvSeq_CvQuadEdge2D_append",_wrap_CvSeq_CvQuadEdge2D_append,0,0,2,_wrap_CvSeq_CvQuadEdge2D_append_texinfo},
{"CvSeq_CvQuadEdge2D_pop",_wrap_CvSeq_CvQuadEdge2D_pop,0,0,2,_wrap_CvSeq_CvQuadEdge2D_pop_texinfo},
{"new_CvSeq_CvQuadEdge2D",_wrap_new_CvSeq_CvQuadEdge2D,0,0,2,_wrap_new_CvSeq_CvQuadEdge2D_texinfo},
{"delete_CvSeq_CvQuadEdge2D",_wrap_delete_CvSeq_CvQuadEdge2D,0,0,2,_wrap_delete_CvSeq_CvQuadEdge2D_texinfo},
{"CvSeq_CvConnectedComp_cast",_wrap_CvSeq_CvConnectedComp_cast,0,0,2,_wrap_CvSeq_CvConnectedComp_cast_texinfo},
{"CvSeq_CvConnectedComp___paren",_wrap_CvSeq_CvConnectedComp___paren,0,0,2,_wrap_CvSeq_CvConnectedComp___paren_texinfo},
{"CvSeq_CvConnectedComp___paren_asgn",_wrap_CvSeq_CvConnectedComp___paren_asgn,0,0,2,_wrap_CvSeq_CvConnectedComp___paren_asgn_texinfo},
{"CvSeq_CvConnectedComp___brace",_wrap_CvSeq_CvConnectedComp___brace,0,0,2,_wrap_CvSeq_CvConnectedComp___brace_texinfo},
{"CvSeq_CvConnectedComp___brace_asgn",_wrap_CvSeq_CvConnectedComp___brace_asgn,0,0,2,_wrap_CvSeq_CvConnectedComp___brace_asgn_texinfo},
{"CvSeq_CvConnectedComp_append",_wrap_CvSeq_CvConnectedComp_append,0,0,2,_wrap_CvSeq_CvConnectedComp_append_texinfo},
{"CvSeq_CvConnectedComp_pop",_wrap_CvSeq_CvConnectedComp_pop,0,0,2,_wrap_CvSeq_CvConnectedComp_pop_texinfo},
{"new_CvSeq_CvConnectedComp",_wrap_new_CvSeq_CvConnectedComp,0,0,2,_wrap_new_CvSeq_CvConnectedComp_texinfo},
{"delete_CvSeq_CvConnectedComp",_wrap_delete_CvSeq_CvConnectedComp,0,0,2,_wrap_delete_CvSeq_CvConnectedComp_texinfo},
{"CvSeq_CvPoint_2_cast",_wrap_CvSeq_CvPoint_2_cast,0,0,2,_wrap_CvSeq_CvPoint_2_cast_texinfo},
{"CvSeq_CvPoint_2___paren",_wrap_CvSeq_CvPoint_2___paren,0,0,2,_wrap_CvSeq_CvPoint_2___paren_texinfo},
{"CvSeq_CvPoint_2___paren_asgn",_wrap_CvSeq_CvPoint_2___paren_asgn,0,0,2,_wrap_CvSeq_CvPoint_2___paren_asgn_texinfo},
{"CvSeq_CvPoint_2___brace",_wrap_CvSeq_CvPoint_2___brace,0,0,2,_wrap_CvSeq_CvPoint_2___brace_texinfo},
{"CvSeq_CvPoint_2___brace_asgn",_wrap_CvSeq_CvPoint_2___brace_asgn,0,0,2,_wrap_CvSeq_CvPoint_2___brace_asgn_texinfo},
{"CvSeq_CvPoint_2_append",_wrap_CvSeq_CvPoint_2_append,0,0,2,_wrap_CvSeq_CvPoint_2_append_texinfo},
{"CvSeq_CvPoint_2_pop",_wrap_CvSeq_CvPoint_2_pop,0,0,2,_wrap_CvSeq_CvPoint_2_pop_texinfo},
{"new_CvSeq_CvPoint_2",_wrap_new_CvSeq_CvPoint_2,0,0,2,_wrap_new_CvSeq_CvPoint_2_texinfo},
{"delete_CvSeq_CvPoint_2",_wrap_delete_CvSeq_CvPoint_2,0,0,2,_wrap_delete_CvSeq_CvPoint_2_texinfo},
{"CvSeq_float_2_cast",_wrap_CvSeq_float_2_cast,0,0,2,_wrap_CvSeq_float_2_cast_texinfo},
{"CvSeq_float_2___paren",_wrap_CvSeq_float_2___paren,0,0,2,_wrap_CvSeq_float_2___paren_texinfo},
{"CvSeq_float_2___paren_asgn",_wrap_CvSeq_float_2___paren_asgn,0,0,2,_wrap_CvSeq_float_2___paren_asgn_texinfo},
{"CvSeq_float_2___brace",_wrap_CvSeq_float_2___brace,0,0,2,_wrap_CvSeq_float_2___brace_texinfo},
{"CvSeq_float_2___brace_asgn",_wrap_CvSeq_float_2___brace_asgn,0,0,2,_wrap_CvSeq_float_2___brace_asgn_texinfo},
{"CvSeq_float_2_append",_wrap_CvSeq_float_2_append,0,0,2,_wrap_CvSeq_float_2_append_texinfo},
{"CvSeq_float_2_pop",_wrap_CvSeq_float_2_pop,0,0,2,_wrap_CvSeq_float_2_pop_texinfo},
{"new_CvSeq_float_2",_wrap_new_CvSeq_float_2,0,0,2,_wrap_new_CvSeq_float_2_texinfo},
{"delete_CvSeq_float_2",_wrap_delete_CvSeq_float_2,0,0,2,_wrap_delete_CvSeq_float_2_texinfo},
{"CvSeq_float_3_cast",_wrap_CvSeq_float_3_cast,0,0,2,_wrap_CvSeq_float_3_cast_texinfo},
{"CvSeq_float_3___paren",_wrap_CvSeq_float_3___paren,0,0,2,_wrap_CvSeq_float_3___paren_texinfo},
{"CvSeq_float_3___paren_asgn",_wrap_CvSeq_float_3___paren_asgn,0,0,2,_wrap_CvSeq_float_3___paren_asgn_texinfo},
{"CvSeq_float_3___brace",_wrap_CvSeq_float_3___brace,0,0,2,_wrap_CvSeq_float_3___brace_texinfo},
{"CvSeq_float_3___brace_asgn",_wrap_CvSeq_float_3___brace_asgn,0,0,2,_wrap_CvSeq_float_3___brace_asgn_texinfo},
{"CvSeq_float_3_append",_wrap_CvSeq_float_3_append,0,0,2,_wrap_CvSeq_float_3_append_texinfo},
{"CvSeq_float_3_pop",_wrap_CvSeq_float_3_pop,0,0,2,_wrap_CvSeq_float_3_pop_texinfo},
{"new_CvSeq_float_3",_wrap_new_CvSeq_float_3,0,0,2,_wrap_new_CvSeq_float_3_texinfo},
{"delete_CvSeq_float_3",_wrap_delete_CvSeq_float_3,0,0,2,_wrap_delete_CvSeq_float_3_texinfo},
{0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_tTo_p_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq **)  ((CvTypedSeq< CvTuple< CvPoint,2 > > **) x));
}
static void *_p_p_CvTypedSeqT_CvTupleT_float_2_t_tTo_p_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq **)  ((CvTypedSeq< CvTuple< float,2 > > **) x));
}
static void *_p_p_CvTypedSeqT_CvConnectedComp_tTo_p_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq **)  ((CvTypedSeq< CvConnectedComp > **) x));
}
static void *_p_p_CvTypedSeqT_CvRect_tTo_p_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq **)  ((CvTypedSeq< CvRect > **) x));
}
static void *_p_p_CvTypedSeqT_CvPoint_tTo_p_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq **)  ((CvTypedSeq< CvPoint > **) x));
}
static void *_p_p_CvTypedSeqT_CvTupleT_float_3_t_tTo_p_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq **)  ((CvTypedSeq< CvTuple< float,3 > > **) x));
}
static void *_p_p_CvTypedSeqT_CvSeq_p_tTo_p_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq **)  ((CvTypedSeq< CvSeq * > **) x));
}
static void *_p_p_CvTypedSeqT_CvQuadEdge2D_tTo_p_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq **)  ((CvTypedSeq< CvQuadEdge2D > **) x));
}
static void *_p_p_CvTypedSeqT_CvPoint2D32f_tTo_p_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq **)  ((CvTypedSeq< CvPoint2D32f > **) x));
}
static void *_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_tTo_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq *)  ((CvTypedSeq< CvTuple< CvPoint,2 > > *) x));
}
static void *_p_CvTypedSeqT_CvTupleT_float_2_t_tTo_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq *)  ((CvTypedSeq< CvTuple< float,2 > > *) x));
}
static void *_p_CvTypedSeqT_CvConnectedComp_tTo_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq *)  ((CvTypedSeq< CvConnectedComp > *) x));
}
static void *_p_CvTypedSeqT_CvRect_tTo_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq *)  ((CvTypedSeq< CvRect > *) x));
}
static void *_p_CvTypedSeqT_CvPoint_tTo_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq *)  ((CvTypedSeq< CvPoint > *) x));
}
static void *_p_CvTypedSeqT_CvTupleT_float_3_t_tTo_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq *)  ((CvTypedSeq< CvTuple< float,3 > > *) x));
}
static void *_p_CvTypedSeqT_CvSeq_p_tTo_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq *)  ((CvTypedSeq< CvSeq * > *) x));
}
static void *_p_CvTypedSeqT_CvQuadEdge2D_tTo_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq *)  ((CvTypedSeq< CvQuadEdge2D > *) x));
}
static void *_p_CvTypedSeqT_CvPoint2D32f_tTo_p_CvSeq(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((CvSeq *)  ((CvTypedSeq< CvPoint2D32f > *) x));
}
static swig_type_info _swigt__p_Cv32suf = {"_p_Cv32suf", "Cv32suf *", 0, 0, (void*)&_wrap_class_Cv32suf, 0};
static swig_type_info _swigt__p_Cv64suf = {"_p_Cv64suf", "Cv64suf *", 0, 0, (void*)&_wrap_class_Cv64suf, 0};
static swig_type_info _swigt__p_CvAttrList = {"_p_CvAttrList", "CvAttrList *", 0, 0, (void*)&_wrap_class_CvAttrList, 0};
static swig_type_info _swigt__p_CvAvgComp = {"_p_CvAvgComp", "CvAvgComp *", 0, 0, (void*)&_wrap_class_CvAvgComp, 0};
static swig_type_info _swigt__p_CvBox2D = {"_p_CvBox2D", "CvBox2D *", 0, 0, (void*)&_wrap_class_CvBox2D, 0};
static swig_type_info _swigt__p_CvChain = {"_p_CvChain", "CvChain *", 0, 0, (void*)&_wrap_class_CvChain, 0};
static swig_type_info _swigt__p_CvChainPtReader = {"_p_CvChainPtReader", "CvChainPtReader *", 0, 0, (void*)&_wrap_class_CvChainPtReader, 0};
static swig_type_info _swigt__p_CvConDensation = {"_p_CvConDensation", "CvConDensation *", 0, 0, (void*)&_wrap_class_CvConDensation, 0};
static swig_type_info _swigt__p_CvConnectedComp = {"_p_CvConnectedComp", "CvConnectedComp *", 0, 0, (void*)&_wrap_class_CvConnectedComp, 0};
static swig_type_info _swigt__p_CvContour = {"_p_CvContour", "CvPoint2DSeq *|CvContour *", 0, 0, (void*)&_wrap_class_CvContour, 0};
static swig_type_info _swigt__p_CvContourTree = {"_p_CvContourTree", "CvContourTree *", 0, 0, (void*)&_wrap_class_CvContourTree, 0};
static swig_type_info _swigt__p_CvConvexityDefect = {"_p_CvConvexityDefect", "CvConvexityDefect *", 0, 0, (void*)&_wrap_class_CvConvexityDefect, 0};
static swig_type_info _swigt__p_CvFeatureTree = {"_p_CvFeatureTree", "CvFeatureTree *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CvFileNode = {"_p_CvFileNode", "CvFileNode *", 0, 0, (void*)&_wrap_class_CvFileNode, 0};
static swig_type_info _swigt__p_CvFileNode_data = {"_p_CvFileNode_data", "CvFileNode_data *", 0, 0, (void*)&_wrap_class_CvFileNode_data, 0};
static swig_type_info _swigt__p_CvFileStorage = {"_p_CvFileStorage", "CvFileStorage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CvFilter = {"_p_CvFilter", "enum CvFilter *|CvFilter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CvFont = {"_p_CvFont", "CvFont *", 0, 0, (void*)&_wrap_class_CvFont, 0};
static swig_type_info _swigt__p_CvGenericHash = {"_p_CvGenericHash", "CvGenericHash *|CvFileNodeHash *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CvGraph = {"_p_CvGraph", "CvGraph *", 0, 0, (void*)&_wrap_class_CvGraph, 0};
static swig_type_info _swigt__p_CvGraphEdge = {"_p_CvGraphEdge", "CvGraphEdge *", 0, 0, (void*)&_wrap_class_CvGraphEdge, 0};
static swig_type_info _swigt__p_CvGraphScanner = {"_p_CvGraphScanner", "CvGraphScanner *", 0, 0, (void*)&_wrap_class_CvGraphScanner, 0};
static swig_type_info _swigt__p_CvGraphVtx = {"_p_CvGraphVtx", "CvGraphVtx *", 0, 0, (void*)&_wrap_class_CvGraphVtx, 0};
static swig_type_info _swigt__p_CvGraphVtx2D = {"_p_CvGraphVtx2D", "CvGraphVtx2D *", 0, 0, (void*)&_wrap_class_CvGraphVtx2D, 0};
static swig_type_info _swigt__p_CvHaarClassifier = {"_p_CvHaarClassifier", "CvHaarClassifier *", 0, 0, (void*)&_wrap_class_CvHaarClassifier, 0};
static swig_type_info _swigt__p_CvHaarClassifierCascade = {"_p_CvHaarClassifierCascade", "CvHaarClassifierCascade *", 0, 0, (void*)&_wrap_class_CvHaarClassifierCascade, 0};
static swig_type_info _swigt__p_CvHaarFeature = {"_p_CvHaarFeature", "CvHaarFeature *", 0, 0, (void*)&_wrap_class_CvHaarFeature, 0};
static swig_type_info _swigt__p_CvHaarFeature_rect = {"_p_CvHaarFeature_rect", "CvHaarFeature_rect *", 0, 0, (void*)&_wrap_class_CvHaarFeature_rect, 0};
static swig_type_info _swigt__p_CvHaarStageClassifier = {"_p_CvHaarStageClassifier", "CvHaarStageClassifier *", 0, 0, (void*)&_wrap_class_CvHaarStageClassifier, 0};
static swig_type_info _swigt__p_CvHidHaarClassifierCascade = {"_p_CvHidHaarClassifierCascade", "CvHidHaarClassifierCascade *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CvHistogram = {"_p_CvHistogram", "CvHistogram *", 0, 0, (void*)&_wrap_class_CvHistogram, 0};
static swig_type_info _swigt__p_CvHuMoments = {"_p_CvHuMoments", "CvHuMoments *", 0, 0, (void*)&_wrap_class_CvHuMoments, 0};
static swig_type_info _swigt__p_CvImage = {"_p_CvImage", "CvImage *", 0, 0, (void*)&_wrap_class_CvImage, 0};
static swig_type_info _swigt__p_CvKalman = {"_p_CvKalman", "CvKalman *", 0, 0, (void*)&_wrap_class_CvKalman, 0};
static swig_type_info _swigt__p_CvLSH = {"_p_CvLSH", "CvLSH *", 0, 0, (void*)&_wrap_class_CvLSH, 0};
static swig_type_info _swigt__p_CvLSHOperations = {"_p_CvLSHOperations", "CvLSHOperations *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CvLineIterator = {"_p_CvLineIterator", "CvLineIterator *", 0, 0, (void*)&_wrap_class_CvLineIterator, 0};
static swig_type_info _swigt__p_CvMSERParams = {"_p_CvMSERParams", "CvMSERParams *", 0, 0, (void*)&_wrap_class_CvMSERParams, 0};
static swig_type_info _swigt__p_CvMat = {"_p_CvMat", "CvMat *", 0, 0, (void*)&_wrap_class_CvMat, 0};
static swig_type_info _swigt__p_CvMatND = {"_p_CvMatND", "CvMatND *", 0, 0, (void*)&_wrap_class_CvMatND, 0};
static swig_type_info _swigt__p_CvMatND_data = {"_p_CvMatND_data", "CvMatND_data *", 0, 0, (void*)&_wrap_class_CvMatND_data, 0};
static swig_type_info _swigt__p_CvMatND_dim = {"_p_CvMatND_dim", "CvMatND_dim *", 0, 0, (void*)&_wrap_class_CvMatND_dim, 0};
static swig_type_info _swigt__p_CvMat_data = {"_p_CvMat_data", "CvMat_data *", 0, 0, (void*)&_wrap_class_CvMat_data, 0};
static swig_type_info _swigt__p_CvMatrix = {"_p_CvMatrix", "CvMatrix *", 0, 0, (void*)&_wrap_class_CvMatrix, 0};
static swig_type_info _swigt__p_CvMatrix3 = {"_p_CvMatrix3", "CvMatrix3 *", 0, 0, (void*)&_wrap_class_CvMatrix3, 0};
static swig_type_info _swigt__p_CvMemBlock = {"_p_CvMemBlock", "CvMemBlock *", 0, 0, (void*)&_wrap_class_CvMemBlock, 0};
static swig_type_info _swigt__p_CvMemStorage = {"_p_CvMemStorage", "CvMemStorage *", 0, 0, (void*)&_wrap_class_CvMemStorage, 0};
static swig_type_info _swigt__p_CvMemStoragePos = {"_p_CvMemStoragePos", "CvMemStoragePos *", 0, 0, (void*)&_wrap_class_CvMemStoragePos, 0};
static swig_type_info _swigt__p_CvModule = {"_p_CvModule", "CvModule *", 0, 0, (void*)&_wrap_class_CvModule, 0};
static swig_type_info _swigt__p_CvModuleInfo = {"_p_CvModuleInfo", "CvModuleInfo *", 0, 0, (void*)&_wrap_class_CvModuleInfo, 0};
static swig_type_info _swigt__p_CvMoments = {"_p_CvMoments", "CvMoments *", 0, 0, (void*)&_wrap_class_CvMoments, 0};
static swig_type_info _swigt__p_CvNArrayIterator = {"_p_CvNArrayIterator", "CvNArrayIterator *", 0, 0, (void*)&_wrap_class_CvNArrayIterator, 0};
static swig_type_info _swigt__p_CvNextEdgeType = {"_p_CvNextEdgeType", "enum CvNextEdgeType *|CvNextEdgeType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CvPOSITObject = {"_p_CvPOSITObject", "CvPOSITObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CvPluginFuncInfo = {"_p_CvPluginFuncInfo", "CvPluginFuncInfo *", 0, 0, (void*)&_wrap_class_CvPluginFuncInfo, 0};
static swig_type_info _swigt__p_CvPoint = {"_p_CvPoint", "CvPoint *", 0, 0, (void*)&_wrap_class_CvPoint, 0};
static swig_type_info _swigt__p_CvPoint2D32f = {"_p_CvPoint2D32f", "CvPoint2D32f *", 0, 0, (void*)&_wrap_class_CvPoint2D32f, 0};
static swig_type_info _swigt__p_CvPoint2D64f = {"_p_CvPoint2D64f", "CvPoint2D64f *", 0, 0, (void*)&_wrap_class_CvPoint2D64f, 0};
static swig_type_info _swigt__p_CvPoint3D32f = {"_p_CvPoint3D32f", "CvPoint3D32f *", 0, 0, (void*)&_wrap_class_CvPoint3D32f, 0};
static swig_type_info _swigt__p_CvPoint3D64f = {"_p_CvPoint3D64f", "CvPoint3D64f *", 0, 0, (void*)&_wrap_class_CvPoint3D64f, 0};
static swig_type_info _swigt__p_CvQuadEdge2D = {"_p_CvQuadEdge2D", "CvQuadEdge2D *", 0, 0, (void*)&_wrap_class_CvQuadEdge2D, 0};
static swig_type_info _swigt__p_CvRNG_Wrapper = {"_p_CvRNG_Wrapper", "CvRNG_Wrapper *", 0, 0, (void*)&_wrap_class_CvRNG_Wrapper, 0};
static swig_type_info _swigt__p_CvRandState = {"_p_CvRandState", "CvRandState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CvRect = {"_p_CvRect", "CvRect *", 0, 0, (void*)&_wrap_class_CvRect, 0};
static swig_type_info _swigt__p_CvSURFParams = {"_p_CvSURFParams", "CvSURFParams *", 0, 0, (void*)&_wrap_class_CvSURFParams, 0};
static swig_type_info _swigt__p_CvSURFPoint = {"_p_CvSURFPoint", "CvSURFPoint *", 0, 0, (void*)&_wrap_class_CvSURFPoint, 0};
static swig_type_info _swigt__p_CvScalar = {"_p_CvScalar", "CvScalar *", 0, 0, (void*)&_wrap_class_CvScalar, 0};
static swig_type_info _swigt__p_CvSeq = {"_p_CvSeq", "CvSeq *", 0, 0, (void*)&_wrap_class_CvSeq, 0};
static swig_type_info _swigt__p_CvSeqBlock = {"_p_CvSeqBlock", "CvSeqBlock *", 0, 0, (void*)&_wrap_class_CvSeqBlock, 0};
static swig_type_info _swigt__p_CvSeqReader = {"_p_CvSeqReader", "CvSeqReader *", 0, 0, (void*)&_wrap_class_CvSeqReader, 0};
static swig_type_info _swigt__p_CvSeqWriter = {"_p_CvSeqWriter", "CvSeqWriter *", 0, 0, (void*)&_wrap_class_CvSeqWriter, 0};
static swig_type_info _swigt__p_CvSet = {"_p_CvSet", "CvSet *", 0, 0, (void*)&_wrap_class_CvSet, 0};
static swig_type_info _swigt__p_CvSetElem = {"_p_CvSetElem", "CvSetElem *", 0, 0, (void*)&_wrap_class_CvSetElem, 0};
static swig_type_info _swigt__p_CvSize = {"_p_CvSize", "CvSize *", 0, 0, (void*)&_wrap_class_CvSize, 0};
static swig_type_info _swigt__p_CvSize2D32f = {"_p_CvSize2D32f", "CvSize2D32f *", 0, 0, (void*)&_wrap_class_CvSize2D32f, 0};
static swig_type_info _swigt__p_CvSlice = {"_p_CvSlice", "CvSlice *", 0, 0, (void*)&_wrap_class_CvSlice, 0};
static swig_type_info _swigt__p_CvSparseMat = {"_p_CvSparseMat", "CvSparseMat *", 0, 0, (void*)&_wrap_class_CvSparseMat, 0};
static swig_type_info _swigt__p_CvSparseMatIterator = {"_p_CvSparseMatIterator", "CvSparseMatIterator *", 0, 0, (void*)&_wrap_class_CvSparseMatIterator, 0};
static swig_type_info _swigt__p_CvSparseNode = {"_p_CvSparseNode", "CvSparseNode *", 0, 0, (void*)&_wrap_class_CvSparseNode, 0};
static swig_type_info _swigt__p_CvStarDetectorParams = {"_p_CvStarDetectorParams", "CvStarDetectorParams *", 0, 0, (void*)&_wrap_class_CvStarDetectorParams, 0};
static swig_type_info _swigt__p_CvStarKeypoint = {"_p_CvStarKeypoint", "CvStarKeypoint *", 0, 0, (void*)&_wrap_class_CvStarKeypoint, 0};
static swig_type_info _swigt__p_CvStereoBMState = {"_p_CvStereoBMState", "CvStereoBMState *", 0, 0, (void*)&_wrap_class_CvStereoBMState, 0};
static swig_type_info _swigt__p_CvStereoGCState = {"_p_CvStereoGCState", "CvStereoGCState *", 0, 0, (void*)&_wrap_class_CvStereoGCState, 0};
static swig_type_info _swigt__p_CvString = {"_p_CvString", "CvString *", 0, 0, (void*)&_wrap_class_CvString, 0};
static swig_type_info _swigt__p_CvStringHashNode = {"_p_CvStringHashNode", "CvStringHashNode *", 0, 0, (void*)&_wrap_class_CvStringHashNode, 0};
static swig_type_info _swigt__p_CvSubdiv2D = {"_p_CvSubdiv2D", "CvSubdiv2D *", 0, 0, (void*)&_wrap_class_CvSubdiv2D, 0};
static swig_type_info _swigt__p_CvSubdiv2DEdge_Wrapper = {"_p_CvSubdiv2DEdge_Wrapper", "CvSubdiv2DEdge_Wrapper *", 0, 0, (void*)&_wrap_class_CvSubdiv2DEdge_Wrapper, 0};
static swig_type_info _swigt__p_CvSubdiv2DPoint = {"_p_CvSubdiv2DPoint", "CvSubdiv2DPoint *", 0, 0, (void*)&_wrap_class_CvSubdiv2DPoint, 0};
static swig_type_info _swigt__p_CvSubdiv2DPointLocation = {"_p_CvSubdiv2DPointLocation", "enum CvSubdiv2DPointLocation *|CvSubdiv2DPointLocation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CvTermCriteria = {"_p_CvTermCriteria", "CvTermCriteria *", 0, 0, (void*)&_wrap_class_CvTermCriteria, 0};
static swig_type_info _swigt__p_CvTreeNodeIterator = {"_p_CvTreeNodeIterator", "CvTreeNodeIterator *", 0, 0, (void*)&_wrap_class_CvTreeNodeIterator, 0};
static swig_type_info _swigt__p_CvTupleT_CvPoint_2_t = {"_p_CvTupleT_CvPoint_2_t", "CvTuple< CvPoint,2 > *", 0, 0, (void*)&_wrap_class_CvTuple_CvPoint_2, 0};
static swig_type_info _swigt__p_CvTupleT_float_2_t = {"_p_CvTupleT_float_2_t", "CvTuple< float,2 > *", 0, 0, (void*)&_wrap_class_CvTuple_float_2, 0};
static swig_type_info _swigt__p_CvTupleT_float_3_t = {"_p_CvTupleT_float_3_t", "CvTuple< float,3 > *", 0, 0, (void*)&_wrap_class_CvTuple_float_3, 0};
static swig_type_info _swigt__p_CvType = {"_p_CvType", "CvType *", 0, 0, (void*)&_wrap_class_CvType, 0};
static swig_type_info _swigt__p_CvTypeInfo = {"_p_CvTypeInfo", "CvTypeInfo *", 0, 0, (void*)&_wrap_class_CvTypeInfo, 0};
static swig_type_info _swigt__p_CvTypedSeqT_CvConnectedComp_t = {"_p_CvTypedSeqT_CvConnectedComp_t", "CvTypedSeq< CvConnectedComp > *", 0, 0, (void*)&_wrap_class_CvSeq_CvConnectedComp, 0};
static swig_type_info _swigt__p_CvTypedSeqT_CvPoint2D32f_t = {"_p_CvTypedSeqT_CvPoint2D32f_t", "CvTypedSeq< CvPoint2D32f > *", 0, 0, (void*)&_wrap_class_CvSeq_CvPoint2D32f, 0};
static swig_type_info _swigt__p_CvTypedSeqT_CvPoint_t = {"_p_CvTypedSeqT_CvPoint_t", "CvTypedSeq< CvPoint > *", 0, 0, (void*)&_wrap_class_CvSeq_CvPoint, 0};
static swig_type_info _swigt__p_CvTypedSeqT_CvQuadEdge2D_t = {"_p_CvTypedSeqT_CvQuadEdge2D_t", "CvTypedSeq< CvQuadEdge2D > *", 0, 0, (void*)&_wrap_class_CvSeq_CvQuadEdge2D, 0};
static swig_type_info _swigt__p_CvTypedSeqT_CvRect_t = {"_p_CvTypedSeqT_CvRect_t", "CvTypedSeq< CvRect > *", 0, 0, (void*)&_wrap_class_CvSeq_CvRect, 0};
static swig_type_info _swigt__p_CvTypedSeqT_CvSeq_p_t = {"_p_CvTypedSeqT_CvSeq_p_t", "CvTypedSeq< CvSeq * > *", 0, 0, (void*)&_wrap_class_CvSeq_CvSeq, 0};
static swig_type_info _swigt__p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t = {"_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t", "CvTypedSeq< CvTuple< CvPoint,2 > > *", 0, 0, (void*)&_wrap_class_CvSeq_CvPoint_2, 0};
static swig_type_info _swigt__p_CvTypedSeqT_CvTupleT_float_2_t_t = {"_p_CvTypedSeqT_CvTupleT_float_2_t_t", "CvTypedSeq< CvTuple< float,2 > > *", 0, 0, (void*)&_wrap_class_CvSeq_float_2, 0};
static swig_type_info _swigt__p_CvTypedSeqT_CvTupleT_float_3_t_t = {"_p_CvTypedSeqT_CvTupleT_float_3_t_t", "CvTypedSeq< CvTuple< float,3 > > *", 0, 0, (void*)&_wrap_class_CvSeq_float_3, 0};
static swig_type_info _swigt__p__CvContourScanner = {"_p__CvContourScanner", "_CvContourScanner *|CvContourScanner", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__IplConvKernel = {"_p__IplConvKernel", "_IplConvKernel *|IplConvKernel *", 0, 0, (void*)&_wrap_class_IplConvKernel, 0};
static swig_type_info _swigt__p__IplConvKernelFP = {"_p__IplConvKernelFP", "_IplConvKernelFP *|IplConvKernelFP *", 0, 0, (void*)&_wrap_class_IplConvKernelFP, 0};
static swig_type_info _swigt__p__IplImage = {"_p__IplImage", "_IplImage *|IplImage *", 0, 0, (void*)&_wrap_class_IplImage, 0};
static swig_type_info _swigt__p__IplROI = {"_p__IplROI", "_IplROI *|IplROI *", 0, 0, (void*)&_wrap_class_IplROI, 0};
static swig_type_info _swigt__p__IplTileInfo = {"_p__IplTileInfo", "_IplTileInfo *|IplTileInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_2__float = {"_p_a_2__float", "float (*)[2]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_2__signed_char = {"_p_a_2__signed_char", "signed char (*)[2]|schar (*)[2]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_3__float = {"_p_a_3__float", "float (*)[3]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_int_int_int_int_int__p__IplROI = {"_p_f_int_int_int_int_int__p__IplROI", "Cv_iplCreateROI|_IplROI *(*)(int,int,int,int,int)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_int_int_int_p_char_p_char_int_int_int_int_int_p_IplROI_p_IplImage_p_void_p_IplTileInfo__p__IplImage = {"_p_f_int_int_int_p_char_p_char_int_int_int_int_int_p_IplROI_p_IplImage_p_void_p_IplTileInfo__p__IplImage", "_IplImage *(*)(int,int,int,char *,char *,int,int,int,int,int,IplROI *,IplImage *,void *,IplTileInfo *)|Cv_iplCreateImageHeader", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_int_p_q_const__char_p_q_const__char_p_q_const__char_int_p_void__int = {"_p_f_int_p_q_const__char_p_q_const__char_p_q_const__char_int_p_void__int", "int (*)(int,char const *,char const *,char const *,int,void *)|CvErrorCallback", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_CvFileStorage_p_CvFileNode__p_void = {"_p_f_p_CvFileStorage_p_CvFileNode__p_void", "void *(*)(CvFileStorage *,CvFileNode *)|CvReadFunc", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void = {"_p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void", "void (*)(CvFileStorage *,char const *,void const *,CvAttrList)|CvWriteFunc", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p__IplImage_int__void = {"_p_f_p__IplImage_int__void", "Cv_iplDeallocate|void (*)(_IplImage *,int)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p__IplImage_int_int__void = {"_p_f_p__IplImage_int_int__void", "Cv_iplAllocateImageData|void (*)(_IplImage *,int,int)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_p_void__void = {"_p_f_p_p_void__void", "void (*)(void **)|CvReleaseFunc", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__IplImage__p__IplImage = {"_p_f_p_q_const__IplImage__p__IplImage", "_IplImage *(*)(IplImage const *)|Cv_iplCloneImage", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__char_int__p_CvMat = {"_p_f_p_q_const__char_int__p_CvMat", "CvMat *(*)(char const *,int)|CvLoadImageMFunc", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__char_int__p__IplImage = {"_p_f_p_q_const__char_int__p__IplImage", "CvLoadImageFunc|_IplImage *(*)(char const *,int)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__char_p_q_const__void__void = {"_p_f_p_q_const__char_p_q_const__void__void", "CvShowImageFunc|void (*)(char const *,void const *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__char_p_q_const__void_p_q_const__int__int = {"_p_f_p_q_const__char_p_q_const__void_p_q_const__int__int", "CvSaveImageFunc|int (*)(char const *,void const *,int const *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__float_p_q_const__float_p_void__float = {"_p_f_p_q_const__float_p_q_const__float_p_void__float", "CvDistanceFunction|float (*)(float const *,float const *,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__void__int = {"_p_f_p_q_const__void__int", "CvIsInstanceFunc|int (*)(void const *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__void__p_void = {"_p_f_p_q_const__void__p_void", "CvCloneFunc|void *(*)(void const *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_q_const__void_p_q_const__void_p_void__int = {"_p_f_p_q_const__void_p_q_const__void_p_void__int", "CvCmpFunc|int (*)(void const *,void const *,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_void__int = {"_p_f_p_void_p_void__int", "int (*)(void *,void *)|CvFreeFunc", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_size_t_p_void__p_void = {"_p_f_size_t_p_void__p_void", "CvAllocFunc|void *(*)(size_t,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *|CvVect32f|CvMatr32f", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "CvHistType *|int *|CVStatus *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int64_t = {"_p_int64_t", "int64_t *|int64 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvConDensation = {"_p_p_CvConDensation", "CvConDensation **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvFileStorage = {"_p_p_CvFileStorage", "CvFileStorage **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvGraphEdge = {"_p_p_CvGraphEdge", "CvGraphEdge **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvGraphScanner = {"_p_p_CvGraphScanner", "CvGraphScanner **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvGraphVtx = {"_p_p_CvGraphVtx", "CvGraphVtx **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvHaarClassifierCascade = {"_p_p_CvHaarClassifierCascade", "CvHaarClassifierCascade **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvHistogram = {"_p_p_CvHistogram", "CvHistogram **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvKalman = {"_p_p_CvKalman", "CvKalman **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvLSH = {"_p_p_CvLSH", "CvLSH **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvMat = {"_p_p_CvMat", "CvMat **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvMatND = {"_p_p_CvMatND", "CvMatND **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvMemStorage = {"_p_p_CvMemStorage", "CvMemStorage **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvPOSITObject = {"_p_p_CvPOSITObject", "CvPOSITObject **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvPoint = {"_p_p_CvPoint", "CvPoint **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvSeq = {"_p_p_CvSeq", "CvSeq **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t = {"_p_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_CvTypedSeqT_CvTupleT_float_2_t_t = {"_p_p_CvTypedSeqT_CvTupleT_float_2_t_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_CvTypedSeqT_CvRect_t = {"_p_p_CvTypedSeqT_CvRect_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_CvTypedSeqT_CvPoint_t = {"_p_p_CvTypedSeqT_CvPoint_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_CvTypedSeqT_CvQuadEdge2D_t = {"_p_p_CvTypedSeqT_CvQuadEdge2D_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_CvTypedSeqT_CvSeq_p_t = {"_p_p_CvTypedSeqT_CvSeq_p_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_CvTypedSeqT_CvPoint2D32f_t = {"_p_p_CvTypedSeqT_CvPoint2D32f_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_CvTypedSeqT_CvTupleT_float_3_t_t = {"_p_p_CvTypedSeqT_CvTupleT_float_3_t_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_CvTypedSeqT_CvConnectedComp_t = {"_p_p_CvTypedSeqT_CvConnectedComp_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_CvSeqBlock = {"_p_p_CvSeqBlock", "CvSeqBlock **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvSetElem = {"_p_p_CvSetElem", "CvSetElem **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvSparseMat = {"_p_p_CvSparseMat", "CvSparseMat **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvStereoBMState = {"_p_p_CvStereoBMState", "CvStereoBMState **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvStereoGCState = {"_p_p_CvStereoGCState", "CvStereoGCState **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_CvSubdiv2DPoint = {"_p_p_CvSubdiv2DPoint", "CvSubdiv2DPoint **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p__CvContourScanner = {"_p_p__CvContourScanner", "CvContourScanner *|_CvContourScanner **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p__IplConvKernel = {"_p_p__IplConvKernel", "_IplConvKernel **|IplConvKernel **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p__IplImage = {"_p_p__IplImage", "_IplImage **|IplImage **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_float = {"_p_p_float", "float **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_p_CvMat = {"_p_p_p_CvMat", "CvMat ***", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_unsigned_char = {"_p_p_unsigned_char", "unsigned char **|uchar **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_void = {"_p_p_void", "void **|CvArr **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_short = {"_p_short", "short *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "schar *|signed char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *|CvSubdiv2DEdge *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t = {"_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t", "std::vector< CvPoint,std::allocator< CvPoint > > *|std::vector< CvPoint > *", 0, 0, (void*)&_wrap_class_CvPointVector, 0};
static swig_type_info _swigt__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__allocator_type = {"_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__allocator_type", "std::vector< CvPoint >::allocator_type *|std::allocator< CvPoint > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type = {"_p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type", "std::vector< CvPoint >::value_type *|CvPoint *", 0, 0, (void*)&_wrap_class_CvPoint, 0};
static swig_type_info _swigt__p_std__vectorT_float_std__allocatorT_float_t_t = {"_p_std__vectorT_float_std__allocatorT_float_t_t", "std::vector< float > *|std::vector< float,std::allocator< float > > *", 0, 0, (void*)&_wrap_class_FloatVector, 0};
static swig_type_info _swigt__p_std__vectorT_float_std__allocatorT_float_t_t__allocator_type = {"_p_std__vectorT_float_std__allocatorT_float_t_t__allocator_type", "std::vector< float >::allocator_type *|std::allocator< float > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__OctSwigIterator = {"_p_swig__OctSwigIterator", "swig::OctSwigIterator *", 0, 0, (void*)&_wrap_class_OctSwigIterator, 0};
static swig_type_info _swigt__p_uint64_t = {"_p_uint64_t", "uint64_t *|uint64 *|CvRNG *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "uchar *|unsigned char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "unsigned int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|ushort *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "CvArr *|void *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Cv32suf,
  &_swigt__p_Cv64suf,
  &_swigt__p_CvAttrList,
  &_swigt__p_CvAvgComp,
  &_swigt__p_CvBox2D,
  &_swigt__p_CvChain,
  &_swigt__p_CvChainPtReader,
  &_swigt__p_CvConDensation,
  &_swigt__p_CvConnectedComp,
  &_swigt__p_CvContour,
  &_swigt__p_CvContourTree,
  &_swigt__p_CvConvexityDefect,
  &_swigt__p_CvFeatureTree,
  &_swigt__p_CvFileNode,
  &_swigt__p_CvFileNode_data,
  &_swigt__p_CvFileStorage,
  &_swigt__p_CvFilter,
  &_swigt__p_CvFont,
  &_swigt__p_CvGenericHash,
  &_swigt__p_CvGraph,
  &_swigt__p_CvGraphEdge,
  &_swigt__p_CvGraphScanner,
  &_swigt__p_CvGraphVtx,
  &_swigt__p_CvGraphVtx2D,
  &_swigt__p_CvHaarClassifier,
  &_swigt__p_CvHaarClassifierCascade,
  &_swigt__p_CvHaarFeature,
  &_swigt__p_CvHaarFeature_rect,
  &_swigt__p_CvHaarStageClassifier,
  &_swigt__p_CvHidHaarClassifierCascade,
  &_swigt__p_CvHistogram,
  &_swigt__p_CvHuMoments,
  &_swigt__p_CvImage,
  &_swigt__p_CvKalman,
  &_swigt__p_CvLSH,
  &_swigt__p_CvLSHOperations,
  &_swigt__p_CvLineIterator,
  &_swigt__p_CvMSERParams,
  &_swigt__p_CvMat,
  &_swigt__p_CvMatND,
  &_swigt__p_CvMatND_data,
  &_swigt__p_CvMatND_dim,
  &_swigt__p_CvMat_data,
  &_swigt__p_CvMatrix,
  &_swigt__p_CvMatrix3,
  &_swigt__p_CvMemBlock,
  &_swigt__p_CvMemStorage,
  &_swigt__p_CvMemStoragePos,
  &_swigt__p_CvModule,
  &_swigt__p_CvModuleInfo,
  &_swigt__p_CvMoments,
  &_swigt__p_CvNArrayIterator,
  &_swigt__p_CvNextEdgeType,
  &_swigt__p_CvPOSITObject,
  &_swigt__p_CvPluginFuncInfo,
  &_swigt__p_CvPoint,
  &_swigt__p_CvPoint2D32f,
  &_swigt__p_CvPoint2D64f,
  &_swigt__p_CvPoint3D32f,
  &_swigt__p_CvPoint3D64f,
  &_swigt__p_CvQuadEdge2D,
  &_swigt__p_CvRNG_Wrapper,
  &_swigt__p_CvRandState,
  &_swigt__p_CvRect,
  &_swigt__p_CvSURFParams,
  &_swigt__p_CvSURFPoint,
  &_swigt__p_CvScalar,
  &_swigt__p_CvSeq,
  &_swigt__p_CvSeqBlock,
  &_swigt__p_CvSeqReader,
  &_swigt__p_CvSeqWriter,
  &_swigt__p_CvSet,
  &_swigt__p_CvSetElem,
  &_swigt__p_CvSize,
  &_swigt__p_CvSize2D32f,
  &_swigt__p_CvSlice,
  &_swigt__p_CvSparseMat,
  &_swigt__p_CvSparseMatIterator,
  &_swigt__p_CvSparseNode,
  &_swigt__p_CvStarDetectorParams,
  &_swigt__p_CvStarKeypoint,
  &_swigt__p_CvStereoBMState,
  &_swigt__p_CvStereoGCState,
  &_swigt__p_CvString,
  &_swigt__p_CvStringHashNode,
  &_swigt__p_CvSubdiv2D,
  &_swigt__p_CvSubdiv2DEdge_Wrapper,
  &_swigt__p_CvSubdiv2DPoint,
  &_swigt__p_CvSubdiv2DPointLocation,
  &_swigt__p_CvTermCriteria,
  &_swigt__p_CvTreeNodeIterator,
  &_swigt__p_CvTupleT_CvPoint_2_t,
  &_swigt__p_CvTupleT_float_2_t,
  &_swigt__p_CvTupleT_float_3_t,
  &_swigt__p_CvType,
  &_swigt__p_CvTypeInfo,
  &_swigt__p_CvTypedSeqT_CvConnectedComp_t,
  &_swigt__p_CvTypedSeqT_CvPoint2D32f_t,
  &_swigt__p_CvTypedSeqT_CvPoint_t,
  &_swigt__p_CvTypedSeqT_CvQuadEdge2D_t,
  &_swigt__p_CvTypedSeqT_CvRect_t,
  &_swigt__p_CvTypedSeqT_CvSeq_p_t,
  &_swigt__p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t,
  &_swigt__p_CvTypedSeqT_CvTupleT_float_2_t_t,
  &_swigt__p_CvTypedSeqT_CvTupleT_float_3_t_t,
  &_swigt__p__CvContourScanner,
  &_swigt__p__IplConvKernel,
  &_swigt__p__IplConvKernelFP,
  &_swigt__p__IplImage,
  &_swigt__p__IplROI,
  &_swigt__p__IplTileInfo,
  &_swigt__p_a_2__float,
  &_swigt__p_a_2__signed_char,
  &_swigt__p_a_3__float,
  &_swigt__p_allocator_type,
  &_swigt__p_char,
  &_swigt__p_difference_type,
  &_swigt__p_double,
  &_swigt__p_f_int_int_int_int_int__p__IplROI,
  &_swigt__p_f_int_int_int_p_char_p_char_int_int_int_int_int_p_IplROI_p_IplImage_p_void_p_IplTileInfo__p__IplImage,
  &_swigt__p_f_int_p_q_const__char_p_q_const__char_p_q_const__char_int_p_void__int,
  &_swigt__p_f_p_CvFileStorage_p_CvFileNode__p_void,
  &_swigt__p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void,
  &_swigt__p_f_p__IplImage_int__void,
  &_swigt__p_f_p__IplImage_int_int__void,
  &_swigt__p_f_p_p_void__void,
  &_swigt__p_f_p_q_const__IplImage__p__IplImage,
  &_swigt__p_f_p_q_const__char_int__p_CvMat,
  &_swigt__p_f_p_q_const__char_int__p__IplImage,
  &_swigt__p_f_p_q_const__char_p_q_const__void__void,
  &_swigt__p_f_p_q_const__char_p_q_const__void_p_q_const__int__int,
  &_swigt__p_f_p_q_const__float_p_q_const__float_p_void__float,
  &_swigt__p_f_p_q_const__void__int,
  &_swigt__p_f_p_q_const__void__p_void,
  &_swigt__p_f_p_q_const__void_p_q_const__void_p_void__int,
  &_swigt__p_f_p_void_p_void__int,
  &_swigt__p_f_size_t_p_void__p_void,
  &_swigt__p_float,
  &_swigt__p_int,
  &_swigt__p_int64_t,
  &_swigt__p_p_CvConDensation,
  &_swigt__p_p_CvFileStorage,
  &_swigt__p_p_CvGraphEdge,
  &_swigt__p_p_CvGraphScanner,
  &_swigt__p_p_CvGraphVtx,
  &_swigt__p_p_CvHaarClassifierCascade,
  &_swigt__p_p_CvHistogram,
  &_swigt__p_p_CvKalman,
  &_swigt__p_p_CvLSH,
  &_swigt__p_p_CvMat,
  &_swigt__p_p_CvMatND,
  &_swigt__p_p_CvMemStorage,
  &_swigt__p_p_CvPOSITObject,
  &_swigt__p_p_CvPoint,
  &_swigt__p_p_CvSeq,
  &_swigt__p_p_CvSeqBlock,
  &_swigt__p_p_CvSetElem,
  &_swigt__p_p_CvSparseMat,
  &_swigt__p_p_CvStereoBMState,
  &_swigt__p_p_CvStereoGCState,
  &_swigt__p_p_CvSubdiv2DPoint,
  &_swigt__p_p_CvTypedSeqT_CvConnectedComp_t,
  &_swigt__p_p_CvTypedSeqT_CvPoint2D32f_t,
  &_swigt__p_p_CvTypedSeqT_CvPoint_t,
  &_swigt__p_p_CvTypedSeqT_CvQuadEdge2D_t,
  &_swigt__p_p_CvTypedSeqT_CvRect_t,
  &_swigt__p_p_CvTypedSeqT_CvSeq_p_t,
  &_swigt__p_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t,
  &_swigt__p_p_CvTypedSeqT_CvTupleT_float_2_t_t,
  &_swigt__p_p_CvTypedSeqT_CvTupleT_float_3_t_t,
  &_swigt__p_p__CvContourScanner,
  &_swigt__p_p__IplConvKernel,
  &_swigt__p_p__IplImage,
  &_swigt__p_p_char,
  &_swigt__p_p_float,
  &_swigt__p_p_p_CvMat,
  &_swigt__p_p_unsigned_char,
  &_swigt__p_p_void,
  &_swigt__p_short,
  &_swigt__p_signed_char,
  &_swigt__p_size_t,
  &_swigt__p_size_type,
  &_swigt__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t,
  &_swigt__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__allocator_type,
  &_swigt__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type,
  &_swigt__p_std__vectorT_float_std__allocatorT_float_t_t,
  &_swigt__p_std__vectorT_float_std__allocatorT_float_t_t__allocator_type,
  &_swigt__p_swig__OctSwigIterator,
  &_swigt__p_uint64_t,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_short,
  &_swigt__p_value_type,
  &_swigt__p_void,
};

static swig_cast_info _swigc__p_Cv32suf[] = {  {&_swigt__p_Cv32suf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Cv64suf[] = {  {&_swigt__p_Cv64suf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvAttrList[] = {  {&_swigt__p_CvAttrList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvAvgComp[] = {  {&_swigt__p_CvAvgComp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvBox2D[] = {  {&_swigt__p_CvBox2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvChain[] = {  {&_swigt__p_CvChain, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvChainPtReader[] = {  {&_swigt__p_CvChainPtReader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvConDensation[] = {  {&_swigt__p_CvConDensation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvConnectedComp[] = {  {&_swigt__p_CvConnectedComp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvContour[] = {  {&_swigt__p_CvContour, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvContourTree[] = {  {&_swigt__p_CvContourTree, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvConvexityDefect[] = {  {&_swigt__p_CvConvexityDefect, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvFeatureTree[] = {  {&_swigt__p_CvFeatureTree, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvFileNode[] = {  {&_swigt__p_CvFileNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvFileNode_data[] = {  {&_swigt__p_CvFileNode_data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvFileStorage[] = {  {&_swigt__p_CvFileStorage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvFilter[] = {  {&_swigt__p_CvFilter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvFont[] = {  {&_swigt__p_CvFont, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvGenericHash[] = {  {&_swigt__p_CvGenericHash, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvGraph[] = {  {&_swigt__p_CvGraph, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvGraphEdge[] = {  {&_swigt__p_CvGraphEdge, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvGraphScanner[] = {  {&_swigt__p_CvGraphScanner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvGraphVtx[] = {  {&_swigt__p_CvGraphVtx, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvGraphVtx2D[] = {  {&_swigt__p_CvGraphVtx2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvHaarClassifier[] = {  {&_swigt__p_CvHaarClassifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvHaarClassifierCascade[] = {  {&_swigt__p_CvHaarClassifierCascade, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvHaarFeature[] = {  {&_swigt__p_CvHaarFeature, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvHaarFeature_rect[] = {  {&_swigt__p_CvHaarFeature_rect, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvHaarStageClassifier[] = {  {&_swigt__p_CvHaarStageClassifier, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvHidHaarClassifierCascade[] = {  {&_swigt__p_CvHidHaarClassifierCascade, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvHistogram[] = {  {&_swigt__p_CvHistogram, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvHuMoments[] = {  {&_swigt__p_CvHuMoments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvImage[] = {  {&_swigt__p_CvImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvKalman[] = {  {&_swigt__p_CvKalman, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvLSH[] = {  {&_swigt__p_CvLSH, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvLSHOperations[] = {  {&_swigt__p_CvLSHOperations, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvLineIterator[] = {  {&_swigt__p_CvLineIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMSERParams[] = {  {&_swigt__p_CvMSERParams, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMat[] = {  {&_swigt__p_CvMat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMatND[] = {  {&_swigt__p_CvMatND, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMatND_data[] = {  {&_swigt__p_CvMatND_data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMatND_dim[] = {  {&_swigt__p_CvMatND_dim, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMat_data[] = {  {&_swigt__p_CvMat_data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMatrix[] = {  {&_swigt__p_CvMatrix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMatrix3[] = {  {&_swigt__p_CvMatrix3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMemBlock[] = {  {&_swigt__p_CvMemBlock, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMemStorage[] = {  {&_swigt__p_CvMemStorage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMemStoragePos[] = {  {&_swigt__p_CvMemStoragePos, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvModule[] = {  {&_swigt__p_CvModule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvModuleInfo[] = {  {&_swigt__p_CvModuleInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvMoments[] = {  {&_swigt__p_CvMoments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvNArrayIterator[] = {  {&_swigt__p_CvNArrayIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvNextEdgeType[] = {  {&_swigt__p_CvNextEdgeType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvPOSITObject[] = {  {&_swigt__p_CvPOSITObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvPluginFuncInfo[] = {  {&_swigt__p_CvPluginFuncInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvPoint[] = {  {&_swigt__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type, 0, 0, 0},  {&_swigt__p_CvPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvPoint2D32f[] = {  {&_swigt__p_CvPoint2D32f, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvPoint2D64f[] = {  {&_swigt__p_CvPoint2D64f, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvPoint3D32f[] = {  {&_swigt__p_CvPoint3D32f, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvPoint3D64f[] = {  {&_swigt__p_CvPoint3D64f, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvQuadEdge2D[] = {  {&_swigt__p_CvQuadEdge2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvRNG_Wrapper[] = {  {&_swigt__p_CvRNG_Wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvRandState[] = {  {&_swigt__p_CvRandState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvRect[] = {  {&_swigt__p_CvRect, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSURFParams[] = {  {&_swigt__p_CvSURFParams, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSURFPoint[] = {  {&_swigt__p_CvSURFPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvScalar[] = {  {&_swigt__p_CvScalar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSeq[] = {  {&_swigt__p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, _p_CvTypedSeqT_CvTupleT_CvPoint_2_t_tTo_p_CvSeq, 0, 0},  {&_swigt__p_CvTypedSeqT_CvTupleT_float_2_t_t, _p_CvTypedSeqT_CvTupleT_float_2_t_tTo_p_CvSeq, 0, 0},  {&_swigt__p_CvTypedSeqT_CvRect_t, _p_CvTypedSeqT_CvRect_tTo_p_CvSeq, 0, 0},  {&_swigt__p_CvTypedSeqT_CvPoint_t, _p_CvTypedSeqT_CvPoint_tTo_p_CvSeq, 0, 0},  {&_swigt__p_CvTypedSeqT_CvQuadEdge2D_t, _p_CvTypedSeqT_CvQuadEdge2D_tTo_p_CvSeq, 0, 0},  {&_swigt__p_CvTypedSeqT_CvSeq_p_t, _p_CvTypedSeqT_CvSeq_p_tTo_p_CvSeq, 0, 0},  {&_swigt__p_CvTypedSeqT_CvPoint2D32f_t, _p_CvTypedSeqT_CvPoint2D32f_tTo_p_CvSeq, 0, 0},  {&_swigt__p_CvSeq, 0, 0, 0},  {&_swigt__p_CvTypedSeqT_CvTupleT_float_3_t_t, _p_CvTypedSeqT_CvTupleT_float_3_t_tTo_p_CvSeq, 0, 0},  {&_swigt__p_CvTypedSeqT_CvConnectedComp_t, _p_CvTypedSeqT_CvConnectedComp_tTo_p_CvSeq, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSeqBlock[] = {  {&_swigt__p_CvSeqBlock, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSeqReader[] = {  {&_swigt__p_CvSeqReader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSeqWriter[] = {  {&_swigt__p_CvSeqWriter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSet[] = {  {&_swigt__p_CvSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSetElem[] = {  {&_swigt__p_CvSetElem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSize[] = {  {&_swigt__p_CvSize, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSize2D32f[] = {  {&_swigt__p_CvSize2D32f, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSlice[] = {  {&_swigt__p_CvSlice, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSparseMat[] = {  {&_swigt__p_CvSparseMat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSparseMatIterator[] = {  {&_swigt__p_CvSparseMatIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSparseNode[] = {  {&_swigt__p_CvSparseNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvStarDetectorParams[] = {  {&_swigt__p_CvStarDetectorParams, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvStarKeypoint[] = {  {&_swigt__p_CvStarKeypoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvStereoBMState[] = {  {&_swigt__p_CvStereoBMState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvStereoGCState[] = {  {&_swigt__p_CvStereoGCState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvString[] = {  {&_swigt__p_CvString, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvStringHashNode[] = {  {&_swigt__p_CvStringHashNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSubdiv2D[] = {  {&_swigt__p_CvSubdiv2D, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSubdiv2DEdge_Wrapper[] = {  {&_swigt__p_CvSubdiv2DEdge_Wrapper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSubdiv2DPoint[] = {  {&_swigt__p_CvSubdiv2DPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvSubdiv2DPointLocation[] = {  {&_swigt__p_CvSubdiv2DPointLocation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTermCriteria[] = {  {&_swigt__p_CvTermCriteria, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTreeNodeIterator[] = {  {&_swigt__p_CvTreeNodeIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTupleT_CvPoint_2_t[] = {  {&_swigt__p_CvTupleT_CvPoint_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTupleT_float_2_t[] = {  {&_swigt__p_CvTupleT_float_2_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTupleT_float_3_t[] = {  {&_swigt__p_CvTupleT_float_3_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvType[] = {  {&_swigt__p_CvType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTypeInfo[] = {  {&_swigt__p_CvTypeInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTypedSeqT_CvConnectedComp_t[] = {  {&_swigt__p_CvTypedSeqT_CvConnectedComp_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTypedSeqT_CvPoint2D32f_t[] = {  {&_swigt__p_CvTypedSeqT_CvPoint2D32f_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTypedSeqT_CvPoint_t[] = {  {&_swigt__p_CvTypedSeqT_CvPoint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTypedSeqT_CvQuadEdge2D_t[] = {  {&_swigt__p_CvTypedSeqT_CvQuadEdge2D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTypedSeqT_CvRect_t[] = {  {&_swigt__p_CvTypedSeqT_CvRect_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTypedSeqT_CvSeq_p_t[] = {  {&_swigt__p_CvTypedSeqT_CvSeq_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t[] = {  {&_swigt__p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTypedSeqT_CvTupleT_float_2_t_t[] = {  {&_swigt__p_CvTypedSeqT_CvTupleT_float_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CvTypedSeqT_CvTupleT_float_3_t_t[] = {  {&_swigt__p_CvTypedSeqT_CvTupleT_float_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__CvContourScanner[] = {  {&_swigt__p__CvContourScanner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__IplConvKernel[] = {  {&_swigt__p__IplConvKernel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__IplConvKernelFP[] = {  {&_swigt__p__IplConvKernelFP, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__IplImage[] = {  {&_swigt__p__IplImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__IplROI[] = {  {&_swigt__p__IplROI, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__IplTileInfo[] = {  {&_swigt__p__IplTileInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_2__float[] = {  {&_swigt__p_a_2__float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_2__signed_char[] = {  {&_swigt__p_a_2__signed_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_3__float[] = {  {&_swigt__p_a_3__float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_int_int_int_int_int__p__IplROI[] = {  {&_swigt__p_f_int_int_int_int_int__p__IplROI, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_int_int_int_p_char_p_char_int_int_int_int_int_p_IplROI_p_IplImage_p_void_p_IplTileInfo__p__IplImage[] = {  {&_swigt__p_f_int_int_int_p_char_p_char_int_int_int_int_int_p_IplROI_p_IplImage_p_void_p_IplTileInfo__p__IplImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_int_p_q_const__char_p_q_const__char_p_q_const__char_int_p_void__int[] = {  {&_swigt__p_f_int_p_q_const__char_p_q_const__char_p_q_const__char_int_p_void__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_CvFileStorage_p_CvFileNode__p_void[] = {  {&_swigt__p_f_p_CvFileStorage_p_CvFileNode__p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void[] = {  {&_swigt__p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p__IplImage_int__void[] = {  {&_swigt__p_f_p__IplImage_int__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p__IplImage_int_int__void[] = {  {&_swigt__p_f_p__IplImage_int_int__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_p_void__void[] = {  {&_swigt__p_f_p_p_void__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__IplImage__p__IplImage[] = {  {&_swigt__p_f_p_q_const__IplImage__p__IplImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__char_int__p_CvMat[] = {  {&_swigt__p_f_p_q_const__char_int__p_CvMat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__char_int__p__IplImage[] = {  {&_swigt__p_f_p_q_const__char_int__p__IplImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__char_p_q_const__void__void[] = {  {&_swigt__p_f_p_q_const__char_p_q_const__void__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__char_p_q_const__void_p_q_const__int__int[] = {  {&_swigt__p_f_p_q_const__char_p_q_const__void_p_q_const__int__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__float_p_q_const__float_p_void__float[] = {  {&_swigt__p_f_p_q_const__float_p_q_const__float_p_void__float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__void__int[] = {  {&_swigt__p_f_p_q_const__void__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__void__p_void[] = {  {&_swigt__p_f_p_q_const__void__p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_q_const__void_p_q_const__void_p_void__int[] = {  {&_swigt__p_f_p_q_const__void_p_q_const__void_p_void__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_void__int[] = {  {&_swigt__p_f_p_void_p_void__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_size_t_p_void__p_void[] = {  {&_swigt__p_f_size_t_p_void__p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int64_t[] = {  {&_swigt__p_int64_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvConDensation[] = {  {&_swigt__p_p_CvConDensation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvFileStorage[] = {  {&_swigt__p_p_CvFileStorage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvGraphEdge[] = {  {&_swigt__p_p_CvGraphEdge, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvGraphScanner[] = {  {&_swigt__p_p_CvGraphScanner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvGraphVtx[] = {  {&_swigt__p_p_CvGraphVtx, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvHaarClassifierCascade[] = {  {&_swigt__p_p_CvHaarClassifierCascade, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvHistogram[] = {  {&_swigt__p_p_CvHistogram, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvKalman[] = {  {&_swigt__p_p_CvKalman, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvLSH[] = {  {&_swigt__p_p_CvLSH, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvMat[] = {  {&_swigt__p_p_CvMat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvMatND[] = {  {&_swigt__p_p_CvMatND, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvMemStorage[] = {  {&_swigt__p_p_CvMemStorage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvPOSITObject[] = {  {&_swigt__p_p_CvPOSITObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvPoint[] = {  {&_swigt__p_p_CvPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t[] = {{&_swigt__p_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvTypedSeqT_CvTupleT_float_2_t_t[] = {{&_swigt__p_p_CvTypedSeqT_CvTupleT_float_2_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvTypedSeqT_CvRect_t[] = {{&_swigt__p_p_CvTypedSeqT_CvRect_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvTypedSeqT_CvPoint_t[] = {{&_swigt__p_p_CvTypedSeqT_CvPoint_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvTypedSeqT_CvQuadEdge2D_t[] = {{&_swigt__p_p_CvTypedSeqT_CvQuadEdge2D_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvTypedSeqT_CvSeq_p_t[] = {{&_swigt__p_p_CvTypedSeqT_CvSeq_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvTypedSeqT_CvPoint2D32f_t[] = {{&_swigt__p_p_CvTypedSeqT_CvPoint2D32f_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvTypedSeqT_CvTupleT_float_3_t_t[] = {{&_swigt__p_p_CvTypedSeqT_CvTupleT_float_3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvTypedSeqT_CvConnectedComp_t[] = {{&_swigt__p_p_CvTypedSeqT_CvConnectedComp_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvSeq[] = {  {&_swigt__p_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t, _p_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_tTo_p_p_CvSeq, 0, 0},  {&_swigt__p_p_CvTypedSeqT_CvTupleT_float_2_t_t, _p_p_CvTypedSeqT_CvTupleT_float_2_t_tTo_p_p_CvSeq, 0, 0},  {&_swigt__p_p_CvTypedSeqT_CvRect_t, _p_p_CvTypedSeqT_CvRect_tTo_p_p_CvSeq, 0, 0},  {&_swigt__p_p_CvTypedSeqT_CvPoint_t, _p_p_CvTypedSeqT_CvPoint_tTo_p_p_CvSeq, 0, 0},  {&_swigt__p_p_CvTypedSeqT_CvQuadEdge2D_t, _p_p_CvTypedSeqT_CvQuadEdge2D_tTo_p_p_CvSeq, 0, 0},  {&_swigt__p_p_CvTypedSeqT_CvSeq_p_t, _p_p_CvTypedSeqT_CvSeq_p_tTo_p_p_CvSeq, 0, 0},  {&_swigt__p_p_CvTypedSeqT_CvPoint2D32f_t, _p_p_CvTypedSeqT_CvPoint2D32f_tTo_p_p_CvSeq, 0, 0},  {&_swigt__p_p_CvSeq, 0, 0, 0},  {&_swigt__p_p_CvTypedSeqT_CvTupleT_float_3_t_t, _p_p_CvTypedSeqT_CvTupleT_float_3_t_tTo_p_p_CvSeq, 0, 0},  {&_swigt__p_p_CvTypedSeqT_CvConnectedComp_t, _p_p_CvTypedSeqT_CvConnectedComp_tTo_p_p_CvSeq, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvSeqBlock[] = {  {&_swigt__p_p_CvSeqBlock, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvSetElem[] = {  {&_swigt__p_p_CvSetElem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvSparseMat[] = {  {&_swigt__p_p_CvSparseMat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvStereoBMState[] = {  {&_swigt__p_p_CvStereoBMState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvStereoGCState[] = {  {&_swigt__p_p_CvStereoGCState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_CvSubdiv2DPoint[] = {  {&_swigt__p_p_CvSubdiv2DPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p__CvContourScanner[] = {  {&_swigt__p_p__CvContourScanner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p__IplConvKernel[] = {  {&_swigt__p_p__IplConvKernel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p__IplImage[] = {  {&_swigt__p_p__IplImage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_float[] = {  {&_swigt__p_p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_p_CvMat[] = {  {&_swigt__p_p_p_CvMat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_unsigned_char[] = {  {&_swigt__p_p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_void[] = {  {&_swigt__p_p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_signed_char[] = {  {&_swigt__p_signed_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t[] = {  {&_swigt__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type[] = {  {&_swigt__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type, 0, 0, 0},  {&_swigt__p_CvPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_float_std__allocatorT_float_t_t[] = {  {&_swigt__p_std__vectorT_float_std__allocatorT_float_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_float_std__allocatorT_float_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_float_std__allocatorT_float_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__OctSwigIterator[] = {  {&_swigt__p_swig__OctSwigIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_uint64_t[] = {  {&_swigt__p_uint64_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Cv32suf,
  _swigc__p_Cv64suf,
  _swigc__p_CvAttrList,
  _swigc__p_CvAvgComp,
  _swigc__p_CvBox2D,
  _swigc__p_CvChain,
  _swigc__p_CvChainPtReader,
  _swigc__p_CvConDensation,
  _swigc__p_CvConnectedComp,
  _swigc__p_CvContour,
  _swigc__p_CvContourTree,
  _swigc__p_CvConvexityDefect,
  _swigc__p_CvFeatureTree,
  _swigc__p_CvFileNode,
  _swigc__p_CvFileNode_data,
  _swigc__p_CvFileStorage,
  _swigc__p_CvFilter,
  _swigc__p_CvFont,
  _swigc__p_CvGenericHash,
  _swigc__p_CvGraph,
  _swigc__p_CvGraphEdge,
  _swigc__p_CvGraphScanner,
  _swigc__p_CvGraphVtx,
  _swigc__p_CvGraphVtx2D,
  _swigc__p_CvHaarClassifier,
  _swigc__p_CvHaarClassifierCascade,
  _swigc__p_CvHaarFeature,
  _swigc__p_CvHaarFeature_rect,
  _swigc__p_CvHaarStageClassifier,
  _swigc__p_CvHidHaarClassifierCascade,
  _swigc__p_CvHistogram,
  _swigc__p_CvHuMoments,
  _swigc__p_CvImage,
  _swigc__p_CvKalman,
  _swigc__p_CvLSH,
  _swigc__p_CvLSHOperations,
  _swigc__p_CvLineIterator,
  _swigc__p_CvMSERParams,
  _swigc__p_CvMat,
  _swigc__p_CvMatND,
  _swigc__p_CvMatND_data,
  _swigc__p_CvMatND_dim,
  _swigc__p_CvMat_data,
  _swigc__p_CvMatrix,
  _swigc__p_CvMatrix3,
  _swigc__p_CvMemBlock,
  _swigc__p_CvMemStorage,
  _swigc__p_CvMemStoragePos,
  _swigc__p_CvModule,
  _swigc__p_CvModuleInfo,
  _swigc__p_CvMoments,
  _swigc__p_CvNArrayIterator,
  _swigc__p_CvNextEdgeType,
  _swigc__p_CvPOSITObject,
  _swigc__p_CvPluginFuncInfo,
  _swigc__p_CvPoint,
  _swigc__p_CvPoint2D32f,
  _swigc__p_CvPoint2D64f,
  _swigc__p_CvPoint3D32f,
  _swigc__p_CvPoint3D64f,
  _swigc__p_CvQuadEdge2D,
  _swigc__p_CvRNG_Wrapper,
  _swigc__p_CvRandState,
  _swigc__p_CvRect,
  _swigc__p_CvSURFParams,
  _swigc__p_CvSURFPoint,
  _swigc__p_CvScalar,
  _swigc__p_CvSeq,
  _swigc__p_CvSeqBlock,
  _swigc__p_CvSeqReader,
  _swigc__p_CvSeqWriter,
  _swigc__p_CvSet,
  _swigc__p_CvSetElem,
  _swigc__p_CvSize,
  _swigc__p_CvSize2D32f,
  _swigc__p_CvSlice,
  _swigc__p_CvSparseMat,
  _swigc__p_CvSparseMatIterator,
  _swigc__p_CvSparseNode,
  _swigc__p_CvStarDetectorParams,
  _swigc__p_CvStarKeypoint,
  _swigc__p_CvStereoBMState,
  _swigc__p_CvStereoGCState,
  _swigc__p_CvString,
  _swigc__p_CvStringHashNode,
  _swigc__p_CvSubdiv2D,
  _swigc__p_CvSubdiv2DEdge_Wrapper,
  _swigc__p_CvSubdiv2DPoint,
  _swigc__p_CvSubdiv2DPointLocation,
  _swigc__p_CvTermCriteria,
  _swigc__p_CvTreeNodeIterator,
  _swigc__p_CvTupleT_CvPoint_2_t,
  _swigc__p_CvTupleT_float_2_t,
  _swigc__p_CvTupleT_float_3_t,
  _swigc__p_CvType,
  _swigc__p_CvTypeInfo,
  _swigc__p_CvTypedSeqT_CvConnectedComp_t,
  _swigc__p_CvTypedSeqT_CvPoint2D32f_t,
  _swigc__p_CvTypedSeqT_CvPoint_t,
  _swigc__p_CvTypedSeqT_CvQuadEdge2D_t,
  _swigc__p_CvTypedSeqT_CvRect_t,
  _swigc__p_CvTypedSeqT_CvSeq_p_t,
  _swigc__p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t,
  _swigc__p_CvTypedSeqT_CvTupleT_float_2_t_t,
  _swigc__p_CvTypedSeqT_CvTupleT_float_3_t_t,
  _swigc__p__CvContourScanner,
  _swigc__p__IplConvKernel,
  _swigc__p__IplConvKernelFP,
  _swigc__p__IplImage,
  _swigc__p__IplROI,
  _swigc__p__IplTileInfo,
  _swigc__p_a_2__float,
  _swigc__p_a_2__signed_char,
  _swigc__p_a_3__float,
  _swigc__p_allocator_type,
  _swigc__p_char,
  _swigc__p_difference_type,
  _swigc__p_double,
  _swigc__p_f_int_int_int_int_int__p__IplROI,
  _swigc__p_f_int_int_int_p_char_p_char_int_int_int_int_int_p_IplROI_p_IplImage_p_void_p_IplTileInfo__p__IplImage,
  _swigc__p_f_int_p_q_const__char_p_q_const__char_p_q_const__char_int_p_void__int,
  _swigc__p_f_p_CvFileStorage_p_CvFileNode__p_void,
  _swigc__p_f_p_CvFileStorage_p_q_const__char_p_q_const__void_CvAttrList__void,
  _swigc__p_f_p__IplImage_int__void,
  _swigc__p_f_p__IplImage_int_int__void,
  _swigc__p_f_p_p_void__void,
  _swigc__p_f_p_q_const__IplImage__p__IplImage,
  _swigc__p_f_p_q_const__char_int__p_CvMat,
  _swigc__p_f_p_q_const__char_int__p__IplImage,
  _swigc__p_f_p_q_const__char_p_q_const__void__void,
  _swigc__p_f_p_q_const__char_p_q_const__void_p_q_const__int__int,
  _swigc__p_f_p_q_const__float_p_q_const__float_p_void__float,
  _swigc__p_f_p_q_const__void__int,
  _swigc__p_f_p_q_const__void__p_void,
  _swigc__p_f_p_q_const__void_p_q_const__void_p_void__int,
  _swigc__p_f_p_void_p_void__int,
  _swigc__p_f_size_t_p_void__p_void,
  _swigc__p_float,
  _swigc__p_int,
  _swigc__p_int64_t,
  _swigc__p_p_CvConDensation,
  _swigc__p_p_CvFileStorage,
  _swigc__p_p_CvGraphEdge,
  _swigc__p_p_CvGraphScanner,
  _swigc__p_p_CvGraphVtx,
  _swigc__p_p_CvHaarClassifierCascade,
  _swigc__p_p_CvHistogram,
  _swigc__p_p_CvKalman,
  _swigc__p_p_CvLSH,
  _swigc__p_p_CvMat,
  _swigc__p_p_CvMatND,
  _swigc__p_p_CvMemStorage,
  _swigc__p_p_CvPOSITObject,
  _swigc__p_p_CvPoint,
  _swigc__p_p_CvSeq,
  _swigc__p_p_CvSeqBlock,
  _swigc__p_p_CvSetElem,
  _swigc__p_p_CvSparseMat,
  _swigc__p_p_CvStereoBMState,
  _swigc__p_p_CvStereoGCState,
  _swigc__p_p_CvSubdiv2DPoint,
  _swigc__p_p_CvTypedSeqT_CvConnectedComp_t,
  _swigc__p_p_CvTypedSeqT_CvPoint2D32f_t,
  _swigc__p_p_CvTypedSeqT_CvPoint_t,
  _swigc__p_p_CvTypedSeqT_CvQuadEdge2D_t,
  _swigc__p_p_CvTypedSeqT_CvRect_t,
  _swigc__p_p_CvTypedSeqT_CvSeq_p_t,
  _swigc__p_p_CvTypedSeqT_CvTupleT_CvPoint_2_t_t,
  _swigc__p_p_CvTypedSeqT_CvTupleT_float_2_t_t,
  _swigc__p_p_CvTypedSeqT_CvTupleT_float_3_t_t,
  _swigc__p_p__CvContourScanner,
  _swigc__p_p__IplConvKernel,
  _swigc__p_p__IplImage,
  _swigc__p_p_char,
  _swigc__p_p_float,
  _swigc__p_p_p_CvMat,
  _swigc__p_p_unsigned_char,
  _swigc__p_p_void,
  _swigc__p_short,
  _swigc__p_signed_char,
  _swigc__p_size_t,
  _swigc__p_size_type,
  _swigc__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t,
  _swigc__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__allocator_type,
  _swigc__p_std__vectorT_CvPoint_std__allocatorT_CvPoint_t_t__value_type,
  _swigc__p_std__vectorT_float_std__allocatorT_float_t_t,
  _swigc__p_std__vectorT_float_std__allocatorT_float_t_t__allocator_type,
  _swigc__p_swig__OctSwigIterator,
  _swigc__p_uint64_t,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_short,
  _swigc__p_value_type,
  _swigc__p_void,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpeters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif



static void SWIG_init_user(octave_swig_type* module_ns);

DEFUN_DLD (SWIG_name,args,nargout,SWIG_name_d) {
  static bool already_init=false;
  if (already_init)
    return octave_value_list();
  already_init=true;

  octave_swig_ref::register_type();
  octave_swig_packed::register_type();
  SWIG_InitializeModule(0);
  SWIG_PropagateClientData();
  
  install_builtin_function(swig_type,"swig_type",std::string());
  install_builtin_function(swig_typequery,"swig_typequery",std::string());
  install_builtin_function(swig_this,"swig_this",std::string());
  install_builtin_function(swig_subclass,"subclass",std::string());

  bool global_option=true; // * swig cli option should control this default
  for (int j=0;j<args.length();++j)
    if (args(j).is_string()&&args(j).string_value()=="noglobal")
      global_option=true;
    else if (args(j).is_string()&&args(j).string_value()=="noglobal")
      global_option=false;

  octave_swig_type* cvar_ns=new octave_swig_type;
  for (int j=0;swig_globals[j].name;++j)
    if (swig_globals[j].get_method)
      cvar_ns->assign(swig_globals[j].name,&swig_globals[j]);

  octave_swig_type* module_ns=new octave_swig_type(0, 0, 0, true);
  module_ns->assign("cvar",Swig::swig_value_ref(cvar_ns));
  for (int j=0;swig_globals[j].name;++j)
    if (swig_globals[j].method)
      module_ns->assign(swig_globals[j].name,&swig_globals[j]);

  // * need better solution here; swig_type -> octave_class mapping is 
  // * really n-to-1, in some cases such as template partial spec, etc. 
  // * see failing tests.
  for (int j=0;swig_types[j];++j)
    if (swig_types[j]->clientdata) {
      swig_octave_class* c=(swig_octave_class*)swig_types[j]->clientdata;
      module_ns->assign(c->name,
			Swig::swig_value_ref
			(new octave_swig_type(0,swig_types[j])));
    }

  SWIG_init_user(module_ns);

  SWIG_InstallOps(octave_swig_ref::static_type_id());

  // the incref is necessary so install_global doesn't destroy module_ns,
  // as it would if it installed something with the same name as the module.
  module_ns->incref();
  if (global_option)
    module_ns->install_global();
  module_ns->decref();

#if USE_OCTAVE_API_VERSION<37
  link_to_global_variable(curr_sym_tab->lookup(SWIG_name_d,true));
#else
  symbol_table::varref(SWIG_name_d);
  symbol_table::mark_global(SWIG_name_d);
#endif
  set_global_value(SWIG_name_d,Swig::swig_value_ref(module_ns));

#if USE_OCTAVE_API_VERSION>=37
  mlock();
#endif

  return octave_value_list();
}

// workaround bug in octave where installing global variable of custom type and then
// exiting without explicitly clearing the variable causes octave to segfault.
#if USE_OCTAVE_API_VERSION>=37
struct oct_file_unload {
  ~oct_file_unload() {
    string_vector vars = symbol_table::global_variable_names();
    for (int i = 0; i < vars.length(); i++)
      symbol_table::clear_global(vars[i]);
  }
};
static oct_file_unload __unload;
#endif


static void SWIG_init_user(octave_swig_type* module_ns)
{
  SWIG_Octave_SetConstant(module_ns,"sizeof_CvContour",SWIG_From_size_t((size_t)(sizeof(CvContour))));
  SWIG_Octave_SetConstant(module_ns,"sizeof_CvPoint",SWIG_From_size_t((size_t)(sizeof(CvPoint))));
  SWIG_Octave_SetConstant(module_ns,"sizeof_CvSeq",SWIG_From_size_t((size_t)(sizeof(CvSeq))));
  SWIG_Octave_SetConstant(module_ns,"CV_AUTOSTEP",SWIG_From_int((int)(0x7fffffff)));
  SWIG_Octave_SetConstant(module_ns,"CV_MAX_ARR",SWIG_From_int((int)(10)));
  SWIG_Octave_SetConstant(module_ns,"CV_NO_DEPTH_CHECK",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_NO_CN_CHECK",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_NO_SIZE_CHECK",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_CMP_EQ",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_CMP_GT",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_CMP_GE",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_CMP_LT",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_CMP_LE",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_CMP_NE",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_CHECK_RANGE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_CHECK_QUIET",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_RAND_UNI",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_RAND_NORMAL",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_SORT_EVERY_ROW",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_SORT_EVERY_COLUMN",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_SORT_ASCENDING",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_SORT_DESCENDING",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_GEMM_A_T",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_GEMM_B_T",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_GEMM_C_T",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_SVD_MODIFY_A",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_SVD_U_T",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_SVD_V_T",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_LU",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_SVD",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_SVD_SYM",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_CHOLESKY",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_QR",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_NORMAL",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_COVAR_SCRAMBLED",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_COVAR_NORMAL",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_COVAR_USE_AVG",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_COVAR_SCALE",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_COVAR_ROWS",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_COVAR_COLS",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_PCA_DATA_AS_ROW",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_PCA_DATA_AS_COL",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_PCA_USE_AVG",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_C",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_L1",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_L2",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_NORM_MASK",SWIG_From_int((int)(7)));
  SWIG_Octave_SetConstant(module_ns,"CV_RELATIVE",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIFF",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_MINMAX",SWIG_From_int((int)(32)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIFF_C",SWIG_From_int((int)((16|1))));
  SWIG_Octave_SetConstant(module_ns,"CV_DIFF_L1",SWIG_From_int((int)((16|2))));
  SWIG_Octave_SetConstant(module_ns,"CV_DIFF_L2",SWIG_From_int((int)((16|4))));
  SWIG_Octave_SetConstant(module_ns,"CV_RELATIVE_C",SWIG_From_int((int)((8|1))));
  SWIG_Octave_SetConstant(module_ns,"CV_RELATIVE_L1",SWIG_From_int((int)((8|2))));
  SWIG_Octave_SetConstant(module_ns,"CV_RELATIVE_L2",SWIG_From_int((int)((8|4))));
  SWIG_Octave_SetConstant(module_ns,"CV_REDUCE_SUM",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_REDUCE_AVG",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_REDUCE_MAX",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_REDUCE_MIN",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_DXT_FORWARD",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_DXT_INVERSE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_DXT_SCALE",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_DXT_INV_SCALE",SWIG_From_int((int)((1+2))));
  SWIG_Octave_SetConstant(module_ns,"CV_DXT_INVERSE_SCALE",SWIG_From_int((int)((1+2))));
  SWIG_Octave_SetConstant(module_ns,"CV_DXT_ROWS",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_DXT_MUL_CONJ",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_FRONT",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_BACK",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_VERTEX",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_TREE_EDGE",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_BACK_EDGE",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_FORWARD_EDGE",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_CROSS_EDGE",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_ANY_EDGE",SWIG_From_int((int)(30)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_NEW_TREE",SWIG_From_int((int)(32)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_BACKTRACKING",SWIG_From_int((int)(64)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_OVER",SWIG_From_int((int)(-1)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_ALL_ITEMS",SWIG_From_int((int)(-1)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_ITEM_VISITED_FLAG",SWIG_From_int((int)((1 << 30))));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_SEARCH_TREE_NODE_FLAG",SWIG_From_int((int)((1 << 29))));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_FORWARD_EDGE_FLAG",SWIG_From_int((int)((1 << 28))));
  SWIG_Octave_SetConstant(module_ns,"CV_FILLED",SWIG_From_int((int)(-1)));
  SWIG_Octave_SetConstant(module_ns,"CV_AA",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_FONT_HERSHEY_SIMPLEX",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_FONT_HERSHEY_PLAIN",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_FONT_HERSHEY_DUPLEX",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_FONT_HERSHEY_COMPLEX",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_FONT_HERSHEY_TRIPLEX",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_FONT_HERSHEY_COMPLEX_SMALL",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_FONT_HERSHEY_SCRIPT_SIMPLEX",SWIG_From_int((int)(6)));
  SWIG_Octave_SetConstant(module_ns,"CV_FONT_HERSHEY_SCRIPT_COMPLEX",SWIG_From_int((int)(7)));
  SWIG_Octave_SetConstant(module_ns,"CV_FONT_ITALIC",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_FONT_VECTOR0",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_KMEANS_USE_INITIAL_LABELS",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_ErrModeLeaf",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_ErrModeParent",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_ErrModeSilent",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_MAJOR_VERSION",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_MINOR_VERSION",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_SUBMINOR_VERSION",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_PI",octave_value(3.1415926535897932384626433832795));
  SWIG_Octave_SetConstant(module_ns,"CV_LOG2",octave_value(0.69314718055994530941723212145818));
  SWIG_Octave_SetConstant(module_ns,"IPL_DEPTH_SIGN",SWIG_From_int((int)(0x80000000)));
  SWIG_Octave_SetConstant(module_ns,"IPL_DEPTH_1U",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"IPL_DEPTH_8U",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"IPL_DEPTH_16U",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"IPL_DEPTH_32F",SWIG_From_int((int)(32)));
  SWIG_Octave_SetConstant(module_ns,"IPL_DEPTH_8S",SWIG_From_int((int)((0x80000000|8))));
  SWIG_Octave_SetConstant(module_ns,"IPL_DEPTH_16S",SWIG_From_int((int)((0x80000000|16))));
  SWIG_Octave_SetConstant(module_ns,"IPL_DEPTH_32S",SWIG_From_int((int)((0x80000000|32))));
  SWIG_Octave_SetConstant(module_ns,"IPL_DATA_ORDER_PIXEL",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"IPL_DATA_ORDER_PLANE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"IPL_ORIGIN_TL",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"IPL_ORIGIN_BL",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"IPL_ALIGN_4BYTES",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"IPL_ALIGN_8BYTES",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"IPL_ALIGN_16BYTES",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"IPL_ALIGN_32BYTES",SWIG_From_int((int)(32)));
  SWIG_Octave_SetConstant(module_ns,"IPL_ALIGN_DWORD",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"IPL_ALIGN_QWORD",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"IPL_BORDER_CONSTANT",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"IPL_BORDER_REPLICATE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"IPL_BORDER_REFLECT",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"IPL_BORDER_WRAP",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"IPL_IMAGE_HEADER",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"IPL_IMAGE_DATA",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"IPL_IMAGE_ROI",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"IPL_BORDER_REFLECT_101",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_TYPE_NAME_IMAGE",SWIG_FromCharPtr("opencv-image"));
  SWIG_Octave_SetConstant(module_ns,"IPL_DEPTH_64F",SWIG_From_int((int)(64)));
  SWIG_Octave_SetConstant(module_ns,"CV_CN_MAX",SWIG_From_int((int)(64)));
  SWIG_Octave_SetConstant(module_ns,"CV_CN_SHIFT",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_DEPTH_MAX",SWIG_From_int((int)((1 << 3))));
  SWIG_Octave_SetConstant(module_ns,"CV_8U",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_8S",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_16U",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_16S",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_32S",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_32F",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_64F",SWIG_From_int((int)(6)));
  SWIG_Octave_SetConstant(module_ns,"CV_USRTYPE1",SWIG_From_int((int)(7)));
  SWIG_Octave_SetConstant(module_ns,"CV_MAT_DEPTH_MASK",SWIG_From_int((int)(((1 << 3) -1))));
  SWIG_Octave_SetConstant(module_ns,"CV_8UC1",SWIG_From_int((int)((((0) &((1 << 3) -1)) +(((1) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_8UC2",SWIG_From_int((int)((((0) &((1 << 3) -1)) +(((2) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_8UC3",SWIG_From_int((int)((((0) &((1 << 3) -1)) +(((3) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_8UC4",SWIG_From_int((int)((((0) &((1 << 3) -1)) +(((4) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_8SC1",SWIG_From_int((int)((((1) &((1 << 3) -1)) +(((1) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_8SC2",SWIG_From_int((int)((((1) &((1 << 3) -1)) +(((2) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_8SC3",SWIG_From_int((int)((((1) &((1 << 3) -1)) +(((3) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_8SC4",SWIG_From_int((int)((((1) &((1 << 3) -1)) +(((4) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_16UC1",SWIG_From_int((int)((((2) &((1 << 3) -1)) +(((1) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_16UC2",SWIG_From_int((int)((((2) &((1 << 3) -1)) +(((2) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_16UC3",SWIG_From_int((int)((((2) &((1 << 3) -1)) +(((3) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_16UC4",SWIG_From_int((int)((((2) &((1 << 3) -1)) +(((4) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_16SC1",SWIG_From_int((int)((((3) &((1 << 3) -1)) +(((1) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_16SC2",SWIG_From_int((int)((((3) &((1 << 3) -1)) +(((2) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_16SC3",SWIG_From_int((int)((((3) &((1 << 3) -1)) +(((3) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_16SC4",SWIG_From_int((int)((((3) &((1 << 3) -1)) +(((4) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_32SC1",SWIG_From_int((int)((((4) &((1 << 3) -1)) +(((1) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_32SC2",SWIG_From_int((int)((((4) &((1 << 3) -1)) +(((2) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_32SC3",SWIG_From_int((int)((((4) &((1 << 3) -1)) +(((3) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_32SC4",SWIG_From_int((int)((((4) &((1 << 3) -1)) +(((4) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_32FC1",SWIG_From_int((int)((((5) &((1 << 3) -1)) +(((1) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_32FC2",SWIG_From_int((int)((((5) &((1 << 3) -1)) +(((2) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_32FC3",SWIG_From_int((int)((((5) &((1 << 3) -1)) +(((3) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_32FC4",SWIG_From_int((int)((((5) &((1 << 3) -1)) +(((4) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_64FC1",SWIG_From_int((int)((((6) &((1 << 3) -1)) +(((1) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_64FC2",SWIG_From_int((int)((((6) &((1 << 3) -1)) +(((2) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_64FC3",SWIG_From_int((int)((((6) &((1 << 3) -1)) +(((3) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_64FC4",SWIG_From_int((int)((((6) &((1 << 3) -1)) +(((4) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_AUTO_STEP",SWIG_From_int((int)(0x7fffffff)));
  SWIG_Octave_SetConstant(module_ns,"CV_MAT_CN_MASK",SWIG_From_int((int)(((64-1) << 3))));
  SWIG_Octave_SetConstant(module_ns,"CV_MAT_TYPE_MASK",SWIG_From_int((int)(((1 << 3) *64-1))));
  SWIG_Octave_SetConstant(module_ns,"CV_MAT_CONT_FLAG_SHIFT",SWIG_From_int((int)(14)));
  SWIG_Octave_SetConstant(module_ns,"CV_MAT_CONT_FLAG",SWIG_From_int((int)((1 << 14))));
  SWIG_Octave_SetConstant(module_ns,"CV_MAT_TEMP_FLAG_SHIFT",SWIG_From_int((int)(15)));
  SWIG_Octave_SetConstant(module_ns,"CV_MAT_TEMP_FLAG",SWIG_From_int((int)((1 << 15))));
  SWIG_Octave_SetConstant(module_ns,"CV_MAGIC_MASK",SWIG_From_int((int)(0xFFFF0000)));
  SWIG_Octave_SetConstant(module_ns,"CV_MAT_MAGIC_VAL",SWIG_From_int((int)(0x42420000)));
  SWIG_Octave_SetConstant(module_ns,"CV_TYPE_NAME_MAT",SWIG_FromCharPtr("opencv-matrix"));
  SWIG_Octave_SetConstant(module_ns,"CV_MATND_MAGIC_VAL",SWIG_From_int((int)(0x42430000)));
  SWIG_Octave_SetConstant(module_ns,"CV_TYPE_NAME_MATND",SWIG_FromCharPtr("opencv-nd-matrix"));
  SWIG_Octave_SetConstant(module_ns,"CV_MAX_DIM",SWIG_From_int((int)(32)));
  SWIG_Octave_SetConstant(module_ns,"CV_MAX_DIM_HEAP",SWIG_From_int((int)((1 << 16))));
  SWIG_Octave_SetConstant(module_ns,"CV_SPARSE_MAT_MAGIC_VAL",SWIG_From_int((int)(0x42440000)));
  SWIG_Octave_SetConstant(module_ns,"CV_TYPE_NAME_SPARSE_MAT",SWIG_FromCharPtr("opencv-sparse-matrix"));
  SWIG_Octave_SetConstant(module_ns,"CV_HIST_MAGIC_VAL",SWIG_From_int((int)(0x42450000)));
  SWIG_Octave_SetConstant(module_ns,"CV_HIST_UNIFORM_FLAG",SWIG_From_int((int)((1 << 10))));
  SWIG_Octave_SetConstant(module_ns,"CV_HIST_RANGES_FLAG",SWIG_From_int((int)((1 << 11))));
  SWIG_Octave_SetConstant(module_ns,"CV_HIST_ARRAY",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_HIST_SPARSE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_HIST_TREE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_HIST_UNIFORM",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_TERMCRIT_ITER",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_TERMCRIT_NUMBER",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_TERMCRIT_EPS",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_WHOLE_SEQ_END_INDEX",SWIG_From_int((int)(0x3fffffff)));
  SWIG_Octave_SetConstant(module_ns,"CV_STORAGE_MAGIC_VAL",SWIG_From_int((int)(0x42890000)));
  SWIG_Octave_SetConstant(module_ns,"CV_TYPE_NAME_SEQ",SWIG_FromCharPtr("opencv-sequence"));
  SWIG_Octave_SetConstant(module_ns,"CV_TYPE_NAME_SEQ_TREE",SWIG_FromCharPtr("opencv-sequence-tree"));
  SWIG_Octave_SetConstant(module_ns,"CV_SET_ELEM_IDX_MASK",SWIG_From_int((int)(((1 << 26) -1))));
  SWIG_Octave_SetConstant(module_ns,"CV_TYPE_NAME_GRAPH",SWIG_FromCharPtr("opencv-graph"));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_MAGIC_VAL",SWIG_From_int((int)(0x42990000)));
  SWIG_Octave_SetConstant(module_ns,"CV_SET_MAGIC_VAL",SWIG_From_int((int)(0x42980000)));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_BITS",SWIG_From_int((int)(9)));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_MASK",SWIG_From_int((int)(((1 << 9) -1))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_POINT",SWIG_From_int((int)((((4) &((1 << 3) -1)) +(((2) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_CODE",SWIG_From_int((int)((((0) &((1 << 3) -1)) +(((1) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_GENERIC",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_PTR",SWIG_From_int((int)(7)));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_PPOINT",SWIG_From_int((int)(7)));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_INDEX",SWIG_From_int((int)((((4) &((1 << 3) -1)) +(((1) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_GRAPH_EDGE",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_GRAPH_VERTEX",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_TRIAN_ATR",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_CONNECTED_COMP",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_ELTYPE_POINT3D",SWIG_From_int((int)((((5) &((1 << 3) -1)) +(((3) -1) << 3)))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_KIND_BITS",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_KIND_MASK",SWIG_From_int((int)((((1 << 3) -1) << 9))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_KIND_GENERIC",SWIG_From_int((int)((0 << 9))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_KIND_CURVE",SWIG_From_int((int)((1 << 9))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_KIND_BIN_TREE",SWIG_From_int((int)((2 << 9))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_KIND_GRAPH",SWIG_From_int((int)((3 << 9))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_KIND_SUBDIV2D",SWIG_From_int((int)((4 << 9))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_FLAG_SHIFT",SWIG_From_int((int)((3+9))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_FLAG_CLOSED",SWIG_From_int((int)((1 << (3+9)))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_FLAG_SIMPLE",SWIG_From_int((int)((2 << (3+9)))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_FLAG_CONVEX",SWIG_From_int((int)((4 << (3+9)))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_FLAG_HOLE",SWIG_From_int((int)((8 << (3+9)))));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH_FLAG_ORIENTED",SWIG_From_int((int)((1 << (3+9)))));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAPH",SWIG_From_int((int)((3 << 9))));
  SWIG_Octave_SetConstant(module_ns,"CV_ORIENTED_GRAPH",SWIG_From_int((int)(((3 << 9)|(1 << (3+9))))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_POINT_SET",SWIG_From_int((int)(((0 << 9)|(((4) &((1 << 3) -1)) +(((2) -1) << 3))))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_POINT3D_SET",SWIG_From_int((int)(((0 << 9)|(((5) &((1 << 3) -1)) +(((3) -1) << 3))))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_POLYLINE",SWIG_From_int((int)(((1 << 9)|(((4) &((1 << 3) -1)) +(((2) -1) << 3))))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_POLYGON",SWIG_From_int((int)(((1 << (3+9))|((1 << 9)|(((4) &((1 << 3) -1)) +(((2) -1) << 3)))))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_CONTOUR",SWIG_From_int((int)(((1 << (3+9))|((1 << 9)|(((4) &((1 << 3) -1)) +(((2) -1) << 3)))))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_SIMPLE_POLYGON",SWIG_From_int((int)(((2 << (3+9))|((1 << (3+9))|((1 << 9)|(((4) &((1 << 3) -1)) +(((2) -1) << 3))))))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_CHAIN",SWIG_From_int((int)(((1 << 9)|(((0) &((1 << 3) -1)) +(((1) -1) << 3))))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_CHAIN_CONTOUR",SWIG_From_int((int)(((1 << (3+9))|((1 << 9)|(((0) &((1 << 3) -1)) +(((1) -1) << 3)))))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_POLYGON_TREE",SWIG_From_int((int)(((2 << 9)|0))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_CONNECTED_COMP",SWIG_From_int((int)(((0 << 9)|0))));
  SWIG_Octave_SetConstant(module_ns,"CV_SEQ_INDEX",SWIG_From_int((int)(((0 << 9)|(((4) &((1 << 3) -1)) +(((1) -1) << 3))))));
  SWIG_Octave_SetConstant(module_ns,"CV_STORAGE_READ",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_STORAGE_WRITE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_STORAGE_WRITE_TEXT",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_STORAGE_WRITE_BINARY",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_STORAGE_APPEND",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_NONE",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_INT",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_INTEGER",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_REAL",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_FLOAT",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_STR",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_STRING",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_REF",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_SEQ",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_MAP",SWIG_From_int((int)(6)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_TYPE_MASK",SWIG_From_int((int)(7)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_FLOW",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_USER",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_EMPTY",SWIG_From_int((int)(32)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_NAMED",SWIG_From_int((int)(64)));
  SWIG_Octave_SetConstant(module_ns,"CV_NODE_SEQ_SIMPLE",SWIG_From_int((int)(256)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsOk",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsBackTrace",SWIG_From_int((int)(-1)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsError",SWIG_From_int((int)(-2)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsInternal",SWIG_From_int((int)(-3)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsNoMem",SWIG_From_int((int)(-4)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsBadArg",SWIG_From_int((int)(-5)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsBadFunc",SWIG_From_int((int)(-6)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsNoConv",SWIG_From_int((int)(-7)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsAutoTrace",SWIG_From_int((int)(-8)));
  SWIG_Octave_SetConstant(module_ns,"CV_HeaderIsNull",SWIG_From_int((int)(-9)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadImageSize",SWIG_From_int((int)(-10)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadOffset",SWIG_From_int((int)(-11)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadDataPtr",SWIG_From_int((int)(-12)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadStep",SWIG_From_int((int)(-13)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadModelOrChSeq",SWIG_From_int((int)(-14)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadNumChannels",SWIG_From_int((int)(-15)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadNumChannel1U",SWIG_From_int((int)(-16)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadDepth",SWIG_From_int((int)(-17)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadAlphaChannel",SWIG_From_int((int)(-18)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadOrder",SWIG_From_int((int)(-19)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadOrigin",SWIG_From_int((int)(-20)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadAlign",SWIG_From_int((int)(-21)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadCallBack",SWIG_From_int((int)(-22)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadTileSize",SWIG_From_int((int)(-23)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadCOI",SWIG_From_int((int)(-24)));
  SWIG_Octave_SetConstant(module_ns,"CV_BadROISize",SWIG_From_int((int)(-25)));
  SWIG_Octave_SetConstant(module_ns,"CV_MaskIsTiled",SWIG_From_int((int)(-26)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsNullPtr",SWIG_From_int((int)(-27)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsVecLengthErr",SWIG_From_int((int)(-28)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsFilterStructContentErr",SWIG_From_int((int)(-29)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsKernelStructContentErr",SWIG_From_int((int)(-30)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsFilterOffsetErr",SWIG_From_int((int)(-31)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsBadSize",SWIG_From_int((int)(-201)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsDivByZero",SWIG_From_int((int)(-202)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsInplaceNotSupported",SWIG_From_int((int)(-203)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsObjectNotFound",SWIG_From_int((int)(-204)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsUnmatchedFormats",SWIG_From_int((int)(-205)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsBadFlag",SWIG_From_int((int)(-206)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsBadPoint",SWIG_From_int((int)(-207)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsBadMask",SWIG_From_int((int)(-208)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsUnmatchedSizes",SWIG_From_int((int)(-209)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsUnsupportedFormat",SWIG_From_int((int)(-210)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsOutOfRange",SWIG_From_int((int)(-211)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsParseError",SWIG_From_int((int)(-212)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsNotImplemented",SWIG_From_int((int)(-213)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsBadMemBlock",SWIG_From_int((int)(-214)));
  SWIG_Octave_SetConstant(module_ns,"CV_StsAssert",SWIG_From_int((int)(-215)));
  SWIG_Octave_SetConstant(module_ns,"CV_BLUR_NO_SCALE",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_BLUR",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_GAUSSIAN",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_MEDIAN",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_BILATERAL",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_INPAINT_NS",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_INPAINT_TELEA",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_SCHARR",SWIG_From_int((int)(-1)));
  SWIG_Octave_SetConstant(module_ns,"CV_MAX_SOBEL_KSIZE",SWIG_From_int((int)(7)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2BGRA",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2RGBA",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGRA2BGR",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGBA2RGB",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2RGBA",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2BGRA",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGBA2BGR",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGRA2RGB",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2RGB",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2BGR",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGRA2RGBA",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGBA2BGRA",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2GRAY",SWIG_From_int((int)(6)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2GRAY",SWIG_From_int((int)(7)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAY2BGR",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAY2RGB",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAY2BGRA",SWIG_From_int((int)(9)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAY2RGBA",SWIG_From_int((int)(9)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGRA2GRAY",SWIG_From_int((int)(10)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGBA2GRAY",SWIG_From_int((int)(11)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2BGR565",SWIG_From_int((int)(12)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2BGR565",SWIG_From_int((int)(13)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR5652BGR",SWIG_From_int((int)(14)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR5652RGB",SWIG_From_int((int)(15)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGRA2BGR565",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGBA2BGR565",SWIG_From_int((int)(17)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR5652BGRA",SWIG_From_int((int)(18)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR5652RGBA",SWIG_From_int((int)(19)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAY2BGR565",SWIG_From_int((int)(20)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR5652GRAY",SWIG_From_int((int)(21)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2BGR555",SWIG_From_int((int)(22)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2BGR555",SWIG_From_int((int)(23)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR5552BGR",SWIG_From_int((int)(24)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR5552RGB",SWIG_From_int((int)(25)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGRA2BGR555",SWIG_From_int((int)(26)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGBA2BGR555",SWIG_From_int((int)(27)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR5552BGRA",SWIG_From_int((int)(28)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR5552RGBA",SWIG_From_int((int)(29)));
  SWIG_Octave_SetConstant(module_ns,"CV_GRAY2BGR555",SWIG_From_int((int)(30)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR5552GRAY",SWIG_From_int((int)(31)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2XYZ",SWIG_From_int((int)(32)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2XYZ",SWIG_From_int((int)(33)));
  SWIG_Octave_SetConstant(module_ns,"CV_XYZ2BGR",SWIG_From_int((int)(34)));
  SWIG_Octave_SetConstant(module_ns,"CV_XYZ2RGB",SWIG_From_int((int)(35)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2YCrCb",SWIG_From_int((int)(36)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2YCrCb",SWIG_From_int((int)(37)));
  SWIG_Octave_SetConstant(module_ns,"CV_YCrCb2BGR",SWIG_From_int((int)(38)));
  SWIG_Octave_SetConstant(module_ns,"CV_YCrCb2RGB",SWIG_From_int((int)(39)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2HSV",SWIG_From_int((int)(40)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2HSV",SWIG_From_int((int)(41)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2Lab",SWIG_From_int((int)(44)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2Lab",SWIG_From_int((int)(45)));
  SWIG_Octave_SetConstant(module_ns,"CV_BayerBG2BGR",SWIG_From_int((int)(46)));
  SWIG_Octave_SetConstant(module_ns,"CV_BayerGB2BGR",SWIG_From_int((int)(47)));
  SWIG_Octave_SetConstant(module_ns,"CV_BayerRG2BGR",SWIG_From_int((int)(48)));
  SWIG_Octave_SetConstant(module_ns,"CV_BayerGR2BGR",SWIG_From_int((int)(49)));
  SWIG_Octave_SetConstant(module_ns,"CV_BayerBG2RGB",SWIG_From_int((int)(48)));
  SWIG_Octave_SetConstant(module_ns,"CV_BayerGB2RGB",SWIG_From_int((int)(49)));
  SWIG_Octave_SetConstant(module_ns,"CV_BayerRG2RGB",SWIG_From_int((int)(46)));
  SWIG_Octave_SetConstant(module_ns,"CV_BayerGR2RGB",SWIG_From_int((int)(47)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2Luv",SWIG_From_int((int)(50)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2Luv",SWIG_From_int((int)(51)));
  SWIG_Octave_SetConstant(module_ns,"CV_BGR2HLS",SWIG_From_int((int)(52)));
  SWIG_Octave_SetConstant(module_ns,"CV_RGB2HLS",SWIG_From_int((int)(53)));
  SWIG_Octave_SetConstant(module_ns,"CV_HSV2BGR",SWIG_From_int((int)(54)));
  SWIG_Octave_SetConstant(module_ns,"CV_HSV2RGB",SWIG_From_int((int)(55)));
  SWIG_Octave_SetConstant(module_ns,"CV_Lab2BGR",SWIG_From_int((int)(56)));
  SWIG_Octave_SetConstant(module_ns,"CV_Lab2RGB",SWIG_From_int((int)(57)));
  SWIG_Octave_SetConstant(module_ns,"CV_Luv2BGR",SWIG_From_int((int)(58)));
  SWIG_Octave_SetConstant(module_ns,"CV_Luv2RGB",SWIG_From_int((int)(59)));
  SWIG_Octave_SetConstant(module_ns,"CV_HLS2BGR",SWIG_From_int((int)(60)));
  SWIG_Octave_SetConstant(module_ns,"CV_HLS2RGB",SWIG_From_int((int)(61)));
  SWIG_Octave_SetConstant(module_ns,"CV_COLORCVT_MAX",SWIG_From_int((int)(100)));
  SWIG_Octave_SetConstant(module_ns,"CV_INTER_NN",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_INTER_LINEAR",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_INTER_CUBIC",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_INTER_AREA",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_WARP_FILL_OUTLIERS",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_WARP_INVERSE_MAP",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_SHAPE_RECT",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_SHAPE_CROSS",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_SHAPE_ELLIPSE",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_SHAPE_CUSTOM",SWIG_From_int((int)(100)));
  SWIG_Octave_SetConstant(module_ns,"CV_MOP_OPEN",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_MOP_CLOSE",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_MOP_GRADIENT",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_MOP_TOPHAT",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_MOP_BLACKHAT",SWIG_From_int((int)(6)));
  SWIG_Octave_SetConstant(module_ns,"CV_TM_SQDIFF",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_TM_SQDIFF_NORMED",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_TM_CCORR",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_TM_CCORR_NORMED",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_TM_CCOEFF",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_TM_CCOEFF_NORMED",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_LKFLOW_PYR_A_READY",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_LKFLOW_PYR_B_READY",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_LKFLOW_INITIAL_GUESSES",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_LKFLOW_GET_MIN_EIGENVALS",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_POLY_APPROX_DP",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_DOMINANT_IPAN",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_CONTOURS_MATCH_I1",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_CONTOURS_MATCH_I2",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_CONTOURS_MATCH_I3",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_CONTOUR_TREES_MATCH_I1",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_CLOCKWISE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_COUNTER_CLOCKWISE",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_COMP_CORREL",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_COMP_CHISQR",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_COMP_INTERSECT",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_COMP_BHATTACHARYYA",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_VALUE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_ARRAY",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_MASK_3",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_MASK_5",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_MASK_PRECISE",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_THRESH_BINARY",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_THRESH_BINARY_INV",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_THRESH_TRUNC",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_THRESH_TOZERO",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_THRESH_TOZERO_INV",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_THRESH_MASK",SWIG_From_int((int)(7)));
  SWIG_Octave_SetConstant(module_ns,"CV_THRESH_OTSU",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_ADAPTIVE_THRESH_MEAN_C",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_ADAPTIVE_THRESH_GAUSSIAN_C",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_FLOODFILL_FIXED_RANGE",SWIG_From_int((int)((1 << 16))));
  SWIG_Octave_SetConstant(module_ns,"CV_FLOODFILL_MASK_ONLY",SWIG_From_int((int)((1 << 17))));
  SWIG_Octave_SetConstant(module_ns,"CV_CANNY_L2_GRADIENT",SWIG_From_int((int)((1 << 31))));
  SWIG_Octave_SetConstant(module_ns,"CV_HOUGH_STANDARD",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_HOUGH_PROBABILISTIC",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_HOUGH_MULTI_SCALE",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_HOUGH_GRADIENT",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_HAAR_DO_CANNY_PRUNING",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_HAAR_SCALE_IMAGE",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_HAAR_FIND_BIGGEST_OBJECT",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_HAAR_DO_ROUGH_SEARCH",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_LMEDS",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_RANSAC",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_CB_ADAPTIVE_THRESH",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_CB_NORMALIZE_IMAGE",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_CB_FILTER_QUADS",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_USE_INTRINSIC_GUESS",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_FIX_ASPECT_RATIO",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_FIX_PRINCIPAL_POINT",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_ZERO_TANGENT_DIST",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_FIX_FOCAL_LENGTH",SWIG_From_int((int)(16)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_FIX_K1",SWIG_From_int((int)(32)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_FIX_K2",SWIG_From_int((int)(64)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_FIX_K3",SWIG_From_int((int)(128)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_FIX_INTRINSIC",SWIG_From_int((int)(256)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_SAME_FOCAL_LENGTH",SWIG_From_int((int)(512)));
  SWIG_Octave_SetConstant(module_ns,"CV_CALIB_ZERO_DISPARITY",SWIG_From_int((int)(1024)));
  SWIG_Octave_SetConstant(module_ns,"CV_FM_7POINT",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_FM_8POINT",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_FM_LMEDS_ONLY",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_FM_RANSAC_ONLY",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_FM_LMEDS",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_FM_RANSAC",SWIG_From_int((int)(8)));
  SWIG_Octave_SetConstant(module_ns,"CV_STEREO_BM_NORMALIZED_RESPONSE",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_STEREO_BM_BASIC",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_STEREO_BM_FISH_EYE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_STEREO_BM_NARROW",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_RETR_EXTERNAL",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_RETR_LIST",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_RETR_CCOMP",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_RETR_TREE",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_CHAIN_CODE",SWIG_From_int((int)(0)));
  SWIG_Octave_SetConstant(module_ns,"CV_CHAIN_APPROX_NONE",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_CHAIN_APPROX_SIMPLE",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_CHAIN_APPROX_TC89_L1",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_CHAIN_APPROX_TC89_KCOS",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_LINK_RUNS",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_SUBDIV2D_VIRTUAL_POINT_FLAG",SWIG_From_int((int)((1 << 30))));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_USER",SWIG_From_int((int)(-1)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_L1",SWIG_From_int((int)(1)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_L2",SWIG_From_int((int)(2)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_C",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_L12",SWIG_From_int((int)(4)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_FAIR",SWIG_From_int((int)(5)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_WELSCH",SWIG_From_int((int)(6)));
  SWIG_Octave_SetConstant(module_ns,"CV_DIST_HUBER",SWIG_From_int((int)(7)));
  SWIG_Octave_SetConstant(module_ns,"CV_HAAR_MAGIC_VAL",SWIG_From_int((int)(0x42500000)));
  SWIG_Octave_SetConstant(module_ns,"CV_TYPE_NAME_HAAR",SWIG_FromCharPtr("opencv-haar-classifier"));
  SWIG_Octave_SetConstant(module_ns,"CV_HAAR_FEATURE_MAX",SWIG_From_int((int)(3)));
  SWIG_Octave_SetConstant(module_ns,"CV_PTLOC_ERROR",SWIG_From_int((int)(CV_PTLOC_ERROR)));
  SWIG_Octave_SetConstant(module_ns,"CV_PTLOC_OUTSIDE_RECT",SWIG_From_int((int)(CV_PTLOC_OUTSIDE_RECT)));
  SWIG_Octave_SetConstant(module_ns,"CV_PTLOC_INSIDE",SWIG_From_int((int)(CV_PTLOC_INSIDE)));
  SWIG_Octave_SetConstant(module_ns,"CV_PTLOC_VERTEX",SWIG_From_int((int)(CV_PTLOC_VERTEX)));
  SWIG_Octave_SetConstant(module_ns,"CV_PTLOC_ON_EDGE",SWIG_From_int((int)(CV_PTLOC_ON_EDGE)));
  SWIG_Octave_SetConstant(module_ns,"CV_NEXT_AROUND_ORG",SWIG_From_int((int)(CV_NEXT_AROUND_ORG)));
  SWIG_Octave_SetConstant(module_ns,"CV_NEXT_AROUND_DST",SWIG_From_int((int)(CV_NEXT_AROUND_DST)));
  SWIG_Octave_SetConstant(module_ns,"CV_PREV_AROUND_ORG",SWIG_From_int((int)(CV_PREV_AROUND_ORG)));
  SWIG_Octave_SetConstant(module_ns,"CV_PREV_AROUND_DST",SWIG_From_int((int)(CV_PREV_AROUND_DST)));
  SWIG_Octave_SetConstant(module_ns,"CV_NEXT_AROUND_LEFT",SWIG_From_int((int)(CV_NEXT_AROUND_LEFT)));
  SWIG_Octave_SetConstant(module_ns,"CV_NEXT_AROUND_RIGHT",SWIG_From_int((int)(CV_NEXT_AROUND_RIGHT)));
  SWIG_Octave_SetConstant(module_ns,"CV_PREV_AROUND_LEFT",SWIG_From_int((int)(CV_PREV_AROUND_LEFT)));
  SWIG_Octave_SetConstant(module_ns,"CV_PREV_AROUND_RIGHT",SWIG_From_int((int)(CV_PREV_AROUND_RIGHT)));
  SWIG_Octave_SetConstant(module_ns,"CV_GAUSSIAN_5x5",SWIG_From_int((int)(CV_GAUSSIAN_5x5)));
  
  cvRedirectError(function_ptr_generator(), void_ptr_generator(), void_ptrptr_generator());
  
}

