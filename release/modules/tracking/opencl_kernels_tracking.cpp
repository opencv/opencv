// This file is auto-generated. Do not edit!

#include "precomp.hpp"
#include "cvconfig.h"
#include "opencl_kernels_tracking.hpp"

#ifdef HAVE_OPENCL

namespace cv
{
namespace ocl
{
namespace tracking
{

const struct ProgramEntry tldDetector={"tldDetector",
"__kernel void NCC(__global const uchar *patch,\n"
"__global const uchar *positiveSamples,\n"
"__global const uchar *negativeSamples,\n"
"__global float *ncc,\n"
"int posNum,\n"
"int negNum)\n"
"{\n"
"int id = get_global_id(0);\n"
"if (id >= 1000) return;\n"
"bool posFlg;\n"
"if (id < 500)\n"
"posFlg = true;\n"
"if (id >= 500)\n"
"{\n"
"id = id - 500;\n"
"posFlg = false;\n"
"}\n"
"int s1 = 0, s2 = 0, n1 = 0, n2 = 0, prod = 0;\n"
"float sq1 = 0, sq2 = 0, ares = 0;\n"
"int N = 225;\n"
"if (posFlg && id < posNum)\n"
"{\n"
"for (int i = 0; i < N; i++)\n"
"{\n"
"s1 += positiveSamples[id * N + i];\n"
"s2 += patch[i];\n"
"n1 += positiveSamples[id * N + i] * positiveSamples[id * N + i];\n"
"n2 += patch[i] * patch[i];\n"
"prod += positiveSamples[id * N + i] * patch[i];\n"
"}\n"
"sq1 = sqrt(max(0.0, n1 - 1.0 * s1 * s1 / N));\n"
"sq2 = sqrt(max(0.0, n2 - 1.0 * s2 * s2 / N));\n"
"ares = (sq2 == 0) ? sq1 / fabs(sq1) : (prod - s1 * s2 / N) / sq1 / sq2;\n"
"ncc[id] = ares;\n"
"}\n"
"if (!posFlg && id < negNum)\n"
"{\n"
"for (int i = 0; i < N; i++)\n"
"{\n"
"s1 += negativeSamples[id * N + i];\n"
"s2 += patch[i];\n"
"n1 += negativeSamples[id * N + i] * negativeSamples[id * N + i];\n"
"n2 += patch[i] * patch[i];\n"
"prod += negativeSamples[id * N + i] * patch[i];\n"
"}\n"
"sq1 = sqrt(max(0.0, n1 - 1.0 * s1 * s1 / N));\n"
"sq2 = sqrt(max(0.0, n2 - 1.0 * s2 * s2 / N));\n"
"ares = (sq2 == 0) ? sq1 / fabs(sq1) : (prod - s1 * s2 / N) / sq1 / sq2;\n"
"ncc[id+500] = ares;\n"
"}\n"
"}\n"
"__kernel void batchNCC(__global const uchar *patches,\n"
"__global const uchar *positiveSamples,\n"
"__global const uchar *negativeSamples,\n"
"__global float *posNcc,\n"
"__global float *negNcc,\n"
"int posNum,\n"
"int negNum,\n"
"int patchNum)\n"
"{\n"
"int id = get_global_id(0);\n"
"bool posFlg;\n"
"if (id < 500*patchNum)\n"
"posFlg = true;\n"
"if (id >= 500*patchNum)\n"
"{\n"
"id = id - 500*patchNum;\n"
"posFlg = false;\n"
"}\n"
"int modelSampleID = id % 500;\n"
"int patchID = id / 500;\n"
"int s1 = 0, s2 = 0, n1 = 0, n2 = 0, prod = 0;\n"
"float sq1 = 0, sq2 = 0, ares = 0;\n"
"int N = 225;\n"
"if (posFlg && modelSampleID < posNum)\n"
"{\n"
"for (int i = 0; i < N; i++)\n"
"{\n"
"s1 += positiveSamples[modelSampleID * N + i];\n"
"s2 += patches[patchID*N + i];\n"
"n1 += positiveSamples[modelSampleID * N + i] * positiveSamples[modelSampleID * N + i];\n"
"n2 += patches[patchID*N + i] * patches[patchID*N + i];\n"
"prod += positiveSamples[modelSampleID * N + i] * patches[patchID*N + i];\n"
"}\n"
"sq1 = sqrt(max(0.0, n1 - 1.0 * s1 * s1 / N));\n"
"sq2 = sqrt(max(0.0, n2 - 1.0 * s2 * s2 / N));\n"
"ares = (sq2 == 0) ? sq1 / fabs(sq1) : (prod - s1 * s2 / N) / sq1 / sq2;\n"
"posNcc[id] = ares;\n"
"}\n"
"if (!posFlg && modelSampleID < negNum)\n"
"{\n"
"for (int i = 0; i < N; i++)\n"
"{\n"
"s1 += negativeSamples[modelSampleID * N + i];\n"
"s2 += patches[patchID*N + i];\n"
"n1 += negativeSamples[modelSampleID * N + i] * negativeSamples[modelSampleID * N + i];\n"
"n2 += patches[patchID*N + i] * patches[patchID*N + i];\n"
"prod += negativeSamples[modelSampleID * N + i] * patches[patchID*N + i];\n"
"}\n"
"sq1 = sqrt(max(0.0, n1 - 1.0 * s1 * s1 / N));\n"
"sq2 = sqrt(max(0.0, n2 - 1.0 * s2 * s2 / N));\n"
"ares = (sq2 == 0) ? sq1 / fabs(sq1) : (prod - s1 * s2 / N) / sq1 / sq2;\n"
"negNcc[id] = ares;\n"
"}\n"
"}\n"
, "f15ba33f44bb0051df83a2b52cf9d67f"};
ProgramSource tldDetector_oclsrc(tldDetector.programStr);
}
}}
#endif
