\section{Image Filtering}

Functions and classes described in this section are used to perform various linear or non-linear filtering operations on 2D images.

See also: \hyperref[section.cpp.cpu.ImageFiltering]{Image Filtering}


\cvclass{gpu::BaseRowFilter\_GPU}\label{class.gpu.BaseRowFilter}
The base class for linear or non-linear filters that processes rows of 2D arrays. Such filters are used for the "horizontal" filtering passes in separable filters.

\begin{lstlisting}
class BaseRowFilter_GPU
{
public:
    BaseRowFilter_GPU(int ksize_, int anchor_);
    virtual ~BaseRowFilter_GPU() {}
    virtual void operator()(const GpuMat& src, GpuMat& dst) = 0;
    int ksize, anchor;
};
\end{lstlisting}


\cvclass{gpu::BaseColumnFilter\_GPU}\label{class.gpu.BaseColumnFilter}
The base class for linear or non-linear filters that processes columns of 2D arrays. Such filters are used for the "vertical" filtering passes in separable filters.

\begin{lstlisting}
class BaseColumnFilter_GPU
{
public:
    BaseColumnFilter_GPU(int ksize_, int anchor_);
    virtual ~BaseColumnFilter_GPU() {}
    virtual void operator()(const GpuMat& src, GpuMat& dst) = 0;
    int ksize, anchor;
};
\end{lstlisting}


\cvclass{gpu::BaseFilter\_GPU}\label{class.gpu.BaseFilter}
The base class for non-separable 2D filters. 

\begin{lstlisting}
class CV_EXPORTS BaseFilter_GPU
{
public:
    BaseFilter_GPU(const Size& ksize_, const Point& anchor_);
    virtual ~BaseFilter_GPU() {}
    virtual void operator()(const GpuMat& src, GpuMat& dst) = 0;
    Size ksize;
    Point anchor;
};
\end{lstlisting}


\cvclass{gpu::FilterEngine\_GPU}\label{class.gpu.FilterEngine}
The base class for Filter Engine.

\begin{lstlisting}
class CV_EXPORTS FilterEngine_GPU
{
public:
    virtual ~FilterEngine_GPU() {}

    virtual void apply(const GpuMat& src, GpuMat& dst, 
                       Rect roi = Rect(0,0,-1,-1)) = 0;
};
\end{lstlisting}

The class can be used to apply an arbitrary filtering operation to an image. It contains all the necessary intermediate buffers. Pointers to the initialized \texttt{FilterEngine\_GPU} instances are returned by various \texttt{create*Filter\_GPU} functions, see below, and they are used inside high-level functions such as \cvCppCross{gpu::filter2D}, \cvCppCross{gpu::erode}, \cvCppCross{gpu::Sobel} etc.

By using \texttt{FilterEngine\_GPU} instead of functions you can avoid unnecessary memory allocation for intermediate buffers and get much better performance:

\begin{lstlisting}
while (...)
{
    cv::gpu::GpuMat src = getImg();
    cv::gpu::GpuMat dst;
    // Allocate and release buffers at each iterations
    cv::gpu::GaussianBlur(src, dst, ksize, sigma1);
}

// Allocate buffers only once
cv::Ptr<cv::gpu::FilterEngine_GPU> filter = 
    cv::gpu::createGaussianFilter_GPU(CV_8UC4, ksize, sigma1);
while (...)
{
    cv::gpu::GpuMat src = getImg();
    cv::gpu::GpuMat dst;
    filter->apply(src, dst, cv::Rect(0, 0, src.cols, src.rows));
}
// Release buffers only once
filter.release();
\end{lstlisting}

\texttt{FilterEngine\_GPU} can process a rectangular sub-region of an image. By default, if \texttt{roi == Rect(0,0,-1,-1)}, \texttt{FilterEngine\_GPU} process inner region of image (\texttt{Rect(anchor.x, anchor.y, src\_size.width - ksize.width, src\_size.height - ksize.height)}), because some filters doesn't check indexes outside the image for better perfomace. Which filters supports processing the whole image and which not and image type limitations see below.

The GPU filters doesn't support the in-place mode.

See also: \hyperref[class.gpu.BaseRowFilter]{cv::gpu::BaseRowFilter\_GPU}, \hyperref[class.gpu.BaseColumnFilter]{cv::gpu::BaseColumnFilter\_GPU}, \hyperref[class.gpu.BaseFilter]{cv::gpu::BaseFilter\_GPU}, \hyperref[cppfunc.gpu.createFilter2D]{cv::gpu::createFilter2D\_GPU}, \hyperref[cppfunc.gpu.createSeparableFilter]{cv::gpu::createSeparableFilter\_GPU}, \hyperref[cppfunc.gpu.createBoxFilter]{cv::gpu::createBoxFilter\_GPU}, \hyperref[cppfunc.gpu.createMorphologyFilter]{cv::gpu::createMorphologyFilter\_GPU}, \hyperref[cppfunc.gpu.createLinearFilter]{cv::gpu::createLinearFilter\_GPU}, \hyperref[cppfunc.gpu.createSeparableLinearFilter]{cv::gpu::createSeparableLinearFilter\_GPU}, \hyperref[cppfunc.gpu.createDerivFilter]{cv::gpu::createDerivFilter\_GPU}, \hyperref[cppfunc.gpu.createGaussianFilter]{cv::gpu::createGaussianFilter\_GPU}


\cvfunc{cv::gpu::createFilter2D\_GPU}\label{cppfunc.gpu.createFilter2D}
Creates non-separable filter engine with the specified filter.

\cvdefCpp{
Ptr<FilterEngine\_GPU> createFilter2D\_GPU(\par const Ptr<BaseFilter\_GPU>\& filter2D, \par int srcType, int dstType);
}

\begin{description}
\cvarg{filter2D} {Non-separable 2D filter.}
\cvarg{srcType}{Input image type. It must be supported by \texttt{filter2D}.}
\cvarg{dstType}{Output image type. It must be supported by \texttt{filter2D}.}
\end{description}

Usually this function is used inside high-level functions, like \hyperref[cppfunc.gpu.createLinearFilter]{cv::gpu::createLinearFilter\_GPU}, \hyperref[cppfunc.gpu.createBoxFilter]{cv::gpu::createBoxFilter\_GPU}.


\cvfunc{cv::gpu::createSeparableFilter\_GPU}\label{cppfunc.gpu.createSeparableFilter}
Creates separable filter engine with the specified filters.

\cvdefCpp{
Ptr<FilterEngine\_GPU> createSeparableFilter\_GPU(\par const Ptr<BaseRowFilter\_GPU>\& rowFilter, \par const Ptr<BaseColumnFilter\_GPU>\& columnFilter, \par int srcType, int bufType, int dstType);
}

\begin{description}
\cvarg{rowFilter} {"Horizontal" 1D filter.}
\cvarg{columnFilter} {"Vertical" 1D filter.}
\cvarg{srcType}{Input image type. It must be supported by \texttt{rowFilter}.}
\cvarg{bufType}{Buffer image type. It must be supported by \texttt{rowFilter} and \texttt{columnFilter}.}
\cvarg{dstType}{Output image type. It must be supported by \texttt{columnFilter}.}
\end{description}

Usually this function is used inside high-level functions, like \hyperref[cppfunc.gpu.createSeparableLinearFilter]{cv::gpu::createSeparableLinearFilter\_GPU}.


\cvfunc{cv::gpu::getRowSumFilter\_GPU}\label{cppfunc.gpu.getRowSumFilter}
Creates horizontal 1D box filter.

\cvdefCpp{
Ptr<BaseRowFilter\_GPU> getRowSumFilter\_GPU(int srcType, int sumType, \par int ksize, int anchor = -1);
}

\begin{description}
\cvarg{srcType}{Input image type. Only \texttt{CV\_8UC1} type is supported for now.}
\cvarg{sumType}{Output image type. Only \texttt{CV\_32FC1} type is supported for now.}
\cvarg{ksize}{Kernel size.}
\cvarg{anchor}{Anchor point. The default value (-1) means that the anchor is at the kernel center.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area. 


\cvfunc{cv::gpu::getColumnSumFilter\_GPU}\label{cppfunc.gpu.getColumnSumFilter}
Creates vertical 1D box filter.

\cvdefCpp{
Ptr<BaseColumnFilter\_GPU> getColumnSumFilter\_GPU(int sumType, \par int dstType, int ksize, int anchor = -1);
}

\begin{description}
\cvarg{sumType}{Input image type. Only \texttt{CV\_8UC1} type is supported for now.}
\cvarg{dstType}{Output image type. Only \texttt{CV\_32FC1} type is supported for now.}
\cvarg{ksize}{Kernel size.}
\cvarg{anchor}{Anchor point. The default value (-1) means that the anchor is at the kernel center.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area. 


\cvfunc{cv::gpu::createBoxFilter\_GPU}\label{cppfunc.gpu.createBoxFilter}
Creates normalized 2D box filter.

\cvdefCpp{
Ptr<FilterEngine\_GPU> createBoxFilter\_GPU(int srcType, int dstType, \par const Size\& ksize, \par const Point\& anchor = Point(-1,-1));
}
\cvdefCpp{
Ptr<BaseFilter\_GPU> getBoxFilter\_GPU(int srcType, int dstType, \par const Size\& ksize, \par Point anchor = Point(-1, -1));
}

\begin{description}
\cvarg{srcType}{Input image type. Supports \texttt{CV\_8UC1} and \texttt{CV\_8UC4}.}
\cvarg{dstType}{Output image type. Supports only the same as source type.}
\cvarg{ksize}{Kernel size.}
\cvarg{anchor}{Anchor point. The default value Point(-1, -1) means that the anchor is at the kernel center.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area.

See also: \cvCppCross{boxFilter}.


\cvCppFunc{gpu::boxFilter}
Smooths the image using the normalized box filter.

\cvdefCpp{
void boxFilter(const GpuMat\& src, GpuMat\& dst, int ddepth, Size ksize, \par Point anchor = Point(-1,-1));
}

\begin{description}
\cvarg{src}{Input image. Supports \texttt{CV\_8UC1} and \texttt{CV\_8UC4} source types.}
\cvarg{dst}{Output image type. Will have the same size and the same type as \texttt{src}.}
\cvarg{ddepth}{Output image depth. Support only the same as source depth (\texttt{CV\_8U}) or -1 what means use source depth.}
\cvarg{ksize}{Kernel size.}
\cvarg{anchor}{Anchor point. The default value Point(-1, -1) means that the anchor is at the kernel center.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area.

See also: \cvCppCross{boxFilter}, \hyperref[cppfunc.gpu.createBoxFilter]{cv::gpu::createBoxFilter\_GPU}.


\cvCppFunc{gpu::blur}
A synonym for normalized box filter.

\cvdefCpp{
void blur(const GpuMat\& src, GpuMat\& dst, Size ksize, \par Point anchor = Point(-1,-1));
}

\begin{description}
\cvarg{src}{Input image. Supports \texttt{CV\_8UC1} and \texttt{CV\_8UC4} source type.}
\cvarg{dst}{Output image type. Will have the same size and the same type as \texttt{src}.}
\cvarg{ksize}{Kernel size.}
\cvarg{anchor}{Anchor point. The default value Point(-1, -1) means that the anchor is at the kernel center.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area.

See also: \cvCppCross{blur}, \cvCppCross{gpu::boxFilter}.


\cvfunc{cv::gpu::createMorphologyFilter\_GPU}\label{cppfunc.gpu.createMorphologyFilter}
Creates 2D morphological filter.

\cvdefCpp{
Ptr<FilterEngine\_GPU> createMorphologyFilter\_GPU(int op, int type, \par const Mat\& kernel, \par const Point\& anchor = Point(-1,-1), \par int iterations = 1);
}
\cvdefCpp{
Ptr<BaseFilter\_GPU> getMorphologyFilter\_GPU(int op, int type, \par const Mat\& kernel, const Size\& ksize, \par Point anchor=Point(-1,-1));
}

\begin{description}
\cvarg{op} {Morphology operation id. Only \texttt{MORPH\_ERODE} and \texttt{MORPH\_DILATE} are supported.}
\cvarg{type}{Input/output image type. Only \texttt{CV\_8UC1} and \texttt{CV\_8UC4} are supported.}
\cvarg{kernel}{2D 8-bit structuring element for the morphological operation.}
\cvarg{size}{Horizontal or vertical structuring element size for separable morphological operations.}
\cvarg{anchor}{Anchor position within the structuring element; negative values mean that the anchor is at the center.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area.

See also: \cvCppCross{createMorphologyFilter}.


\cvCppFunc{gpu::erode}
Erodes an image by using a specific structuring element.

\cvdefCpp{
void erode(const GpuMat\& src, GpuMat\& dst, const Mat\& kernel, \par Point anchor = Point(-1, -1), \par int iterations = 1);
}

\begin{description}
\cvarg{src}{Source image. Only \texttt{CV\_8UC1} and \texttt{CV\_8UC4} types are supported.}
\cvarg{dst}{Destination image. It will have the same size and the same type as \texttt{src}.}
\cvarg{kernel}{Structuring element used for dilation. If \texttt{kernel=Mat()}, a $3 \times 3$ rectangular structuring element is used.}
\cvarg{anchor}{Position of the anchor within the element. The default value $(-1, -1)$ means that the anchor is at the element center.}
\cvarg{iterations}{Number of times erosion to be applied.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area.

See also: \cvCppCross{erode}, \hyperref[cppfunc.gpu.createMorphologyFilter]{cv::gpu::createMorphologyFilter\_GPU}.


\cvCppFunc{gpu::dilate}
Dilates an image by using a specific structuring element.

\cvdefCpp{
void dilate(const GpuMat\& src, GpuMat\& dst, const Mat\& kernel, \par Point anchor = Point(-1, -1), \par int iterations = 1);
}

\begin{description}
\cvarg{src}{Source image. Supports \texttt{CV\_8UC1} and \texttt{CV\_8UC4} source types.}
\cvarg{dst}{Destination image. It will have the same size and the same type as \texttt{src}.}
\cvarg{kernel}{Structuring element used for dilation. If \texttt{kernel=Mat()}, a $3 \times 3$ rectangular structuring element is used.}
\cvarg{anchor}{Position of the anchor within the element. The default value $(-1, -1)$ means that the anchor is at the element center.}
\cvarg{iterations}{Number of times dilation to be applied.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area.

See also: \cvCppCross{dilate}, \hyperref[cppfunc.gpu.createMorphologyFilter]{cv::gpu::createMorphologyFilter\_GPU}.


\cvCppFunc{gpu::morphologyEx}
Applies an advanced morphological operation to image.

\cvdefCpp{
void morphologyEx(const GpuMat\& src, GpuMat\& dst, int op, \par const Mat\& kernel, \par Point anchor = Point(-1, -1), \par int iterations = 1);
}

\begin{description}
\cvarg{src}{Source image. Supports \texttt{CV\_8UC1} and \texttt{CV\_8UC4} source type.}
\cvarg{dst}{Destination image. It will have the same size and the same type as \texttt{src}}
\cvarg{op}{Type of morphological operation, one of the following:
\begin{description}
\cvarg{MORPH\_OPEN}{opening}
\cvarg{MORPH\_CLOSE}{closing}
\cvarg{MORPH\_GRADIENT}{morphological gradient}
\cvarg{MORPH\_TOPHAT}{"top hat"}
\cvarg{MORPH\_BLACKHAT}{"black hat"}
\end{description}}
\cvarg{kernel}{Structuring element.}
\cvarg{anchor}{Position of the anchor within the element. The default value Point(-1, -1) means that the anchor is at the element center.}
\cvarg{iterations}{Number of times erosion and dilation to be applied.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area.

See also: \cvCppCross{morphologyEx}.


\cvfunc{cv::gpu::createLinearFilter\_GPU}\label{cppfunc.gpu.createLinearFilter}
Creates the non-separable linear filter.

\cvdefCpp{
Ptr<FilterEngine\_GPU> createLinearFilter\_GPU(int srcType, int dstType, \par const Mat\& kernel, \par const Point\& anchor = Point(-1,-1));
}
\cvdefCpp{
Ptr<BaseFilter\_GPU> getLinearFilter\_GPU(int srcType, int dstType, \par const Mat\& kernel, const Size\& ksize, \par Point anchor = Point(-1, -1));
}

\begin{description}
\cvarg{srcType}{Input image type. Supports \texttt{CV\_8UC1} and \texttt{CV\_8UC4}.}
\cvarg{dstType}{Output image type. Supports only the same as source type.}
\cvarg{kernel}{2D array of filter coefficients. This filter works with integers kernels, if \texttt{kernel} has \texttt{float} or \texttt{double} type it will be used fixed point arithmetic.}
\cvarg{ksize}{Kernel size.}
\cvarg{anchor}{Anchor point. The default value Point(-1, -1) means that the anchor is at the kernel center.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area.

See also: \cvCppCross{createLinearFilter}.


\cvCppFunc{gpu::filter2D}
Applies non-separable 2D linear filter to image.

\cvdefCpp{
void filter2D(const GpuMat\& src, GpuMat\& dst, int ddepth, \par const Mat\& kernel, \par Point anchor=Point(-1,-1));
}

\begin{description}
\cvarg{src}{Source image. Supports \texttt{CV\_8UC1} and \texttt{CV\_8UC4} source types.}
\cvarg{dst}{Destination image. It will have the same size and the same number of channels as \texttt{src}.}
\cvarg{ddepth}{The desired depth of the destination image. If it is negative, it will be the same as \texttt{src.depth()}. Supports only the same depth as source image.}
\cvarg{kernel}{2D array of filter coefficients. This filter works with integers kernels, if \texttt{kernel} has \texttt{float} or \texttt{double} type it will use fixed point arithmetic.}
\cvarg{anchor}{Anchor of the kernel that indicates the relative position of a filtered point within the kernel. The anchor should lie within the kernel. The special default value (-1,-1) means that the anchor is at the kernel center.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area.

See also: \cvCppCross{filter2D}, \hyperref[cppfunc.gpu.createLinearFilter]{cv::gpu::createLinearFilter\_GPU}.


\cvCppFunc{gpu::Laplacian}
Applies Laplacian operator to image.

\cvdefCpp{
void Laplacian(const GpuMat\& src, GpuMat\& dst, int ddepth, \par int ksize = 1, double scale = 1);
}

\begin{description}
\cvarg{src}{Source image. Supports \texttt{CV\_8UC1} and \texttt{CV\_8UC4} source types.}
\cvarg{dst}{Destination image; will have the same size and the same number of channels as \texttt{src}.}
\cvarg{ddepth}{Desired depth of the destination image. Supports only tha same depth as source image depth.}
\cvarg{ksize}{Aperture size used to compute the second-derivative filters, see \cvCppCross{getDerivKernels}. It must be positive and odd. Supports only \texttt{ksize} = 1 and \texttt{ksize} = 3.}
\cvarg{scale}{Optional scale factor for the computed Laplacian values (by default, no scaling is applied, see \cvCppCross{getDerivKernels}).}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area.

See also: \cvCppCross{Laplacian}, \cvCppCross{gpu::filter2D}.


\cvfunc{cv::gpu::getLinearRowFilter\_GPU}\label{cppfunc.gpu.getLinearRowFilter}
Creates primitive row filter with the specified kernel.

\cvdefCpp{
Ptr<BaseRowFilter\_GPU> getLinearRowFilter\_GPU(int srcType, \par int bufType, const Mat\& rowKernel, int anchor = -1, \par int borderType = BORDER\_CONSTANT);
}

\begin{description}
\cvarg{srcType}{Source array type. Supports only \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_16SC1}, \texttt{CV\_16SC2}, \texttt{CV\_32SC1}, \texttt{CV\_32FC1} source types.}
\cvarg{bufType}{Inermediate buffer type; must have as many channels as \texttt{srcType}.}
\cvarg{rowKernel}{Filter coefficients.}
\cvarg{anchor}{Anchor position within the kernel; negative values mean that anchor is positioned at the aperture center.}
\cvarg{borderType}{Pixel extrapolation method; see \cvCppCross{borderInterpolate}. About limitation see below.}
\end{description}

There are two version of algorithm: NPP and OpenCV. NPP calls when \texttt{srcType == CV\_8UC1} or \texttt{srcType == CV\_8UC4} and \texttt{bufType == srcType}, otherwise calls OpenCV version. NPP supports only \texttt{BORDER\_CONSTANT} border type and doesn't check indexes outside image. OpenCV version supports only \texttt{CV\_32F} buffer depth and \texttt{BORDER\_REFLECT101}, \texttt{BORDER\_REPLICATE} and \texttt{BORDER\_CONSTANT} border types and checks indexes outside image.

See also: \hyperref[cppfunc.gpu.getLinearColumnFilter]{cv::gpu::getLinearColumnFilter\_GPU}, \cvCppCross{createSeparableLinearFilter}.


\cvfunc{cv::gpu::getLinearColumnFilter\_GPU}\label{cppfunc.gpu.getLinearColumnFilter}
Creates the primitive column filter with the specified kernel.

\cvdefCpp{
Ptr<BaseColumnFilter\_GPU> getLinearColumnFilter\_GPU(int bufType, \par int dstType, const Mat\& columnKernel, int anchor = -1, \par int borderType = BORDER\_CONSTANT);
}

\begin{description}
\cvarg{bufType}{Inermediate buffer type; must have as many channels as \texttt{dstType}.}
\cvarg{dstType}{Destination array type. Supports \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_16SC1}, \texttt{CV\_16SC2}, \texttt{CV\_32SC1}, \texttt{CV\_32FC1} destination types.}
\cvarg{columnKernel}{Filter coefficients.}
\cvarg{anchor}{Anchor position within the kernel; negative values mean that anchor is positioned at the aperture center.}
\cvarg{borderType}{Pixel extrapolation method; see \cvCppCross{borderInterpolate}. About limitation see below.}
\end{description}

There are two version of algorithm: NPP and OpenCV. NPP calls when \texttt{dstType == CV\_8UC1} or \texttt{dstType == CV\_8UC4} and \texttt{bufType == dstType}, otherwise calls OpenCV version. NPP supports only \texttt{BORDER\_CONSTANT} border type and doesn't check indexes outside image. OpenCV version supports only \texttt{CV\_32F} buffer depth and \texttt{BORDER\_REFLECT101}, \texttt{BORDER\_REPLICATE} and \texttt{BORDER\_CONSTANT} border types and checks indexes outside image.\newline

See also: \hyperref[cppfunc.gpu.getLinearRowFilter]{cv::gpu::getLinearRowFilter\_GPU}, \cvCppCross{createSeparableLinearFilter}.


\cvfunc{cv::gpu::createSeparableLinearFilter\_GPU}\label{cppfunc.gpu.createSeparableLinearFilter}
Creates the separable linear filter engine.

\cvdefCpp{
Ptr<FilterEngine\_GPU> createSeparableLinearFilter\_GPU(int srcType, \par int dstType, const Mat\& rowKernel, const Mat\& columnKernel, \par const Point\& anchor = Point(-1,-1), \par int rowBorderType = BORDER\_DEFAULT, \par int columnBorderType = -1);
}

\begin{description}
\cvarg{srcType}{Source array type. Supports \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_16SC1}, \texttt{CV\_16SC2}, \texttt{CV\_32SC1}, \texttt{CV\_32FC1} source types.}
\cvarg{dstType}{Destination array type. Supports \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_16SC1}, \texttt{CV\_16SC2}, \texttt{CV\_32SC1}, \texttt{CV\_32FC1} destination types.}
\cvarg{rowKernel, columnKernel}{Filter coefficients.}
\cvarg{anchor}{Anchor position within the kernel; negative values mean that anchor is positioned at the aperture center.}
\cvarg{rowBorderType, columnBorderType}{Pixel extrapolation method in the horizontal and the vertical directions; see \cvCppCross{borderInterpolate}. About limitation see \hyperref[cppfunc.gpu.getLinearRowFilter]{cv::gpu::getLinearRowFilter\_GPU}, \hyperref[cppfunc.gpu.getLinearColumnFilter]{cv::gpu::getLinearColumnFilter\_GPU}.}
\end{description}

See also: \hyperref[cppfunc.gpu.getLinearRowFilter]{cv::gpu::getLinearRowFilter\_GPU}, \hyperref[cppfunc.gpu.getLinearColumnFilter]{cv::gpu::getLinearColumnFilter\_GPU}, \cvCppCross{createSeparableLinearFilter}.


\cvCppFunc{gpu::sepFilter2D}
Applies separable 2D linear filter to the image.

\cvdefCpp{
void sepFilter2D(const GpuMat\& src, GpuMat\& dst, int ddepth, \par const Mat\& kernelX, const Mat\& kernelY, \par Point anchor = Point(-1,-1), \par int rowBorderType = BORDER\_DEFAULT, \par int columnBorderType = -1);
}

\begin{description}
\cvarg{src}{Source image. Supports \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_16SC1}, \texttt{CV\_16SC2}, \texttt{CV\_32SC1}, \texttt{CV\_32FC1} source types.}
\cvarg{dst}{Destination image; will have the same size and the same number of channels as \texttt{src}.}
\cvarg{ddepth}{Destination image depth. Supports \texttt{CV\_8U}, \texttt{CV\_16S}, \texttt{CV\_32S} and \texttt{CV\_32F}.}
\cvarg{kernelX, kernelY}{Filter coefficients.}
\cvarg{anchor}{Anchor position within the kernel; The default value $(-1, 1)$ means that the anchor is at the kernel center.}
\cvarg{rowBorderType, columnBorderType}{Pixel extrapolation method; see \cvCppCross{borderInterpolate}.}
\end{description}

See also: \hyperref[cppfunc.gpu.createSeparableLinearFilter]{cv::gpu::createSeparableLinearFilter\_GPU}, \cvCppCross{sepFilter2D}.


\cvfunc{cv::gpu::createDerivFilter\_GPU}\label{cppfunc.gpu.createDerivFilter}
Creates filter engine for the generalized Sobel operator.

\cvdefCpp{
Ptr<FilterEngine\_GPU> createDerivFilter\_GPU(int srcType, int dstType, \par int dx, int dy, int ksize, \par int rowBorderType = BORDER\_DEFAULT, \par int columnBorderType = -1);
}

\begin{description}
\cvarg{srcType}{Source image type. Supports \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_16SC1}, \texttt{CV\_16SC2}, \texttt{CV\_32SC1}, \texttt{CV\_32FC1} source types.}
\cvarg{dstType}{Destination image type; must have as many channels as \texttt{srcType}. Supports \texttt{CV\_8U}, \texttt{CV\_16S}, \texttt{CV\_32S} and \texttt{CV\_32F} depths.}
\cvarg{dx}{Derivative order in respect with x.}
\cvarg{dy}{Derivative order in respect with y.}
\cvarg{ksize}{Aperture size; see \cvCppCross{getDerivKernels}.}
\cvarg{rowBorderType, columnBorderType}{Pixel extrapolation method; see \cvCppCross{borderInterpolate}.}
\end{description}

See also: \hyperref[cppfunc.gpu.createSeparableLinearFilter]{cv::gpu::createSeparableLinearFilter\_GPU}, \cvCppCross{createDerivFilter}.


\cvCppFunc{gpu::Sobel}
Applies generalized Sobel operator to the image.

\cvdefCpp{
void Sobel(const GpuMat\& src, GpuMat\& dst, int ddepth, int dx, int dy, \par int ksize = 3, double scale = 1, \par int rowBorderType = BORDER\_DEFAULT, \par int columnBorderType = -1);
}

\begin{description}
\cvarg{src}{Source image. Supports \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_16SC1}, \texttt{CV\_16SC2}, \texttt{CV\_32SC1}, \texttt{CV\_32FC1} source types.}
\cvarg{dst}{Destination image. Will have the same size and number of channels as source image.}
\cvarg{ddepth}{Destination image depth. Supports \texttt{CV\_8U}, \texttt{CV\_16S}, \texttt{CV\_32S} and \texttt{CV\_32F}.}
\cvarg{dx}{Derivative order in respect with x.}
\cvarg{dy}{Derivative order in respect with y.}
\cvarg{ksize}{Size of the extended Sobel kernel, must be 1, 3, 5 or 7.}
\cvarg{scale}{Optional scale factor for the computed derivative values (by default, no scaling is applied, see \cvCppCross{getDerivKernels}).}
\cvarg{rowBorderType, columnBorderType}{Pixel extrapolation method; see \cvCppCross{borderInterpolate}.}
\end{description}

See also: \hyperref[cppfunc.gpu.createSeparableLinearFilter]{cv::gpu::createSeparableLinearFilter\_GPU}, \cvCppCross{Sobel}.


\cvCppFunc{gpu::Scharr}
Calculates the first x- or y- image derivative using Scharr operator.

\cvdefCpp{
void Scharr(const GpuMat\& src, GpuMat\& dst, int ddepth, \par int dx, int dy, double scale = 1, \par int rowBorderType = BORDER\_DEFAULT, \par int columnBorderType = -1);
}

\begin{description}
\cvarg{src}{Source image. Supports \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_16SC1}, \texttt{CV\_16SC2}, \texttt{CV\_32SC1}, \texttt{CV\_32FC1} source types.}
\cvarg{dst}{Destination image; will have the same size and the same number of channels as \texttt{src}.}
\cvarg{ddepth}{Destination image depth. Supports \texttt{CV\_8U}, \texttt{CV\_16S}, \texttt{CV\_32S} and \texttt{CV\_32F}.}
\cvarg{xorder}{Order of the derivative x.}
\cvarg{yorder}{Order of the derivative y.}
\cvarg{scale}{Optional scale factor for the computed derivative values (by default, no scaling is applied, see \cvCppCross{getDerivKernels}).}
\cvarg{rowBorderType, columnBorderType}{Pixel extrapolation method, see \cvCppCross{borderInterpolate}}
\end{description}

See also: \hyperref[cppfunc.gpu.createSeparableLinearFilter]{cv::gpu::createSeparableLinearFilter\_GPU}, \cvCppCross{Scharr}.


\cvfunc{cv::gpu::createGaussianFilter\_GPU}\label{cppfunc.gpu.createGaussianFilter}
Creates Gaussian filter engine.

\cvdefCpp{
Ptr<FilterEngine\_GPU> createGaussianFilter\_GPU(int type, Size ksize, \par double sigmaX, double sigmaY = 0, \par int rowBorderType = BORDER\_DEFAULT, \par int columnBorderType = -1);
}

\begin{description}
\cvarg{type}{Source and the destination image type. Supports \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_16SC1}, \texttt{CV\_16SC2}, \texttt{CV\_32SC1}, \texttt{CV\_32FC1}.}
\cvarg{ksize}{Aperture size; see \cvCppCross{getGaussianKernel}.}
\cvarg{sigmaX}{Gaussian sigma in the horizontal direction; see \cvCppCross{getGaussianKernel}.}
\cvarg{sigmaY}{Gaussian sigma in the vertical direction; if 0, then $\texttt{sigmaY}\leftarrow\texttt{sigmaX}$.}
\cvarg{rowBorderType, columnBorderType}{Which border type to use; see \cvCppCross{borderInterpolate}.}
\end{description}

See also: \hyperref[cppfunc.gpu.createSeparableLinearFilter]{cv::gpu::createSeparableLinearFilter\_GPU}, \cvCppCross{createGaussianFilter}.


\cvCppFunc{gpu::GaussianBlur}
Smooths the image using Gaussian filter.

\cvdefCpp{
void GaussianBlur(const GpuMat\& src, GpuMat\& dst, Size ksize, \par double sigmaX, double sigmaY = 0, \par int rowBorderType = BORDER\_DEFAULT, \par int columnBorderType = -1);
}

\begin{description}
\cvarg{src}{Source image. Supports \texttt{CV\_8UC1}, \texttt{CV\_8UC4}, \texttt{CV\_16SC1}, \texttt{CV\_16SC2}, \texttt{CV\_32SC1}, \texttt{CV\_32FC1} source types.}
\cvarg{dst}{Destination image; will have the same size and the same type as \texttt{src}.}
\cvarg{ksize}{Gaussian kernel size; \texttt{ksize.width} and \texttt{ksize.height} can differ, but they both must be positive and odd. Or, they can be zero's, then they are computed from \texttt{sigmaX} amd \texttt{sigmaY}.}
\cvarg{sigmaX, sigmaY}{Gaussian kernel standard deviations in X and Y direction. If \texttt{sigmaY} is zero, it is set to be equal to \texttt{sigmaX}. If they are both zeros, they are computed from \texttt{ksize.width} and \texttt{ksize.height}, respectively, see \cvCppCross{getGaussianKernel}. To fully control the result regardless of possible future modification of all this semantics, it is recommended to specify all of \texttt{ksize}, \texttt{sigmaX} and \texttt{sigmaY}.}
\cvarg{rowBorderType, columnBorderType}{Pixel extrapolation method; see \cvCppCross{borderInterpolate}.}
\end{description}

See also: \hyperref[cppfunc.gpu.createGaussianFilter]{cv::gpu::createGaussianFilter\_GPU}, \cvCppCross{GaussianBlur}.


\cvfunc{cv::gpu::getMaxFilter\_GPU}\label{cppfunc.gpu.getMaxFilter}
Creates maximum filter.

\cvdefCpp{
Ptr<BaseFilter\_GPU> getMaxFilter\_GPU(int srcType, int dstType, \par const Size\& ksize, Point anchor = Point(-1,-1));
}

\begin{description}
\cvarg{srcType}{Input image type. Supports only \texttt{CV\_8UC1} and \texttt{CV\_8UC4}.}
\cvarg{dstType}{Output image type. Supports only the same type as source.}
\cvarg{ksize}{Kernel size.}
\cvarg{anchor}{Anchor point. The default value (-1) means that the anchor is at the kernel center.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area. 


\cvfunc{cv::gpu::getMinFilter\_GPU}\label{cppfunc.gpu.getMinFilter}
Creates minimum filter.

\cvdefCpp{
Ptr<BaseFilter\_GPU> getMinFilter\_GPU(int srcType, int dstType, \par const Size\& ksize, Point anchor = Point(-1,-1));
}

\begin{description}
\cvarg{srcType}{Input image type. Supports only \texttt{CV\_8UC1} and \texttt{CV\_8UC4}.}
\cvarg{dstType}{Output image type. Supports only the same type as source.}
\cvarg{ksize}{Kernel size.}
\cvarg{anchor}{Anchor point. The default value (-1) means that the anchor is at the kernel center.}
\end{description}

This filter doesn't check indexes outside the image, so it can process only inner area. 
