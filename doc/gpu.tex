\ifCpp

%\section{Per-element Operations}

%\section{Matrix Reductions}

%\section{Image Processing}

\section{Object Detection}

\cvclass{gpu::HOGDescriptor}
Histogram of Oriented Gradients descriptor and detector.

\begin{lstlisting}
struct CV_EXPORTS HOGDescriptor
{
public:
    enum { DEFAULT_WIN_SIGMA = -1 };
    enum { DEFAULT_NLEVELS = 64 };
    enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };

    HOGDescriptor(Size win_size=Size(64, 128), Size block_size=Size(16, 16),
                  Size block_stride=Size(8, 8), Size cell_size=Size(8, 8),
                  int nbins=9, double win_sigma=DEFAULT_WIN_SIGMA,
                  double threshold_L2hys=0.2, bool gamma_correction=true,
                  int nlevels=DEFAULT_NLEVELS);

    size_t getDescriptorSize() const;
    size_t getBlockHistogramSize() const;

    void setSVMDetector(const vector<float>& detector);

    static vector<float> getDefaultPeopleDetector();
    static vector<float> getPeopleDetector48x96();
    static vector<float> getPeopleDetector64x128();

    void detect(const GpuMat& img, vector<Point>& found_locations, 
                double hit_threshold=0, Size win_stride=Size(), 
                Size padding=Size());

    void detectMultiScale(const GpuMat& img, vector<Rect>& found_locations,
                          double hit_threshold=0, Size win_stride=Size(), 
                          Size padding=Size(), double scale0=1.05, 
                          int group_threshold=2);

    void getDescriptors(const GpuMat& img, Size win_stride, 
                        GpuMat& descriptors,
                        int descr_format=DESCR_FORMAT_COL_BY_COL);

    Size win_size;
    Size block_size;
    Size block_stride;
    Size cell_size;
    int nbins;
    double win_sigma;
    double threshold_L2hys;
    bool gamma_correction;
    int nlevels;
}
\end{lstlisting}

Interfaces of all methods are kept similar to CPU HOG descriptor and detector's analogues as much as possible.

\cvCppFunc{gpu::HOGDescriptor::HOGDescriptor}
Creates HOG descriptor and detector.

\cvdefCpp{HOGDescriptor(Size win\_size=Size(64, 128), Size block\_size=Size(16, 16),\par
          Size block\_stride=Size(8, 8), Size cell\_size=Size(8, 8),\par
          int nbins=9, double win\_sigma=DEFAULT\_WIN\_SIGMA,\par
          double threshold\_L2hys=0.2, bool gamma\_correction=true,\par
          int nlevels=DEFAULT\_NLEVELS);}

\begin{description}
\cvarg{win\_size}{Detection window size. Must be aligned to block size and block stride.}
\cvarg{block\_size}{Block size in cells. Only (2,2) is supported for now.}
\cvarg{block\_stride}{Block stride. Must be a multiple of cell size.}
\cvarg{cell\_size}{Cell size. Only (8, 8) is supported for now.}
\cvarg{nbins}{Number of bins. Only 9 bins per cell is supported for now.}
\cvarg{win\_sigma}{Gaussian smoothing window parameter.}
\cvarg{threshold\_L2Hys}{L2-Hys normalization method shrinkage.}
\cvarg{gamma\_correction}{Do gamma correction preprocessing or not.}
\cvarg{nlevels}{Maximum number of detection window increases.}
\end{description}

\cvCppFunc{gpu::HOGDescriptor::getDescriptorSize}
Returns number of coefficients required for the classification.

\cvdefCpp{size\_t getDescriptorSize() const;}

\cvCppFunc{gpu::HOGDescriptor::getBlockHistogramSize}
Returns block histogram size.

\cvdefCpp{size\_t getBlockHistogramSize() const;}

\cvCppFunc{gpu::HOGDescriptor::setSVMDetector}
Sets coefficients for the linear SVM classifier. 

\cvdefCpp{void setSVMDetector(const vector<float>\& detector);}

\cvCppFunc{gpu::HOGDescriptor::getDefaultPeopleDetector}
Returns coefficients of the classifier trained for people detection (for default window size).

\cvdefCpp{static vector<float> getDefaultPeopleDetector();}

\cvCppFunc{gpu::HOGDescriptor::getPeopleDetector48x96}
Returns coefficients of the classifier trained for people detection (for 48x96 windows).

\cvdefCpp{static vector<float> getPeopleDetector48x96();}

\cvCppFunc{gpu::HOGDescriptor::getPeopleDetector64x128}
Returns coefficients of the classifier trained for people detection (for 64x128 windows).

\cvdefCpp{static vector<float> getPeopleDetector64x128();}

\cvCppFunc{gpu::HOGDescriptor::detect}
Perfroms object detection without increasing detection window.

\cvdefCpp{void detect(const GpuMat\& img, vector<Point>\& found\_locations,\par
             double hit\_threshold=0, Size win\_stride=Size(),\par
             Size padding=Size());}

\begin{description}
\cvarg{img}{Source image. 8UC1 and 8UC4 types are supported for now.}
\cvarg{found\_locations}{Will contain left-top corner points of detected objects boundaries.}
\cvarg{hit\_threshold}{The threshold for the distance between features and classifying plane. Usually it's 0, and should be specfied in the detector coefficients (as the last free coefficient), but if the free coefficient is missed (it's allowed) you can specify it manually here.}
\cvarg{win\_stride}{Window stride. Must be a multiple of block stride.}
\cvarg{padding}{Mock parameter to keep CPU interface compatibility. Must be (0,0).}
\end{description}

\cvCppFunc{gpu::HOGDescriptor::detectMultiScale}
Perfroms object detection with increasing detection window.

\cvdefCpp{void detectMultiScale(const GpuMat\& img, vector<Rect>\& found\_locations,\par
                      double hit\_threshold=0, Size win\_stride=Size(),\par
                      Size padding=Size(), double scale0=1.05,\par
                      int group\_threshold=2);}

\begin{description}
\cvarg{img}{Source image. See \cvCppCross{gpu::HOGDescriptor::detect} for type limitations.}
\cvarg{found\_locations}{Will contain detected objects boundaries.}
\cvarg{hit\_threshold}{The threshold for the distance between features and classifying plane. See \cvCppCross{gpu::HOGDescriptor::detect} for details.}
\cvarg{win\_stride}{Window stride. Must be a multiple of block stride.}
\cvarg{padding}{Mock parameter to keep CPU interface compatibility. Must be (0,0).}
\cvarg{scale0}{Coefficient of the detection window increase.}
\cvarg{group\_threshold}{After detection some objects could be covered by many rectangles. This coefficient regulates similarity threshold. 0 means don't perform grouping. See \cvCppCross{groupRectangles}}
\end{description}

\cvCppFunc{gpu::HOGDescriptor::getDescriptors}
Returns block descriptors computed for the whole image. 

\cvdefCpp{void getDescriptors(const GpuMat\& img, Size win\_stride,\par
                    GpuMat\& descriptors,\par
                    int descr\_format=DESCR\_FORMAT\_COL\_BY\_COL);}

\begin{description}
\cvarg{img}{Source image. See \cvCppCross{gpu::HOGDescriptor::detect} for type limitations.}
\cvarg{win\_stride}{Window stride. Must be a multiple of block stride.}
\cvarg{descriptors}{2D array of descriptors.}
\cvarg{descr\_format}{Descriptor storage format: 
\begin{description}
    \cvarg{DESCR\_FORMAT\_ROW\_BY\_ROW}{Row-major order.}
    \cvarg{DESCR\_FORMAT\_COL\_BY\_COL}{Column-major order.}
\end{description}}
\end{description}

\fi