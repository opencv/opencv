\section{Data Structures}


\cvCppFunc{gpu::createContinuous}
Creates continuous matrix in GPU memory.

\cvdefCpp{void createContinuous(int rows, int cols, int type, GpuMat\& m);}
\begin{description}
\cvarg{rows}{Row count.}
\cvarg{cols}{Column count.}
\cvarg{type}{Type of the matrix.}
\cvarg{m}{Destination matrix. Will be reshaped only if it has proper type and area ($rows \times cols$).}
\end{description}


\section{Operations on Matrices}


\cvCppFunc{gpu::transpose}
Transposes the matrix.

\cvdefCpp{void transpose(const GpuMat\& src, GpuMat\& dst);}
\begin{description}
\cvarg{src}{Source matrix. Elements sizes 1, 4, 8 bytes are supported for now.}
\cvarg{dst}{Destination matrix.}
\end{description}

See also: \cvCppCross{transpose}.


\cvCppFunc{gpu::flip}
Flips a 2D matrix around vertical, horizontal or both axes.

\cvdefCpp{void flip(const GpuMat\& a, GpuMat\& b, int flipCode);}
\begin{description}
\cvarg{a}{Source matrix. Only 8UC1 and 8UC4 matrixes are supported for now.}
\cvarg{b}{Destination matrix.}
\cvarg{flipCode}{Specifies how to flip the source:
\begin{description}
\cvarg{0}{Flip around x-axis.}
\cvarg{$>$0}{Flip around y-axis.}
\cvarg{$<$0}{Flip around both axes.}
\end{description}}
\end{description}

See also: \cvCppCross{flip}.

\cvCppFunc{gpu::merge}
Makes multi-channel matrix out of several single-channel matrices.

\cvdefCpp{void merge(const GpuMat* src, size\_t n, GpuMat\& dst);\newline
void merge(const GpuMat* src, size\_t n, GpuMat\& dst,\par
  const Stream\& stream);\newline\newline
void merge(const vector$<$GpuMat$>$\& src, GpuMat\& dst);\newline
void merge(const vector$<$GpuMat$>$\& src, GpuMat\& dst,\par
  const Stream\& stream);}
\begin{description}
\cvarg{src}{Vector or pointer to array of the source matrices.}
\cvarg{n}{Number of source matrices.}
\cvarg{dst}{Destination matrix.}
\cvarg{stream}{Stream for the asynchronous versions.}
\end{description}

See also: \cvCppCross{merge}.


\cvCppFunc{gpu::split}
Copies each plane of a multi-channel matrix into an array.

\cvdefCpp{void split(const GpuMat\& src, GpuMat* dst);\newline
void split(const GpuMat\& src, GpuMat* dst, const Stream\& stream);\newline\newline
void split(const GpuMat\& src, vector$<$GpuMat$>$\& dst);\newline
void split(const GpuMat\& src, vector$<$GpuMat$>$\& dst,\par
  const Stream\& stream);}
\begin{description}
\cvarg{src}{Source matrix.}
\cvarg{dst}{Destination vector or pointer to array of single-channel matrices.}
\cvarg{stream}{Stream for the asynchronous versions.}
\end{description}

See also: \cvCppCross{split}.


\cvCppFunc{gpu::magnitude}
Computes magnitude of complex vector.

\cvdefCpp{void magnitude(const GpuMat\& x, GpuMat\& magnitude);}
\begin{description}
\cvarg{x}{Source complex matrix in the interleaved format (32FC2). }
\cvarg{magnitude}{Destination matrix of float magnitudes (32FC1).}
\end{description}

\cvdefCpp{void magnitude(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude);\newline
void magnitude(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude,\par
  const Stream\& stream);}
\begin{description}
\cvarg{x}{Source matrix, containing real components (32FC1).}
\cvarg{y}{Source matrix, containing imaginary components (32FC1).}
\cvarg{magnitude}{Destination matrix of float magnitudes (32FC1).}
\cvarg{stream}{Sream for the asynchronous version.}
\end{description}

See also: \cvCppCross{magnitude}.


\cvCppFunc{gpu::magnitudeSqr}
Computes squared magnitude of complex vector.

\cvdefCpp{void magnitudeSqr(const GpuMat\& x, GpuMat\& magnitude);}
\begin{description}
\cvarg{x}{Source complex matrix in the interleaved format (32FC2). }
\cvarg{magnitude}{Destination matrix of float magnitude squares (32FC1).}
\end{description}

\cvdefCpp{void magnitudeSqr(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude);\newline
void magnitudeSqr(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude,\par
  const Stream\& stream);}
\begin{description}
\cvarg{x}{Source matrix, containing real components (32FC1).}
\cvarg{y}{Source matrix, containing imaginary components (32FC1).}
\cvarg{magnitude}{Destination matrix of float magnitude squares (32FC1).}
\cvarg{stream}{Sream for the asynchronous version.}
\end{description}


\cvCppFunc{gpu::phase}
Computes polar angle of each complex value.

\cvdefCpp{void phase(const GpuMat\& x, const GpuMat\& y, GpuMat\& angle,\par
  bool angleInDegrees=false);\newline
void phase(const GpuMat\& x, const GpuMat\& y, GpuMat\& angle,\par
  bool angleInDegrees, const Stream\& stream);}
\begin{description}
\cvarg{x}{Source matrix, containing real components (32FC1).}
\cvarg{y}{Source matrix, containing imaginary components (32FC1).}
\cvarg{angle}{Destionation matrix of angles (32FC1).}
\cvarg{angleInDegress}{Flag which indicates angles must be evaluated in degress.}
\cvarg{stream}{Sream for the asynchronous version.}
\end{description}

See also: \cvCppCross{phase}.


\cvCppFunc{gpu::cartToPolar}
Converts Cartesian coordinates into polar.

\cvdefCpp{void cartToPolar(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude,\par
  GpuMat\& angle, bool angleInDegrees=false);\newline
void cartToPolar(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude,\par
  GpuMat\& angle, bool angleInDegrees, const Stream\& stream);}
\begin{description}
\cvarg{x}{Source matrix, containing real components (32FC1).}
\cvarg{y}{Source matrix, containing imaginary components (32FC1).}
\cvarg{magnitude}{Destination matrix of float magnituds (32FC1).}
\cvarg{angle}{Destionation matrix of angles (32FC1).}
\cvarg{angleInDegress}{Flag which indicates angles must be evaluated in degress.}
\cvarg{stream}{Sream for the asynchronous version.}
\end{description}

See also: \cvCppCross{cartToPolar}.


\cvCppFunc{gpu::polarToCart}
Converts polar coordinates into Cartesian.

\cvdefCpp{void polarToCart(const GpuMat\& magnitude, const GpuMat\& angle,\par
  GpuMat\& x, GpuMat\& y, bool angleInDegrees=false);\newline
void polarToCart(const GpuMat\& magnitude, const GpuMat\& angle,\par
  GpuMat\& x, GpuMat\& y, bool angleInDegrees,\par
  const Stream\& stream);}
\begin{description}
\cvarg{magnitude}{Source matrix, containing magnitudes (32FC1).}
\cvarg{angle}{Source matrix, containing angles (32FC1).}
\cvarg{x}{Destination matrix of real components (32FC1).}
\cvarg{y}{Destination matrix of imaginary components (32FC1).}
\cvarg{angleInDegress}{Flag which indicates angles are in degress.}
\cvarg{stream}{Sream for the asynchronous version.}
\end{description}

See also: \cvCppCross{polarToCart}.


\section{Per-element Operations.}


\cvCppFunc{add}
Computes matrx-matrix or matrix-scalar sum.

\cvdefCpp{void add(const GpuMat\& a, const GpuMat\& b, GpuMat\& c);}
\begin{description}
\cvarg{a}{First source matrix. 8UC1, 8UC4, 32SC1 and 32FC2 matrixes are supported for now.}
\cvarg{b}{Second source matrix. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

\cvdefCpp{void add(const GpuMat\& a, const Scalar\& sc, GpuMat\& c);}
\begin{description}
\cvarg{a}{Source matrix. 32SC1 and 32FC2 matrixes are supported for now.}
\cvarg{b}{Source scalar.}
\cvarg{c}{Destination matrix. Will have the same size and type as \texttt{a}.}
\end{description}

See also: \cvCppCross{add}.


\cvfunc{cv::gpu::bitwise\_not}\label{cppfunc.gpu.bitwise.not}
Performs per-element bitwise inversion.

\cvdefCpp{void bitwise\_not(const GpuMat\& src, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_not(const GpuMat\& src, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src}{Source matrix.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \hyperref[cppfunc.bitwise.not]{cv::bitwise\_not}.


\cvfunc{cv::gpu::bitwise\_or}\label{cppfunc.gpu.bitwise.or}
Performs per-element bitwise disjunction of two matrices.

\cvdefCpp{void bitwise\_or(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_or(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src1}{First source matrix.}
\cvarg{src2}{Second source matrix. It must have the same size and type as \texttt{src1}.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \hyperref[cppfunc.bitwise.or]{cv::bitwise\_or}.


\cvfunc{cv::gpu::bitwise\_and}\label{cppfunc.gpu.bitwise.and}
Performs per-element bitwise conjunction of two matrices.

\cvdefCpp{void bitwise\_and(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_and(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src1}{First source matrix.}
\cvarg{src2}{Second source matrix. It must have the same size and type as \texttt{src1}.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \hyperref[cppfunc.bitwise.and]{cv::bitwise\_and}.


\cvfunc{cv::gpu::bitwise\_xor}\label{cppfunc.gpu.bitwise.xor}
Performs per-element bitwise "exclusive or" of two matrices.

\cvdefCpp{void bitwise\_xor(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask=GpuMat());\newline
void bitwise\_xor(const GpuMat\& src1, const GpuMat\& src2, GpuMat\& dst,\par
  const GpuMat\& mask, const Stream\& stream);}

\begin{description}
\cvarg{src1}{First source matrix.}
\cvarg{src2}{Second source matrix. It must have the same size and type as \texttt{src1}.}
\cvarg{dst}{Destination matrix. Will have the same size and type as \texttt{src1}.}
\cvarg{mask}{Optional operation mask. 8-bit single channel image.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \hyperref[cppfunc.bitwise.xor]{cv::bitwise\_xor}.


\section{Image Processing}


\cvCppFunc{gpu::meanShiftFiltering}
Performs mean-shift filtering.

\cvdefCpp{void meanShiftFiltering(const GpuMat\& src, GpuMat\& dst,\par
  int sp, int sr,\par
  TermCriteria criteria = TermCriteria(TermCriteria::MAX\_ITER\par
  + TermCriteria::EPS, 5, 1));}

\begin{description}
\cvarg{src}{Source image. Only 8UC4 images are supported for now.}
\cvarg{dst}{Destination image. Will have the same size and type as \texttt{src}. Each pixel \texttt{(x,y)} of the destination image will contain color of the converged point started from \texttt{(x,y)} pixel of the source image.}
\cvarg{sp}{Spatial window radius.}
\cvarg{sr}{Color window radius.}
\cvarg{criteria}{Termination criteria. See \hyperref[TermCriteria]{cv::TermCriteria}.}
\end{description}


\cvCppFunc{gpu::meanShiftProc}
Performs mean-shift procedure and stores information about converged points in two images..

\cvdefCpp{void meanShiftProc(const GpuMat\& src, GpuMat\& dstr, GpuMat\& dstsp,\par
  int sp, int sr,\par
  TermCriteria criteria = TermCriteria(TermCriteria::MAX\_ITER\par
  + TermCriteria::EPS, 5, 1));}

\begin{description}
\cvarg{src}{Source image. Only 8UC4 images are supported for now.}
\cvarg{dstr}{Destination image. Will have the same size and type as \texttt{src}. Each pixel \texttt{(x,y)} of the destination image will contain color of converged point started from \texttt{(x,y)} pixel of the source image.}
\cvarg{dstsp}{16SC2 matrix, which will contain coordinates of converged points and have the same size as \texttt{src}.}
\cvarg{sp}{Spatial window radius.}
\cvarg{sr}{Color window radius.}
\cvarg{criteria}{Termination criteria. See \hyperref[TermCriteria]{cv::TermCriteria}.}
\end{description}


\cvCppFunc{gpu::meanShiftSegmentation}
Performs mean-shift segmentation of the source image and eleminates small segments.

\cvdefCpp{void meanShiftSegmentation(const GpuMat\& src, Mat\& dst,\par
  int sp, int sr, int minsize,\par
  TermCriteria criteria = TermCriteria(TermCriteria::MAX\_ITER\par
  + TermCriteria::EPS, 5, 1));}

\begin{description}
\cvarg{src}{Source image. Only 8UC4 images are supported for now.}
\cvarg{dst}{Segmented image. Will have the same size and type as \texttt{src}.}
\cvarg{sp}{Spatial window radius.}
\cvarg{sr}{Color window radius.}
\cvarg{minsize}{Minimum segment size. Smaller segements will be merged.}
\cvarg{criteria}{Termination criteria. See \hyperref[TermCriteria]{cv::TermCriteria}.}
\end{description}


\cvCppFunc{gpu::integral}
Computes the integral image and squared integral image.

\cvdefCpp{void integral(const GpuMat\& src, GpuMat\& sum);\newline
void integral(const GpuMat\& src, GpuMat\& sum, GpuMat\& sqsum);}

\begin{description}
\cvarg{src}{Source image. Only 8UC1 images are supported for now.}
\cvarg{sum}{Integral image. Will contain 32-bit unsigned integer values packed into 32SC1.}
\cvarg{sqsum}{Squared integral image. Will have 32FC1 type.}
\end{description}

See also: \cvCppCross{integral}.


\cvCppFunc{gpu::sqrIntegral}
Computes squared integral image.

\cvdefCpp{void sqrIntegral(const GpuMat\& src, GpuMat\& sqsum);}
\begin{description}
\cvarg{src}{Source image. Only 8UC1 images are supported for now.}
\cvarg{sqsum}{Squared integral image. Will contain 64-bit floating point values packed into 64U.}
\end{description}


\cvCppFunc{gpu::columnSum}
Computes vertical (column) sum.

\cvdefCpp{void columnSum(const GpuMat\& src, GpuMat\& sum);}
\begin{description}
\cvarg{src}{Source image. Only 32FC1 images are supported for now.}
\cvarg{sum}{Destination image. Will have 32FC1 type.}
\end{description}


\cvCppFunc{gpu::cornerHarris}
Computes Harris cornerness criteria at each image pixel.

\cvdefCpp{void cornerHarris(const GpuMat\& src, GpuMat\& dst,\par
  int blockSize, int ksize, double k,\par
  int borderType=BORDER\_REFLECT101);}

\begin{description}
\cvarg{src}{Source image. Only 8UC1 and 32FC1 images are supported for now.}
\cvarg{dst}{Destination image. Will have the same size and 32FC1 type and contain cornerness values.}
\cvarg{blockSize}{Neighborhood size.}
\cvarg{ksize}{Aperture parameter for the Sobel operator.}
\cvarg{k}{Harris detector free parameter.}
\cvarg{borderType}{Pixel extrapolation method. Only \texttt{BORDER\_REFLECT101} and \texttt{BORDER\_REPLICATE} are supported for now.}
\end{description}

See also: \cvCppCross{cornerHarris}.


\cvCppFunc{gpu::cornerMinEigenVal}
Computes minimum eigen value of 2x2 derivative covariation matrix at each pixel - the cornerness criteria.

\cvdefCpp{void cornerMinEigenVal(const GpuMat\& src, GpuMat\& dst,\par
  int blockSize, int ksize,\par
  int borderType=BORDER\_REFLECT101);}

\begin{description}
\cvarg{src}{Source image. Only 8UC1 and 32FC1 images are supported for now.}
\cvarg{dst}{Destination image. Will have the same size and 32FC1 type and contain cornerness values.}
\cvarg{blockSize}{Neighborhood size.}
\cvarg{ksize}{Aperture parameter for the Sobel operator.}
\cvarg{k}{Harris detector free parameter.}
\cvarg{borderType}{Pixel extrapolation method. Only \texttt{BORDER\_REFLECT101} and \texttt{BORDER\_REPLICATE} are supported for now.}
\end{description}

See also: \cvCppCross{cornerMinEigenValue}.


\cvCppFunc{gpu::mulSpectrums}
Performs per-element multiplication of two Fourier spectrums.

\cvdefCpp{void mulSpectrums(const GpuMat\& a, const GpuMat\& b,\par
  GpuMat\& c, int flags, bool conjB=false);}

\begin{description}
\cvarg{a}{First spectrum.}
\cvarg{b}{Second spectrum. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destination spectrum.}
\cvarg{flags}{Mock paramter is kept for CPU/GPU interfaces similarity.}
\cvarg{conjB}{Optional flag which indicates the second spectrum must be conjugated before the multiplcation.}
\end{description}

Only full (i.e. not packed) 32FC2 complex spectrums in the interleaved format are supported for now.

See also: \cvCppCross{mulSpectrums}.


\cvCppFunc{gpu::mulAndScaleSpectrums}
Performs per-element multiplication of two Fourier spectrums and scales the result.

\cvdefCpp{void mulAndScaleSpectrums(const GpuMat\& a, const GpuMat\& b,\par
  GpuMat\& c, int flags, float scale, bool conjB=false);}

\begin{description}
\cvarg{a}{First spectrum.}
\cvarg{b}{Second spectrum. Must have the same size and type as \texttt{a}.}
\cvarg{c}{Destination spectrum.}
\cvarg{flags}{Mock paramter is kept for CPU/GPU interfaces similarity.}
\cvarg{scale}{Scale constant.}
\cvarg{conjB}{Optional flag which indicates the second spectrum must be conjugated before the multiplcation.}
\end{description}

Only full (i.e. not packed) 32FC2 complex spectrums in the interleaved format are supported for now.

See also: \cvCppCross{mulSpectrums}.


\cvCppFunc{gpu::dft}
Performs a forward or inverse discrete Fourier transform (1D or 2D) of floating point matrix.

\cvdefCpp{void dft(const GpuMat\& src, GpuMat\& dst, Size dft\_size, int flags=0);}

\begin{description}
\cvarg{src}{Real of complex source matrix.}
\cvarg{dst}{Real or complex destination matrix.}
\cvarg{dft\_size}{Size of discrete Fourier transform.}
\cvarg{flags}{Optional flags:
\begin{description}
  \cvarg{DFT\_ROWS}{Transform each individual row of the source matrix.}
  \cvarg{DFT\_SCALE}{Scale the result: divide it by the number of elements in the transform (it's obtained from \texttt{dft\_size}).
  \cvarg{DFT\_INVERSE}{Inverse DFT must be perfromed for complex-complex case (real-complex and  complex-real cases are respectively forward and inverse always).}}
  \cvarg{DFT\_REAL\_OUTPUT}{The source matrix is the result of real-complex transform and the destination matrix must be real.}
\end{description}}
\end{description}

The source matrix should be continuous, otherwise reallocation and data copying will be performed. Function chooses the operation mode depending on the flags, size and channel count of the source matrix:
\begin{itemize}
  \item If the source matrix is complex and the output isn't specified as real then the destination matrix will be complex, will have \texttt{dft\_size} size and 32FC2 type. It will contain full result of the DFT (forward or inverse).
  \item If the source matrix is complex and the output is specified as real then function assumes that its input is the result of the forward transform (see next item). The destionation matrix will have \texttt{dft\_size} size and 32FC1 type. It will contain result of the inverse DFT.
  \item If the source matrix is real (i.e. its type is 32FC1) then forward DFT will be performed. The result of the DFT will be packed into complex (32FC2) matrix so its width will be \texttt{dft\_size.width / 2 + 1}, but if the source is a single column then height will be reduced.
\end{itemize}

See also: \cvCppCross{dft}.


\cvCppFunc{gpu::convolve}
Computes convolution (or cross-correlation) of two images.

\cvdefCpp{void convolve(const GpuMat\& image, const GpuMat\& templ, GpuMat\& result,\par
  bool ccorr=false);\newline
void convolve(const GpuMat\& image, const GpuMat\& templ, GpuMat\& result,\par
  bool ccorr, ConvolveBuf\& buf);}

\begin{description}
\cvarg{image}{Source image. Only 32FC1 images are supported for now.}
\cvarg{templ}{Template image. Must have size not greater then \texttt{image} size and be the same type as \texttt{image}.}
\cvarg{result}{Result image. Will have the same size and type as \texttt{image}.}
\cvarg{ccorr}{Flags which indicates cross-correlation must be evaluated instead of convolution.}
\cvarg{buf}{Optional buffer to decrease memory reallocation count (for many calls with the same sizes).}
\end{description}


\cvclass{gpu::ConvolveBuf}
Memory buffer for the \cvCppCross{gpu::convolve} function.

\begin{lstlisting}
struct CV_EXPORTS ConvolveBuf
{
    ConvolveBuf() {}
    ConvolveBuf(Size image_size, Size templ_size) 
        { create(image_size, templ_size); }
    void create(Size image_size, Size templ_size);

private:
    // Hidden
};
\end{lstlisting}


\cvCppFunc{gpu::ConvolveBuf::ConvolveBuf}

\cvdefCpp{ConvolveBuf();}
Construct empty buffer which will be properly resized after first call of the convolve function.

\cvdefCpp{ConvolveBuf(Size image\_size, Size templ\_size);}
Construct buffer for the convolve function with respectively arguments.


\cvCppFunc{gpu::matchTemplate}
Computes the proximity map for the raster template and the image where the template is searched for.

\cvdefCpp{void matchTemplate(const GpuMat\& image, const GpuMat\& templ,\par
  GpuMat\& result, int method);}

\begin{description}
\cvarg{image}{Source image. 32F and 8U images (1..4 channels) are supported for now.}
\cvarg{templ}{Template image. Must have the same size and type as \texttt{image}.}
\cvarg{result}{A map of comparison results (32FC1). If \texttt{image} is $W \times H$ and
\texttt{templ} is $w \times h$ then \texttt{result} must be $(W-w+1) \times (H-h+1)$.}
\cvarg{method}{Specifies the way the template must be compared with the image.}
\end{description}
Following methods are supported for 8U images for now:
\begin{itemize}
\item CV\_TM\_SQDIFF \item CV\_TM\_SQDIFF\_NORMED \item CV\_TM\_CCORR \item CV\_TM\_CCORR\_NORMED \item CV\_TM\_CCOEFF \item CV\_TM\_CCOEFF\_NORMED 
\end{itemize}
Following methods are supported for 32F images for now:
\begin{itemize}
\item CV\_TM\_SQDIFF \item CV\_TM\_CCORR
\end{itemize}

See also: \cvCppCross{matchTemplate}. 


\section{Matrix Reductions}


\cvCppFunc{gpu::sum}
Returns sum of array elements.

\cvdefCpp{Scalar sum(const GpuMat\& src);\newline
Scalar sum(const GpuMat\& src, GpuMat\& buf);}

\begin{description}
\cvarg{src}{Source image of any depth excepting 64F, single-channel.}
\cvarg{buf}{Optional buffer. It's resized automatically.}
\end{description}

See also: \cvCppCross{sum}.


\cvCppFunc{gpu::sqrSum}
Returns squared sum of array elements.

\cvdefCpp{Scalar sqrSum(const GpuMat\& src);\newline
Scalar sqrSum(const GpuMat\& src, GpuMat\& buf);}
\begin{description}
\cvarg{src}{Source image of any depth excepting 64F, single-channel.}
\cvarg{buf}{Optional buffer. It's resized automatically.}
\end{description}


\cvCppFunc{gpu::minMax}
Finds global minimum and maximum array elements and returns their values.

\cvdefCpp{void minMax(const GpuMat\& src, double* minVal,\par
  double* maxVal=0, const GpuMat\& mask=GpuMat());\newline
void minMax(const GpuMat\& src, double* minVal, double* maxVal,\par
  const GpuMat\& mask, GpuMat\& buf);}
\begin{description}
\cvarg{src}{Single-channel source image.}
\cvarg{minVal}{Pointer to returned minimum value. \texttt{NULL} if not required.}
\cvarg{maxVal}{Pointer to returned maximum value. \texttt{NULL} if not required.}
\cvarg{mask}{Optional mask to select a sub-array.}
\cvarg{buf}{Optional buffer. It's resized automatically.}
\end{description}

Function doesn't work with 64F images on GPU with compute capability $<$ 1.3.\newline
See also: \cvCppCross{minMaxLoc}.


\cvCppFunc{gpu::minMaxLoc}
Finds global minimum and maximum array elements and returns their values with locations.

\cvdefCpp{void minMaxLoc(const GpuMat\& src, double\* minVal, double* maxVal=0,\par
  Point* minLoc=0, Point* maxLoc=0,\par
  const GpuMat\& mask=GpuMat());\newline
void minMaxLoc(const GpuMat\& src, double* minVal, double* maxVal,\par
  Point* minLoc, Point* maxLoc, const GpuMat\& mask,\par
  GpuMat\& valbuf, GpuMat\& locbuf);}
\begin{description}
\cvarg{src}{Single-channel source image.}
\cvarg{minVal}{Pointer to returned minimum value. \texttt{NULL} if not required.}
\cvarg{maxVal}{Pointer to returned maximum value. \texttt{NULL} if not required.}
\cvarg{minValLoc}{Pointer to returned minimum location. \texttt{NULL} if not required.}
\cvarg{maxValLoc}{Pointer to returned maximum location. \texttt{NULL} if not required.}
\cvarg{mask}{Optional mask to select a sub-array.}
\cvarg{valbuf}{Optional values buffer. It's resized automatically.}
\cvarg{locbuf}{Optional location buffer. It's resized automatically.}
\end{description}

Function doesn't work with 64F images on GPU with compute capability $<$ 1.3.\newline
See also: \cvCppCross{minMaxLoc}.


\cvCppFunc{gpu::countNonZero}
Counts non-zero array elements.

\cvdefCpp{int countNonZero(const GpuMat\& src);\newline
int countNonZero(const GpuMat\& src, GpuMat\& buf);}
\begin{description}
\cvarg{src}{Single-channel source image.}
\cvarg{buf}{Optional buffer. It's resized automatically.}
\end{description}

Function doesn't work with 64F images on GPU with compute capability $<$ 1.3.\newline
See also: \cvCppCross{countNonZero}.


\section{Object Detection}


\cvclass{gpu::HOGDescriptor}
Histogram of Oriented Gradients descriptor and detector.

\begin{lstlisting}
struct CV_EXPORTS HOGDescriptor
{
    enum { DEFAULT_WIN_SIGMA = -1 };
    enum { DEFAULT_NLEVELS = 64 };
    enum { DESCR_FORMAT_ROW_BY_ROW, DESCR_FORMAT_COL_BY_COL };

    HOGDescriptor(Size win_size=Size(64, 128), Size block_size=Size(16, 16),
                  Size block_stride=Size(8, 8), Size cell_size=Size(8, 8),
                  int nbins=9, double win_sigma=DEFAULT_WIN_SIGMA,
                  double threshold_L2hys=0.2, bool gamma_correction=true,
                  int nlevels=DEFAULT_NLEVELS);

    size_t getDescriptorSize() const;
    size_t getBlockHistogramSize() const;

    void setSVMDetector(const vector<float>& detector);

    static vector<float> getDefaultPeopleDetector();
    static vector<float> getPeopleDetector48x96();
    static vector<float> getPeopleDetector64x128();

    void detect(const GpuMat& img, vector<Point>& found_locations, 
                double hit_threshold=0, Size win_stride=Size(), 
                Size padding=Size());

    void detectMultiScale(const GpuMat& img, vector<Rect>& found_locations,
                          double hit_threshold=0, Size win_stride=Size(), 
                          Size padding=Size(), double scale0=1.05, 
                          int group_threshold=2);

    void getDescriptors(const GpuMat& img, Size win_stride, 
                        GpuMat& descriptors,
                        int descr_format=DESCR_FORMAT_COL_BY_COL);

    Size win_size;
    Size block_size;
    Size block_stride;
    Size cell_size;
    int nbins;
    double win_sigma;
    double threshold_L2hys;
    bool gamma_correction;
    int nlevels;

private:
    // Hidden
}
\end{lstlisting}

Interfaces of all methods are kept similar to CPU HOG descriptor and detector's analogues as much as possible.


\cvCppFunc{gpu::HOGDescriptor::HOGDescriptor}
Creates HOG descriptor and detector.

\cvdefCpp{HOGDescriptor(Size win\_size=Size(64, 128), Size block\_size=Size(16, 16),\par
          Size block\_stride=Size(8, 8), Size cell\_size=Size(8, 8),\par
          int nbins=9, double win\_sigma=DEFAULT\_WIN\_SIGMA,\par
          double threshold\_L2hys=0.2, bool gamma\_correction=true,\par
          int nlevels=DEFAULT\_NLEVELS);}

\begin{description}
\cvarg{win\_size}{Detection window size. Must be aligned to block size and block stride.}
\cvarg{block\_size}{Block size in cells. Only (2,2) is supported for now.}
\cvarg{block\_stride}{Block stride. Must be a multiple of cell size.}
\cvarg{cell\_size}{Cell size. Only (8, 8) is supported for now.}
\cvarg{nbins}{Number of bins. Only 9 bins per cell is supported for now.}
\cvarg{win\_sigma}{Gaussian smoothing window parameter.}
\cvarg{threshold\_L2Hys}{L2-Hys normalization method shrinkage.}
\cvarg{gamma\_correction}{Do gamma correction preprocessing or not.}
\cvarg{nlevels}{Maximum number of detection window increases.}
\end{description}


\cvCppFunc{gpu::HOGDescriptor::getDescriptorSize}
Returns number of coefficients required for the classification.

\cvdefCpp{size\_t getDescriptorSize() const;}


\cvCppFunc{gpu::HOGDescriptor::getBlockHistogramSize}
Returns block histogram size.

\cvdefCpp{size\_t getBlockHistogramSize() const;}


\cvCppFunc{gpu::HOGDescriptor::setSVMDetector}
Sets coefficients for the linear SVM classifier. 

\cvdefCpp{void setSVMDetector(const vector<float>\& detector);}


\cvCppFunc{gpu::HOGDescriptor::getDefaultPeopleDetector}
Returns coefficients of the classifier trained for people detection (for default window size).

\cvdefCpp{static vector<float> getDefaultPeopleDetector();}


\cvCppFunc{gpu::HOGDescriptor::getPeopleDetector48x96}
Returns coefficients of the classifier trained for people detection (for 48x96 windows).

\cvdefCpp{static vector<float> getPeopleDetector48x96();}


\cvCppFunc{gpu::HOGDescriptor::getPeopleDetector64x128}
Returns coefficients of the classifier trained for people detection (for 64x128 windows).

\cvdefCpp{static vector<float> getPeopleDetector64x128();}


\cvCppFunc{gpu::HOGDescriptor::detect}
Perfroms object detection without increasing detection window.

\cvdefCpp{void detect(const GpuMat\& img, vector<Point>\& found\_locations,\par
             double hit\_threshold=0, Size win\_stride=Size(),\par
             Size padding=Size());}

\begin{description}
\cvarg{img}{Source image. 8UC1 and 8UC4 types are supported for now.}
\cvarg{found\_locations}{Will contain left-top corner points of detected objects boundaries.}
\cvarg{hit\_threshold}{Threshold for the distance between features and classifying plane. Usually it's 0, and should be specfied in the detector coefficients (as the last free coefficient), but if the free coefficient is missed (it's allowed) you can specify it manually here.}
\cvarg{win\_stride}{Window stride. Must be a multiple of block stride.}
\cvarg{padding}{Mock parameter to keep CPU interface compatibility. Must be (0,0).}
\end{description}


\cvCppFunc{gpu::HOGDescriptor::detectMultiScale}
Perfroms object detection with increasing detection window.

\cvdefCpp{void detectMultiScale(const GpuMat\& img, vector<Rect>\& found\_locations,\par
                      double hit\_threshold=0, Size win\_stride=Size(),\par
                      Size padding=Size(), double scale0=1.05,\par
                      int group\_threshold=2);}

\begin{description}
\cvarg{img}{Source image. See \cvCppCross{gpu::HOGDescriptor::detect} for type limitations.}
\cvarg{found\_locations}{Will contain detected objects boundaries.}
\cvarg{hit\_threshold}{The threshold for the distance between features and classifying plane. See \cvCppCross{gpu::HOGDescriptor::detect} for details.}
\cvarg{win\_stride}{Window stride. Must be a multiple of block stride.}
\cvarg{padding}{Mock parameter to keep CPU interface compatibility. Must be (0,0).}
\cvarg{scale0}{Coefficient of the detection window increase.}
\cvarg{group\_threshold}{After detection some objects could be covered by many rectangles. This coefficient regulates similarity threshold. 0 means don't perform grouping.\newline
See \cvCppCross{groupRectangles}.}
\end{description}


\cvCppFunc{gpu::HOGDescriptor::getDescriptors}
Returns block descriptors computed for the whole image. 

\cvdefCpp{void getDescriptors(const GpuMat\& img, Size win\_stride,\par
                    GpuMat\& descriptors,\par
                    int descr\_format=DESCR\_FORMAT\_COL\_BY\_COL);}

\begin{description}
\cvarg{img}{Source image. See \cvCppCross{gpu::HOGDescriptor::detect} for type limitations.}
\cvarg{win\_stride}{Window stride. Must be a multiple of block stride.}
\cvarg{descriptors}{2D array of descriptors.}
\cvarg{descr\_format}{Descriptor storage format: 
\begin{description}
    \cvarg{DESCR\_FORMAT\_ROW\_BY\_ROW}{Row-major order.}
    \cvarg{DESCR\_FORMAT\_COL\_BY\_COL}{Column-major order.}
\end{description}}
\end{description}
