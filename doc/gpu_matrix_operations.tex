\section{Operations on Matrices}


\cvCppFunc{gpu::transpose}
Transposes a matrix.

\cvdefCpp{void transpose(const GpuMat\& src, GpuMat\& dst);}
\begin{description}
\cvarg{src}{Source matrix. 1, 4, 8 bytes element sizes are supported for now.}
\cvarg{dst}{Destination matrix.}
\end{description}

See also: \cvCppCross{transpose}.


\cvCppFunc{gpu::flip}
Flips a 2D matrix around vertical, horizontal or both axes.

\cvdefCpp{void flip(const GpuMat\& a, GpuMat\& b, int flipCode);}
\begin{description}
\cvarg{a}{Source matrix. Only \texttt{CV\_8UC1} and \texttt{CV\_8UC4} matrices are supported for now.}
\cvarg{b}{Destination matrix.}
\cvarg{flipCode}{Specifies how to flip the source:
\begin{description}
\cvarg{0}{Flip around x-axis.}
\cvarg{$>$0}{Flip around y-axis.}
\cvarg{$<$0}{Flip around both axes.}
\end{description}}
\end{description}

See also: \cvCppCross{flip}.


\cvCppFunc{gpu::LUT}
Transforms the source matrix into the destination matrix using given look-up table: 
\[dst(I) = lut(src(I))\]

\cvdefCpp{void LUT(const GpuMat\& src, const Mat\& lut, GpuMat\& dst);}
\begin{description}
\cvarg{src}{Source matrix. \texttt{CV\_8UC1} and \texttt{CV\_8UC3} matrixes are supported for now.}
\cvarg{lut}{Look-up table. Must be continuous, \texttt{CV\_8U} depth matrix. Its area must satisfy to \texttt{lut.rows} $\times$ \texttt{lut.cols} = 256 condition.}
\cvarg{dst}{Destination matrix. Will have the same depth as \texttt{lut} and the same number of channels as \texttt{src}.}
\end{description}

See also: \cvCppCross{LUT}.


\cvCppFunc{gpu::merge}
Makes a multi-channel matrix out of several single-channel matrices.

\cvdefCpp{void merge(const GpuMat* src, size\_t n, GpuMat\& dst);\newline
void merge(const GpuMat* src, size\_t n, GpuMat\& dst,\par
  const Stream\& stream);\newline}
\begin{description}
\cvarg{src}{Pointer to array of the source matrices.}
\cvarg{n}{Number of source matrices.}
\cvarg{dst}{Destination matrix.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

\cvdefCpp{void merge(const vector$<$GpuMat$>$\& src, GpuMat\& dst);\newline
void merge(const vector$<$GpuMat$>$\& src, GpuMat\& dst,\par
  const Stream\& stream);}
\begin{description}
\cvarg{src}{Vector of the source matrices.}
\cvarg{dst}{Destination matrix.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \cvCppCross{merge}.


\cvCppFunc{gpu::split}
Copies each plane of a multi-channel matrix into an array.

\cvdefCpp{void split(const GpuMat\& src, GpuMat* dst);\newline
void split(const GpuMat\& src, GpuMat* dst, const Stream\& stream);}
\begin{description}
\cvarg{src}{Source matrix.}
\cvarg{dst}{Pointer to array of single-channel matrices.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

\cvdefCpp{void split(const GpuMat\& src, vector$<$GpuMat$>$\& dst);\newline
void split(const GpuMat\& src, vector$<$GpuMat$>$\& dst,\par
  const Stream\& stream);}
\begin{description}
\cvarg{src}{Source matrix.}
\cvarg{dst}{Destination vector of single-channel matrices.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \cvCppCross{split}.


\cvCppFunc{gpu::magnitude}
Computes magnitudes of complex matrix elements.

\cvdefCpp{void magnitude(const GpuMat\& x, GpuMat\& magnitude);}
\begin{description}
\cvarg{x}{Source complex matrix in the interleaved format (\texttt{CV\_32FC2}). }
\cvarg{magnitude}{Destination matrix of float magnitudes (\texttt{CV\_32FC1}).}
\end{description}

\cvdefCpp{void magnitude(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude);\newline
void magnitude(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude,\par
  const Stream\& stream);}
\begin{description}
\cvarg{x}{Source matrix, containing real components (\texttt{CV\_32FC1}).}
\cvarg{y}{Source matrix, containing imaginary components (\texttt{CV\_32FC1}).}
\cvarg{magnitude}{Destination matrix of float magnitudes (\texttt{CV\_32FC1}).}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \cvCppCross{magnitude}.


\cvCppFunc{gpu::magnitudeSqr}
Computes squared magnitudes of complex matrix elements.

\cvdefCpp{void magnitudeSqr(const GpuMat\& x, GpuMat\& magnitude);}
\begin{description}
\cvarg{x}{Source complex matrix in the interleaved format (\texttt{CV\_32FC2}). }
\cvarg{magnitude}{Destination matrix of float magnitude squares (\texttt{CV\_32FC1}).}
\end{description}

\cvdefCpp{void magnitudeSqr(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude);\newline
void magnitudeSqr(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude,\par
  const Stream\& stream);}
\begin{description}
\cvarg{x}{Source matrix, containing real components (\texttt{CV\_32FC1}).}
\cvarg{y}{Source matrix, containing imaginary components (\texttt{CV\_32FC1}).}
\cvarg{magnitude}{Destination matrix of float magnitude squares (\texttt{CV\_32FC1}).}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}


\cvCppFunc{gpu::phase}
Computes polar angles of complex matrix elements.

\cvdefCpp{void phase(const GpuMat\& x, const GpuMat\& y, GpuMat\& angle,\par
  bool angleInDegrees=false);\newline
void phase(const GpuMat\& x, const GpuMat\& y, GpuMat\& angle,\par
  bool angleInDegrees, const Stream\& stream);}
\begin{description}
\cvarg{x}{Source matrix, containing real components (\texttt{CV\_32FC1}).}
\cvarg{y}{Source matrix, containing imaginary components (\texttt{CV\_32FC1}).}
\cvarg{angle}{Destionation matrix of angles (\texttt{CV\_32FC1}).}
\cvarg{angleInDegress}{Flag which indicates angles must be evaluated in degress.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \cvCppCross{phase}.


\cvCppFunc{gpu::cartToPolar}
Converts Cartesian coordinates into polar.

\cvdefCpp{void cartToPolar(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude,\par
  GpuMat\& angle, bool angleInDegrees=false);\newline
void cartToPolar(const GpuMat\& x, const GpuMat\& y, GpuMat\& magnitude,\par
  GpuMat\& angle, bool angleInDegrees, const Stream\& stream);}
\begin{description}
\cvarg{x}{Source matrix, containing real components (\texttt{CV\_32FC1}).}
\cvarg{y}{Source matrix, containing imaginary components (\texttt{CV\_32FC1}).}
\cvarg{magnitude}{Destination matrix of float magnituds (\texttt{CV\_32FC1}).}
\cvarg{angle}{Destionation matrix of angles (\texttt{CV\_32FC1}).}
\cvarg{angleInDegress}{Flag which indicates angles must be evaluated in degress.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \cvCppCross{cartToPolar}.


\cvCppFunc{gpu::polarToCart}
Converts polar coordinates into Cartesian.

\cvdefCpp{void polarToCart(const GpuMat\& magnitude, const GpuMat\& angle,\par
  GpuMat\& x, GpuMat\& y, bool angleInDegrees=false);\newline
void polarToCart(const GpuMat\& magnitude, const GpuMat\& angle,\par
  GpuMat\& x, GpuMat\& y, bool angleInDegrees,\par
  const Stream\& stream);}
\begin{description}
\cvarg{magnitude}{Source matrix, containing magnitudes (\texttt{CV\_32FC1}).}
\cvarg{angle}{Source matrix, containing angles (\texttt{CV\_32FC1}).}
\cvarg{x}{Destination matrix of real components (\texttt{CV\_32FC1}).}
\cvarg{y}{Destination matrix of imaginary components (\texttt{CV\_32FC1}).}
\cvarg{angleInDegress}{Flag which indicates angles are in degress.}
\cvarg{stream}{Stream for the asynchronous version.}
\end{description}

See also: \cvCppCross{polarToCart}.