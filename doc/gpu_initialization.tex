\section{Initalization and Information}


\cvCppFunc{gpu::getCudaEnabledDeviceCount}
Returns number of CUDA-enabled devices installed. It is to be used before any other GPU functions calls. If OpenCV is compiled without GPU support this function returns 0. 

\cvdefCpp{int getCudaEnabledDeviceCount();}


\cvCppFunc{gpu::setDevice}
Sets device and initializes it for the current thread. Call of this function can be omitted, but in this case a default device will be initialized on fist GPU usage.

\cvdefCpp{void setDevice(int device);}
\begin{description}
\cvarg{device}{index of GPU device in system starting with 0.}
\end{description}


\cvCppFunc{gpu::getDevice}
Returns the current device index, which was set by \cvCppCross{gpu::getDevice} or initialized by default.

\cvdefCpp{int getDevice();}


\cvclass{gpu::DeviceInfo}
This class provides functionality for querying the specified GPU properties. 

\begin{lstlisting}
class CV_EXPORTS DeviceInfo
{
public:
    DeviceInfo();
    DeviceInfo(int device_id);

    string name() const;

    int major() const;
    int minor() const;

    int multiProcessorCount() const;

    size_t freeMemory() const;
    size_t totalMemory() const;

    bool has(GpuFeature feature) const;
    bool isCompatible() const;
};
\end{lstlisting}


\cvCppFunc{gpu::DeviceInfo::DeviceInfo}
Constructs DeviceInfo object for the specified device. If \texttt{device\_id} parameter is missed it constructs object for the current device.

\cvdefCpp{DeviceInfo::DeviceInfo();\newline
DeviceInfo::DeviceInfo(int device\_id);}
\begin{description}
\cvarg{device\_id}{Index of the GPU device in system starting with 0.}
\end{description}


\cvCppFunc{gpu::DeviceInfo::name}
Returns the device name.

\cvdefCpp{string DeviceInfo::name();}


\cvCppFunc{gpu::DeviceInfo::major}
Returns the major compute capability version.

\cvdefCpp{int DeviceInfo::major();}


\cvCppFunc{gpu::DeviceInfo::minor}
Returns the minor compute capability version.

\cvdefCpp{int DeviceInfo::minor();}


\cvCppFunc{gpu::DeviceInfo::multiProcessorCount}
Returns the number of streaming multiprocessors.

\cvdefCpp{int DeviceInfo::multiProcessorCount();}


\cvCppFunc{gpu::DeviceInfo::freeMemory}
Returns the amount of free memory in bytes.

\cvdefCpp{size\_t DeviceInfo::freeMemory();}


\cvCppFunc{gpu::DeviceInfo::totalMemory}
Returns the amount of total memory in bytes.

\cvdefCpp{size\_t DeviceInfo::totalMemory();}


\cvCppFunc{gpu::DeviceInfo::has}
Returns true if the device has the given GPU feature, otherwise false.

\cvdefCpp{bool DeviceInfo::has(GpuFeature feature);}
\begin{description}
\cvarg{feature}{Feature to be checked. Available alternatives:
\begin{itemize}
\item NATIVE\_DOUBLE Native double operations support
\item ATOMICS Atomic operations support
\end{itemize}}
\end{description}


\cvCppFunc{gpu::DeviceInfo::isCompatible}
Returns true if the GPU module can be run on the specified device, otherwise false.

\cvdefCpp{bool DeviceInfo::isCompatible();}


\cvclass{gpu::TargetArchs}
This class provides functionality (as set of static methods) for checking which NVIDIA card architectures the GPU module was built for.

\bigskip

The following method checks whether the module was built with the support of the given feature:
\cvdefCpp{static bool builtWith(GpuFeature feature);}
\begin{description}
\cvarg{feature}{Feature to be checked. Available alternatives:
\begin{itemize}
\item NATIVE\_DOUBLE Native double operations support
\item ATOMICS Atomic operations support
\end{itemize}}
\end{description}

There are a set of methods for checking whether the module contains intermediate (PTX) or binary GPU code for the given architecture(s):
\cvdefCpp{
static bool has(int major, int minor);\newline
static bool hasPtx(int major, int minor);\newline
static bool hasBin(int major, int minor);\newline
static bool hasEqualOrLessPtx(int major, int minor);\newline
static bool hasEqualOrGreater(int major, int minor);\newline
static bool hasEqualOrGreaterPtx(int major, int minor);\newline
static bool hasEqualOrGreaterBin(int major, int minor);}
\begin{description}
\cvarg{major}{Major compute capability version.}
\cvarg{minor}{Minor compute capability version.}
\end{description}

% By default GPU module is no compiled for devices with compute capability equal to 1.0. So if you run

According to the CUDA C Programming Guide Version 3.2: "PTX code produced for some specific compute capability can always be compiled to binary code of greater or equal compute capability". 

